- For a migration, shouldn't it be sufficient if the currentPrice is greater than or equal to the target price? (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L206) At least that is what I would imagine after reading the documentation ("If the target price is reached then a buyout can be triggered") - For the buyout, the documentation does not match the implementation. In the documentation (https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout), it is mentioned that "If a pool has more than 51% of the total supply after 4 days, ...". However, 51% are not needed, the buyout actually suceeds with 50.1% in the implementation (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211) - For `FERC1155`, once a signature was given to someone, there is no way to cancel the permission, which can be undesirable. Consider adding a cancel method to the contract (that stores the cancelled signatures). - For `FERC1155`, when a user gives out multiple signatures (to different accounts at the same time), only the first redeem call will succeed (because of the nonce). If the user wants to avoid that and increases the nonces himself (e.g., nonce 1 for user A, nonce 2 for user B), user A has to use the signature before user B, which is undesirable. Consider optimizing the nonce management, e.g. storing all the used nonces (instead of requiring sequential ones). - Because of malleable signatures, it is considered best practice to check for invalid `s` and `v` values, as OpenZeppelin is doing: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5e007871991e4f04e871bf5fb1200668ff16b35f/contracts/utils/cryptography/ECDSA.sol#L142 In `FERC1155.sol`, `ecrecover` is called without these checks. - In `setApprovalFor` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L191), only a boolean can be provided. This can be very undesirable for an ERC1155 token where a user might also want to specify an amount for the allowance. Consequently, the approvals are not decreased or reset in `safeTransferFrom`. - `ERC1155` inherits `safeBatchTransferFrom` from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol#L78), but `isApproved` is not checked in this function, meaning that someone who got the approval for all the provided ids still cannot call `safeBatchTransferFrom`. Consider also overriding this function and adding the check that all ids are approved as an alternative. - In `ERC1155`, it is possible to set arbitrarily high royalties (even >100%), which does not make sense and leads to wrong values in `royaltyInfo`. Consider adding a limit. - In `ERC1155`, although the royalty is a `uint256` value, the actual granularity for the calculation is very small and only whole percent values can be provided (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L247). Consider increasing the granularity, e.g. dividing by 10,000. - In `_execute` of `Vault`, returning `success` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/Vault.sol#L117) is not necessary. The execution will always revert when it was not successful, i.e. there is no way that `sucess` can be false. - `BaseVault` hardcodes the number of hashes to 6 (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128), which seems to be the number when modules contains `BaseVault` and `BuyoutModule`. However, depending on the modules that are passed, the number of hashes can be greater. Therefore, the array size should be dynamic. - It seems strange to me that there is no authentication for plugins, whereas the whole Merkle Tree authentication system exists for modules. Therefore, if an owner would (accidentally) add a module as a plugin, everyone could call it and the whole module authentication would be circumvented. This also contradicts the sentence "An NFT within a given Vault cannot be withdrawn unless its modules allow for it." in the documentation. An owner can simply add a new plugin and withdraw all tokens (meaning there is a lot of trust in the owner). - There is currently no way to transfer airdrops (e.g., ERC20 tokens that are distributed to all holders of a NFT) out of a `Vault` without starting a migration. Consider adding a module that would allow to transfer them. - The WETH address (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/utils/SafeSend.sol#L12) is hardcoded, which can make testing and deploying on other networks more difficult. Consider making the address configurable. - In the documentation, it is mentioned "These modules are set by the curator upon fractionalization and can be adjusted via governance vote of token holders.". However, this does not seem to be true. An owner can always set a new merkle root (via `setMerkleRoot`) which allows new modules. - An attacker could call `createInCollection` with some malicious tokens that he created (conforming to the FERC1155 calls) and therefore create a vault with a malicous, worthless tokens. He could then sell those tokens and for normal users it would appear as if they are normal fractionalization tokens of a vault. - It seems strange to me to have a functionality (`createInCollection`) for creating a new vault with an existing token. This could result in some scenarios that are undesired. For example, when a buyout is active for both vaults, there is an arbitrage opportunity (buy the tokens with the lower price, sell the ones with the higher) and the person that initiated the one with the lower price will not succeed, although it might have (because people would have been willing to sell at this price) when only vault with this token had existed. 
