# Handle  hack3r-0m   # Vulnerability details  Consider the following state:  long_synth_balace = 300; short_synth_balace = 200;  marketUpdateIndex[1] = x; userNextPrice_currentUpdateIndex = 0; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;  User calls shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)  This results in following state changes:  long_synth_balace = 200; short_synth_balace = 200; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; userNextPrice_currentUpdateIndex = x+1 ;   Due to some other transactions, oracle updates twice, and now the marketUpdateIndex[1] is x+2 and also updating price snapshots.  When User calls getUsersConfirmedButNotSettledSynthBalance(user, 1)  initial condition ``` if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&       userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex     )  ``` will be true;  syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex] (https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)  this uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.  
# Handle  shw   # Vulnerability details  ## Impact  The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked.  ## Proof of Concept  Referenced code: [Staker.sol#L885](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)  ## Recommended Mitigation Steps  Add checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure that the sum of the two variables does not exceed user's stake balance.  
# Handle  cmichel   # Vulnerability details  The `SyntheticToken` overwrites the `_beforeTokenTransfer` hook and removes the pausing functionality of `ERC20PresetMinterPauser`. But the `ERC20PresetMinterPauser` constructor still assigns pauser roles which leads to unnecessary gas costs. Inherit from an `ERC20PresetMinterPauser`-like contract without the pausing functionality. This would also make the intention of the code more clear by showcasing that it does not implement the pauser interface functions `pause`/`unpause` (which it currently still does but they don't have any effect).   
# Handle  pauliax   # Vulnerability details  ## Impact contract LongShort has a 'treasury' state variable that is not used in any meaningful way. It is only initialized in function initialize and can be changed by function changeTreasury, no other interactions. YieldManagerAave has its own separate treasury variable that it allocates funds to so this dead code can be removed to save some gas at least.   
# Handle  pauliax   # Vulnerability details  ## Impact Dead code: Staker contract has a modifier onlyValidMarket that is not used anywhere. I think you do not use it as you trust that admin and LongShort contract will not pass invalid values. Unused code can be removed to reduce gas costs.  
# Handle  pauliax   # Vulnerability details  ## Impact functions _mintNextPrice, _redeemNextPrice, _shiftPositionNextPrice could cache a result here and re-use it to avoid duplicate calculations of the same value:     marketUpdateIndex[marketIndex] + 1; Also, you can extract duplicate storage access to a storage variable and update the state on it, e.g.: accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] is accessed 3 times in _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot.  
# Handle  pauliax   # Vulnerability details  ## Impact contract YieldManagerAave caches lendingPool, however, in theory, it is possible that the implementation may change (see https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65). I am not sure how likely in practice is that but a common solution that I see in other protocols that integrate with Aave is querying the lendingPool on the go (of course then you also need to handle the change in approvals).  ## Recommended Mitigation Steps An example solution you can see here: https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L63-L65  
# Handle  hrkrshnn   # Vulnerability details   ## Cache length in the for loop  ``` solidity modified   contracts/contracts/LongShort.sol @@ -1059,7 +1059,8 @@ contract LongShort is ILongShort, Initializable {    /// @param user The address of the user for whom to execute the function for.    /// @param marketIndexes An array of int32s which each uniquely identify a market.    function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external { -    for (uint256 i = 0; i < marketIndexes.length; i++) { +    uint length = marketIndexes.length; +    for (uint256 i = 0; i < length; i++) {        _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);      }    } ```  In the previous case, at each iteration of the loop, length is read from memory. something like `mload(memory_offset)`. It takes `6` gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  In the replacement, the value is placed in the stack only once and each iteration involves a `dupN` (3 gas). Saves around 3 gas per iteration.  Here are other places that can use this.  ``` text ./contracts/contracts/LongShort.sol:776:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/LongShort.sol:1063:    for (uint256 i = 0; i < length; i++) { ./contracts/contracts/Staker.sol:790:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/mocks/BandOracleMock.sol:84:    for (uint256 i = 0; i < _bases.length; i++) { ./contracts/contracts/testing/LongShortInternalStateSetters.sol:34:    for (uint256 i = 0; i < marketIndexes.length; i++) { ```   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Changing a functionâ€™s visibility from public to external can save gas by avoiding the unnecessary copying of data to memory. Function stakeFromUser() in Staker.sol is only called from SyntheticTokens.sol and not from within the contract itself which means this can be made external.   ## Proof of Concept  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/Staker.sol#L839  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/SyntheticToken.sol#L56   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility to external where possible.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are multiple places where state variables are reused within functions by loading them multiple times. These operations result in expensive SLOAD instructions where the first SLOAD costs 2100 gas and successive SLOADs of the same variable cost 100 gas (since the Berlin hardfork).  Using local memory variables to cache them will remove the unnecessary SLOADs costing 100 gas resulting in MLOADs that only cost 3 gas units.  ## Proof of Concept  Caching latestMarket can save upto 13 SLOADs i.e. 1300 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L261-L298  Caching staked can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L267 https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L276  Caching latestMarket can save upto 3 SLOADs i.e. 3 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L352-L365  Caching marketUpdateIndex[marketIndex] appropriately can save many SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L817-L819  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L677-L757  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L860-L864  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L911-L922  Caching longShort address can save 300 300 gas by avoiding 3 SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/TokenFactory.sol#L68-L70  Caching amountReservedInCaseOfInsufficientAaveLiquidity can save upto 2 SLOADs i.e. 200 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L114-L121  Caching paymentToken can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L132-L142  Caching aaveIncentiveController can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167  Caching totalReservedForTreasury can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache storage-based state variables in local memory-based variables appropriately to convert SLOADs to MLOADs and reduce gas consumption from 100 units to 3 units.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the unlikely event `amountReservedInCaseOfInsufficientAaveLiquidity == amount`, the `else` case will be executed, which means `lendingPool.deposit()` is called with a value of zero. It would therefore be better to change the condition so that the `if` case is executed instead.  ### Recommended Mitigation Steps  ```jsx function depositPaymentToken(uint256 amount) external override longShortOnly {   // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount   // It basically always be zero besides extreme and unlikely situations with aave.   if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {   // instead of strictly greater than     if (amountReservedInCaseOfInsufficientAaveLiquidity >= amount) {       amountReservedInCaseOfInsufficientAaveLiquidity -= amount;       // Return early, nothing to deposit into the lending pool       return;     }  ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Updating a `kValue` of a market requires interpolation against the initial timestamp, which can be a hassle and might lead to a wrong value set from what is expected.   ### Proof of Concept  Consider the following scenario:  - Initially set `kValue = 2e18`, `kPeriod = 2592000` (30 days) - After 15 days, would like to refresh the market incentive (start again with `kValue = 2e18`), lasting another 30 days.  In the current implementation, the admin would call `_changeMarketLaunchIncentiveParameters()` with the following inputs:  - `period = 3888000` (45 days) - `kValue` needs to be worked backwards from the formula      `kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod)`. To achieve the desired effect, we would get `kValue = 25e17` (formula returns 2e18 after 15 days with kPeriod = 45 days).  This isn't immediately intuitive and could lead to mistakes.  ### Recommended Mitigation Steps  Instead of calculating from `initialTimestamp` (when `addNewStakingFund()` was called), calculate from when the market incentives were last updated. This would require a new mapping to store last updated timestamps of market incentives.  For example, using the scenario above, refreshing the market incentive would mean using inputs `period = 2592000` (30 days) with `kValue = 2e18`.  ```jsx // marketIndex => timestamp of updated market launch incentive params  mapping(uint32 => uint256) public marketLaunchIncentive_update_timestamps;  function _changeMarketLaunchIncentiveParameters(   uint32 marketIndex,   uint256 period,   uint256 initialMultiplier ) internal virtual {  require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");    marketLaunchIncentive_period[marketIndex] = period;   marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  marketLaunchIncentive_update_timestamps[marketIndex] = block.timestamp; };  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {   // Parameters controlling the float issuance multiplier.   (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);    // Sanity check - under normal circumstances, the multipliers should   // *never* be set to a value < 1e18, as there are guards against this.   assert(kInitialMultiplier >= 1e18);   // currently: uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  // changed to take from last updated timestamp instead of initial timestamp   uint256 initialTimestamp = marketLaunchIncentive_update_timestamps[marketIndex];    if (block.timestamp - initialTimestamp <= kPeriod) {     return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);   } else {     return 1e18;   } }  ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, there is an outstanding TODO in L437  `@dev to see below math in latex form see TODO add link`  The missing URL seems to be the one provided in the README on float [token rate issuance](https://www.overleaf.com/read/jpyhjgrvhfkr).  ### Recommended Mitigation Steps  Update / finish up the TODO.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The user's `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` are retrieved a number of times in `_calculateAccumulatedFloat()`. Caching these values would help save gas.  Note that block scoping is needed to avoid the stack too deep problem.  ### Recommended Mitigation Steps  ```jsx function _calculateAccumulatedFloat() {  // block scope for shiftAmount variable to avoid stack too deep  {   // Update the users balances    uint256 shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];    if (shiftAmount > 0) {      amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        true,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedLong -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;    }      shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user]    if (shiftAmount > 0) {      amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        false,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedShort -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;    }  }  // end of block scoping   // Save the users updated staked amounts  ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  LongShort.sol   - `re-uising` â†’ `reusing` - `visa versa` â†’ `vice versa` - `@param marketIndex An int32` â†’ `@param marketIndex A uint32` - `Non-existant` â†’ `Non-existent`  Staker.sol  - `Explicitely` â†’ `Explicitly` - `extremeley` â†’ `extremely`  YieldManagerAave.sol  - `revent` â†’ `revert`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The comparison and effecting `valueChange` in `_claimAndDistributeYieldThenRebalanceMarket()` can be made consistent with the other functions.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  ### Recommended Mitigation Steps  Change the `else` case to `else if (valueChange < 0)`.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else if (valueChange < 0) {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  By storing `marketUpdateIndex[marketIndex];` locally in `_updateSystemStateInternal()`, multiple sLOADs can be avoided.  ### Recommended Mitigation Steps  Gas savings of about 500-600 is achieved.  ```jsx function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {  ...  // cache marketUpdateIndex[marketIndex]   uint256 currentMarketIndex = marketUpdateIndex[marketIndex];    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;   if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex     ];     uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][       currentMarketIndex     ];    if (       userNextPrice_currentUpdateIndex[marketIndex][staker] == currentMarketIndex + 1 &&       assetPriceHasChanged     ) {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)         currentMarketIndex + 1       );     } else {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         0       );     }   ...   // increment currentMarketIndex   currentMarketIndex ++;    marketUpdateIndex[marketIndex] = currentMarketIndex;   syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_long;      syntheticToken_priceSnapshot[marketIndex][false][      currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_short;   ...   emit SystemStateUpdated(      marketIndex,      currentMarketIndex,    ...   );  } } ```  
# Handle  jonah1005   # Vulnerability details  ## Impact Aave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided. The aave rewards would be unclaimable.  ## Proof of Concept YieldManager's logic: https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170  Reference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards  ## Tools Used None ## Recommended Mitigation Steps Change to ```solidity     address[] memory rewardsDepositedAssets = new address[](1);     rewardsDepositedAssets[0] = address(aToken); ```   
# Handle  jonah1005   # Vulnerability details  # LongShort should not shares the same Yield Manager between different markets ## Impact The LongShort contract would not stop different markets from using the same yield manager contracts. Any extra aToken in the yield manager would be considered as market incentives in function `distributeYieldForTreasuryAndReturnMarketAllocation`. Thus, using the same yield manager for different markets would break the markets and allow users to withdraw fund that doesn't belong to them.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L179-L204  ## Tools Used None  ## Recommended Mitigation Steps Given the fluency of programming skills the dev shows, I believe they wouldn't make this mistake on deployment. Still, I think there's space to improve in the YieldManagerAave contract. IMHO. As it's tightly coupled with longshort contract and its market logic, a initialize market function in the yield manager seems more reasonable.  
# Handle  0xImpostor   # Vulnerability details  ## Impact  Use `marketIndex` to updateSystemState instead of querying `marketIndexOfToken[token]` twice.  ## Proof of Concept  Swap line 949 with 951 and swap line 974 with 976.  For example  ``` function withdrawAll(address token) external {     uint32 marketIndex = marketIndexOfToken[token];      ILongShort(longShort).updateSystemState(marketIndex);      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token       ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]       : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];      _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);   }  ```  ## Tools Used  Manual analysis  
# Handle  jonah1005   # Vulnerability details  ## Impact FloatToken would revoke staker's permission if msg.sender == stakerAddress. In `initializeFloatToken` the contract would first grant roles to `stakerAddress` and than revoke`msg.sender`'s permissions. The contract would be left with no privileged address if stakerAddress == msg.sender.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/FloatToken.sol#L21-L35  ## Tools Used None ## Recommended Mitigation Steps  ```solidity   function initializeFloatToken(     string calldata name,     string calldata symbol,     address stakerAddress   ) external initializer {     initialize(name, symbol);      renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);     renounceRole(MINTER_ROLE, msg.sender);     renounceRole(PAUSER_ROLE, msg.sender);        _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);     _setupRole(MINTER_ROLE, stakerAddress);     _setupRole(PAUSER_ROLE, stakerAddress);   } ```  
# Handle  evertkors   # Vulnerability details  A lot of docstrings for marketIndex are ` @param marketIndex An int32 which uniquely identifies a market.` but it is a `uint32` not an `int32`  
# Handle  gpersoon   # Vulnerability details  ## Impact I've seen comments which are confusing: ~10^31 or 10 Trillion (10^13) ==> probably should be 2^31 x * 5e17` == `(x * 10e18) / 2`   ==> probably should be 1e18/2  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L19 // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)  //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L480       // NOTE: `x * 5e17` == `(x * 10e18) / 2`  ## Tools Used  ## Recommended Mitigation Steps Double check the comments  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions initializeMarket and _seedMarketInitially use the variable latestMarket. If these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially   This would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.  Note: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304 function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {    ...     ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex     ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex    function initializeMarket(      uint32 marketIndex,....)   ...     require(!marketExists[marketIndex], "already initialized");     require(marketIndex <= latestMarket, "index too high");      marketExists[marketIndex] = true; ..     IStaker(staker).addNewStakingFund(       latestMarket,                                       // should be marketIndex       syntheticTokens[latestMarket][true],   // should be marketIndex       syntheticTokens[latestMarket][false],  // should be marketIndex   ...  ## Tools Used  ## Recommended Mitigation Steps Replace latestMarket with marketIndex in the functions initializeMarket and _seedMarketInitially  p.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!  
# Handle  gpersoon   # Vulnerability details  ## Impact In the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.  stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping  can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex [market2]  This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.  ## Proof of Concept // https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622     function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     ...       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;       stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;       batched_stakerNextTokenShiftIndex[marketIndex] += 1; ...  ## Tools Used  ## Recommended Mitigation Steps Add an index with marketIndex to the variables: - stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping  - stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping   Also consider shortening the variable names, this way mistakes can be spotted easier.  Confirmed by Jason of Float Capital: Yes, you are totally right, it should use the marketIndex since they are specific per market!  
# Handle   hickuphh3  # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns  `return (1e18 * k * longPrice, 0);` and  `return (0, 1e18 * k * shortPrice);` respectively.   This is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0`  and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,  `return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);` results in  `(0, 1e18 * k * shortPrice / 1e18)` or `(0, k * shortPrice)`.  As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.  ### Recommended Mitigation Steps  The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively.
# Handle  gpersoon   # Vulnerability details  ## Impact The function _batchConfirmOutstandingPendingActions of LongShort.sol processeses the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0  This means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126 LongShort.sol function _batchConfirmOutstandingPendingActions( ..     amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];     batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; ...         amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];            batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false         ## Tools Used  ## Recommended Mitigation Steps change the second instance of the following (on line 1207)    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0   to    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0    p.s. confirmed by Jason of Floatcapital: "Yes, that should definitely be false!"  
# Handle  hack3r-0m   # Vulnerability details  Consider the following state:  long_synth_balace = 300; short_synth_balace = 200;  marketUpdateIndex[1] = x; userNextPrice_currentUpdateIndex = 0; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;  User calls shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)  This results in following state changes:  long_synth_balace = 200; short_synth_balace = 200; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; userNextPrice_currentUpdateIndex = x+1 ;   Due to some other transactions, oracle updates twice, and now the marketUpdateIndex[1] is x+2 and also updating price snapshots.  When User calls getUsersConfirmedButNotSettledSynthBalance(user, 1)  initial condition ``` if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&       userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex     )  ``` will be true;  syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex] (https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)  this uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.  
# Handle  shw   # Vulnerability details  ## Impact  The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked.  ## Proof of Concept  Referenced code: [Staker.sol#L885](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)  ## Recommended Mitigation Steps  Add checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure that the sum of the two variables does not exceed user's stake balance.  
# Handle  cmichel   # Vulnerability details  The `SyntheticToken` overwrites the `_beforeTokenTransfer` hook and removes the pausing functionality of `ERC20PresetMinterPauser`. But the `ERC20PresetMinterPauser` constructor still assigns pauser roles which leads to unnecessary gas costs. Inherit from an `ERC20PresetMinterPauser`-like contract without the pausing functionality. This would also make the intention of the code more clear by showcasing that it does not implement the pauser interface functions `pause`/`unpause` (which it currently still does but they don't have any effect).   
# Handle  pauliax   # Vulnerability details  ## Impact contract LongShort has a 'treasury' state variable that is not used in any meaningful way. It is only initialized in function initialize and can be changed by function changeTreasury, no other interactions. YieldManagerAave has its own separate treasury variable that it allocates funds to so this dead code can be removed to save some gas at least.   
# Handle  pauliax   # Vulnerability details  ## Impact Dead code: Staker contract has a modifier onlyValidMarket that is not used anywhere. I think you do not use it as you trust that admin and LongShort contract will not pass invalid values. Unused code can be removed to reduce gas costs.  
# Handle  pauliax   # Vulnerability details  ## Impact functions _mintNextPrice, _redeemNextPrice, _shiftPositionNextPrice could cache a result here and re-use it to avoid duplicate calculations of the same value:     marketUpdateIndex[marketIndex] + 1; Also, you can extract duplicate storage access to a storage variable and update the state on it, e.g.: accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] is accessed 3 times in _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot.  
# Handle  pauliax   # Vulnerability details  ## Impact contract YieldManagerAave caches lendingPool, however, in theory, it is possible that the implementation may change (see https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65). I am not sure how likely in practice is that but a common solution that I see in other protocols that integrate with Aave is querying the lendingPool on the go (of course then you also need to handle the change in approvals).  ## Recommended Mitigation Steps An example solution you can see here: https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L63-L65  
# Handle  hrkrshnn   # Vulnerability details   ## Cache length in the for loop  ``` solidity modified   contracts/contracts/LongShort.sol @@ -1059,7 +1059,8 @@ contract LongShort is ILongShort, Initializable {    /// @param user The address of the user for whom to execute the function for.    /// @param marketIndexes An array of int32s which each uniquely identify a market.    function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external { -    for (uint256 i = 0; i < marketIndexes.length; i++) { +    uint length = marketIndexes.length; +    for (uint256 i = 0; i < length; i++) {        _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);      }    } ```  In the previous case, at each iteration of the loop, length is read from memory. something like `mload(memory_offset)`. It takes `6` gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  In the replacement, the value is placed in the stack only once and each iteration involves a `dupN` (3 gas). Saves around 3 gas per iteration.  Here are other places that can use this.  ``` text ./contracts/contracts/LongShort.sol:776:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/LongShort.sol:1063:    for (uint256 i = 0; i < length; i++) { ./contracts/contracts/Staker.sol:790:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/mocks/BandOracleMock.sol:84:    for (uint256 i = 0; i < _bases.length; i++) { ./contracts/contracts/testing/LongShortInternalStateSetters.sol:34:    for (uint256 i = 0; i < marketIndexes.length; i++) { ```   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Changing a functionâ€™s visibility from public to external can save gas by avoiding the unnecessary copying of data to memory. Function stakeFromUser() in Staker.sol is only called from SyntheticTokens.sol and not from within the contract itself which means this can be made external.   ## Proof of Concept  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/Staker.sol#L839  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/SyntheticToken.sol#L56   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility to external where possible.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are multiple places where state variables are reused within functions by loading them multiple times. These operations result in expensive SLOAD instructions where the first SLOAD costs 2100 gas and successive SLOADs of the same variable cost 100 gas (since the Berlin hardfork).  Using local memory variables to cache them will remove the unnecessary SLOADs costing 100 gas resulting in MLOADs that only cost 3 gas units.  ## Proof of Concept  Caching latestMarket can save upto 13 SLOADs i.e. 1300 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L261-L298  Caching staked can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L267 https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L276  Caching latestMarket can save upto 3 SLOADs i.e. 3 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L352-L365  Caching marketUpdateIndex[marketIndex] appropriately can save many SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L817-L819  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L677-L757  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L860-L864  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L911-L922  Caching longShort address can save 300 300 gas by avoiding 3 SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/TokenFactory.sol#L68-L70  Caching amountReservedInCaseOfInsufficientAaveLiquidity can save upto 2 SLOADs i.e. 200 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L114-L121  Caching paymentToken can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L132-L142  Caching aaveIncentiveController can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167  Caching totalReservedForTreasury can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache storage-based state variables in local memory-based variables appropriately to convert SLOADs to MLOADs and reduce gas consumption from 100 units to 3 units.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the unlikely event `amountReservedInCaseOfInsufficientAaveLiquidity == amount`, the `else` case will be executed, which means `lendingPool.deposit()` is called with a value of zero. It would therefore be better to change the condition so that the `if` case is executed instead.  ### Recommended Mitigation Steps  ```jsx function depositPaymentToken(uint256 amount) external override longShortOnly {   // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount   // It basically always be zero besides extreme and unlikely situations with aave.   if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {   // instead of strictly greater than     if (amountReservedInCaseOfInsufficientAaveLiquidity >= amount) {       amountReservedInCaseOfInsufficientAaveLiquidity -= amount;       // Return early, nothing to deposit into the lending pool       return;     }  ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Updating a `kValue` of a market requires interpolation against the initial timestamp, which can be a hassle and might lead to a wrong value set from what is expected.   ### Proof of Concept  Consider the following scenario:  - Initially set `kValue = 2e18`, `kPeriod = 2592000` (30 days) - After 15 days, would like to refresh the market incentive (start again with `kValue = 2e18`), lasting another 30 days.  In the current implementation, the admin would call `_changeMarketLaunchIncentiveParameters()` with the following inputs:  - `period = 3888000` (45 days) - `kValue` needs to be worked backwards from the formula      `kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod)`. To achieve the desired effect, we would get `kValue = 25e17` (formula returns 2e18 after 15 days with kPeriod = 45 days).  This isn't immediately intuitive and could lead to mistakes.  ### Recommended Mitigation Steps  Instead of calculating from `initialTimestamp` (when `addNewStakingFund()` was called), calculate from when the market incentives were last updated. This would require a new mapping to store last updated timestamps of market incentives.  For example, using the scenario above, refreshing the market incentive would mean using inputs `period = 2592000` (30 days) with `kValue = 2e18`.  ```jsx // marketIndex => timestamp of updated market launch incentive params  mapping(uint32 => uint256) public marketLaunchIncentive_update_timestamps;  function _changeMarketLaunchIncentiveParameters(   uint32 marketIndex,   uint256 period,   uint256 initialMultiplier ) internal virtual {  require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");    marketLaunchIncentive_period[marketIndex] = period;   marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  marketLaunchIncentive_update_timestamps[marketIndex] = block.timestamp; };  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {   // Parameters controlling the float issuance multiplier.   (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);    // Sanity check - under normal circumstances, the multipliers should   // *never* be set to a value < 1e18, as there are guards against this.   assert(kInitialMultiplier >= 1e18);   // currently: uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  // changed to take from last updated timestamp instead of initial timestamp   uint256 initialTimestamp = marketLaunchIncentive_update_timestamps[marketIndex];    if (block.timestamp - initialTimestamp <= kPeriod) {     return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);   } else {     return 1e18;   } }  ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, there is an outstanding TODO in L437  `@dev to see below math in latex form see TODO add link`  The missing URL seems to be the one provided in the README on float [token rate issuance](https://www.overleaf.com/read/jpyhjgrvhfkr).  ### Recommended Mitigation Steps  Update / finish up the TODO.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The user's `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` are retrieved a number of times in `_calculateAccumulatedFloat()`. Caching these values would help save gas.  Note that block scoping is needed to avoid the stack too deep problem.  ### Recommended Mitigation Steps  ```jsx function _calculateAccumulatedFloat() {  // block scope for shiftAmount variable to avoid stack too deep  {   // Update the users balances    uint256 shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];    if (shiftAmount > 0) {      amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        true,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedLong -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;    }      shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user]    if (shiftAmount > 0) {      amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        false,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedShort -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;    }  }  // end of block scoping   // Save the users updated staked amounts  ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  LongShort.sol   - `re-uising` â†’ `reusing` - `visa versa` â†’ `vice versa` - `@param marketIndex An int32` â†’ `@param marketIndex A uint32` - `Non-existant` â†’ `Non-existent`  Staker.sol  - `Explicitely` â†’ `Explicitly` - `extremeley` â†’ `extremely`  YieldManagerAave.sol  - `revent` â†’ `revert`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The comparison and effecting `valueChange` in `_claimAndDistributeYieldThenRebalanceMarket()` can be made consistent with the other functions.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  ### Recommended Mitigation Steps  Change the `else` case to `else if (valueChange < 0)`.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else if (valueChange < 0) {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  By storing `marketUpdateIndex[marketIndex];` locally in `_updateSystemStateInternal()`, multiple sLOADs can be avoided.  ### Recommended Mitigation Steps  Gas savings of about 500-600 is achieved.  ```jsx function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {  ...  // cache marketUpdateIndex[marketIndex]   uint256 currentMarketIndex = marketUpdateIndex[marketIndex];    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;   if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex     ];     uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][       currentMarketIndex     ];    if (       userNextPrice_currentUpdateIndex[marketIndex][staker] == currentMarketIndex + 1 &&       assetPriceHasChanged     ) {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)         currentMarketIndex + 1       );     } else {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         0       );     }   ...   // increment currentMarketIndex   currentMarketIndex ++;    marketUpdateIndex[marketIndex] = currentMarketIndex;   syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_long;      syntheticToken_priceSnapshot[marketIndex][false][      currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_short;   ...   emit SystemStateUpdated(      marketIndex,      currentMarketIndex,    ...   );  } } ```  
# Handle  jonah1005   # Vulnerability details  ## Impact Aave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided. The aave rewards would be unclaimable.  ## Proof of Concept YieldManager's logic: https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170  Reference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards  ## Tools Used None ## Recommended Mitigation Steps Change to ```solidity     address[] memory rewardsDepositedAssets = new address[](1);     rewardsDepositedAssets[0] = address(aToken); ```   
# Handle  jonah1005   # Vulnerability details  # LongShort should not shares the same Yield Manager between different markets ## Impact The LongShort contract would not stop different markets from using the same yield manager contracts. Any extra aToken in the yield manager would be considered as market incentives in function `distributeYieldForTreasuryAndReturnMarketAllocation`. Thus, using the same yield manager for different markets would break the markets and allow users to withdraw fund that doesn't belong to them.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L179-L204  ## Tools Used None  ## Recommended Mitigation Steps Given the fluency of programming skills the dev shows, I believe they wouldn't make this mistake on deployment. Still, I think there's space to improve in the YieldManagerAave contract. IMHO. As it's tightly coupled with longshort contract and its market logic, a initialize market function in the yield manager seems more reasonable.  
# Handle  0xImpostor   # Vulnerability details  ## Impact  Use `marketIndex` to updateSystemState instead of querying `marketIndexOfToken[token]` twice.  ## Proof of Concept  Swap line 949 with 951 and swap line 974 with 976.  For example  ``` function withdrawAll(address token) external {     uint32 marketIndex = marketIndexOfToken[token];      ILongShort(longShort).updateSystemState(marketIndex);      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token       ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]       : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];      _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);   }  ```  ## Tools Used  Manual analysis  
# Handle  jonah1005   # Vulnerability details  ## Impact FloatToken would revoke staker's permission if msg.sender == stakerAddress. In `initializeFloatToken` the contract would first grant roles to `stakerAddress` and than revoke`msg.sender`'s permissions. The contract would be left with no privileged address if stakerAddress == msg.sender.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/FloatToken.sol#L21-L35  ## Tools Used None ## Recommended Mitigation Steps  ```solidity   function initializeFloatToken(     string calldata name,     string calldata symbol,     address stakerAddress   ) external initializer {     initialize(name, symbol);      renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);     renounceRole(MINTER_ROLE, msg.sender);     renounceRole(PAUSER_ROLE, msg.sender);        _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);     _setupRole(MINTER_ROLE, stakerAddress);     _setupRole(PAUSER_ROLE, stakerAddress);   } ```  
# Handle  evertkors   # Vulnerability details  A lot of docstrings for marketIndex are ` @param marketIndex An int32 which uniquely identifies a market.` but it is a `uint32` not an `int32`  
# Handle  gpersoon   # Vulnerability details  ## Impact I've seen comments which are confusing: ~10^31 or 10 Trillion (10^13) ==> probably should be 2^31 x * 5e17` == `(x * 10e18) / 2`   ==> probably should be 1e18/2  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L19 // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)  //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L480       // NOTE: `x * 5e17` == `(x * 10e18) / 2`  ## Tools Used  ## Recommended Mitigation Steps Double check the comments  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions initializeMarket and _seedMarketInitially use the variable latestMarket. If these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially   This would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.  Note: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304 function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {    ...     ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex     ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex    function initializeMarket(      uint32 marketIndex,....)   ...     require(!marketExists[marketIndex], "already initialized");     require(marketIndex <= latestMarket, "index too high");      marketExists[marketIndex] = true; ..     IStaker(staker).addNewStakingFund(       latestMarket,                                       // should be marketIndex       syntheticTokens[latestMarket][true],   // should be marketIndex       syntheticTokens[latestMarket][false],  // should be marketIndex   ...  ## Tools Used  ## Recommended Mitigation Steps Replace latestMarket with marketIndex in the functions initializeMarket and _seedMarketInitially  p.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!  
# Handle  gpersoon   # Vulnerability details  ## Impact In the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.  stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping  can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex [market2]  This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.  ## Proof of Concept // https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622     function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     ...       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;       stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;       batched_stakerNextTokenShiftIndex[marketIndex] += 1; ...  ## Tools Used  ## Recommended Mitigation Steps Add an index with marketIndex to the variables: - stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping  - stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping   Also consider shortening the variable names, this way mistakes can be spotted easier.  Confirmed by Jason of Float Capital: Yes, you are totally right, it should use the marketIndex since they are specific per market!  
# Handle   hickuphh3  # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns  `return (1e18 * k * longPrice, 0);` and  `return (0, 1e18 * k * shortPrice);` respectively.   This is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0`  and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,  `return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);` results in  `(0, 1e18 * k * shortPrice / 1e18)` or `(0, k * shortPrice)`.  As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.  ### Recommended Mitigation Steps  The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively.
# Handle  gpersoon   # Vulnerability details  ## Impact The function _batchConfirmOutstandingPendingActions of LongShort.sol processeses the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0  This means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126 LongShort.sol function _batchConfirmOutstandingPendingActions( ..     amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];     batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; ...         amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];            batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false         ## Tools Used  ## Recommended Mitigation Steps change the second instance of the following (on line 1207)    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0   to    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0    p.s. confirmed by Jason of Floatcapital: "Yes, that should definitely be false!"  
# Handle  hack3r-0m   # Vulnerability details  Consider the following state:  long_synth_balace = 300; short_synth_balace = 200;  marketUpdateIndex[1] = x; userNextPrice_currentUpdateIndex = 0; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;  User calls shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)  This results in following state changes:  long_synth_balace = 200; short_synth_balace = 200; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; userNextPrice_currentUpdateIndex = x+1 ;   Due to some other transactions, oracle updates twice, and now the marketUpdateIndex[1] is x+2 and also updating price snapshots.  When User calls getUsersConfirmedButNotSettledSynthBalance(user, 1)  initial condition ``` if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&       userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex     )  ``` will be true;  syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex] (https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)  this uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.  
# Handle  shw   # Vulnerability details  ## Impact  The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked.  ## Proof of Concept  Referenced code: [Staker.sol#L885](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)  ## Recommended Mitigation Steps  Add checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure that the sum of the two variables does not exceed user's stake balance.  
# Handle  cmichel   # Vulnerability details  The `SyntheticToken` overwrites the `_beforeTokenTransfer` hook and removes the pausing functionality of `ERC20PresetMinterPauser`. But the `ERC20PresetMinterPauser` constructor still assigns pauser roles which leads to unnecessary gas costs. Inherit from an `ERC20PresetMinterPauser`-like contract without the pausing functionality. This would also make the intention of the code more clear by showcasing that it does not implement the pauser interface functions `pause`/`unpause` (which it currently still does but they don't have any effect).   
# Handle  pauliax   # Vulnerability details  ## Impact contract LongShort has a 'treasury' state variable that is not used in any meaningful way. It is only initialized in function initialize and can be changed by function changeTreasury, no other interactions. YieldManagerAave has its own separate treasury variable that it allocates funds to so this dead code can be removed to save some gas at least.   
# Handle  pauliax   # Vulnerability details  ## Impact Dead code: Staker contract has a modifier onlyValidMarket that is not used anywhere. I think you do not use it as you trust that admin and LongShort contract will not pass invalid values. Unused code can be removed to reduce gas costs.  
# Handle  pauliax   # Vulnerability details  ## Impact functions _mintNextPrice, _redeemNextPrice, _shiftPositionNextPrice could cache a result here and re-use it to avoid duplicate calculations of the same value:     marketUpdateIndex[marketIndex] + 1; Also, you can extract duplicate storage access to a storage variable and update the state on it, e.g.: accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] is accessed 3 times in _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot.  
# Handle  pauliax   # Vulnerability details  ## Impact contract YieldManagerAave caches lendingPool, however, in theory, it is possible that the implementation may change (see https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65). I am not sure how likely in practice is that but a common solution that I see in other protocols that integrate with Aave is querying the lendingPool on the go (of course then you also need to handle the change in approvals).  ## Recommended Mitigation Steps An example solution you can see here: https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L63-L65  
# Handle  hrkrshnn   # Vulnerability details   ## Cache length in the for loop  ``` solidity modified   contracts/contracts/LongShort.sol @@ -1059,7 +1059,8 @@ contract LongShort is ILongShort, Initializable {    /// @param user The address of the user for whom to execute the function for.    /// @param marketIndexes An array of int32s which each uniquely identify a market.    function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external { -    for (uint256 i = 0; i < marketIndexes.length; i++) { +    uint length = marketIndexes.length; +    for (uint256 i = 0; i < length; i++) {        _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);      }    } ```  In the previous case, at each iteration of the loop, length is read from memory. something like `mload(memory_offset)`. It takes `6` gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  In the replacement, the value is placed in the stack only once and each iteration involves a `dupN` (3 gas). Saves around 3 gas per iteration.  Here are other places that can use this.  ``` text ./contracts/contracts/LongShort.sol:776:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/LongShort.sol:1063:    for (uint256 i = 0; i < length; i++) { ./contracts/contracts/Staker.sol:790:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/mocks/BandOracleMock.sol:84:    for (uint256 i = 0; i < _bases.length; i++) { ./contracts/contracts/testing/LongShortInternalStateSetters.sol:34:    for (uint256 i = 0; i < marketIndexes.length; i++) { ```   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Changing a functionâ€™s visibility from public to external can save gas by avoiding the unnecessary copying of data to memory. Function stakeFromUser() in Staker.sol is only called from SyntheticTokens.sol and not from within the contract itself which means this can be made external.   ## Proof of Concept  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/Staker.sol#L839  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/SyntheticToken.sol#L56   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility to external where possible.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are multiple places where state variables are reused within functions by loading them multiple times. These operations result in expensive SLOAD instructions where the first SLOAD costs 2100 gas and successive SLOADs of the same variable cost 100 gas (since the Berlin hardfork).  Using local memory variables to cache them will remove the unnecessary SLOADs costing 100 gas resulting in MLOADs that only cost 3 gas units.  ## Proof of Concept  Caching latestMarket can save upto 13 SLOADs i.e. 1300 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L261-L298  Caching staked can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L267 https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L276  Caching latestMarket can save upto 3 SLOADs i.e. 3 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L352-L365  Caching marketUpdateIndex[marketIndex] appropriately can save many SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L817-L819  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L677-L757  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L860-L864  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L911-L922  Caching longShort address can save 300 300 gas by avoiding 3 SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/TokenFactory.sol#L68-L70  Caching amountReservedInCaseOfInsufficientAaveLiquidity can save upto 2 SLOADs i.e. 200 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L114-L121  Caching paymentToken can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L132-L142  Caching aaveIncentiveController can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167  Caching totalReservedForTreasury can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache storage-based state variables in local memory-based variables appropriately to convert SLOADs to MLOADs and reduce gas consumption from 100 units to 3 units.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the unlikely event `amountReservedInCaseOfInsufficientAaveLiquidity == amount`, the `else` case will be executed, which means `lendingPool.deposit()` is called with a value of zero. It would therefore be better to change the condition so that the `if` case is executed instead.  ### Recommended Mitigation Steps  ```jsx function depositPaymentToken(uint256 amount) external override longShortOnly {   // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount   // It basically always be zero besides extreme and unlikely situations with aave.   if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {   // instead of strictly greater than     if (amountReservedInCaseOfInsufficientAaveLiquidity >= amount) {       amountReservedInCaseOfInsufficientAaveLiquidity -= amount;       // Return early, nothing to deposit into the lending pool       return;     }  ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Updating a `kValue` of a market requires interpolation against the initial timestamp, which can be a hassle and might lead to a wrong value set from what is expected.   ### Proof of Concept  Consider the following scenario:  - Initially set `kValue = 2e18`, `kPeriod = 2592000` (30 days) - After 15 days, would like to refresh the market incentive (start again with `kValue = 2e18`), lasting another 30 days.  In the current implementation, the admin would call `_changeMarketLaunchIncentiveParameters()` with the following inputs:  - `period = 3888000` (45 days) - `kValue` needs to be worked backwards from the formula      `kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod)`. To achieve the desired effect, we would get `kValue = 25e17` (formula returns 2e18 after 15 days with kPeriod = 45 days).  This isn't immediately intuitive and could lead to mistakes.  ### Recommended Mitigation Steps  Instead of calculating from `initialTimestamp` (when `addNewStakingFund()` was called), calculate from when the market incentives were last updated. This would require a new mapping to store last updated timestamps of market incentives.  For example, using the scenario above, refreshing the market incentive would mean using inputs `period = 2592000` (30 days) with `kValue = 2e18`.  ```jsx // marketIndex => timestamp of updated market launch incentive params  mapping(uint32 => uint256) public marketLaunchIncentive_update_timestamps;  function _changeMarketLaunchIncentiveParameters(   uint32 marketIndex,   uint256 period,   uint256 initialMultiplier ) internal virtual {  require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");    marketLaunchIncentive_period[marketIndex] = period;   marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  marketLaunchIncentive_update_timestamps[marketIndex] = block.timestamp; };  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {   // Parameters controlling the float issuance multiplier.   (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);    // Sanity check - under normal circumstances, the multipliers should   // *never* be set to a value < 1e18, as there are guards against this.   assert(kInitialMultiplier >= 1e18);   // currently: uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  // changed to take from last updated timestamp instead of initial timestamp   uint256 initialTimestamp = marketLaunchIncentive_update_timestamps[marketIndex];    if (block.timestamp - initialTimestamp <= kPeriod) {     return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);   } else {     return 1e18;   } }  ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, there is an outstanding TODO in L437  `@dev to see below math in latex form see TODO add link`  The missing URL seems to be the one provided in the README on float [token rate issuance](https://www.overleaf.com/read/jpyhjgrvhfkr).  ### Recommended Mitigation Steps  Update / finish up the TODO.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The user's `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` are retrieved a number of times in `_calculateAccumulatedFloat()`. Caching these values would help save gas.  Note that block scoping is needed to avoid the stack too deep problem.  ### Recommended Mitigation Steps  ```jsx function _calculateAccumulatedFloat() {  // block scope for shiftAmount variable to avoid stack too deep  {   // Update the users balances    uint256 shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];    if (shiftAmount > 0) {      amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        true,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedLong -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;    }      shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user]    if (shiftAmount > 0) {      amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        false,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedShort -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;    }  }  // end of block scoping   // Save the users updated staked amounts  ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  LongShort.sol   - `re-uising` â†’ `reusing` - `visa versa` â†’ `vice versa` - `@param marketIndex An int32` â†’ `@param marketIndex A uint32` - `Non-existant` â†’ `Non-existent`  Staker.sol  - `Explicitely` â†’ `Explicitly` - `extremeley` â†’ `extremely`  YieldManagerAave.sol  - `revent` â†’ `revert`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The comparison and effecting `valueChange` in `_claimAndDistributeYieldThenRebalanceMarket()` can be made consistent with the other functions.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  ### Recommended Mitigation Steps  Change the `else` case to `else if (valueChange < 0)`.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else if (valueChange < 0) {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  By storing `marketUpdateIndex[marketIndex];` locally in `_updateSystemStateInternal()`, multiple sLOADs can be avoided.  ### Recommended Mitigation Steps  Gas savings of about 500-600 is achieved.  ```jsx function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {  ...  // cache marketUpdateIndex[marketIndex]   uint256 currentMarketIndex = marketUpdateIndex[marketIndex];    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;   if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex     ];     uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][       currentMarketIndex     ];    if (       userNextPrice_currentUpdateIndex[marketIndex][staker] == currentMarketIndex + 1 &&       assetPriceHasChanged     ) {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)         currentMarketIndex + 1       );     } else {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         0       );     }   ...   // increment currentMarketIndex   currentMarketIndex ++;    marketUpdateIndex[marketIndex] = currentMarketIndex;   syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_long;      syntheticToken_priceSnapshot[marketIndex][false][      currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_short;   ...   emit SystemStateUpdated(      marketIndex,      currentMarketIndex,    ...   );  } } ```  
# Handle  jonah1005   # Vulnerability details  ## Impact Aave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided. The aave rewards would be unclaimable.  ## Proof of Concept YieldManager's logic: https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170  Reference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards  ## Tools Used None ## Recommended Mitigation Steps Change to ```solidity     address[] memory rewardsDepositedAssets = new address[](1);     rewardsDepositedAssets[0] = address(aToken); ```   
# Handle  jonah1005   # Vulnerability details  # LongShort should not shares the same Yield Manager between different markets ## Impact The LongShort contract would not stop different markets from using the same yield manager contracts. Any extra aToken in the yield manager would be considered as market incentives in function `distributeYieldForTreasuryAndReturnMarketAllocation`. Thus, using the same yield manager for different markets would break the markets and allow users to withdraw fund that doesn't belong to them.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L179-L204  ## Tools Used None  ## Recommended Mitigation Steps Given the fluency of programming skills the dev shows, I believe they wouldn't make this mistake on deployment. Still, I think there's space to improve in the YieldManagerAave contract. IMHO. As it's tightly coupled with longshort contract and its market logic, a initialize market function in the yield manager seems more reasonable.  
# Handle  0xImpostor   # Vulnerability details  ## Impact  Use `marketIndex` to updateSystemState instead of querying `marketIndexOfToken[token]` twice.  ## Proof of Concept  Swap line 949 with 951 and swap line 974 with 976.  For example  ``` function withdrawAll(address token) external {     uint32 marketIndex = marketIndexOfToken[token];      ILongShort(longShort).updateSystemState(marketIndex);      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token       ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]       : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];      _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);   }  ```  ## Tools Used  Manual analysis  
# Handle  jonah1005   # Vulnerability details  ## Impact FloatToken would revoke staker's permission if msg.sender == stakerAddress. In `initializeFloatToken` the contract would first grant roles to `stakerAddress` and than revoke`msg.sender`'s permissions. The contract would be left with no privileged address if stakerAddress == msg.sender.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/FloatToken.sol#L21-L35  ## Tools Used None ## Recommended Mitigation Steps  ```solidity   function initializeFloatToken(     string calldata name,     string calldata symbol,     address stakerAddress   ) external initializer {     initialize(name, symbol);      renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);     renounceRole(MINTER_ROLE, msg.sender);     renounceRole(PAUSER_ROLE, msg.sender);        _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);     _setupRole(MINTER_ROLE, stakerAddress);     _setupRole(PAUSER_ROLE, stakerAddress);   } ```  
# Handle  evertkors   # Vulnerability details  A lot of docstrings for marketIndex are ` @param marketIndex An int32 which uniquely identifies a market.` but it is a `uint32` not an `int32`  
# Handle  gpersoon   # Vulnerability details  ## Impact I've seen comments which are confusing: ~10^31 or 10 Trillion (10^13) ==> probably should be 2^31 x * 5e17` == `(x * 10e18) / 2`   ==> probably should be 1e18/2  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L19 // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)  //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L480       // NOTE: `x * 5e17` == `(x * 10e18) / 2`  ## Tools Used  ## Recommended Mitigation Steps Double check the comments  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions initializeMarket and _seedMarketInitially use the variable latestMarket. If these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially   This would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.  Note: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304 function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {    ...     ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex     ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex    function initializeMarket(      uint32 marketIndex,....)   ...     require(!marketExists[marketIndex], "already initialized");     require(marketIndex <= latestMarket, "index too high");      marketExists[marketIndex] = true; ..     IStaker(staker).addNewStakingFund(       latestMarket,                                       // should be marketIndex       syntheticTokens[latestMarket][true],   // should be marketIndex       syntheticTokens[latestMarket][false],  // should be marketIndex   ...  ## Tools Used  ## Recommended Mitigation Steps Replace latestMarket with marketIndex in the functions initializeMarket and _seedMarketInitially  p.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!  
# Handle  gpersoon   # Vulnerability details  ## Impact In the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.  stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping  can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex [market2]  This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.  ## Proof of Concept // https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622     function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     ...       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;       stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;       batched_stakerNextTokenShiftIndex[marketIndex] += 1; ...  ## Tools Used  ## Recommended Mitigation Steps Add an index with marketIndex to the variables: - stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping  - stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping   Also consider shortening the variable names, this way mistakes can be spotted easier.  Confirmed by Jason of Float Capital: Yes, you are totally right, it should use the marketIndex since they are specific per market!  
# Handle   hickuphh3  # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns  `return (1e18 * k * longPrice, 0);` and  `return (0, 1e18 * k * shortPrice);` respectively.   This is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0`  and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,  `return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);` results in  `(0, 1e18 * k * shortPrice / 1e18)` or `(0, k * shortPrice)`.  As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.  ### Recommended Mitigation Steps  The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively.
# Handle  gpersoon   # Vulnerability details  ## Impact The function _batchConfirmOutstandingPendingActions of LongShort.sol processeses the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0  This means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126 LongShort.sol function _batchConfirmOutstandingPendingActions( ..     amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];     batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; ...         amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];            batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false         ## Tools Used  ## Recommended Mitigation Steps change the second instance of the following (on line 1207)    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0   to    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0    p.s. confirmed by Jason of Floatcapital: "Yes, that should definitely be false!"  
