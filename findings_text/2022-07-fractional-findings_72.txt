- [Low](#low)     - [**1. Packages with vulnerabilities**](#1-packages-with-vulnerabilities)     - [**2. Outdated compiler**](#2-outdated-compiler)     - [**3. Unsafe ERC20 calls**](#3-unsafe-erc20-calls)     - [**4. Lack of ACK during owner change**](#4-lack-of-ack-during-owner-change)     - [**5. Lack of nonReentrant in Buyout and Migration**](#5-lack-of-nonreentrant-in-buyout-and-migration)     - [**6. Lock ether**](#6-lock-ether)     - [**7. Complex fallback**](#7-complex-fallback) - [Non-Critical](#non-critical)     - [**8. Outdated packages**](#8-outdated-packages)     - [**9. Lack of checks**](#9-lack-of-checks)     - [**10. Open TODO**](#10-open-todo)     - [**11. Use abstract for base contracts**](#11-use-abstract-for-base-contracts)     - [**12. install allows uninstall**](#12-install-allows-uninstall)     - [**13. Contracts with functions without auth that can produce economic losses**](#13-contracts-with-functions-without-auth-that-can-produce-economic-losses)     - [**14. Improve propose method design**](#14-improve-propose-method-design)  # Low  ## **1. Packages with vulnerabilities**  The project contains packages that urgently need to be updated because they contain important vulnerabilities.  `npm audit`:  ``` 54 vulnerabilities (11 moderate, 40 high, 3 critical) ```  ## **2. Outdated compiler**  The pragma version used is:  ``` pragma solidity 0.8.13; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## **3. Unsafe ERC20 calls**  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [EIP-20](https://eips.ethereum.org/EIPS/eip-20) > NOTES: The following specifications use syntax from Solidity 0.4.17 (or above). Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  ```diff function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external { -   IERC20(_token).transfer(_to, _value); +   require(IERC20(_token).transfer(_to, _value)); } ```  - [TransferReference.sol#L22](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L22) - [SafeSend.sol#L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SafeSend.sol#L33)  Affected source code for `transferFrom`:  - [BaseVault.sol#L65](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L65)  ## **4. Lack of ACK during owner change**  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [FERC1155.sol#L234](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L234)  ## **5. Lack of `nonReentrant` in `Buyout` and `Migration`**  **ERC1155** tokens incorporate the ability to react to a transfer using the `onERC1155Received` method on the receiver. And in the `Buyout` contract there is an alteration of the states after the call to `safeTransferFrom`, so a reentry is possible.  ```javascript IERC1155(token).safeTransferFrom(     address(this),     msg.sender,     id,     _amount,     "" ); // Updates ether balance of pool buyoutInfo[_vault].ethBalance += msg.value; ```   In the `end` method, you play with fire by sending ether after the transfer, saving the reentrancy by deleting the `buyoutInfo[_vault];`  > *Safe Transfer Rules* > To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the ERC1155TokenReceiver hook functions, a list of scenarios and rules follows.  The definition of the `burn` method of an **ERC1155** is as follows:  > A contract **MAY** skip calling the ERC1155TokenReceiver hook function(s) if the mint operation is transferring the token(s) to itself. In all other cases the ERC1155TokenReceiver rules MUST be followed as appropriate for the implementation (i.e. safe, custom and/or hybrid).  Reference:  - https://eips.ethereum.org/EIPS/eip-1155#erc-1155-token-receiver  So some implementations that follow the standard of an **ERC1155** could also trigger a reentrancy.  In the case of the `settleFractions` method of the `Migration` contract, **reentrancy is possible since the `fractionsMigrated` flag is set after minting**, which would allow the contract to be minted multiple times, however the receiver of the `ERC1155TokenReceiver` event is ` address(this)` and is considered non-exploitable.  Under all these premises, I consider that the `nonReentrant` modifier is needed in the following methods:  - [Buyout.sol#L168-L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L168-L176) - [Buyout.sol#L226-L235](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L226-L235) - [Buyout.sol#L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L221) - [Buyout.sol#L264-L270](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L264-L270) - [Migration.sol#L164-L172](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L164-L172) - [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L279) - [Migration.sol#L312-L325](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L312-L325)  ## **6. Lock ether**  If someone sends ether to the `Buyout` contract without using the buy/sell methods, via the `receive` method, they will be blocked forever. A similar behavior occurs in the `Migration` contract.  Affected source code:  - [Buyout.sol#L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53) - [Migration.sol#L63](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L63)  ## **7. Complex `fallback`**  The fallback method iss too complex and can be denied in certain cases.  According to the `fallback` solidity (documentation](https://docs.soliditylang.org/en/develop/contracts.html#fallback-function)  > In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see [receive Ether function](https://docs.soliditylang.org/en/develop/contracts.html#receive-ether-function) for a brief description of the implications of this).  > In the worst case, the receive function can only rely on 2300 gas being available (for example when send or transfer is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend: > - Writing to storage > - Creating a contract > - Calling an external function which consumes a large amount of gas > - Sending Ether  Reference:  - https://docs.soliditylang.org/en/develop/contracts.html#fallback-function  Affected source code:  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ----  # Non-Critical  ## **8. Outdated packages**  Some used packages are out of date, it is good practice to use the latest version of these packages:  `"@openzeppelin/contracts": "^4.6.0"`   last `4.7.0`  ## **9. Lack of checks**  Check for `address(0)` during `constructor`, otherwise it could lead to bad initialization, bad implementations, or bad admin changes.  Affected source code for `address(0)`:  - [Supply.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L17) - [Metadata.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L17) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18) - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Buyout.sol#L47-L49](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L47-L49) - [Migration.sol#L58-L59](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L58-L59)  Royalty `_percentage` must be less than 100, otherwise it could result in a Denial of Service in [royaltyInfo](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L247): - [FERC1155.sol#L223](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L223)  ## **10. Open TODO**  The code that contains "open todos" reflects that the development is not finished and that the code can change a posteriori, prior release, with or without audit.  Affected source code:  - [MerkleBase.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L24)  ## **11. Use `abstract` for base contracts**  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Minter.sol#L12](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L12)  ## **12. `install` allows `uninstall`**  It is possible to use the method `install` for `uninstall`, and the emmited event will be different. Being able to affect the correct functioning of the dApps that consume it. You only need to specify an `address(0)` as plugin during `install`.  Affected source code:  - [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  ## **13. Contracts with functions without auth that can produce economic losses**  The `BaseVault`, `Transfer` or `TransferReference` contracts allows an attacker to steal all the tokens to the implementation it has without having any type of auth, although it is not expected to have tokens, and trying to call with a delegate call is a risk that must be known.  ```javascript function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external {    IERC20(_token).transfer(_to, _value); } ```  Affected source code:  - [Transfer.sol#L13](https://github.com/code-423n4/2022-07-fractional/blob/main/src/targets/Transfer.sol#L13) - [TransferReference.sol#L17-L69](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L17-L69) - [BaseVault.sol#L53-L117](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L53-L117)  The same thing happens in the `Supply` contract with `mint` and `burn`:  ```javascript /// @notice Mints fractional tokens /// @param _to Target address /// @param _value Transfer amount function mint(address _to, uint256 _value) external {     IVaultRegistry(registry).mint(_to, _value); }  /// @notice Burns fractional tokens /// @param _from Source address /// @param _value Burn amount function burn(address _from, uint256 _value) external {     IVaultRegistry(registry).burn(_from, _value); } ```  Affected source code:  - [Supply.sol#L11](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L11) - [SupplyReference.sol#L22-L31](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L22-L31)  ## **14. Improve `propose` method design**  The `propose` method of `Migration` contract should return the `proposalId` in order to avoid human errors like the one mentioned in the *"User may lose ether due to incorrect `proposalId`*.  Affected source code:  - [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) 
