# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L50-L59 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L33-L44   # Vulnerability details  ## Impact  Removing Yieldy contract addresses from the `contracts` array with `BatchRequests.removeAddress` replaces the contract address with a zero-address (due to how `delete` works).  Each function that loops over the `contracts` array or accesses an array item by index, should zero-address check the value before calling any external contract functions. If this zero-address check is missing, an external call to this zero-address will revert.  ## Proof of Concept  [BatchRequests.canBatchContractByIndex](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L50-L59)  ```solidity function canBatchContractByIndex(uint256 _index)     external     view     returns (address, bool) {     return (         contracts[_index],         IStaking(contracts[_index]).canBatchTransactions() // @audit-info `contracts` with zero-address elements (due to deletion) will revert - add zero-address check and return false     ); } ```  [BatchRequests.canBatchContracts](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L33-L44)  ```solidity function canBatchContracts() external view returns (Batch[] memory) {     uint256 contractsLength = contracts.length;     Batch[] memory batch = new Batch[](contractsLength);     for (uint256 i; i < contractsLength; ) {         bool canBatch = IStaking(contracts[i]).canBatchTransactions(); // @audit-info `contracts` with zero-address elements (due to deletion) will revert - add zero-address check         batch[i] = Batch(contracts[i], canBatch);         unchecked {             ++i;         }     }     return batch; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Add zero-address checks to both mentioned functions.   
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100   # Vulnerability details  `_storeRebase()`'s signature is as such:  - [Yieldy.sol#_storeRebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114)  ```solidity File: Yieldy.sol 104:     /** 105:         @notice emits event with data about rebase 106:         @param _previousCirculating uint 107:         @param _profit uint 108:         @param _epoch uint 109:      */ 110:     function _storeRebase( 111:         uint256 _previousCirculating, 112:         uint256 _profit, 113:         uint256 _epoch 114:     ) internal { ```  However, instead of being called with the expected `_previousCirculating` value, it's called with the current circulation value:  - [Yieldy.sol#rebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100)  ```solidity File: Yieldy.sol 89:             uint256 updatedTotalSupply = currentTotalSupply + _profit; ... 103:             _totalSupply = updatedTotalSupply; 104:  105:             _storeRebase(updatedTotalSupply, _profit, _epoch); // @audit-info this should be currentTotalSupply otherwise previous = current ```  As a consequence, the functionality isn't doing what it was created for.  ## Mitigation  Consider calling `_storeRebase()` with `currentTotalSupply`:  ```diff File: Yieldy.sol - 105:             _storeRebase(updatedTotalSupply, _profit, _epoch); + 105:             _storeRebase(currentTotalSupply, _profit, _epoch); ```   
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L435-L447   # Vulnerability details  ```solidity if (warmUpPeriod == 0) {     IYieldy(YIELDY_TOKEN).mint(_recipient, _amount); } else {     // create a claim and mint tokens so a user can claim them once warm up has passed     warmUpInfo[_recipient] = Claim({         amount: info.amount + _amount,         credits: info.credits +             IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),         expiry: epoch.number + warmUpPeriod     });      IYieldy(YIELDY_TOKEN).mint(address(this), _amount); } ```  `Staking.sol#stake()` is a public function and you can specify an arbitrary address as the `_recipient`.  When `warmUpPeriod > 0`, with as little as 1 wei of `YIELDY_TOKEN`, the `_recipient`'s `warmUpInfo` will be push back til `epoch.number + warmUpPeriod`.  ### Recommendation  Consider changing to not allow deposit to another address when `warmUpPeriod > 0`.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L769   # Vulnerability details  The function `preSign` acceps any `orderUid` `function preSign(bytes calldata orderUid) external onlyOwner`  Because of how Cowswap works, accepting any `orderUid` can be used as a rug-vector.  This is because the orderData contains a `receiver` which in lack of validation could be any address.  You'd also be signing other parameters such as minOut and how long the order could be filled for, which you may or may not want to validate to give stronger security guarantees to end users.   ## Recomended mitigation steps I'd recommend adding basic validation for tokenOut, minOut and receiver.  Feel free to check the work we've done at Badger to validate order parameters, giving way stronger guarantees to end users. https://github.com/GalloDaSballo/fair-selling/blob/44c0c0629289a0c4ccb3ca971cc5cd665ce5cb82/contracts/CowSwapSeller.sol#L194  Also notice how through the code above we are able to re-construct the `orderUid`, feel free to re-use that code which has been validated by the original Cowswap / GPv2 Developers  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L674-L696   # Vulnerability details  ## Impact In the Yieldy contract, functions such as balanceOf/creditsForTokenBalance/tokenBalanceForCredits/transfer/transferFrom/burn/mint will use the rebasingCreditsPerToken variable, so before calling these functions in the Staking contract, make sure that the rebase of this epoch has occurred. Therefore, the rebase function should also be called in the unstake/claim/claimWithdraw function of the Staking contract. ## Proof of Concept https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L674-L696 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L465-L508 ## Tools Used None ## Recommended Mitigation Steps ```     function claim(address _recipient) public {         Claim memory info = warmUpInfo[_recipient]; +      rebase(); ...     function claimWithdraw(address _recipient) public {         Claim memory info = coolDownInfo[_recipient]; +      rebase(); ...     function unstake(uint256 _amount, bool _trigger) external {         // prevent unstaking if override due to vulnerabilities asdf         require(!isUnstakingPaused, "Unstaking is paused"); -        if (_trigger) {             rebase(); -        } ```  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/Staking.sol#L308   # Vulnerability details  ## Impact The `withdraw` function of the ETH Tokemak pool has an additional parameter `asEth`. This can be seen in the Tokemak [Github repository](https://github.com/Tokemak/tokemak-smart-contracts-public/blob/2f54689d5d16ddfd1751493b161a049d6c98c382/contracts/pools/EthPool.sol#L94) or also when looking at the deployed code of the [ETH pool](https://etherscan.io/address/0xb104A7fA1041168556218DDb40Fe2516F88246d5#code). Compare that to e.g. the [USDC pool](https://etherscan.io/address/0xca5e07804beef19b6e71b9db18327d215cd58d4e#code), which does not have this parameter.  This means that the call to `withdraw` will when the staking token is ETH / WETH and no withdrawals would be possible.  ## Proof of Concept A new `Staking` contract with ETH / WETH as the staking token is deployed. Deposits in Tokemak work fine, so users stake their tokens. However, because of the previously described issue, no withdrawal is possible, leaving the funds locked.  ## Recommended Mitigation Steps Handle the case where the underlying asset is WETH / ETH separately and pass this boolean in that case.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/LiquidityReserve.sol#L161   # Vulnerability details  ## Impact Whale who provided most liquidity to the contract can simply use removeLiquidity function and can remove all of his liquidity. This can leave the residual liquidity to be less than MINIMUM_LIQUIDITY which is incorrect  ## Proof of Concept  1. Whale A provided initial liquidity plus more liquidity using enableLiquidityReserve and addLiquidity function  2. There are other small liquidity providers as well  3. Now Whale A decides to remove all the liquidity provided   4. This means after liquidity removal the balance liquidity will even drop below MINIMUM_LIQUIDITY which is incorrect  ## Recommended Mitigation Steps Add below check  ``` require(             IERC20Upgradeable(stakingToken).balanceOf(address(this)) - MINIMUM_LIQUIDITY >=                 amountToWithdraw,             "Not enough funds"         ); ```  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L38 https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L61-L62   # Vulnerability details  ## Impact A deprecated method is used in `Yieldy` contract.  ## Proof of Concept  In `Yieldy` contract the method `_setupRole` is used, and and it is explicitly marked as deprecated by OpenZeppelin.  > * NOTE: This function is deprecated in favor of {_grantRole}.  Affected source code:  - [Yieldy.sol#L38](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L38) - [Yieldy.sol#L61-L62](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L61-L62)  ## Recommended Mitigation Steps - The method `_setupRole` must be changed to `_grantRole`.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L93 https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L57 https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L37   # Vulnerability details  ## Impact The `BatchRequests.removeAddress` logic is wrong and it will produce a denial of service.  ## Proof of Concept  Removing the element from the array is done using the `delete` statement, but this is not the proper way to remove an entry from an array, it will just set that position to `address(0)`.  Append dummy data:  - `addAddress('0x0000000000000000000000000000000000000001')` - `addAddress('0x0000000000000000000000000000000000000002')` - `addAddress('0x0000000000000000000000000000000000000003')` - `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000002,0x0000000000000000000000000000000000000003`  Remove address: - `removeAddress(0x0000000000000000000000000000000000000002)` (or `0x0000000000000000000000000000000000000003`) - `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000000,0x0000000000000000000000000000000000000003`  Service is denied because it will try to call `canBatchContracts`  to `address(0)`.  ## Recommended Mitigation Steps - To remove an entry in an array you have to use `pop` and move the last element to the removed entry position.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L212   # Vulnerability details  ## Impact The security of the `Yieldy` contract is delegated to the compiler used.  ## Proof of Concept The `allowance` of an account does not have to reflect the real balance of an account, however in the `transferFrom` method, it is the value that is checked in order to verify that the user has enough balance to make the transfer.  ```javascript     function transferFrom(         address _from,         address _to,         uint256 _value     ) public override returns (bool) {         require(_allowances[_from][msg.sender] >= _value, "Allowance too low"); ```  However, the real balance of the `Yieldy` contract is based on the calculation made by the `creditsForTokenBalance` method, so an underflow could be made in the subtraction of the balance of the `from` account.  ```javascript         uint256 creditAmount = creditsForTokenBalance(_value);         creditBalances[_from] = creditBalances[_from] - creditAmount;         creditBalances[_to] = creditBalances[_to] + creditAmount;         emit Transfer(_from, _to, _value); ```  This means that the security of the contract is delegated to the checks added by the compiler depending on the pragma used, it must be taken into account that these checks may appear and disappear in future versions of the compiler, so they must be checked at the level of smart contracts.  Affected source code:  - [Yieldy.sol#L212](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L212)  ## Recommended Mitigation Steps - Check that the from account has a `creditAmount` balance.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/LiquidityReserve.sol#L196   # Vulnerability details  ## Impact Users can utilize the `instantUnstake` function without paying the liquidity provider fee using rounding errors in the fee calculation. This attack only allows for a relatively small amount of tokens to be unstaked in each call, so is likely not feasible on mainnet. However, on low-cost L2s and for tokens with a small decimal precision it is likely a feasible workaround.  ## Proof of Concept The `instantUnstake` fee is handled by sending the user back `amount - fee`. We can work around the fee by unstaking small amounts (`amount < BASIS_POINTS / fee`) in a loop until reaching the desired amount.  ## Tools Used N/A  ## Recommended Mitigation Steps Avoid using subtraction to calculate the fee as this causes the fee to be rounded down rather than the amount. I'd propose calculating amount less fee using a muldiv operation over (1 - fee). In this case, the fee is effectively rounded up instead of down, so it can never be 0 unless fee is 0. Uniswapv2 uses a similar solution for their LP fee: https://github.com/Uniswap/v2-core/blob/8b82b04a0b9e696c0e83f8b2f00e5d7be6888c79/contracts/UniswapV2Pair.sol#L180-L182  It might look like the following: ``` uint256 amountMinusFee = amount * (BASIS_POINTS - fee) / BASIS_POINTS ```  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L50-L59 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L33-L44   # Vulnerability details  ## Impact  Removing Yieldy contract addresses from the `contracts` array with `BatchRequests.removeAddress` replaces the contract address with a zero-address (due to how `delete` works).  Each function that loops over the `contracts` array or accesses an array item by index, should zero-address check the value before calling any external contract functions. If this zero-address check is missing, an external call to this zero-address will revert.  ## Proof of Concept  [BatchRequests.canBatchContractByIndex](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L50-L59)  ```solidity function canBatchContractByIndex(uint256 _index)     external     view     returns (address, bool) {     return (         contracts[_index],         IStaking(contracts[_index]).canBatchTransactions() // @audit-info `contracts` with zero-address elements (due to deletion) will revert - add zero-address check and return false     ); } ```  [BatchRequests.canBatchContracts](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L33-L44)  ```solidity function canBatchContracts() external view returns (Batch[] memory) {     uint256 contractsLength = contracts.length;     Batch[] memory batch = new Batch[](contractsLength);     for (uint256 i; i < contractsLength; ) {         bool canBatch = IStaking(contracts[i]).canBatchTransactions(); // @audit-info `contracts` with zero-address elements (due to deletion) will revert - add zero-address check         batch[i] = Batch(contracts[i], canBatch);         unchecked {             ++i;         }     }     return batch; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Add zero-address checks to both mentioned functions.   
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100   # Vulnerability details  `_storeRebase()`'s signature is as such:  - [Yieldy.sol#_storeRebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114)  ```solidity File: Yieldy.sol 104:     /** 105:         @notice emits event with data about rebase 106:         @param _previousCirculating uint 107:         @param _profit uint 108:         @param _epoch uint 109:      */ 110:     function _storeRebase( 111:         uint256 _previousCirculating, 112:         uint256 _profit, 113:         uint256 _epoch 114:     ) internal { ```  However, instead of being called with the expected `_previousCirculating` value, it's called with the current circulation value:  - [Yieldy.sol#rebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100)  ```solidity File: Yieldy.sol 89:             uint256 updatedTotalSupply = currentTotalSupply + _profit; ... 103:             _totalSupply = updatedTotalSupply; 104:  105:             _storeRebase(updatedTotalSupply, _profit, _epoch); // @audit-info this should be currentTotalSupply otherwise previous = current ```  As a consequence, the functionality isn't doing what it was created for.  ## Mitigation  Consider calling `_storeRebase()` with `currentTotalSupply`:  ```diff File: Yieldy.sol - 105:             _storeRebase(updatedTotalSupply, _profit, _epoch); + 105:             _storeRebase(currentTotalSupply, _profit, _epoch); ```   
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L435-L447   # Vulnerability details  ```solidity if (warmUpPeriod == 0) {     IYieldy(YIELDY_TOKEN).mint(_recipient, _amount); } else {     // create a claim and mint tokens so a user can claim them once warm up has passed     warmUpInfo[_recipient] = Claim({         amount: info.amount + _amount,         credits: info.credits +             IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),         expiry: epoch.number + warmUpPeriod     });      IYieldy(YIELDY_TOKEN).mint(address(this), _amount); } ```  `Staking.sol#stake()` is a public function and you can specify an arbitrary address as the `_recipient`.  When `warmUpPeriod > 0`, with as little as 1 wei of `YIELDY_TOKEN`, the `_recipient`'s `warmUpInfo` will be push back til `epoch.number + warmUpPeriod`.  ### Recommendation  Consider changing to not allow deposit to another address when `warmUpPeriod > 0`.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L769   # Vulnerability details  The function `preSign` acceps any `orderUid` `function preSign(bytes calldata orderUid) external onlyOwner`  Because of how Cowswap works, accepting any `orderUid` can be used as a rug-vector.  This is because the orderData contains a `receiver` which in lack of validation could be any address.  You'd also be signing other parameters such as minOut and how long the order could be filled for, which you may or may not want to validate to give stronger security guarantees to end users.   ## Recomended mitigation steps I'd recommend adding basic validation for tokenOut, minOut and receiver.  Feel free to check the work we've done at Badger to validate order parameters, giving way stronger guarantees to end users. https://github.com/GalloDaSballo/fair-selling/blob/44c0c0629289a0c4ccb3ca971cc5cd665ce5cb82/contracts/CowSwapSeller.sol#L194  Also notice how through the code above we are able to re-construct the `orderUid`, feel free to re-use that code which has been validated by the original Cowswap / GPv2 Developers  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L674-L696   # Vulnerability details  ## Impact In the Yieldy contract, functions such as balanceOf/creditsForTokenBalance/tokenBalanceForCredits/transfer/transferFrom/burn/mint will use the rebasingCreditsPerToken variable, so before calling these functions in the Staking contract, make sure that the rebase of this epoch has occurred. Therefore, the rebase function should also be called in the unstake/claim/claimWithdraw function of the Staking contract. ## Proof of Concept https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L674-L696 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L465-L508 ## Tools Used None ## Recommended Mitigation Steps ```     function claim(address _recipient) public {         Claim memory info = warmUpInfo[_recipient]; +      rebase(); ...     function claimWithdraw(address _recipient) public {         Claim memory info = coolDownInfo[_recipient]; +      rebase(); ...     function unstake(uint256 _amount, bool _trigger) external {         // prevent unstaking if override due to vulnerabilities asdf         require(!isUnstakingPaused, "Unstaking is paused"); -        if (_trigger) {             rebase(); -        } ```  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/Staking.sol#L308   # Vulnerability details  ## Impact The `withdraw` function of the ETH Tokemak pool has an additional parameter `asEth`. This can be seen in the Tokemak [Github repository](https://github.com/Tokemak/tokemak-smart-contracts-public/blob/2f54689d5d16ddfd1751493b161a049d6c98c382/contracts/pools/EthPool.sol#L94) or also when looking at the deployed code of the [ETH pool](https://etherscan.io/address/0xb104A7fA1041168556218DDb40Fe2516F88246d5#code). Compare that to e.g. the [USDC pool](https://etherscan.io/address/0xca5e07804beef19b6e71b9db18327d215cd58d4e#code), which does not have this parameter.  This means that the call to `withdraw` will when the staking token is ETH / WETH and no withdrawals would be possible.  ## Proof of Concept A new `Staking` contract with ETH / WETH as the staking token is deployed. Deposits in Tokemak work fine, so users stake their tokens. However, because of the previously described issue, no withdrawal is possible, leaving the funds locked.  ## Recommended Mitigation Steps Handle the case where the underlying asset is WETH / ETH separately and pass this boolean in that case.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/LiquidityReserve.sol#L161   # Vulnerability details  ## Impact Whale who provided most liquidity to the contract can simply use removeLiquidity function and can remove all of his liquidity. This can leave the residual liquidity to be less than MINIMUM_LIQUIDITY which is incorrect  ## Proof of Concept  1. Whale A provided initial liquidity plus more liquidity using enableLiquidityReserve and addLiquidity function  2. There are other small liquidity providers as well  3. Now Whale A decides to remove all the liquidity provided   4. This means after liquidity removal the balance liquidity will even drop below MINIMUM_LIQUIDITY which is incorrect  ## Recommended Mitigation Steps Add below check  ``` require(             IERC20Upgradeable(stakingToken).balanceOf(address(this)) - MINIMUM_LIQUIDITY >=                 amountToWithdraw,             "Not enough funds"         ); ```  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L38 https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L61-L62   # Vulnerability details  ## Impact A deprecated method is used in `Yieldy` contract.  ## Proof of Concept  In `Yieldy` contract the method `_setupRole` is used, and and it is explicitly marked as deprecated by OpenZeppelin.  > * NOTE: This function is deprecated in favor of {_grantRole}.  Affected source code:  - [Yieldy.sol#L38](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L38) - [Yieldy.sol#L61-L62](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L61-L62)  ## Recommended Mitigation Steps - The method `_setupRole` must be changed to `_grantRole`.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L93 https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L57 https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L37   # Vulnerability details  ## Impact The `BatchRequests.removeAddress` logic is wrong and it will produce a denial of service.  ## Proof of Concept  Removing the element from the array is done using the `delete` statement, but this is not the proper way to remove an entry from an array, it will just set that position to `address(0)`.  Append dummy data:  - `addAddress('0x0000000000000000000000000000000000000001')` - `addAddress('0x0000000000000000000000000000000000000002')` - `addAddress('0x0000000000000000000000000000000000000003')` - `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000002,0x0000000000000000000000000000000000000003`  Remove address: - `removeAddress(0x0000000000000000000000000000000000000002)` (or `0x0000000000000000000000000000000000000003`) - `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000000,0x0000000000000000000000000000000000000003`  Service is denied because it will try to call `canBatchContracts`  to `address(0)`.  ## Recommended Mitigation Steps - To remove an entry in an array you have to use `pop` and move the last element to the removed entry position.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L212   # Vulnerability details  ## Impact The security of the `Yieldy` contract is delegated to the compiler used.  ## Proof of Concept The `allowance` of an account does not have to reflect the real balance of an account, however in the `transferFrom` method, it is the value that is checked in order to verify that the user has enough balance to make the transfer.  ```javascript     function transferFrom(         address _from,         address _to,         uint256 _value     ) public override returns (bool) {         require(_allowances[_from][msg.sender] >= _value, "Allowance too low"); ```  However, the real balance of the `Yieldy` contract is based on the calculation made by the `creditsForTokenBalance` method, so an underflow could be made in the subtraction of the balance of the `from` account.  ```javascript         uint256 creditAmount = creditsForTokenBalance(_value);         creditBalances[_from] = creditBalances[_from] - creditAmount;         creditBalances[_to] = creditBalances[_to] + creditAmount;         emit Transfer(_from, _to, _value); ```  This means that the security of the contract is delegated to the checks added by the compiler depending on the pragma used, it must be taken into account that these checks may appear and disappear in future versions of the compiler, so they must be checked at the level of smart contracts.  Affected source code:  - [Yieldy.sol#L212](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L212)  ## Recommended Mitigation Steps - Check that the from account has a `creditAmount` balance.  
# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/LiquidityReserve.sol#L196   # Vulnerability details  ## Impact Users can utilize the `instantUnstake` function without paying the liquidity provider fee using rounding errors in the fee calculation. This attack only allows for a relatively small amount of tokens to be unstaked in each call, so is likely not feasible on mainnet. However, on low-cost L2s and for tokens with a small decimal precision it is likely a feasible workaround.  ## Proof of Concept The `instantUnstake` fee is handled by sending the user back `amount - fee`. We can work around the fee by unstaking small amounts (`amount < BASIS_POINTS / fee`) in a loop until reaching the desired amount.  ## Tools Used N/A  ## Recommended Mitigation Steps Avoid using subtraction to calculate the fee as this causes the fee to be rounded down rather than the amount. I'd propose calculating amount less fee using a muldiv operation over (1 - fee). In this case, the fee is effectively rounded up instead of down, so it can never be 0 unless fee is 0. Uniswapv2 uses a similar solution for their LP fee: https://github.com/Uniswap/v2-core/blob/8b82b04a0b9e696c0e83f8b2f00e5d7be6888c79/contracts/UniswapV2Pair.sol#L180-L182  It might look like the following: ``` uint256 amountMinusFee = amount * (BASIS_POINTS - fee) / BASIS_POINTS ```  
