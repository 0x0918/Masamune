# Handle  leastwood   # Vulnerability details  ## Impact  There are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`. All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract. However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.  ## Proof of Concept  Initial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).  Consider the following scenario: - Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`. - This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract. - Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role. - The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function. - As a result, the implementation contract will be self-destructed due the user controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `StorageLayoutV1.sol` contract is inherited by several contracts and represents a shared common state that ensures the slot layout of certain contracts are the same. It is possible to minimise the number of storage slots used by rearranging the state variables in the most efficient way.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/global/StorageLayoutV1.sol  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Arrange the `uint16`  and `bytes1` variables such that they fit into the same slot.  
# Handle  leastwood   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  
# Handle  leastwood   # Vulnerability details  ## Impact  There is currently no input validation done on the `Router.initialize()` and `NoteERC20.initialize()` functions, potentially leading to an initialized state where the contracts have no owner and the deployer needs to re-deploy the contract to have it working properly.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L63-L92 https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L90-L108  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Perform zero address checks for the `owner_`, `pauseRouter_` and `pauseGuardian_` inputs to ensure the contract isn't initialized into an unexpected state.  
# Handle  a_delamo   # Vulnerability details  On `ExchangeRate.sol`, we are using `latestRoundData`, but there are no validations that the data is not stale.  The current code is:  ```solidity             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, "ExchangeRate: invalid rate"); ```  But is missing the checks to validate the data is stale   ```solidity (roundId, rawPrice,, updatedAt, answeredInRound) = AggregatorV2V3Interface(rateOracle).latestRoundData(); require(rawPrice > 0, "Chainlink price <= 0"); require(updateTime != 0, "Incomplete round"); require(answeredInRound >= roundId, "Stale price"); ```  More information: https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round    
# Handle  hrkrshnn   # Vulnerability details  ## Used a fixed or pragma that spans only a single `0.x.*`  Currently, the pragma `>0.7.0` is used in several contracts. However, since 0.7.0 and 0.8.0 has breaking changes, especially the safemath by default, the contracts could be semantically different when compiled via `0.7.*` and `0.8.*`.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra `sload` operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra `mload` operation (3 additional gas for each iteration except for the first).  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` operation is only done once and subsequently replaced by a cheap `dupN` instruction.  This optimization is especially important if it is a storage array or if it is a lengthy for loop.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project.  ### Examples  Here are some examples where this can be applied (found using a simple grep)  ``` txt ./contracts/external/Views.sol:187:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/BatchAction.sol:42:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/BatchAction.sol:120:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/ERC1155Action.sol:62:        for (uint256 i; i < accounts.length; i++) { ./contracts/external/actions/ERC1155Action.sol:91:        for (uint256 i; i < portfolio.length; i++) { ./contracts/external/actions/ERC1155Action.sol:240:        for (uint256 i; i < ids.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:121:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:146:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:537:        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/TradingAction.sol:81:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/TradingAction.sol:123:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/nTokenMintAction.sol:110:        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) { ./contracts/external/actions/nTokenRedeemAction.sol:138:        for (uint256 i; i < markets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:222:        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:265:        for (uint256 i; i < markets.length; i++) { ./contracts/external/adapters/CompoundToNotionalV2.sol:81:        for (uint256 i; i < notionalV2CollateralIds.length; i++) { ./contracts/external/governance/NoteERC20.sol:98:        for (uint256 i = 0; i < initialGrantAmount.length; i++) { ./contracts/internal/balances/BalanceHandler.sol:300:        for (uint256 i; i < settleAmounts.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:31:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:345:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:449:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:528:            for (uint256 i; i < markets.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:77:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:131:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:232:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:495:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/markets/CashGroup.sol:297:        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) { ./contracts/internal/markets/CashGroup.sol:309:        for (uint256 i; i < cashGroup.rateScalars.length; i++) { ./contracts/internal/nTokenHandler.sol:279:        for (uint256 i; i < depositShares.length; i++) { ./contracts/internal/nTokenHandler.sol:306:        for (uint256 i; i < proportions.length; i++) { ./contracts/internal/nTokenHandler.sol:371:        for (; i < array1.length; i++) { ./contracts/internal/nTokenHandler.sol:494:            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/BitmapAssetsHandler.sol:96:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:20:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:40:        for (uint256 i; i < assetArray.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:129:        for (uint256 i; i < newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:161:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:171:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:202:        for (uint256 i; i < portfolioState.newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:283:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/TransferAssets.sol:47:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:32:        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:137:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:231:        for (uint256 i = portfolioIndex; i < assets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:250:        for (; j < assets.length; j++) { ./contracts/mocks/BaseMockLiquidation.sol:52:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/mocks/BaseMockLiquidation.sol:72:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/mocks/MockFlashLender.sol:30:        for (uint256 i; i < assets.length; i++) { ./contracts/mocks/MockFlashLender.sol:39:        for (uint256 i; i < assets.length; i++) { ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:  ```solidity // @audit token.notional are the LP tokens to redeem assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity); fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity); ```  This means the value depends on the **current market reserves** which can be manipulated. You're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.  See the "How do I tell if I’m using spot price?" section on [https://shouldiusespotpriceasmyoracle.com/](https://shouldiusespotpriceasmyoracle.com/). > However, by doing this you’re actually incorporating the spot price because you’re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.  ## Impact The value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )` where `(assetCashClaim, fCashClaim)` depend on the current market reserves which can be manipulated by an attacker via flashloans. Therefore, an attacker trading large amounts in the market either increases or decreases the value of an LP token.  If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens. If the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.  The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage. In constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/). However, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles: > "Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated." - Market.sol L424  ## Recommendation Do not use the current market reserves to determine the value of LP tokens. Think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.getMarketIndex` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact "Valid" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact "Valid" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it.   ## Impact Luckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.  ## Recommended Mitigation Steps We still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past. This should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.  ## Impact Users that didn't even have tokens at the time of proposal creation but are now interested in voting on the proposal can farm unclaimed incentives and impact the outcome of the proposal.  ## Recommended Mitigation Steps Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas. It also needs to be ensured that incentives cannot be increased through flash-loaning of assets.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.  ## Recommended Mitigation Steps In `initialize`, emit `OwnershipTransferred(address(0), owner_)`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700` value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see [blocktime](https://etherscan.io/chart/blocktime).  ## Recommended Mitigation Steps Use a `MIN_VOTING_PERIOD_BLOCKS` of `6545`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false` indicating an unsuccessful action.  ## Impact An off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful. This happens in the `approve`, `transfer` and `transferFrom` functions.  ## Recommended Mitigation Steps Only emit evens on `success`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `cTokenAggregator.decimals` value is set to `18` but `cTokens` only have `8` decimals. It's unclear what this `decimals` field refers to.  ## Recommended Mitigation Steps If it should refer to the `cToken` decimals, it's wrong and should be set to `8`. This value is not used inside the contract but it's `public` and anyone can read it.    
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.  ```solidity function notionalCallback(     address sender,     address account,     bytes calldata callbackData ) external returns (uint256) { // @audit sender can be passed in by the attacker require(sender == address(this), "Unauthorized callback"); ```  ## Impact An attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract. The `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker frontruns the actual transaction.  It's at least a griefing attack: I can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op. This will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:  ```solidity // @audit using a malicious contract, this can be any token address underlyingToken = CTokenInterface(cTokenBorrow).underlying(); bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount); require(success, "Transfer of repayment failed");  // Use the amount transferred to repay the borrow // @audit using a malicious contract, this can be a no-op uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount); ```  Note that the assumption at the end of the function "// When this exits a free collateral check will be triggered" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.  ## Recommended Mitigation Steps Fix the authorization check.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  See `CompoundToNotionalV2.notionalCallback`'s `IERC20(underlyingToken).transferFrom` call.  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value. As there is a `cToken` with `USDT` as the underlying this issue directly applies to the protocol.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `enableToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenAction` implements two token approvals, the `nTokenWhitelist` which is always used first, and the `nTokenAllowance` which is checked second. If the `nTokenWhitelist` does _not_ have enough allowance for the transfer, the transaction fails, even in the case where `nTokenAllowance` still has enough allowance.  ## Impact Transfers that have sufficient allowance fail in certain cases.  ## Recommended Mitigation Steps Instead of reverting if the `nTokenWhitelist` allowance is not enough, default to the `nTokenAllowance` case:  ```solidity // something like this  uint256 requiredAllowance = amount;  uint256 allowance = nTokenWhitelist[from][spender]; // use whitelist allowance first if (allowance > 0) {     uint256 min = amount < allowance ? amount : allowance;     requiredAllowance -= min;     allowance = allowance.sub(min);     nTokenWhitelist[from][spender] = allowance; }  // use currency-specific allowance now if(requiredAllowance > 0)     // This is the specific allowance for the nToken.     allowance = nTokenAllowance[from][spender][currencyId];     require(allowance >= requiredAllowance, "Insufficient allowance");     allowance = allowance.sub(requiredAllowance);     nTokenAllowance[from][spender][currencyId] = allowance; } ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action._checkPostTransferEvent` has open TODOs:  ```solidity // TODO: retrieve revert string require(status, "Call failed"); ```  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action.safeTransferFrom` / `ERC1155Action.safeBatchTransferFrom` functions do not follow the [recommended re-entrancy protection guidelines](https://docs.soliditylang.org/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern) and allow a re-entrancy through the `onERC1155Received` while state still has to be written.  ## Impact The re-entrancy doesn't seem to open any attacks currently as the re-entrancy call happens right at the beginning and no interesting variables are set yet.  ## Recommended Mitigation Steps While no immediate re-entrancy issues could be found, it's better to add these checks, especially, as calling this function from another Notional finance function in the future might lead to unintended issues.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details As the return value of `ERC1155.balanceOf` was changed to a signed integer, the `nERC1155Interface` does not implement the `ERC1155` interface and the `supportsInterface` call will return false if people call it with the actual `ERC1155` interface ID.  ## Impact Not all users of the contract might care about the `balance` function and call `supportsInterface` with the original EIP1155 interface. The contract will still deny the   ## Recommended Mitigation Steps It is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of `supportsInterface(ERC1155.interface)` should be for compatibility. Users need to be aware that this contract is not standard compliant and the `supportsInterface` call will fail.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `initialize` function that initializes important contract state can be called by anyone. Occurences: - `NoteERC20.initialize` - `Router.initialize`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. See details on [OZ](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the [fix here](https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1). The bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed. As the custom `GovernorAlpha.executeProposal` function removed the original "queued state check" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.  ## POC 1. Create a proposal using `propose`. The calldata will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`) 2. Call `executeProposal(proposalId, ...)` such that the following calls are made:  ``` call-0: grantRole(TIME_LOCK_ADMIN, attackerContract) call-1: grantRole(EXECUTOR, attackerContract) call-2: grantRole(PROPOSER, attackerContract) call-3: updateDelay(0) // such that _afterCall "isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp" passes call-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential) // attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal ```  > ℹ️  I already talked to Jeff Wu about this and he created a test case for it confirming this finding  ## Impact Anyone who can create a proposal can become Timelock admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`. Note that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.  ## Recommended Mitigation Steps We recommend updating the vulnerable contract to `TimelockController v3.4.2`. It currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Some parameters of functions are not checked for invalid values: - `PauseRouter.constructor`: addresses can be zero or not a contract - `CompoundToNotionalV2.constructor`: addresses can be zero or not a contract   ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  pauliax   # Vulnerability details  ## Impact Total supply depends on the decimals. I think it makes sense to express totalSupply something like this to make it more readable and maintainable in case you will decide to change decimals:      /// @notice EIP-20 token decimals for this token     uint8 public constant decimals = 8;      /// @notice Total number of tokens in circulation (100 million NOTE)     uint256 public constant totalSupply = 10_000_0000 * 10 ** decimals;   
# Handle  pauliax   # Vulnerability details  ## Impact function transferFrom in nTokenERC20Proxy emits Approval event:   emit Approval(msg.sender, from, newAllowance); The order of the parameters is wrong, 'msg.sender' and 'from' should be in the opposite order. This may confuse frontends or other services that consume these events from the outside.  ## Recommended Mitigation Steps   emit Approval(from, msg.sender, newAllowance);  
# Handle  pauliax   # Vulnerability details  ## Impact There are several checks that uint is not negative, e.g.:   cashGroup.maxMarketIndex >= 0 && These checks are pretty much useless as uint can never be negative. Remove them to save some gas.   
# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter of the constructor are used to initialize the sate variable and these state variable are used throughout the contract error in these parameter can lead to redeployment of the contract  ## Proof of Concept  constructor of ctokenAggregator.sol,  NotionalV1ToNotionalV2.sol, nTokenERC20Proxy.sol, Reservoir.sol, PauseRouter.sol lack zero address validation  ## Tools Used manual review  ## Recommended Mitigation Steps add address(0) validation in constructor  
# Handle  pauliax   # Vulnerability details  ## Impact contract NotionalV1ToNotionalV2 has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.  ## Recommended Mitigation Steps require(msg.sender == address(WETH), "Not WETH");  
# Handle  pauliax   # Vulnerability details  ## Impact There are several places that check if the address is a contract or not, e.g.:     uint256 codeSize;     assembly {         codeSize := extcodesize(operator)     }     // Sanity check to ensure that operator is a contract, not an EOA     require(codeSize > 0, "Operator must be a contract"); First of all, I want you to be aware that this check can be easily bypassed. A contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but extcodesize for its address returns zero. In your case, currently, I do not see a real problem with that as you only use it as an additional check (no critical functionality) but I have a suggestion for you to extract this check to a separate library to make it more maintainable or use a library from OpenZeppelin that exposes this function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L26   
# Handle  pauliax   # Vulnerability details  ## Impact function notionalCallback (in NotionalV1ToNotionalV2 and CompoundToNotionalV2) declares to return uint, however, no actual value is returned.   ## Recommended Mitigation Steps Either remove the return declaration or return the intended value (I assume it may return a value that it gets from depositUnderlyingToken/depositAssetToken). Otherwise, it may confuse other protocols that later may want to integrate with you.  
# Handle  pauliax   # Vulnerability details  ## Impact Anyone can call function notionalCallback with arbitrary params and pass the auth check. The only auth check can be easily bypassed by setting sender param to the address of this contract. It allows to choose any parameter that I want:     function notionalCallback(         address sender,         address account,         bytes calldata callbackData     ) external returns (uint256) {         require(sender == address(this), "Unauthorized callback");  ## Recommended Mitigation Steps It needs to check that msg.sender is Notional.  
# Handle  pauliax   # Vulnerability details  ## Impact function activateNotional calls Address.isContract(...) but does not check the returned value, thus making this call pretty much useless:   Address.isContract(address(notionalProxy_));  ## Recommended Mitigation Steps Wrap this in a require statement.  
# Handle  JMukesh   # Vulnerability details  ## Impact function migrateBorrowFromCompound(         address cTokenBorrow,         uint256 cTokenRepayAmount,         uint16[] memory notionalV2CollateralIds,         uint256[] memory notionalV2CollateralAmounts,         BalanceActionWithTrades[] calldata borrowAction     ) ;  if the  array length of notionalV2CollateralId ,  notionalV2CollateralAmounts and  borrowAction is not equal it can lead to an error  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24   ## Tools Used  manual review  ## Recommended Mitigation Steps check the input array length  
# Handle  JMukesh   # Vulnerability details  ## Impact proposal get defeated even if forVotes == againstVotes during the voting which impact the given proposals. Instead of this condition forVotes <= againstVotes, it should be  forVotes < againstVotes  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/GovernorAlpha.sol#L389  ## Tools Used manual review  ## Recommended Mitigation Steps change the condition for determining the states  
# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract ExchangeRate.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID nor timeStamp, resulting in stale prices. Stale prices could put funds at risk. Freshness of the returned price should be checked, since it affects an account's health (and therefore liquidations). Stale prices that do not reflect the current market price anymore could be used which would influence the liquidation pricing.   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol". 2. latestRoundData has been used in the repository. 3. The code can be seen from the below. Stale prices have not been checked.  ```         } else {             address rateOracle = address(bytes20(data << 96));             // prettier-ignore             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, "ExchangeRate: invalid rate");              uint8 rateDecimalPlaces = uint8(bytes1(data << 88));             rateDecimals = int256(10**rateDecimalPlaces);             if (                 bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */             ) {                 rate = rateDecimals.mul(rateDecimals).div(rate);             }         }  ```  ## Tools Used  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```   
# Handle  tensors   # Vulnerability details  ## Impact Lack of checks on target could lead to loss of funds.  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50  ## Recommended Mitigation Steps Require that target is non-zero.  
# Handle  tensors   # Vulnerability details  ## Impact Registering tokens that aren't properly vetted can lead to a loss of funds if the token has callbacks.  CREAM finance got hacked in a similar way because the ampleforth token had a callback in the transfer method that wasn't noticed when they vetted it.   ## Proof of Concept For example, the redeem function is vulnerable to such a reentrancy in the balanceOf method, since address balances aren't updated before the token call.  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L131   ## Recommended Mitigation Steps Either: - Add nonreentrant modifiers - Update all storage variables before making outside calls with the token - Put steps in place for devs to properly vet tokens.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilise the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic. When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious frontrunning. However, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and frontrun the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60 https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  As the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer of nTokenAction.sol uses temporary variables and updates the sender and recipient separately. This is a dangerous constructions because the update of the recipient could overwrite the update of the sender. This has led to several hacks at other comparable contracts  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol ```JS  function _transfer(uint256 currencyId,address sender,address recipient, uint256 amount) internal returns (bool) {        ...           senderBalance.netNTokenTransfer = amountInt.neg();         recipientBalance.netNTokenTransfer = amountInt;          senderBalance.finalize(sender, senderContext, false);         recipientBalance.finalize(recipient, recipientContext, false);         senderContext.setAccountContext(sender);         recipientContext.setAccountContext(recipient); ... ```  ## Tools Used  ## Recommended Mitigation Steps Double check what happens when sender==recipient  Add checks to make sure (sender!=recipient) because that usually isn't useful anyway.   
# Handle  gpersoon   # Vulnerability details  ## Impact The code contains "pragma experimental ABIEncoderV2;" In the later Solidity versions it is no longer necessary to use the "experimental" version. Using experimental constructions is not recommended for production code.  See: https://docs.soliditylang.org/en/v0.8.7/layout-of-source-files.html#abiencoderv2  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol ```JS pragma experimental ABIEncoderV2; ```  ## Tools Used  ## Recommended Mitigation Steps Replace pragma experimental ABIEncoderV2; with pragma abicoder v2;  And make sure you use at least solidity version 0.7.5    
# Handle  gpersoon   # Vulnerability details  ## Impact The function getRouterImplementation of Router.sol checks the selectors of functions and calls the appropriate function. Selectors are only 4 bytes long so there is a theoretical probability of a collision (e.g. two functions having the same selector).  This is comparable to the "birthday attack" : https://en.wikipedia.org/wiki/Birthday_attack The probability of a collision when you have 93 different functions is 10^−6. Due to the structure of the Router.sol, the solidity compiler does not prevent collisions  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97 ```JS   function getRouterImplementation(bytes4 sig) public view returns (address) {         if (             sig == NotionalProxy.batchBalanceAction.selector ||             sig == NotionalProxy.batchBalanceAndTradeAction.selector ||      ...  ```  ## Tools Used  ## Recommended Mitigation Steps Double check (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.  
# Handle  Omik   # Vulnerability details  ## Impact The implementation of the transfer function in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol is the different from the usual erc20 token transfer function, this happen because it count the incentive that the user get, but the with self tranfer it can lead to unlimited mint, because https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L278 it makes the amount to negative, but in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279 it return the value to amount that not negative, so in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282 it finalize the positive value only since the negative value is change to the positive value, you can interact this transfer function through https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used Manual  ## Recommended Mitigation Steps add (sender != recipient)  
# Handle  leastwood   # Vulnerability details  ## Impact  There are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`. All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract. However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.  ## Proof of Concept  Initial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).  Consider the following scenario: - Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`. - This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract. - Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role. - The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function. - As a result, the implementation contract will be self-destructed due the user controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `StorageLayoutV1.sol` contract is inherited by several contracts and represents a shared common state that ensures the slot layout of certain contracts are the same. It is possible to minimise the number of storage slots used by rearranging the state variables in the most efficient way.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/global/StorageLayoutV1.sol  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Arrange the `uint16`  and `bytes1` variables such that they fit into the same slot.  
# Handle  leastwood   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  
# Handle  leastwood   # Vulnerability details  ## Impact  There is currently no input validation done on the `Router.initialize()` and `NoteERC20.initialize()` functions, potentially leading to an initialized state where the contracts have no owner and the deployer needs to re-deploy the contract to have it working properly.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L63-L92 https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L90-L108  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Perform zero address checks for the `owner_`, `pauseRouter_` and `pauseGuardian_` inputs to ensure the contract isn't initialized into an unexpected state.  
# Handle  a_delamo   # Vulnerability details  On `ExchangeRate.sol`, we are using `latestRoundData`, but there are no validations that the data is not stale.  The current code is:  ```solidity             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, "ExchangeRate: invalid rate"); ```  But is missing the checks to validate the data is stale   ```solidity (roundId, rawPrice,, updatedAt, answeredInRound) = AggregatorV2V3Interface(rateOracle).latestRoundData(); require(rawPrice > 0, "Chainlink price <= 0"); require(updateTime != 0, "Incomplete round"); require(answeredInRound >= roundId, "Stale price"); ```  More information: https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round    
# Handle  hrkrshnn   # Vulnerability details  ## Used a fixed or pragma that spans only a single `0.x.*`  Currently, the pragma `>0.7.0` is used in several contracts. However, since 0.7.0 and 0.8.0 has breaking changes, especially the safemath by default, the contracts could be semantically different when compiled via `0.7.*` and `0.8.*`.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra `sload` operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra `mload` operation (3 additional gas for each iteration except for the first).  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` operation is only done once and subsequently replaced by a cheap `dupN` instruction.  This optimization is especially important if it is a storage array or if it is a lengthy for loop.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project.  ### Examples  Here are some examples where this can be applied (found using a simple grep)  ``` txt ./contracts/external/Views.sol:187:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/BatchAction.sol:42:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/BatchAction.sol:120:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/ERC1155Action.sol:62:        for (uint256 i; i < accounts.length; i++) { ./contracts/external/actions/ERC1155Action.sol:91:        for (uint256 i; i < portfolio.length; i++) { ./contracts/external/actions/ERC1155Action.sol:240:        for (uint256 i; i < ids.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:121:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:146:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:537:        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/TradingAction.sol:81:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/TradingAction.sol:123:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/nTokenMintAction.sol:110:        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) { ./contracts/external/actions/nTokenRedeemAction.sol:138:        for (uint256 i; i < markets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:222:        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:265:        for (uint256 i; i < markets.length; i++) { ./contracts/external/adapters/CompoundToNotionalV2.sol:81:        for (uint256 i; i < notionalV2CollateralIds.length; i++) { ./contracts/external/governance/NoteERC20.sol:98:        for (uint256 i = 0; i < initialGrantAmount.length; i++) { ./contracts/internal/balances/BalanceHandler.sol:300:        for (uint256 i; i < settleAmounts.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:31:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:345:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:449:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:528:            for (uint256 i; i < markets.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:77:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:131:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:232:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:495:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/markets/CashGroup.sol:297:        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) { ./contracts/internal/markets/CashGroup.sol:309:        for (uint256 i; i < cashGroup.rateScalars.length; i++) { ./contracts/internal/nTokenHandler.sol:279:        for (uint256 i; i < depositShares.length; i++) { ./contracts/internal/nTokenHandler.sol:306:        for (uint256 i; i < proportions.length; i++) { ./contracts/internal/nTokenHandler.sol:371:        for (; i < array1.length; i++) { ./contracts/internal/nTokenHandler.sol:494:            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/BitmapAssetsHandler.sol:96:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:20:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:40:        for (uint256 i; i < assetArray.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:129:        for (uint256 i; i < newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:161:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:171:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:202:        for (uint256 i; i < portfolioState.newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:283:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/TransferAssets.sol:47:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:32:        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:137:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:231:        for (uint256 i = portfolioIndex; i < assets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:250:        for (; j < assets.length; j++) { ./contracts/mocks/BaseMockLiquidation.sol:52:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/mocks/BaseMockLiquidation.sol:72:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/mocks/MockFlashLender.sol:30:        for (uint256 i; i < assets.length; i++) { ./contracts/mocks/MockFlashLender.sol:39:        for (uint256 i; i < assets.length; i++) { ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:  ```solidity // @audit token.notional are the LP tokens to redeem assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity); fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity); ```  This means the value depends on the **current market reserves** which can be manipulated. You're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.  See the "How do I tell if I’m using spot price?" section on [https://shouldiusespotpriceasmyoracle.com/](https://shouldiusespotpriceasmyoracle.com/). > However, by doing this you’re actually incorporating the spot price because you’re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.  ## Impact The value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )` where `(assetCashClaim, fCashClaim)` depend on the current market reserves which can be manipulated by an attacker via flashloans. Therefore, an attacker trading large amounts in the market either increases or decreases the value of an LP token.  If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens. If the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.  The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage. In constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/). However, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles: > "Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated." - Market.sol L424  ## Recommendation Do not use the current market reserves to determine the value of LP tokens. Think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.getMarketIndex` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact "Valid" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact "Valid" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it.   ## Impact Luckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.  ## Recommended Mitigation Steps We still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past. This should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.  ## Impact Users that didn't even have tokens at the time of proposal creation but are now interested in voting on the proposal can farm unclaimed incentives and impact the outcome of the proposal.  ## Recommended Mitigation Steps Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas. It also needs to be ensured that incentives cannot be increased through flash-loaning of assets.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.  ## Recommended Mitigation Steps In `initialize`, emit `OwnershipTransferred(address(0), owner_)`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700` value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see [blocktime](https://etherscan.io/chart/blocktime).  ## Recommended Mitigation Steps Use a `MIN_VOTING_PERIOD_BLOCKS` of `6545`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false` indicating an unsuccessful action.  ## Impact An off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful. This happens in the `approve`, `transfer` and `transferFrom` functions.  ## Recommended Mitigation Steps Only emit evens on `success`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `cTokenAggregator.decimals` value is set to `18` but `cTokens` only have `8` decimals. It's unclear what this `decimals` field refers to.  ## Recommended Mitigation Steps If it should refer to the `cToken` decimals, it's wrong and should be set to `8`. This value is not used inside the contract but it's `public` and anyone can read it.    
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.  ```solidity function notionalCallback(     address sender,     address account,     bytes calldata callbackData ) external returns (uint256) { // @audit sender can be passed in by the attacker require(sender == address(this), "Unauthorized callback"); ```  ## Impact An attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract. The `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker frontruns the actual transaction.  It's at least a griefing attack: I can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op. This will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:  ```solidity // @audit using a malicious contract, this can be any token address underlyingToken = CTokenInterface(cTokenBorrow).underlying(); bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount); require(success, "Transfer of repayment failed");  // Use the amount transferred to repay the borrow // @audit using a malicious contract, this can be a no-op uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount); ```  Note that the assumption at the end of the function "// When this exits a free collateral check will be triggered" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.  ## Recommended Mitigation Steps Fix the authorization check.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  See `CompoundToNotionalV2.notionalCallback`'s `IERC20(underlyingToken).transferFrom` call.  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value. As there is a `cToken` with `USDT` as the underlying this issue directly applies to the protocol.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `enableToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenAction` implements two token approvals, the `nTokenWhitelist` which is always used first, and the `nTokenAllowance` which is checked second. If the `nTokenWhitelist` does _not_ have enough allowance for the transfer, the transaction fails, even in the case where `nTokenAllowance` still has enough allowance.  ## Impact Transfers that have sufficient allowance fail in certain cases.  ## Recommended Mitigation Steps Instead of reverting if the `nTokenWhitelist` allowance is not enough, default to the `nTokenAllowance` case:  ```solidity // something like this  uint256 requiredAllowance = amount;  uint256 allowance = nTokenWhitelist[from][spender]; // use whitelist allowance first if (allowance > 0) {     uint256 min = amount < allowance ? amount : allowance;     requiredAllowance -= min;     allowance = allowance.sub(min);     nTokenWhitelist[from][spender] = allowance; }  // use currency-specific allowance now if(requiredAllowance > 0)     // This is the specific allowance for the nToken.     allowance = nTokenAllowance[from][spender][currencyId];     require(allowance >= requiredAllowance, "Insufficient allowance");     allowance = allowance.sub(requiredAllowance);     nTokenAllowance[from][spender][currencyId] = allowance; } ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action._checkPostTransferEvent` has open TODOs:  ```solidity // TODO: retrieve revert string require(status, "Call failed"); ```  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action.safeTransferFrom` / `ERC1155Action.safeBatchTransferFrom` functions do not follow the [recommended re-entrancy protection guidelines](https://docs.soliditylang.org/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern) and allow a re-entrancy through the `onERC1155Received` while state still has to be written.  ## Impact The re-entrancy doesn't seem to open any attacks currently as the re-entrancy call happens right at the beginning and no interesting variables are set yet.  ## Recommended Mitigation Steps While no immediate re-entrancy issues could be found, it's better to add these checks, especially, as calling this function from another Notional finance function in the future might lead to unintended issues.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details As the return value of `ERC1155.balanceOf` was changed to a signed integer, the `nERC1155Interface` does not implement the `ERC1155` interface and the `supportsInterface` call will return false if people call it with the actual `ERC1155` interface ID.  ## Impact Not all users of the contract might care about the `balance` function and call `supportsInterface` with the original EIP1155 interface. The contract will still deny the   ## Recommended Mitigation Steps It is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of `supportsInterface(ERC1155.interface)` should be for compatibility. Users need to be aware that this contract is not standard compliant and the `supportsInterface` call will fail.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `initialize` function that initializes important contract state can be called by anyone. Occurences: - `NoteERC20.initialize` - `Router.initialize`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. See details on [OZ](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the [fix here](https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1). The bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed. As the custom `GovernorAlpha.executeProposal` function removed the original "queued state check" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.  ## POC 1. Create a proposal using `propose`. The calldata will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`) 2. Call `executeProposal(proposalId, ...)` such that the following calls are made:  ``` call-0: grantRole(TIME_LOCK_ADMIN, attackerContract) call-1: grantRole(EXECUTOR, attackerContract) call-2: grantRole(PROPOSER, attackerContract) call-3: updateDelay(0) // such that _afterCall "isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp" passes call-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential) // attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal ```  > ℹ️  I already talked to Jeff Wu about this and he created a test case for it confirming this finding  ## Impact Anyone who can create a proposal can become Timelock admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`. Note that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.  ## Recommended Mitigation Steps We recommend updating the vulnerable contract to `TimelockController v3.4.2`. It currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Some parameters of functions are not checked for invalid values: - `PauseRouter.constructor`: addresses can be zero or not a contract - `CompoundToNotionalV2.constructor`: addresses can be zero or not a contract   ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  pauliax   # Vulnerability details  ## Impact Total supply depends on the decimals. I think it makes sense to express totalSupply something like this to make it more readable and maintainable in case you will decide to change decimals:      /// @notice EIP-20 token decimals for this token     uint8 public constant decimals = 8;      /// @notice Total number of tokens in circulation (100 million NOTE)     uint256 public constant totalSupply = 10_000_0000 * 10 ** decimals;   
# Handle  pauliax   # Vulnerability details  ## Impact function transferFrom in nTokenERC20Proxy emits Approval event:   emit Approval(msg.sender, from, newAllowance); The order of the parameters is wrong, 'msg.sender' and 'from' should be in the opposite order. This may confuse frontends or other services that consume these events from the outside.  ## Recommended Mitigation Steps   emit Approval(from, msg.sender, newAllowance);  
# Handle  pauliax   # Vulnerability details  ## Impact There are several checks that uint is not negative, e.g.:   cashGroup.maxMarketIndex >= 0 && These checks are pretty much useless as uint can never be negative. Remove them to save some gas.   
# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter of the constructor are used to initialize the sate variable and these state variable are used throughout the contract error in these parameter can lead to redeployment of the contract  ## Proof of Concept  constructor of ctokenAggregator.sol,  NotionalV1ToNotionalV2.sol, nTokenERC20Proxy.sol, Reservoir.sol, PauseRouter.sol lack zero address validation  ## Tools Used manual review  ## Recommended Mitigation Steps add address(0) validation in constructor  
# Handle  pauliax   # Vulnerability details  ## Impact contract NotionalV1ToNotionalV2 has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.  ## Recommended Mitigation Steps require(msg.sender == address(WETH), "Not WETH");  
# Handle  pauliax   # Vulnerability details  ## Impact There are several places that check if the address is a contract or not, e.g.:     uint256 codeSize;     assembly {         codeSize := extcodesize(operator)     }     // Sanity check to ensure that operator is a contract, not an EOA     require(codeSize > 0, "Operator must be a contract"); First of all, I want you to be aware that this check can be easily bypassed. A contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but extcodesize for its address returns zero. In your case, currently, I do not see a real problem with that as you only use it as an additional check (no critical functionality) but I have a suggestion for you to extract this check to a separate library to make it more maintainable or use a library from OpenZeppelin that exposes this function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L26   
# Handle  pauliax   # Vulnerability details  ## Impact function notionalCallback (in NotionalV1ToNotionalV2 and CompoundToNotionalV2) declares to return uint, however, no actual value is returned.   ## Recommended Mitigation Steps Either remove the return declaration or return the intended value (I assume it may return a value that it gets from depositUnderlyingToken/depositAssetToken). Otherwise, it may confuse other protocols that later may want to integrate with you.  
# Handle  pauliax   # Vulnerability details  ## Impact Anyone can call function notionalCallback with arbitrary params and pass the auth check. The only auth check can be easily bypassed by setting sender param to the address of this contract. It allows to choose any parameter that I want:     function notionalCallback(         address sender,         address account,         bytes calldata callbackData     ) external returns (uint256) {         require(sender == address(this), "Unauthorized callback");  ## Recommended Mitigation Steps It needs to check that msg.sender is Notional.  
# Handle  pauliax   # Vulnerability details  ## Impact function activateNotional calls Address.isContract(...) but does not check the returned value, thus making this call pretty much useless:   Address.isContract(address(notionalProxy_));  ## Recommended Mitigation Steps Wrap this in a require statement.  
# Handle  JMukesh   # Vulnerability details  ## Impact function migrateBorrowFromCompound(         address cTokenBorrow,         uint256 cTokenRepayAmount,         uint16[] memory notionalV2CollateralIds,         uint256[] memory notionalV2CollateralAmounts,         BalanceActionWithTrades[] calldata borrowAction     ) ;  if the  array length of notionalV2CollateralId ,  notionalV2CollateralAmounts and  borrowAction is not equal it can lead to an error  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24   ## Tools Used  manual review  ## Recommended Mitigation Steps check the input array length  
# Handle  JMukesh   # Vulnerability details  ## Impact proposal get defeated even if forVotes == againstVotes during the voting which impact the given proposals. Instead of this condition forVotes <= againstVotes, it should be  forVotes < againstVotes  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/GovernorAlpha.sol#L389  ## Tools Used manual review  ## Recommended Mitigation Steps change the condition for determining the states  
# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract ExchangeRate.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID nor timeStamp, resulting in stale prices. Stale prices could put funds at risk. Freshness of the returned price should be checked, since it affects an account's health (and therefore liquidations). Stale prices that do not reflect the current market price anymore could be used which would influence the liquidation pricing.   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol". 2. latestRoundData has been used in the repository. 3. The code can be seen from the below. Stale prices have not been checked.  ```         } else {             address rateOracle = address(bytes20(data << 96));             // prettier-ignore             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, "ExchangeRate: invalid rate");              uint8 rateDecimalPlaces = uint8(bytes1(data << 88));             rateDecimals = int256(10**rateDecimalPlaces);             if (                 bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */             ) {                 rate = rateDecimals.mul(rateDecimals).div(rate);             }         }  ```  ## Tools Used  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```   
# Handle  tensors   # Vulnerability details  ## Impact Lack of checks on target could lead to loss of funds.  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50  ## Recommended Mitigation Steps Require that target is non-zero.  
# Handle  tensors   # Vulnerability details  ## Impact Registering tokens that aren't properly vetted can lead to a loss of funds if the token has callbacks.  CREAM finance got hacked in a similar way because the ampleforth token had a callback in the transfer method that wasn't noticed when they vetted it.   ## Proof of Concept For example, the redeem function is vulnerable to such a reentrancy in the balanceOf method, since address balances aren't updated before the token call.  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L131   ## Recommended Mitigation Steps Either: - Add nonreentrant modifiers - Update all storage variables before making outside calls with the token - Put steps in place for devs to properly vet tokens.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilise the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic. When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious frontrunning. However, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and frontrun the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60 https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  As the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer of nTokenAction.sol uses temporary variables and updates the sender and recipient separately. This is a dangerous constructions because the update of the recipient could overwrite the update of the sender. This has led to several hacks at other comparable contracts  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol ```JS  function _transfer(uint256 currencyId,address sender,address recipient, uint256 amount) internal returns (bool) {        ...           senderBalance.netNTokenTransfer = amountInt.neg();         recipientBalance.netNTokenTransfer = amountInt;          senderBalance.finalize(sender, senderContext, false);         recipientBalance.finalize(recipient, recipientContext, false);         senderContext.setAccountContext(sender);         recipientContext.setAccountContext(recipient); ... ```  ## Tools Used  ## Recommended Mitigation Steps Double check what happens when sender==recipient  Add checks to make sure (sender!=recipient) because that usually isn't useful anyway.   
# Handle  gpersoon   # Vulnerability details  ## Impact The code contains "pragma experimental ABIEncoderV2;" In the later Solidity versions it is no longer necessary to use the "experimental" version. Using experimental constructions is not recommended for production code.  See: https://docs.soliditylang.org/en/v0.8.7/layout-of-source-files.html#abiencoderv2  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol ```JS pragma experimental ABIEncoderV2; ```  ## Tools Used  ## Recommended Mitigation Steps Replace pragma experimental ABIEncoderV2; with pragma abicoder v2;  And make sure you use at least solidity version 0.7.5    
# Handle  gpersoon   # Vulnerability details  ## Impact The function getRouterImplementation of Router.sol checks the selectors of functions and calls the appropriate function. Selectors are only 4 bytes long so there is a theoretical probability of a collision (e.g. two functions having the same selector).  This is comparable to the "birthday attack" : https://en.wikipedia.org/wiki/Birthday_attack The probability of a collision when you have 93 different functions is 10^−6. Due to the structure of the Router.sol, the solidity compiler does not prevent collisions  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97 ```JS   function getRouterImplementation(bytes4 sig) public view returns (address) {         if (             sig == NotionalProxy.batchBalanceAction.selector ||             sig == NotionalProxy.batchBalanceAndTradeAction.selector ||      ...  ```  ## Tools Used  ## Recommended Mitigation Steps Double check (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.  
# Handle  Omik   # Vulnerability details  ## Impact The implementation of the transfer function in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol is the different from the usual erc20 token transfer function, this happen because it count the incentive that the user get, but the with self tranfer it can lead to unlimited mint, because https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L278 it makes the amount to negative, but in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279 it return the value to amount that not negative, so in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282 it finalize the positive value only since the negative value is change to the positive value, you can interact this transfer function through https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used Manual  ## Recommended Mitigation Steps add (sender != recipient)  
# Handle  leastwood   # Vulnerability details  ## Impact  There are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`. All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract. However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.  ## Proof of Concept  Initial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).  Consider the following scenario: - Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`. - This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract. - Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role. - The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function. - As a result, the implementation contract will be self-destructed due the user controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `StorageLayoutV1.sol` contract is inherited by several contracts and represents a shared common state that ensures the slot layout of certain contracts are the same. It is possible to minimise the number of storage slots used by rearranging the state variables in the most efficient way.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/global/StorageLayoutV1.sol  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Arrange the `uint16`  and `bytes1` variables such that they fit into the same slot.  
# Handle  leastwood   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  
# Handle  leastwood   # Vulnerability details  ## Impact  There is currently no input validation done on the `Router.initialize()` and `NoteERC20.initialize()` functions, potentially leading to an initialized state where the contracts have no owner and the deployer needs to re-deploy the contract to have it working properly.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L63-L92 https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L90-L108  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Perform zero address checks for the `owner_`, `pauseRouter_` and `pauseGuardian_` inputs to ensure the contract isn't initialized into an unexpected state.  
# Handle  a_delamo   # Vulnerability details  On `ExchangeRate.sol`, we are using `latestRoundData`, but there are no validations that the data is not stale.  The current code is:  ```solidity             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, "ExchangeRate: invalid rate"); ```  But is missing the checks to validate the data is stale   ```solidity (roundId, rawPrice,, updatedAt, answeredInRound) = AggregatorV2V3Interface(rateOracle).latestRoundData(); require(rawPrice > 0, "Chainlink price <= 0"); require(updateTime != 0, "Incomplete round"); require(answeredInRound >= roundId, "Stale price"); ```  More information: https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round    
# Handle  hrkrshnn   # Vulnerability details  ## Used a fixed or pragma that spans only a single `0.x.*`  Currently, the pragma `>0.7.0` is used in several contracts. However, since 0.7.0 and 0.8.0 has breaking changes, especially the safemath by default, the contracts could be semantically different when compiled via `0.7.*` and `0.8.*`.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra `sload` operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra `mload` operation (3 additional gas for each iteration except for the first).  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` operation is only done once and subsequently replaced by a cheap `dupN` instruction.  This optimization is especially important if it is a storage array or if it is a lengthy for loop.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project.  ### Examples  Here are some examples where this can be applied (found using a simple grep)  ``` txt ./contracts/external/Views.sol:187:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/BatchAction.sol:42:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/BatchAction.sol:120:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/ERC1155Action.sol:62:        for (uint256 i; i < accounts.length; i++) { ./contracts/external/actions/ERC1155Action.sol:91:        for (uint256 i; i < portfolio.length; i++) { ./contracts/external/actions/ERC1155Action.sol:240:        for (uint256 i; i < ids.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:121:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:146:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:537:        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/TradingAction.sol:81:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/TradingAction.sol:123:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/nTokenMintAction.sol:110:        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) { ./contracts/external/actions/nTokenRedeemAction.sol:138:        for (uint256 i; i < markets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:222:        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:265:        for (uint256 i; i < markets.length; i++) { ./contracts/external/adapters/CompoundToNotionalV2.sol:81:        for (uint256 i; i < notionalV2CollateralIds.length; i++) { ./contracts/external/governance/NoteERC20.sol:98:        for (uint256 i = 0; i < initialGrantAmount.length; i++) { ./contracts/internal/balances/BalanceHandler.sol:300:        for (uint256 i; i < settleAmounts.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:31:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:345:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:449:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:528:            for (uint256 i; i < markets.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:77:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:131:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:232:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:495:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/markets/CashGroup.sol:297:        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) { ./contracts/internal/markets/CashGroup.sol:309:        for (uint256 i; i < cashGroup.rateScalars.length; i++) { ./contracts/internal/nTokenHandler.sol:279:        for (uint256 i; i < depositShares.length; i++) { ./contracts/internal/nTokenHandler.sol:306:        for (uint256 i; i < proportions.length; i++) { ./contracts/internal/nTokenHandler.sol:371:        for (; i < array1.length; i++) { ./contracts/internal/nTokenHandler.sol:494:            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/BitmapAssetsHandler.sol:96:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:20:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:40:        for (uint256 i; i < assetArray.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:129:        for (uint256 i; i < newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:161:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:171:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:202:        for (uint256 i; i < portfolioState.newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:283:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/TransferAssets.sol:47:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:32:        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:137:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:231:        for (uint256 i = portfolioIndex; i < assets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:250:        for (; j < assets.length; j++) { ./contracts/mocks/BaseMockLiquidation.sol:52:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/mocks/BaseMockLiquidation.sol:72:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/mocks/MockFlashLender.sol:30:        for (uint256 i; i < assets.length; i++) { ./contracts/mocks/MockFlashLender.sol:39:        for (uint256 i; i < assets.length; i++) { ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:  ```solidity // @audit token.notional are the LP tokens to redeem assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity); fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity); ```  This means the value depends on the **current market reserves** which can be manipulated. You're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.  See the "How do I tell if I’m using spot price?" section on [https://shouldiusespotpriceasmyoracle.com/](https://shouldiusespotpriceasmyoracle.com/). > However, by doing this you’re actually incorporating the spot price because you’re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.  ## Impact The value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )` where `(assetCashClaim, fCashClaim)` depend on the current market reserves which can be manipulated by an attacker via flashloans. Therefore, an attacker trading large amounts in the market either increases or decreases the value of an LP token.  If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens. If the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.  The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage. In constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/). However, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles: > "Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated." - Market.sol L424  ## Recommendation Do not use the current market reserves to determine the value of LP tokens. Think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.getMarketIndex` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact "Valid" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact "Valid" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it.   ## Impact Luckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.  ## Recommended Mitigation Steps We still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past. This should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.  ## Impact Users that didn't even have tokens at the time of proposal creation but are now interested in voting on the proposal can farm unclaimed incentives and impact the outcome of the proposal.  ## Recommended Mitigation Steps Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas. It also needs to be ensured that incentives cannot be increased through flash-loaning of assets.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.  ## Recommended Mitigation Steps In `initialize`, emit `OwnershipTransferred(address(0), owner_)`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700` value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see [blocktime](https://etherscan.io/chart/blocktime).  ## Recommended Mitigation Steps Use a `MIN_VOTING_PERIOD_BLOCKS` of `6545`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false` indicating an unsuccessful action.  ## Impact An off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful. This happens in the `approve`, `transfer` and `transferFrom` functions.  ## Recommended Mitigation Steps Only emit evens on `success`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `cTokenAggregator.decimals` value is set to `18` but `cTokens` only have `8` decimals. It's unclear what this `decimals` field refers to.  ## Recommended Mitigation Steps If it should refer to the `cToken` decimals, it's wrong and should be set to `8`. This value is not used inside the contract but it's `public` and anyone can read it.    
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.  ```solidity function notionalCallback(     address sender,     address account,     bytes calldata callbackData ) external returns (uint256) { // @audit sender can be passed in by the attacker require(sender == address(this), "Unauthorized callback"); ```  ## Impact An attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract. The `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker frontruns the actual transaction.  It's at least a griefing attack: I can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op. This will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:  ```solidity // @audit using a malicious contract, this can be any token address underlyingToken = CTokenInterface(cTokenBorrow).underlying(); bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount); require(success, "Transfer of repayment failed");  // Use the amount transferred to repay the borrow // @audit using a malicious contract, this can be a no-op uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount); ```  Note that the assumption at the end of the function "// When this exits a free collateral check will be triggered" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.  ## Recommended Mitigation Steps Fix the authorization check.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  See `CompoundToNotionalV2.notionalCallback`'s `IERC20(underlyingToken).transferFrom` call.  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value. As there is a `cToken` with `USDT` as the underlying this issue directly applies to the protocol.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `enableToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenAction` implements two token approvals, the `nTokenWhitelist` which is always used first, and the `nTokenAllowance` which is checked second. If the `nTokenWhitelist` does _not_ have enough allowance for the transfer, the transaction fails, even in the case where `nTokenAllowance` still has enough allowance.  ## Impact Transfers that have sufficient allowance fail in certain cases.  ## Recommended Mitigation Steps Instead of reverting if the `nTokenWhitelist` allowance is not enough, default to the `nTokenAllowance` case:  ```solidity // something like this  uint256 requiredAllowance = amount;  uint256 allowance = nTokenWhitelist[from][spender]; // use whitelist allowance first if (allowance > 0) {     uint256 min = amount < allowance ? amount : allowance;     requiredAllowance -= min;     allowance = allowance.sub(min);     nTokenWhitelist[from][spender] = allowance; }  // use currency-specific allowance now if(requiredAllowance > 0)     // This is the specific allowance for the nToken.     allowance = nTokenAllowance[from][spender][currencyId];     require(allowance >= requiredAllowance, "Insufficient allowance");     allowance = allowance.sub(requiredAllowance);     nTokenAllowance[from][spender][currencyId] = allowance; } ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action._checkPostTransferEvent` has open TODOs:  ```solidity // TODO: retrieve revert string require(status, "Call failed"); ```  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action.safeTransferFrom` / `ERC1155Action.safeBatchTransferFrom` functions do not follow the [recommended re-entrancy protection guidelines](https://docs.soliditylang.org/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern) and allow a re-entrancy through the `onERC1155Received` while state still has to be written.  ## Impact The re-entrancy doesn't seem to open any attacks currently as the re-entrancy call happens right at the beginning and no interesting variables are set yet.  ## Recommended Mitigation Steps While no immediate re-entrancy issues could be found, it's better to add these checks, especially, as calling this function from another Notional finance function in the future might lead to unintended issues.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details As the return value of `ERC1155.balanceOf` was changed to a signed integer, the `nERC1155Interface` does not implement the `ERC1155` interface and the `supportsInterface` call will return false if people call it with the actual `ERC1155` interface ID.  ## Impact Not all users of the contract might care about the `balance` function and call `supportsInterface` with the original EIP1155 interface. The contract will still deny the   ## Recommended Mitigation Steps It is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of `supportsInterface(ERC1155.interface)` should be for compatibility. Users need to be aware that this contract is not standard compliant and the `supportsInterface` call will fail.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `initialize` function that initializes important contract state can be called by anyone. Occurences: - `NoteERC20.initialize` - `Router.initialize`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. See details on [OZ](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the [fix here](https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1). The bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed. As the custom `GovernorAlpha.executeProposal` function removed the original "queued state check" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.  ## POC 1. Create a proposal using `propose`. The calldata will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`) 2. Call `executeProposal(proposalId, ...)` such that the following calls are made:  ``` call-0: grantRole(TIME_LOCK_ADMIN, attackerContract) call-1: grantRole(EXECUTOR, attackerContract) call-2: grantRole(PROPOSER, attackerContract) call-3: updateDelay(0) // such that _afterCall "isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp" passes call-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential) // attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal ```  > ℹ️  I already talked to Jeff Wu about this and he created a test case for it confirming this finding  ## Impact Anyone who can create a proposal can become Timelock admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`. Note that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.  ## Recommended Mitigation Steps We recommend updating the vulnerable contract to `TimelockController v3.4.2`. It currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Some parameters of functions are not checked for invalid values: - `PauseRouter.constructor`: addresses can be zero or not a contract - `CompoundToNotionalV2.constructor`: addresses can be zero or not a contract   ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  pauliax   # Vulnerability details  ## Impact Total supply depends on the decimals. I think it makes sense to express totalSupply something like this to make it more readable and maintainable in case you will decide to change decimals:      /// @notice EIP-20 token decimals for this token     uint8 public constant decimals = 8;      /// @notice Total number of tokens in circulation (100 million NOTE)     uint256 public constant totalSupply = 10_000_0000 * 10 ** decimals;   
# Handle  pauliax   # Vulnerability details  ## Impact function transferFrom in nTokenERC20Proxy emits Approval event:   emit Approval(msg.sender, from, newAllowance); The order of the parameters is wrong, 'msg.sender' and 'from' should be in the opposite order. This may confuse frontends or other services that consume these events from the outside.  ## Recommended Mitigation Steps   emit Approval(from, msg.sender, newAllowance);  
# Handle  pauliax   # Vulnerability details  ## Impact There are several checks that uint is not negative, e.g.:   cashGroup.maxMarketIndex >= 0 && These checks are pretty much useless as uint can never be negative. Remove them to save some gas.   
# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter of the constructor are used to initialize the sate variable and these state variable are used throughout the contract error in these parameter can lead to redeployment of the contract  ## Proof of Concept  constructor of ctokenAggregator.sol,  NotionalV1ToNotionalV2.sol, nTokenERC20Proxy.sol, Reservoir.sol, PauseRouter.sol lack zero address validation  ## Tools Used manual review  ## Recommended Mitigation Steps add address(0) validation in constructor  
# Handle  pauliax   # Vulnerability details  ## Impact contract NotionalV1ToNotionalV2 has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.  ## Recommended Mitigation Steps require(msg.sender == address(WETH), "Not WETH");  
# Handle  pauliax   # Vulnerability details  ## Impact There are several places that check if the address is a contract or not, e.g.:     uint256 codeSize;     assembly {         codeSize := extcodesize(operator)     }     // Sanity check to ensure that operator is a contract, not an EOA     require(codeSize > 0, "Operator must be a contract"); First of all, I want you to be aware that this check can be easily bypassed. A contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but extcodesize for its address returns zero. In your case, currently, I do not see a real problem with that as you only use it as an additional check (no critical functionality) but I have a suggestion for you to extract this check to a separate library to make it more maintainable or use a library from OpenZeppelin that exposes this function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L26   
# Handle  pauliax   # Vulnerability details  ## Impact function notionalCallback (in NotionalV1ToNotionalV2 and CompoundToNotionalV2) declares to return uint, however, no actual value is returned.   ## Recommended Mitigation Steps Either remove the return declaration or return the intended value (I assume it may return a value that it gets from depositUnderlyingToken/depositAssetToken). Otherwise, it may confuse other protocols that later may want to integrate with you.  
# Handle  pauliax   # Vulnerability details  ## Impact Anyone can call function notionalCallback with arbitrary params and pass the auth check. The only auth check can be easily bypassed by setting sender param to the address of this contract. It allows to choose any parameter that I want:     function notionalCallback(         address sender,         address account,         bytes calldata callbackData     ) external returns (uint256) {         require(sender == address(this), "Unauthorized callback");  ## Recommended Mitigation Steps It needs to check that msg.sender is Notional.  
# Handle  pauliax   # Vulnerability details  ## Impact function activateNotional calls Address.isContract(...) but does not check the returned value, thus making this call pretty much useless:   Address.isContract(address(notionalProxy_));  ## Recommended Mitigation Steps Wrap this in a require statement.  
# Handle  JMukesh   # Vulnerability details  ## Impact function migrateBorrowFromCompound(         address cTokenBorrow,         uint256 cTokenRepayAmount,         uint16[] memory notionalV2CollateralIds,         uint256[] memory notionalV2CollateralAmounts,         BalanceActionWithTrades[] calldata borrowAction     ) ;  if the  array length of notionalV2CollateralId ,  notionalV2CollateralAmounts and  borrowAction is not equal it can lead to an error  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24   ## Tools Used  manual review  ## Recommended Mitigation Steps check the input array length  
# Handle  JMukesh   # Vulnerability details  ## Impact proposal get defeated even if forVotes == againstVotes during the voting which impact the given proposals. Instead of this condition forVotes <= againstVotes, it should be  forVotes < againstVotes  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/GovernorAlpha.sol#L389  ## Tools Used manual review  ## Recommended Mitigation Steps change the condition for determining the states  
# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract ExchangeRate.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID nor timeStamp, resulting in stale prices. Stale prices could put funds at risk. Freshness of the returned price should be checked, since it affects an account's health (and therefore liquidations). Stale prices that do not reflect the current market price anymore could be used which would influence the liquidation pricing.   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol". 2. latestRoundData has been used in the repository. 3. The code can be seen from the below. Stale prices have not been checked.  ```         } else {             address rateOracle = address(bytes20(data << 96));             // prettier-ignore             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, "ExchangeRate: invalid rate");              uint8 rateDecimalPlaces = uint8(bytes1(data << 88));             rateDecimals = int256(10**rateDecimalPlaces);             if (                 bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */             ) {                 rate = rateDecimals.mul(rateDecimals).div(rate);             }         }  ```  ## Tools Used  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```   
# Handle  tensors   # Vulnerability details  ## Impact Lack of checks on target could lead to loss of funds.  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50  ## Recommended Mitigation Steps Require that target is non-zero.  
# Handle  tensors   # Vulnerability details  ## Impact Registering tokens that aren't properly vetted can lead to a loss of funds if the token has callbacks.  CREAM finance got hacked in a similar way because the ampleforth token had a callback in the transfer method that wasn't noticed when they vetted it.   ## Proof of Concept For example, the redeem function is vulnerable to such a reentrancy in the balanceOf method, since address balances aren't updated before the token call.  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L131   ## Recommended Mitigation Steps Either: - Add nonreentrant modifiers - Update all storage variables before making outside calls with the token - Put steps in place for devs to properly vet tokens.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilise the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic. When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious frontrunning. However, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and frontrun the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60 https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  As the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer of nTokenAction.sol uses temporary variables and updates the sender and recipient separately. This is a dangerous constructions because the update of the recipient could overwrite the update of the sender. This has led to several hacks at other comparable contracts  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol ```JS  function _transfer(uint256 currencyId,address sender,address recipient, uint256 amount) internal returns (bool) {        ...           senderBalance.netNTokenTransfer = amountInt.neg();         recipientBalance.netNTokenTransfer = amountInt;          senderBalance.finalize(sender, senderContext, false);         recipientBalance.finalize(recipient, recipientContext, false);         senderContext.setAccountContext(sender);         recipientContext.setAccountContext(recipient); ... ```  ## Tools Used  ## Recommended Mitigation Steps Double check what happens when sender==recipient  Add checks to make sure (sender!=recipient) because that usually isn't useful anyway.   
# Handle  gpersoon   # Vulnerability details  ## Impact The code contains "pragma experimental ABIEncoderV2;" In the later Solidity versions it is no longer necessary to use the "experimental" version. Using experimental constructions is not recommended for production code.  See: https://docs.soliditylang.org/en/v0.8.7/layout-of-source-files.html#abiencoderv2  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol ```JS pragma experimental ABIEncoderV2; ```  ## Tools Used  ## Recommended Mitigation Steps Replace pragma experimental ABIEncoderV2; with pragma abicoder v2;  And make sure you use at least solidity version 0.7.5    
# Handle  gpersoon   # Vulnerability details  ## Impact The function getRouterImplementation of Router.sol checks the selectors of functions and calls the appropriate function. Selectors are only 4 bytes long so there is a theoretical probability of a collision (e.g. two functions having the same selector).  This is comparable to the "birthday attack" : https://en.wikipedia.org/wiki/Birthday_attack The probability of a collision when you have 93 different functions is 10^−6. Due to the structure of the Router.sol, the solidity compiler does not prevent collisions  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97 ```JS   function getRouterImplementation(bytes4 sig) public view returns (address) {         if (             sig == NotionalProxy.batchBalanceAction.selector ||             sig == NotionalProxy.batchBalanceAndTradeAction.selector ||      ...  ```  ## Tools Used  ## Recommended Mitigation Steps Double check (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.  
# Handle  Omik   # Vulnerability details  ## Impact The implementation of the transfer function in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol is the different from the usual erc20 token transfer function, this happen because it count the incentive that the user get, but the with self tranfer it can lead to unlimited mint, because https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L278 it makes the amount to negative, but in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279 it return the value to amount that not negative, so in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282 it finalize the positive value only since the negative value is change to the positive value, you can interact this transfer function through https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used Manual  ## Recommended Mitigation Steps add (sender != recipient)  
