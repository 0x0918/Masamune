# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L322-L324 ```solidity=322 function setGovernance(address _governance) external onlyGovernance {     _setGovernance(_governance); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L331-L333 ```solidity=331 function approveContractAccess(address account) external onlyGovernance {     _approveContractAccess(account); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L335-L337 ```solidity=335 function revokeContractAccess(address account) external onlyGovernance {     _revokeContractAccess(account); } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L116-L119 ```solidity=116 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L121-L124 ```solidity=121 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```    https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L130-L133 ```solidity=130 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L135-L138 ```solidity=135 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/SettToRenIbbtcZap.sol#L162-L183  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  In the current implementation, when `curvePool` or `token` got updated, `token` is not approved to `curvePool`, which will malfunction the contract and break minting.  ### Recommendation  Change to:  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          if (zapConfigs[_idx].curvePool != _curvePool && _curvePool != address(0)) {             IERC20Upgradeable(_token).safeApprove(                 _curvePool,                 type(uint256).max             );         }          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  
# Handle  WatchPug   # Vulnerability details  The check for `RENCRV_VAULT.blockLock` is only needed when `if (_amounts[1] > 0 || _amounts[2] > 0)`.   However, in the current implementation, the check is done at the very first, making transactions unrelated to `RENCRV_VAULT` fail unexpectedly if there is a prior transaction involved with `RENCRV_VAULT` in the same block.  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/IbbtcVaultZap.sol#L149-L199  ```solidity=149{154-157,182} function deposit(uint256[4] calldata _amounts, uint256 _minOut)     public     whenNotPaused {     // Not block locked by setts     require(         RENCRV_VAULT.blockLock(address(this)) < block.number,         "blockLocked"     );     require(         IBBTC_VAULT.blockLock(address(this)) < block.number,         "blockLocked"     );      uint256[4] memory depositAmounts;      for (uint256 i = 0; i < 4; i++) {         if (_amounts[i] > 0) {             ASSETS[i].safeTransferFrom(                 msg.sender,                 address(this),                 _amounts[i]             );             if (i == 0 || i == 3) {                 // ibbtc and sbtc                 depositAmounts[i] += _amounts[i];             }         }     }      if (_amounts[1] > 0 || _amounts[2] > 0) {         // Use renbtc and wbtc to mint ibbtc         // NOTE: Can change to external zap if implemented         depositAmounts[0] += _renZapToIbbtc([_amounts[1], _amounts[2]]);     }     // ... } ```   
# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L177-L179  ```solidity=177 function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L196-L198  ```solidity=196 function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L274-L275  ```solidity=274 uint _fee; uint _ren; ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L295-L296  ```solidity=295 uint _fee; uint _wbtc; ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unneeded branches and returns can reduce gas usage and improve code clarity.  ## Proof of Concept  This code https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L309-L317 can be refactored to:  ```  if (bBtc <= max) {   // pesimistically charge 0.5% on the withdrawal.   // Actual fee might be lesser if the vault keeps keeps a buffer   uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);   lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);   fee = fee.add(strategyFee);  } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `deposit` in `IbbtcVaultZap.sol` computes two additions without overflow protection, see lines [158](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L158) and [166](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L166).  In the first case, i.e. line 158, the addition can be changed to an assignment, as `depositAmount[i]` is always 0.  In the second case, i.e. line 166, an overflow would lead to a wrong amount of funds deposited into Curve and from there to a wrong amount of LP tokens send to the `msg.sender`.  ## Recommended Steps of Mitigation As OpenZeppelin's `SafeMathUpgradeable` library is already imported, use their `add` function instead of the native `+` operator.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  The variable `_ren` in `Zap.calcRedeemInRen` is declared but unused. This increases gas costs for no benefit.  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L272-L280  This also happens in other functions.  ## Recommended Mitigation Steps  Remove unused variable  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L322-L324 ```solidity=322 function setGovernance(address _governance) external onlyGovernance {     _setGovernance(_governance); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L331-L333 ```solidity=331 function approveContractAccess(address account) external onlyGovernance {     _approveContractAccess(account); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L335-L337 ```solidity=335 function revokeContractAccess(address account) external onlyGovernance {     _revokeContractAccess(account); } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L116-L119 ```solidity=116 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L121-L124 ```solidity=121 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```    https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L130-L133 ```solidity=130 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L135-L138 ```solidity=135 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/SettToRenIbbtcZap.sol#L162-L183  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  In the current implementation, when `curvePool` or `token` got updated, `token` is not approved to `curvePool`, which will malfunction the contract and break minting.  ### Recommendation  Change to:  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          if (zapConfigs[_idx].curvePool != _curvePool && _curvePool != address(0)) {             IERC20Upgradeable(_token).safeApprove(                 _curvePool,                 type(uint256).max             );         }          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  
# Handle  WatchPug   # Vulnerability details  The check for `RENCRV_VAULT.blockLock` is only needed when `if (_amounts[1] > 0 || _amounts[2] > 0)`.   However, in the current implementation, the check is done at the very first, making transactions unrelated to `RENCRV_VAULT` fail unexpectedly if there is a prior transaction involved with `RENCRV_VAULT` in the same block.  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/IbbtcVaultZap.sol#L149-L199  ```solidity=149{154-157,182} function deposit(uint256[4] calldata _amounts, uint256 _minOut)     public     whenNotPaused {     // Not block locked by setts     require(         RENCRV_VAULT.blockLock(address(this)) < block.number,         "blockLocked"     );     require(         IBBTC_VAULT.blockLock(address(this)) < block.number,         "blockLocked"     );      uint256[4] memory depositAmounts;      for (uint256 i = 0; i < 4; i++) {         if (_amounts[i] > 0) {             ASSETS[i].safeTransferFrom(                 msg.sender,                 address(this),                 _amounts[i]             );             if (i == 0 || i == 3) {                 // ibbtc and sbtc                 depositAmounts[i] += _amounts[i];             }         }     }      if (_amounts[1] > 0 || _amounts[2] > 0) {         // Use renbtc and wbtc to mint ibbtc         // NOTE: Can change to external zap if implemented         depositAmounts[0] += _renZapToIbbtc([_amounts[1], _amounts[2]]);     }     // ... } ```   
# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L177-L179  ```solidity=177 function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L196-L198  ```solidity=196 function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L274-L275  ```solidity=274 uint _fee; uint _ren; ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L295-L296  ```solidity=295 uint _fee; uint _wbtc; ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unneeded branches and returns can reduce gas usage and improve code clarity.  ## Proof of Concept  This code https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L309-L317 can be refactored to:  ```  if (bBtc <= max) {   // pesimistically charge 0.5% on the withdrawal.   // Actual fee might be lesser if the vault keeps keeps a buffer   uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);   lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);   fee = fee.add(strategyFee);  } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `deposit` in `IbbtcVaultZap.sol` computes two additions without overflow protection, see lines [158](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L158) and [166](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L166).  In the first case, i.e. line 158, the addition can be changed to an assignment, as `depositAmount[i]` is always 0.  In the second case, i.e. line 166, an overflow would lead to a wrong amount of funds deposited into Curve and from there to a wrong amount of LP tokens send to the `msg.sender`.  ## Recommended Steps of Mitigation As OpenZeppelin's `SafeMathUpgradeable` library is already imported, use their `add` function instead of the native `+` operator.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  The variable `_ren` in `Zap.calcRedeemInRen` is declared but unused. This increases gas costs for no benefit.  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L272-L280  This also happens in other functions.  ## Recommended Mitigation Steps  Remove unused variable  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L322-L324 ```solidity=322 function setGovernance(address _governance) external onlyGovernance {     _setGovernance(_governance); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L331-L333 ```solidity=331 function approveContractAccess(address account) external onlyGovernance {     _approveContractAccess(account); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L335-L337 ```solidity=335 function revokeContractAccess(address account) external onlyGovernance {     _revokeContractAccess(account); } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L116-L119 ```solidity=116 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L121-L124 ```solidity=121 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```    https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L130-L133 ```solidity=130 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L135-L138 ```solidity=135 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/SettToRenIbbtcZap.sol#L162-L183  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  In the current implementation, when `curvePool` or `token` got updated, `token` is not approved to `curvePool`, which will malfunction the contract and break minting.  ### Recommendation  Change to:  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          if (zapConfigs[_idx].curvePool != _curvePool && _curvePool != address(0)) {             IERC20Upgradeable(_token).safeApprove(                 _curvePool,                 type(uint256).max             );         }          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  
# Handle  WatchPug   # Vulnerability details  The check for `RENCRV_VAULT.blockLock` is only needed when `if (_amounts[1] > 0 || _amounts[2] > 0)`.   However, in the current implementation, the check is done at the very first, making transactions unrelated to `RENCRV_VAULT` fail unexpectedly if there is a prior transaction involved with `RENCRV_VAULT` in the same block.  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/IbbtcVaultZap.sol#L149-L199  ```solidity=149{154-157,182} function deposit(uint256[4] calldata _amounts, uint256 _minOut)     public     whenNotPaused {     // Not block locked by setts     require(         RENCRV_VAULT.blockLock(address(this)) < block.number,         "blockLocked"     );     require(         IBBTC_VAULT.blockLock(address(this)) < block.number,         "blockLocked"     );      uint256[4] memory depositAmounts;      for (uint256 i = 0; i < 4; i++) {         if (_amounts[i] > 0) {             ASSETS[i].safeTransferFrom(                 msg.sender,                 address(this),                 _amounts[i]             );             if (i == 0 || i == 3) {                 // ibbtc and sbtc                 depositAmounts[i] += _amounts[i];             }         }     }      if (_amounts[1] > 0 || _amounts[2] > 0) {         // Use renbtc and wbtc to mint ibbtc         // NOTE: Can change to external zap if implemented         depositAmounts[0] += _renZapToIbbtc([_amounts[1], _amounts[2]]);     }     // ... } ```   
# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L177-L179  ```solidity=177 function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L196-L198  ```solidity=196 function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {     uint _ibbtc;     uint _fee;     ... ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L274-L275  ```solidity=274 uint _fee; uint _ren; ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L295-L296  ```solidity=295 uint _fee; uint _wbtc; ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unneeded branches and returns can reduce gas usage and improve code clarity.  ## Proof of Concept  This code https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L309-L317 can be refactored to:  ```  if (bBtc <= max) {   // pesimistically charge 0.5% on the withdrawal.   // Actual fee might be lesser if the vault keeps keeps a buffer   uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);   lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);   fee = fee.add(strategyFee);  } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `deposit` in `IbbtcVaultZap.sol` computes two additions without overflow protection, see lines [158](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L158) and [166](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L166).  In the first case, i.e. line 158, the addition can be changed to an assignment, as `depositAmount[i]` is always 0.  In the second case, i.e. line 166, an overflow would lead to a wrong amount of funds deposited into Curve and from there to a wrong amount of LP tokens send to the `msg.sender`.  ## Recommended Steps of Mitigation As OpenZeppelin's `SafeMathUpgradeable` library is already imported, use their `add` function instead of the native `+` operator.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  The variable `_ren` in `Zap.calcRedeemInRen` is declared but unused. This increases gas costs for no benefit.  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L272-L280  This also happens in other functions.  ## Recommended Mitigation Steps  Remove unused variable  
