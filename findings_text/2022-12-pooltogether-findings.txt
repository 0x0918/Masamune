# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-optimism/EthereumToOptimismExecutor.sol#L45-L59 https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol#L31-L45   # Vulnerability details  ## Impact The `CrossChainExecutorArbitrum` and `CrossChainExecutorOptimism` contracts both use `CallLib` library to invoke `Call`s on external contract. As per the `CallLib` library implementation, any failing `Call` results in the entire transaction getting reverted.  The `CrossChainExecutor` contracts does not store whether the calls in `CallLib.Call[]` were already attempted which failed.   This creates several issues for `CrossChainExecutor` contracts.   1. Offchain components can be tricked to submit failing `Call[]`s again and again. This can be used to drain the offchain component of gas.    2. Once a failing `Call[]` was invoked (which failed) and if again the same `Call[]` is invoked, the transaction should revert with `CallsAlreadyExecuted` error but it reverts with `CallFailure` error.  3. It is difficult to determine whether a to-be executed `Call[]` is pending or the invocation was already tried but failed.   PoCs for the above issues are listed below.   ## Proof of Concept  #### Scenario 1 ```solidity contract Foo {     function bar() public {         for(uint256 i; ; i++) {}     } } ```  - The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract with `maxGasLimit` as the `_gasLimit` parameter.  - The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction reverts costing the transport layer client `maxGasLimit` gas.  - Since no state updates were performed in `CrossChainExecutor`, the transport layer still assumes the relayed call as pending which needs to be executed. The transport layer client again tries to execute the pending relayed call which reverts again. - Repeated execution of the above steps can deplete the gas reserves of transport layer client.  #### Scenario 2 ```solidity contract Foo {     function bar() public {         revert();     } } ```  - The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract.  - The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction gets reverted.  - Since the relayed calls still seems as pending, the transport layer tries to invoke the `Foo.bar()` call again. This call should get reverted with `CallsAlreadyExecuted` error but it gets reverted with `CallFailure` error.  ## Tools Used Manual review  ## Recommended Mitigation Steps The `CrossChainExecutor` contract should store whether a relayed call was attempted to be executed to make sure the execution cannot be tried again.  The `CallLib` library can be changed to not completely revert the transaction when any individual `Call` gets failed. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-pooltogether-findings/blob/main/data/0xSmartContract-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-pooltogether-findings/blob/main/data/Rolezn-G.md).
# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127   # Vulnerability details  ## Impact When the user calls CrossChainRelayerArbitrum.processCalls, ETH is sent as the submission fee.  According to the documentation : https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#retryable-transaction-lifecycle ``` Credit-Back Address: Address to which all excess gas is credited on L2; i.e., excess ETH for base submission cost (MaxSubmissionCost - ActualSubmissionCostPaid) and excess ETH provided for L2 execution ( (GasPrice x MaxGas) - ActualETHSpentInExecution). ... Submission fee is collected: submission fee is deducted from the senderâ€™s L2 account; MaxSubmissionCost - submission fee is credited to Credit-Back Address. ``` the excess submission fee is refunded to the address on L2 of the excessFeeRefundAddress provided when calling createRetryableTicket.  ```solidity      * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts      * @dev all msg.value will deposited to callValueRefundAddress on L2      * @param destAddr destination L2 contract address      * @param l2CallValue call value for retryable L2 message      * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee      * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance      * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled      * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution      * @param gasPriceBid price bid for L2 execution      * @param data ABI encoded data of L2 message      * @return unique id for retryable transaction (keccak256(requestID, uint(0) )      */     function createRetryableTicket(         address destAddr,         uint256 l2CallValue,         uint256 maxSubmissionCost,         address excessFeeRefundAddress,         address callValueRefundAddress,         uint256 maxGas,         uint256 gasPriceBid,         bytes calldata data     ) external payable virtual override onlyWhitelisted returns (uint256) { ``` In CrossChainRelayerArbitrum.processCalls, excessFeeRefundAddress == msg.sender. ```solidity     uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(       address(executor),       0,       _maxSubmissionCost,       msg.sender,   // @audit : excessFeeRefundAddress       msg.sender,  // @audit: callValueRefundAddress       _gasLimit,       _gasPriceBid,       _data     ); ``` For EOA accounts, the excess submission fees are correctly refunded to their address on L2. However, for smart contracts, since there may not exist a corresponding address on L2, these excess submission fees will be lost.  Also, since the callValueRefundAddress is also msg.sender, according to the documentation, if the Retryable Ticket is cancelled or expired, then the smart contract caller may lose all the submission fees ``` If the Retryable Ticket is cancelled or expires before it is redeemed, Callvalue is credited to Beneficiary.  ```  ## Proof of Concept https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127 https://github.com/OffchainLabs/arbitrum/blob/master/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L333-L354 ## Tools Used None ## Recommended Mitigation Steps Consider allowing the user to specify excessFeeRefundAddress and callValueRefundAddress when calling CrossChainRelayerArbitrum.processCalls 
# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-#L127   # Vulnerability details  ## Impact An attacker can make users unable to cancel their L1 calls on Ethereum To Arbitrum.  ## Proof of Concept When someone want to make  calls to Arbitrum from Ethereum, first they call `relayCalls` to fingerprint their data and then anyone else can call `processCalls` to process the calls. According to the doc in Inbox source code https://github.com/OffchainLabs/nitro/blob/1f32bec6b9b228bb2fab4bfa02867716f65d0c5c/contracts/src/bridge/Inbox.sol#L427, function `createRetryableTicket` has one parameter called `callValueRefundAddress` and this is the address that is granted the option to `cancel` a `Retryable`. In `EthereumToArbitrumRelayer.sol` it's currently set as `msg.sender` (5th parameter) which is whoever make the call to  function `processCall`:  ``` uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(       address(executor),       0,       _maxSubmissionCost,       msg.sender,       msg.sender,       _gasLimit,       _gasPriceBid,       _data     ); ``` This implementation allows an attacker to remove the possibility of a user to cancel their calls, which is an important mechanism to be properly implemented. This scenario demonstrates how this could happen: - User A call `relayCalls` to fingerprint their calls - User B call `processCalls` to process user A's calls. - User A now changes his mind and wants to cancel his calls but he's unable to since  `callValueRefundAddress` is set to user B's address, now user B is the one who decides whether to cancel user A's calls or not, which should be user A's option. - Another common case is when users's calls failed, anyone can try to `redeem` it, according to the doc https://developer.arbitrum.io/arbos/l1-to-l2-messaging. So if a someone calls `processCalls` to process others's calls and it fails, the owner of the calls now cannot cancel their calls and anyone else can redeem (reexecute) them.  It should be noted here that `EthereumToArbitrumRelayer.sol` provides no other functionality to cancel users's calls, but it seems to rely only on Arbitrum's Retryable cancel mechanism to do so.   ## Tools Used Manual review.  ## Recommended Mitigation Steps Currently, anyone can process others's calls by calling `processCalls` functions and I think this does not pose any security risk as long as the user who actually fingerprinted these calls can reserve their rights to cancel it if they want to. Therefore, I recommend changing `callValueRefundAddress` in `createRetryableTicket` to `_sender`, this combines with event `ProcessedCalls(_nonce, msg.sender, _ticketID)` emitted at the end of `processCalls` function will allow a user to be notified if their calls has been processed by anyone else and they can cancel it in L2 using `_ticketID`. 
# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-optimism/EthereumToOptimismExecutor.sol#L45-L59 https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol#L31-L45   # Vulnerability details  ## Impact The `CrossChainExecutorArbitrum` and `CrossChainExecutorOptimism` contracts both use `CallLib` library to invoke `Call`s on external contract. As per the `CallLib` library implementation, any failing `Call` results in the entire transaction getting reverted.  The `CrossChainExecutor` contracts does not store whether the calls in `CallLib.Call[]` were already attempted which failed.   This creates several issues for `CrossChainExecutor` contracts.   1. Offchain components can be tricked to submit failing `Call[]`s again and again. This can be used to drain the offchain component of gas.    2. Once a failing `Call[]` was invoked (which failed) and if again the same `Call[]` is invoked, the transaction should revert with `CallsAlreadyExecuted` error but it reverts with `CallFailure` error.  3. It is difficult to determine whether a to-be executed `Call[]` is pending or the invocation was already tried but failed.   PoCs for the above issues are listed below.   ## Proof of Concept  #### Scenario 1 ```solidity contract Foo {     function bar() public {         for(uint256 i; ; i++) {}     } } ```  - The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract with `maxGasLimit` as the `_gasLimit` parameter.  - The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction reverts costing the transport layer client `maxGasLimit` gas.  - Since no state updates were performed in `CrossChainExecutor`, the transport layer still assumes the relayed call as pending which needs to be executed. The transport layer client again tries to execute the pending relayed call which reverts again. - Repeated execution of the above steps can deplete the gas reserves of transport layer client.  #### Scenario 2 ```solidity contract Foo {     function bar() public {         revert();     } } ```  - The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract.  - The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction gets reverted.  - Since the relayed calls still seems as pending, the transport layer tries to invoke the `Foo.bar()` call again. This call should get reverted with `CallsAlreadyExecuted` error but it gets reverted with `CallFailure` error.  ## Tools Used Manual review  ## Recommended Mitigation Steps The `CrossChainExecutor` contract should store whether a relayed call was attempted to be executed to make sure the execution cannot be tried again.  The `CallLib` library can be changed to not completely revert the transaction when any individual `Call` gets failed. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-pooltogether-findings/blob/main/data/0xSmartContract-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-pooltogether-findings/blob/main/data/Rolezn-G.md).
# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127   # Vulnerability details  ## Impact When the user calls CrossChainRelayerArbitrum.processCalls, ETH is sent as the submission fee.  According to the documentation : https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#retryable-transaction-lifecycle ``` Credit-Back Address: Address to which all excess gas is credited on L2; i.e., excess ETH for base submission cost (MaxSubmissionCost - ActualSubmissionCostPaid) and excess ETH provided for L2 execution ( (GasPrice x MaxGas) - ActualETHSpentInExecution). ... Submission fee is collected: submission fee is deducted from the senderâ€™s L2 account; MaxSubmissionCost - submission fee is credited to Credit-Back Address. ``` the excess submission fee is refunded to the address on L2 of the excessFeeRefundAddress provided when calling createRetryableTicket.  ```solidity      * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts      * @dev all msg.value will deposited to callValueRefundAddress on L2      * @param destAddr destination L2 contract address      * @param l2CallValue call value for retryable L2 message      * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee      * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance      * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled      * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution      * @param gasPriceBid price bid for L2 execution      * @param data ABI encoded data of L2 message      * @return unique id for retryable transaction (keccak256(requestID, uint(0) )      */     function createRetryableTicket(         address destAddr,         uint256 l2CallValue,         uint256 maxSubmissionCost,         address excessFeeRefundAddress,         address callValueRefundAddress,         uint256 maxGas,         uint256 gasPriceBid,         bytes calldata data     ) external payable virtual override onlyWhitelisted returns (uint256) { ``` In CrossChainRelayerArbitrum.processCalls, excessFeeRefundAddress == msg.sender. ```solidity     uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(       address(executor),       0,       _maxSubmissionCost,       msg.sender,   // @audit : excessFeeRefundAddress       msg.sender,  // @audit: callValueRefundAddress       _gasLimit,       _gasPriceBid,       _data     ); ``` For EOA accounts, the excess submission fees are correctly refunded to their address on L2. However, for smart contracts, since there may not exist a corresponding address on L2, these excess submission fees will be lost.  Also, since the callValueRefundAddress is also msg.sender, according to the documentation, if the Retryable Ticket is cancelled or expired, then the smart contract caller may lose all the submission fees ``` If the Retryable Ticket is cancelled or expires before it is redeemed, Callvalue is credited to Beneficiary.  ```  ## Proof of Concept https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127 https://github.com/OffchainLabs/arbitrum/blob/master/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L333-L354 ## Tools Used None ## Recommended Mitigation Steps Consider allowing the user to specify excessFeeRefundAddress and callValueRefundAddress when calling CrossChainRelayerArbitrum.processCalls 
# Lines of code  https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-#L127   # Vulnerability details  ## Impact An attacker can make users unable to cancel their L1 calls on Ethereum To Arbitrum.  ## Proof of Concept When someone want to make  calls to Arbitrum from Ethereum, first they call `relayCalls` to fingerprint their data and then anyone else can call `processCalls` to process the calls. According to the doc in Inbox source code https://github.com/OffchainLabs/nitro/blob/1f32bec6b9b228bb2fab4bfa02867716f65d0c5c/contracts/src/bridge/Inbox.sol#L427, function `createRetryableTicket` has one parameter called `callValueRefundAddress` and this is the address that is granted the option to `cancel` a `Retryable`. In `EthereumToArbitrumRelayer.sol` it's currently set as `msg.sender` (5th parameter) which is whoever make the call to  function `processCall`:  ``` uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(       address(executor),       0,       _maxSubmissionCost,       msg.sender,       msg.sender,       _gasLimit,       _gasPriceBid,       _data     ); ``` This implementation allows an attacker to remove the possibility of a user to cancel their calls, which is an important mechanism to be properly implemented. This scenario demonstrates how this could happen: - User A call `relayCalls` to fingerprint their calls - User B call `processCalls` to process user A's calls. - User A now changes his mind and wants to cancel his calls but he's unable to since  `callValueRefundAddress` is set to user B's address, now user B is the one who decides whether to cancel user A's calls or not, which should be user A's option. - Another common case is when users's calls failed, anyone can try to `redeem` it, according to the doc https://developer.arbitrum.io/arbos/l1-to-l2-messaging. So if a someone calls `processCalls` to process others's calls and it fails, the owner of the calls now cannot cancel their calls and anyone else can redeem (reexecute) them.  It should be noted here that `EthereumToArbitrumRelayer.sol` provides no other functionality to cancel users's calls, but it seems to rely only on Arbitrum's Retryable cancel mechanism to do so.   ## Tools Used Manual review.  ## Recommended Mitigation Steps Currently, anyone can process others's calls by calling `processCalls` functions and I think this does not pose any security risk as long as the user who actually fingerprinted these calls can reserve their rights to cancel it if they want to. Therefore, I recommend changing `callValueRefundAddress` in `createRetryableTicket` to `_sender`, this combines with event `ProcessedCalls(_nonce, msg.sender, _ticketID)` emitted at the end of `processCalls` function will allow a user to be notified if their calls has been processed by anyone else and they can cancel it in L2 using `_ticketID`. 
