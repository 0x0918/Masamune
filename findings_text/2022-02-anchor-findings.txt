# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L543-L580 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L582-L665 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/staking.rs#L15-L57 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L364-L455   # Vulnerability details  ## Impact  Polls are created by targeting the `receive_cw20` function which is queried whenever the contract receives tokens. By setting the hook message to `Cw20HookMsg::CreatePoll`, the sender is able to create a poll, assuming the amount sent satisfies the minimum deposit amount for poll creation. Users can also choose to call `ExecuteMsg::SnapshotPoll` or have it handled automatically when a user casts a vote on the newly created poll.  The snapshot simply sets `a_poll.staked_amount`, which represents the total staked amount within the governance contract at a given block. However, during the voting period, other users can stake tokens and effectively have an increasing influence over the outcome of a given poll. There are no check-pointed balances to ensure that a certain user had staked tokens at the time the poll had its snapshot taken.  This can be abused to skew poll results in favour of users who stake their Anchor tokens after a poll has had its snapshot taken.  ## Proof of Concept  Let's assume the share to token exchange rate is `1:1` such that if a user deposits 100 Anchor tokens, they receive 100 shares in return.  Consider the following scenario:  - There are a total of 100 Anchor tokens in the Governance contract. - Alice creates a poll and executes `ExecuteMsg::SnapshotPoll` such that `a_poll.staked_amount == 100`. - Bob deposits 10 Anchor tokens through the `Cw20HookMsg::StakeVotingTokens` hook message which increases the contract's total balance to 110 and shares to 110 as the exchange rate is `1:1` upon minting and redeeming shares. - At this point, the target poll has a `a_poll.staked_amount == 100`, even though there are really 110 Anchor tokens staked. - As a result, if Bob votes on a poll, they have a 10% degree of influence on the outcome of the poll, even though they have less than 10% of the total staked tokens (i.e. 10/110). - Therefore, poll voters are actually incentivised to stake tokens after a poll has had its snapshot taken in order to maximise their voting power.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance. This check-pointing behaviour is implemented on Ethereum which has a more restrictive block space. The mechanism will simply store the staker's balance on each stake/unstake action. When user's wish to vote, the protocol will check the balance at a specific block (i.e. the snapshotted block). An example implementation can be found [here](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol#L189-L221).  
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fmoney-market-contracts%2Fcontracts%2Fmarket%2Fsrc%2Fborrow.rs#L304   # Vulnerability details  ## Impact The borrow rate uses a simple interest formula to compute the accrued debt, instead of a compounding formula.  ```rust pub fn compute_interest_raw(     state: &mut State,     block_height: u64,     balance: Uint256,     aterra_supply: Uint256,     borrow_rate: Decimal256,     target_deposit_rate: Decimal256, ) {   // @audit simple interest     let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);      let interest_factor = passed_blocks * borrow_rate;     let interest_accrued = state.total_liabilities * interest_factor;     // ... } ```  This means the actual borrow rate and interest for suppliers depend on how often updates are made. This difference should be negligible in highly active markets, but it could lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest.  ## Recommended Mitigation Steps Ensure that the markets are accrued regularly, or switch to a compound interest formula (which has a higher computational cost due to exponentiation, but can be approximated, see Aave).   
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fanchor-token-contracts%2Fcontracts%2Fcollector%2Fsrc%2Fcontract.rs#L130-L137   # Vulnerability details  ## Impact The collector contract allows anyone to `sweep`, swapping an asset token to ANC through astro port. Note that `belief_price` is not set and `config.max_spread` might not be set as well or misconfigured.  This allows an attacker to create a contract to perform a sandwich attack to make a profit on this trade.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the protocol's loss.  #### POC Attacker creates a contract that triggers 3 messages for the sandwich attack:  - Astroport: buy ANC with asset - call `sweep` which trades at bad price - Astroport: sell assets from the first message for profit   ## Recommended Mitigation Steps Consider setting a ANC/asset `belief_price` from an oracle.   
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L530-L531   # Vulnerability details  # Impact Users will still be able to find failed polls under "Executed" and "Failed"  # Proof of Concept A poll attempts to execute and fails. That poll will stay in the poll indexer as executed and failed.  # Mitigation `Passed` should be `Executed`.   Test proof: https://pastebin.com/Cz0wujn9   
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L543-L580 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L582-L665 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/staking.rs#L15-L57 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L364-L455   # Vulnerability details  ## Impact  Polls are created by targeting the `receive_cw20` function which is queried whenever the contract receives tokens. By setting the hook message to `Cw20HookMsg::CreatePoll`, the sender is able to create a poll, assuming the amount sent satisfies the minimum deposit amount for poll creation. Users can also choose to call `ExecuteMsg::SnapshotPoll` or have it handled automatically when a user casts a vote on the newly created poll.  The snapshot simply sets `a_poll.staked_amount`, which represents the total staked amount within the governance contract at a given block. However, during the voting period, other users can stake tokens and effectively have an increasing influence over the outcome of a given poll. There are no check-pointed balances to ensure that a certain user had staked tokens at the time the poll had its snapshot taken.  This can be abused to skew poll results in favour of users who stake their Anchor tokens after a poll has had its snapshot taken.  ## Proof of Concept  Let's assume the share to token exchange rate is `1:1` such that if a user deposits 100 Anchor tokens, they receive 100 shares in return.  Consider the following scenario:  - There are a total of 100 Anchor tokens in the Governance contract. - Alice creates a poll and executes `ExecuteMsg::SnapshotPoll` such that `a_poll.staked_amount == 100`. - Bob deposits 10 Anchor tokens through the `Cw20HookMsg::StakeVotingTokens` hook message which increases the contract's total balance to 110 and shares to 110 as the exchange rate is `1:1` upon minting and redeeming shares. - At this point, the target poll has a `a_poll.staked_amount == 100`, even though there are really 110 Anchor tokens staked. - As a result, if Bob votes on a poll, they have a 10% degree of influence on the outcome of the poll, even though they have less than 10% of the total staked tokens (i.e. 10/110). - Therefore, poll voters are actually incentivised to stake tokens after a poll has had its snapshot taken in order to maximise their voting power.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance. This check-pointing behaviour is implemented on Ethereum which has a more restrictive block space. The mechanism will simply store the staker's balance on each stake/unstake action. When user's wish to vote, the protocol will check the balance at a specific block (i.e. the snapshotted block). An example implementation can be found [here](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol#L189-L221).  
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fmoney-market-contracts%2Fcontracts%2Fmarket%2Fsrc%2Fborrow.rs#L304   # Vulnerability details  ## Impact The borrow rate uses a simple interest formula to compute the accrued debt, instead of a compounding formula.  ```rust pub fn compute_interest_raw(     state: &mut State,     block_height: u64,     balance: Uint256,     aterra_supply: Uint256,     borrow_rate: Decimal256,     target_deposit_rate: Decimal256, ) {   // @audit simple interest     let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);      let interest_factor = passed_blocks * borrow_rate;     let interest_accrued = state.total_liabilities * interest_factor;     // ... } ```  This means the actual borrow rate and interest for suppliers depend on how often updates are made. This difference should be negligible in highly active markets, but it could lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest.  ## Recommended Mitigation Steps Ensure that the markets are accrued regularly, or switch to a compound interest formula (which has a higher computational cost due to exponentiation, but can be approximated, see Aave).   
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fanchor-token-contracts%2Fcontracts%2Fcollector%2Fsrc%2Fcontract.rs#L130-L137   # Vulnerability details  ## Impact The collector contract allows anyone to `sweep`, swapping an asset token to ANC through astro port. Note that `belief_price` is not set and `config.max_spread` might not be set as well or misconfigured.  This allows an attacker to create a contract to perform a sandwich attack to make a profit on this trade.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the protocol's loss.  #### POC Attacker creates a contract that triggers 3 messages for the sandwich attack:  - Astroport: buy ANC with asset - call `sweep` which trades at bad price - Astroport: sell assets from the first message for profit   ## Recommended Mitigation Steps Consider setting a ANC/asset `belief_price` from an oracle.   
# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L530-L531   # Vulnerability details  # Impact Users will still be able to find failed polls under "Executed" and "Failed"  # Proof of Concept A poll attempts to execute and fails. That poll will stay in the poll indexer as executed and failed.  # Mitigation `Passed` should be `Executed`.   Test proof: https://pastebin.com/Cz0wujn9   
