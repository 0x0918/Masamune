# Handle  shw   # Vulnerability details  ## Impact  The function `_calculateDeltaOfFSD` of contract `ABC` incorrectly converts an `int256` type parameter, `_reserveDelta`, to `uint256` by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation `sub` at line 43 to revert, and thus the FSD tokens cannot be burned. (`_reserveDelta` is negative when burning FSD tokens)  ## Proof of Concept  Simply calling `fsd.burn` after a successful `fsd.mint` will trigger this bug.  Referenced code: [ABC.sol#L43](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L43) [ABC.sol#L49](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L49) [ABC.sol#L54](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L54)  ## Recommended Mitigation Steps  Use the solidity function `abs` to get the `_reserveDelta` absolute value.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `fShareRatio` in the function `purchaseMembership` of contract `FSDNetwork` is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).  ## Proof of Concept  The `fShareRatio` is calculated (line 136) by:  ```solidity (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare; ```  where `fsd.getReserveBalance()` can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased `fShareRatio` could affect the function `purchaseMembership` results. For example, the user could purchase the membership even if the `fShareRatio` is < 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of `fShareRatio`.  Referenced code: [FSDNetwork.sol#L134-L142](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L134-L142) [FSDNetwork.sol#L178-L182](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L178-L182)  ## Recommended Mitigation Steps  Force users to wait for (at least) a block to prevent flash minting and burning.  
# Handle  shw   # Vulnerability details  ## Impact  The current implementation of the arctan formula in the contract `FairSideFormula` is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function `calculateDeltaOfFSD` and the number of FSD tokens minted or burned.  ## Proof of Concept  The function `_arctan` misses two `abs` on the variable `a`. The correct implementation should be:  ```solidity function _arctan(bytes16 a) private pure returns (bytes16) {     return         a.mul(PI_4).sub(             a.mul(a.abs().sub(ONE)).mul(APPROX_A.add(APPROX_B.mul(a.abs())))         ); } ```  Notice that `_arctan` is called by `arctan`, and `arctan` is called by `arcs` with `ONE.sub(arcInner)` provided as the input parameter. Since `arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)` can be a large number (recall that `x` is the capital pool), it is possible that the parameter `a` is negative.  Referenced code:  [FairSideFormula.sol#L45-L61](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L45-L61) [FairSideFormula.sol#L77-L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L77-L85) [FairSideFormula.sol#L127](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L127) [ABC.sol#L38](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L38)  ## Recommended Mitigation Steps  Modify the `_arctan` function as above.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `pendingWithdrawals` in the contract `Withdrawable` is not decreased after the function `withdraw` is called, which causes the return value of function `getReserveBalance` less than it should be. This bug could cause incorrect results in several critical functions related to FSD token pricing, including `getFSDPrice`, `purchaseMembership`, `getMaximumBenefitPerUser`, `mint`, and `burn` in the `FSDNetwork` and `FSD` contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L14-L19](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L14-L19) [Withdrawable.sol#L26-L28](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L26-L28)  Affected functions: [FSD.sol#L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L85) [FSD.sol#L100](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L100) [FSDNetwork.sol#L136](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L136) [FSDNetwork.sol#L361](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L361) [FSDNetwork.sol#L369](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L369)  ## Recommended Mitigation Steps  Add `pendingWithdrawals = pendingWithdrawals.sub(reserveAmount);` after line 17 in the contract `Withdrawable`.  
# Handle  shw   # Vulnerability details  ## Impact  Gas optimization is possible for the current `rootPows` implementation.  ## Proof of Concept  The original implementation of `rootPows` requires 4 `mul` and 2 `sqrt`:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     // fourth root     x = x.sqrt().sqrt();     // to the power of 3     x = _pow3(x);     // we offset the root on the second arg     return (x, x.mul(x)); } ```  However, the calculation process can be simplified to be more gas-efficient than the original with only 1 `mul` and 2 `sqrt` requried:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     bytes16 x1_2 = x.sqrt();     bytes16 x3_2 = x.mul(x1_2);     bytes16 x3_4 = x3_2.sqrt();     return (x3_4, x3_2); } ```  Referenced code: [FairSideFormula.sol#L67-L75](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L67-L75)  ## Recommended Mitigation Steps  To save gas, change the implementation of `rootPows` as mentioned above.  
# Handle  shw   # Vulnerability details  ## Impact  The `getEtherPrice` function in the contract `FSDNetwork` fetches the ETH price from a Chainlink aggregator using the `latestRoundData` function. However, there are no checks on `roundID` nor `timeStamp`, resulting in stale prices.  ## Proof of Concept  Referenced code: [FSDNetwork.sol#L376-L381](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L376-L381)  ## Recommended Mitigation Steps  Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:  ```solidity (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```  
# Handle  shw   # Vulnerability details  ## Impact  The function `withdraw` in the contract `Withdrawable` uses the Solidity keyword, `transfer`, which is unrecommended since it forwards a fixed amount of 2300 gas to the recipient. The gas cost of opcodes may change during hard forks in the future and thus break the functionalities of existing deployed contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L18](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L18)  Please refer to the following references for more details:  [Solidity issue - Remove .send and .transfer](https://github.com/ethereum/solidity/issues/7455) [Stop Using Solidity's transfer() Now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)   ## Recommended Mitigation Steps  Use `.call{value: 1 ether}("")` instead of `transfer` or `send`. Besides, since the `call` function forwards all gas to the recipient, the contract should add protections (e.g., reentrancy guards) to prevent the recipient from reentering critical functions.  
# Handle  s1m0   # Vulnerability details  ## Impact The following revert messages refer to a different function instead of the one where they actually are, making harder to understand the flow of the program in case of error. [l. 166](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166) [l. 185](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185) [l. 254](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254)  ## Recommended Mitigation Steps Set the messages with the correct function name.  
# Handle  pauliax   # Vulnerability details  ## Impact convictionless can be set via function setConvictionless, however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like _updateConvictionScore.  ## Recommended Mitigation Steps Either remove this mapping or use it where intended.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The method `purchaseMembership` in `FSDNetwork` contract contains the code below. Inside this method, we are constantly reading from the mapping `membership`, so why not use just one read `Membership userMembership = membership[msg.sender]` and use this instance for everything related to memberships.  Each read we are currently doing has an impact on the gas cost.  ``` function purchaseMembership(uint256 costShareBenefit) external {         require(             costShareBenefit % 10 ether == 0 && costShareBenefit > 0,             "FSDNetwork::purchaseMembership: Invalid cost share benefit specified"         );          if (             membership[msg.sender].creation + MEMBERSHIP_DURATION <             block.timestamp         ) {             membership[msg.sender].creation = 0;             membership[msg.sender].availableCostShareBenefits = 0;         }          uint256 totalCostShareBenefit =             membership[msg.sender].availableCostShareBenefits.add(                 costShareBenefit             );         require(             totalCostShareBenefit <= getMaximumBenefitPerUser(),             "FSDNetwork::purchaseMembership: Exceeds cost share benefit limit per account"         );          totalCostShareBenefits = totalCostShareBenefits.add(costShareBenefit);          // FSHARE = Total Available Cost Share Benefits / Gearing Factor         uint256 fShare = totalCostShareBenefits / GEARING_FACTOR;         // Floor of 7500 ETH         if (fShare < 7500 ether) fShare = 7500 ether;          // FSHARERatio = Capital Pool / FSHARE (scaled by 1e18)         uint256 fShareRatio =             (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare;          // 1 ether = 100%         require(             fShareRatio >= 1 ether,             "FSDNetwork::purchaseMembership: Insufficient Capital to Cover Membership"         );          uint256 membershipFee = costShareBenefit.wmul(MEMBERSHIP_FEE);         uint256 fsdSpotPrice = getFSDPrice();         uint256 fsdFee = membershipFee.wdiv(fsdSpotPrice);          // Automatically locks 65% to the Network by disallowing its retrieval         fsd.safeTransferFrom(msg.sender, address(this), fsdFee);          if (membership[msg.sender].creation == 0) {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;             membership[msg.sender].creation = block.timestamp;             membership[msg.sender].gracePeriod =                 membership[msg.sender].creation +                 MEMBERSHIP_DURATION +                 60 days;         } else {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;              uint256 elapsedDurationPercentage =                 ((block.timestamp - membership[msg.sender].creation) *                     1 ether) / MEMBERSHIP_DURATION;             if (elapsedDurationPercentage < 1 ether) {                 uint256 durationIncrease =                     (costShareBenefit.mul(1 ether) /                         (totalCostShareBenefit - costShareBenefit))                         .mul(MEMBERSHIP_DURATION) / 1 ether;                 membership[msg.sender].creation += durationIncrease;             }         }          uint256 governancePoolRewards =             fsdFee.wmul(GOVERNANCE_FUNDING_POOL_REWARDS);          // Staking Rewards = 20% + [FSHARERatio - 125%] (if FSHARERatio > 125%)         uint256 stakingMultiplier =             fShareRatio >= 1.25 ether                 ? STAKING_REWARDS + fShareRatio - 1.25 ether                 : STAKING_REWARDS;          // Maximum of 75% as we have 15% distributed to governance + funding pool         if (stakingMultiplier > 0.75 ether) stakingMultiplier = 0.75 ether;          uint256 stakingRewards = fsdFee.wmul(stakingMultiplier);          // 20% as staking rewards         fsd.safeTransfer(address(fsd), stakingRewards);         fsd.addRegistrationTribute(stakingRewards);          // 7.5% towards governance         fsd.safeTransfer(address(fsd), governancePoolRewards);         fsd.addRegistrationTributeGovernance(governancePoolRewards);          // 7.5% towards funding pool         fsd.safeTransfer(FUNDING_POOL, governancePoolRewards);     } ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  There are two issues with the governance checks when acquiring them from an NFT:  #### Missing balance check The governance checks in `_updateConvictionScore` are:  ```solidity !isGovernance[user] && userConvictionScore >= governanceThreshold  && balanceOf(user) >= governanceMinimumBalance; ```  Whereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.  ```solidity else if (     !isGovernance[msg.sender] && userNew >= governanceThreshold ) {     isGovernance[msg.sender] = true; } ```  #### the `wasGovernance` might be outdated  The second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now. The NFT's governance state is blindly appplied to the new user:  ```solidity if (wasGovernance && !isGovernance[msg.sender]) {     isGovernance[msg.sender] = true; } ```  This allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation.  ## Impact It's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and backrunning with a redemption.  ## Recommended Mitigation Steps Add the missing balance check in `acquireConviction`. Remove the `wasGovernance` governance transfer from the NFT and solely recompute it based on the current `governanceThreshold` / `governanceMinimumBalance` settings.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors. But any user can directly transfer to this address increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`. It'll first write a snapshot of this address' balance which should be very low:  ```solidity // in _updateConvictionScore _writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta); ```  This address then accumulates a score based on its balance which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.  ## Impact Increasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. (by manipulating `FairSideDAO.totalVotes`). `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Disallow transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  The user could increase their conviction / governance score first in the same block and then lose their status in a second transaction, and the total governance conviction score would only be reduced by the previous score.  Example: Block n - 10000: User is a governor and has a credit score of 1000 which was also contributed to the `TOTAL_GOVERNANCE_SCORE` Block n: - User updates their own conviction score using public `updateConvictionScore` function which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total. - User transfers their whole balance away, the balance drops below `governanceMinimumBalance` and user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score) but it's only `1000` because it takes the snapshot of block n - 1.  ## Impact The `TOTAL_GOVERNANCE_SCORE` score can be inflated this way and break the voting mechanism in the worst case as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Use the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.  In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative but it's positive.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  It then gets added to the new total:  ```solidity uint224 totalGCSNew =     add224(         totalGCSOld,         governanceDelta,         "ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows"     ); ```  ## Impact The `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data which can then be used for anyone to pass proposals in the worst case. Or `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Return a negative, signed integer for this case and add it to the new total.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The error message states:  ```solidity require(     proposal.offchain,     "FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain" ); ```  But it should be "... meant to be voted onchain".   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Besides the conviction scores of users, there appears to be tracking of the FairSide protocol’s tokenized conviction score as a whole (using fscAddress = address(fairSideConviction)). This is evident in the attempted reduction of the protocol’s score when a user acquires conviction back from a NFT. However, the complementary accrual of user's conviction score to fscAddress when user tokenizes their conviction score to mint a NFT is missing in tokenizeConviction().  Because of this missing updation of conviction score to fscAddress on tokenization, there are no checkpoints written for fscAddress and there also doesn’t appear to be any initialization for bootstrapping this address’s conviction score checkpoints. As a result, the sub224() on Line350 of ERC20ConvictionScore.sol will always fail with an underflow because fscOld = 0 (because fscNum = 0) and convictionScore > 0, effectively reverting all calls to acquireConviction().  The impact is that all tokenized NFTs can never be redeemed back to their conviction scores and therefore leads to lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.   ## Proof of Concept  1. Alice tokenizes her conviction score into a NFT. She sells that NFT to Bob who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.   2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on FairSide network. But the call to acquireConviction() fails. Bob is never able to redeem Alice’s NFT and has lost the funds used to buy it.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L343-L355   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add appropriate logic to bootstrap+initialize fscAddress’s tokenized conviction score checkpoints and update it during tokenization.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The tokens optionally locked during tokenization are released twice on acquiring conviction back from a NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and also occurs in a different part of the code.)  When a user wants to acquire back the conviction score captured by a NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in _release() (via acquireConviction -> burn) of FairSideConviction.sol and again immediately after the burn on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  This leads to loss of protocol funds.  ## Proof of Concept  Alice tokenizes her conviction score into a NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L123  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L314-L316   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the redundant transfer of FSD tokens from protocol to user on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  _updateConvictionScore() function returns convictionDelta and governanceDelta which need to be used immediately in a call to _updateConvictionTotals(convictionDelta, governanceDelta) for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.  This updation of totals after a call to _updateConvictionScore() is done on Line70 in _beforeTokenTransfer() and Line367 in updateConvictionScore() of ERC20ConvictionScore.sol.  However, the return values of _updateConvictionScore() are ignored on Line284 in tokenizeConviction() and not used to update the totals using _updateConvictionTotals(convictionDelta, governanceDelta).  The impact is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero which is incorrect and reported separately in a different finding) but the totals are not updated. This leads to incorrect accounting of TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE which are used in the calculation of tributes and therefore will lead to incorrect tribute calculations.  ## Proof of Concept  Alice calls tokenizeConviction() to convert her conviction score into an NFT. Her conviction deltas as returned by _updateConvictionScore() are ignored and TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE values are not updated. As a result, the tributes rewarded are proportionally more than what should have been the case because the conviction score totals are used as the denominator in availableTribute() and availableGovernanceTribute().  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L284  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L108-L110  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L52-L70  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L365-L367  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L73-L106  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L83-L100  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L102-L123   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use the return values of _updateConvictionScore() function (i.e. convictionDelta and governanceDelta) on Line284 of ERC20ConvictionScore.sol and use them in a call to _updateConvictionTotals(convictionDelta, governanceDelta).  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Conviction scores for new addresses/users fail to initialize+bootstrap in ERC20ConvictionScore’s _updateConvictionScore() because a new user’s numCheckpoints will be zero and never gets initialized.   This effectively means that FairSide conviction scoring fails to bootstrap at all, leading to failure of the protocol’s pivotal feature.  ## Proof of Concept  When Alice transfers FSD tokens to Bob for the first time, _beforeTokenTransfer(Alice, Bob, 100) is triggered which calls _updateConvictionScore(Bob, 100) on Line55 of ERC20ConvictionScore.sol.   In function _updateConvictionScore(), given that this is the first time Bob is receiving FSD tokens, numCheckpoints[Bob] will be 0 (Line116) which will make ts = 0 (Line120), and Bob’s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes convictionDelta = 0 (Line122) and not let control go past Line129.   This means that a new checkpoint never gets written, i.e. conviction score never gets initialized, for Bob or for any user for that matter.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  FairSide’s adjustment of Compound’s conviction scoring is based on time and so needs an initialization to take place vs. Compound’s implementation. A new checkpoint therefore needs to be created+initialized for a new user during token transfer.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  liquidateDai() calls Uniswap’s swapExactTokensForETH to swap Dai to ETH. This will work if msg.sender, i.e. FSD contract, has already given the router an allowance of at least amount on the input token Dai.   Given that there is no prior approval, the call to UniswapV2 router for swapping will fail because msg.sender has not approved UniswapV2 with an allowance for the tokens being attempted to swap.  The impact is that updateCostShareRequest() will fail and revert while working with stablecoin Dai.  ## Proof of Concept  https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L191  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L182-L198  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L323  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L307-L329  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L280  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L297   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add FSD approval to UniswapV2 with an allowance for the tokens being attempted to swap.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The addRegistrationTributeGovernance() function is called by the FSD network to update tribute when 7.5% is contributed towards governance as part of purchaseMembership(). However, this function incorrectly calls _addTribute() (as done in addRegistrationTribute) instead of _addGovernanceTribute().  The impact is that governanceTributes never gets updated and the entire tribute accounting logic is rendered incorrect.   ## Proof of Concept  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L140  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L130  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L195  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L30-L48  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L50-L70   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _addGovernanceTribute() instead of _addTribute on L140 of FSD.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function _addTribute can reuse lastTribute to reduce the numbers of storage access: tributes[totalTributes - 1].amount = add224(...) can be replaced with lastTribute.amount = add224(...) as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function _addGovernanceTribute governanceTributes.  ## Recommended Mitigation Steps lastTribute.amount = add224(...)  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions castVote and  castVoteBySig of FairSideDAO.sol have no "returns" parameters, however they do call "return" at the end of the function.  This is confusing for the readers of the code.  ## Proof of Concept // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dao/FairSideDAO.sol#L443  function castVote(uint256 proposalId, bool support) public {         return _castVote(msg.sender, proposalId, support);     }   function castVoteBySig( .. ) public {        ...        return _castVote(signatory, proposalId, support);     }  ## Tools Used Editor  ## Recommended Mitigation Steps  Remove the "return" statements from castVote and castVoteBySig  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function purchaseMembership of FSDNetwork.sol, when the membership is extended then membership[msg.sender].creation is increased, however  membership[msg.sender].gracePeriod is not increased. This might lead to a gracePeriod than is less then expected. It seems logical to also increase the gracePeriod    ## Proof of Concept FSDNetwork.sol // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L171 function purchaseMembership(uint256 costShareBenefit) external {      ...       if (membership[msg.sender].creation == 0) {             ...             membership[msg.sender].creation       = block.timestamp;             membership[msg.sender].gracePeriod =  membership[msg.sender].creation +  MEMBERSHIP_DURATION +  60 days;         } else {           ....           membership[msg.sender].creation += durationIncrease;    }  ## Tools Used Editor  ## Recommended Mitigation Steps Check if gracePeriod has to be increased also.  When that is the case add the logic to do that.  
# Handle  shw   # Vulnerability details  ## Impact  The function `_calculateDeltaOfFSD` of contract `ABC` incorrectly converts an `int256` type parameter, `_reserveDelta`, to `uint256` by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation `sub` at line 43 to revert, and thus the FSD tokens cannot be burned. (`_reserveDelta` is negative when burning FSD tokens)  ## Proof of Concept  Simply calling `fsd.burn` after a successful `fsd.mint` will trigger this bug.  Referenced code: [ABC.sol#L43](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L43) [ABC.sol#L49](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L49) [ABC.sol#L54](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L54)  ## Recommended Mitigation Steps  Use the solidity function `abs` to get the `_reserveDelta` absolute value.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `fShareRatio` in the function `purchaseMembership` of contract `FSDNetwork` is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).  ## Proof of Concept  The `fShareRatio` is calculated (line 136) by:  ```solidity (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare; ```  where `fsd.getReserveBalance()` can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased `fShareRatio` could affect the function `purchaseMembership` results. For example, the user could purchase the membership even if the `fShareRatio` is < 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of `fShareRatio`.  Referenced code: [FSDNetwork.sol#L134-L142](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L134-L142) [FSDNetwork.sol#L178-L182](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L178-L182)  ## Recommended Mitigation Steps  Force users to wait for (at least) a block to prevent flash minting and burning.  
# Handle  shw   # Vulnerability details  ## Impact  The current implementation of the arctan formula in the contract `FairSideFormula` is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function `calculateDeltaOfFSD` and the number of FSD tokens minted or burned.  ## Proof of Concept  The function `_arctan` misses two `abs` on the variable `a`. The correct implementation should be:  ```solidity function _arctan(bytes16 a) private pure returns (bytes16) {     return         a.mul(PI_4).sub(             a.mul(a.abs().sub(ONE)).mul(APPROX_A.add(APPROX_B.mul(a.abs())))         ); } ```  Notice that `_arctan` is called by `arctan`, and `arctan` is called by `arcs` with `ONE.sub(arcInner)` provided as the input parameter. Since `arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)` can be a large number (recall that `x` is the capital pool), it is possible that the parameter `a` is negative.  Referenced code:  [FairSideFormula.sol#L45-L61](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L45-L61) [FairSideFormula.sol#L77-L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L77-L85) [FairSideFormula.sol#L127](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L127) [ABC.sol#L38](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L38)  ## Recommended Mitigation Steps  Modify the `_arctan` function as above.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `pendingWithdrawals` in the contract `Withdrawable` is not decreased after the function `withdraw` is called, which causes the return value of function `getReserveBalance` less than it should be. This bug could cause incorrect results in several critical functions related to FSD token pricing, including `getFSDPrice`, `purchaseMembership`, `getMaximumBenefitPerUser`, `mint`, and `burn` in the `FSDNetwork` and `FSD` contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L14-L19](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L14-L19) [Withdrawable.sol#L26-L28](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L26-L28)  Affected functions: [FSD.sol#L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L85) [FSD.sol#L100](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L100) [FSDNetwork.sol#L136](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L136) [FSDNetwork.sol#L361](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L361) [FSDNetwork.sol#L369](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L369)  ## Recommended Mitigation Steps  Add `pendingWithdrawals = pendingWithdrawals.sub(reserveAmount);` after line 17 in the contract `Withdrawable`.  
# Handle  shw   # Vulnerability details  ## Impact  Gas optimization is possible for the current `rootPows` implementation.  ## Proof of Concept  The original implementation of `rootPows` requires 4 `mul` and 2 `sqrt`:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     // fourth root     x = x.sqrt().sqrt();     // to the power of 3     x = _pow3(x);     // we offset the root on the second arg     return (x, x.mul(x)); } ```  However, the calculation process can be simplified to be more gas-efficient than the original with only 1 `mul` and 2 `sqrt` requried:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     bytes16 x1_2 = x.sqrt();     bytes16 x3_2 = x.mul(x1_2);     bytes16 x3_4 = x3_2.sqrt();     return (x3_4, x3_2); } ```  Referenced code: [FairSideFormula.sol#L67-L75](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L67-L75)  ## Recommended Mitigation Steps  To save gas, change the implementation of `rootPows` as mentioned above.  
# Handle  shw   # Vulnerability details  ## Impact  The `getEtherPrice` function in the contract `FSDNetwork` fetches the ETH price from a Chainlink aggregator using the `latestRoundData` function. However, there are no checks on `roundID` nor `timeStamp`, resulting in stale prices.  ## Proof of Concept  Referenced code: [FSDNetwork.sol#L376-L381](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L376-L381)  ## Recommended Mitigation Steps  Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:  ```solidity (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```  
# Handle  shw   # Vulnerability details  ## Impact  The function `withdraw` in the contract `Withdrawable` uses the Solidity keyword, `transfer`, which is unrecommended since it forwards a fixed amount of 2300 gas to the recipient. The gas cost of opcodes may change during hard forks in the future and thus break the functionalities of existing deployed contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L18](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L18)  Please refer to the following references for more details:  [Solidity issue - Remove .send and .transfer](https://github.com/ethereum/solidity/issues/7455) [Stop Using Solidity's transfer() Now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)   ## Recommended Mitigation Steps  Use `.call{value: 1 ether}("")` instead of `transfer` or `send`. Besides, since the `call` function forwards all gas to the recipient, the contract should add protections (e.g., reentrancy guards) to prevent the recipient from reentering critical functions.  
# Handle  s1m0   # Vulnerability details  ## Impact The following revert messages refer to a different function instead of the one where they actually are, making harder to understand the flow of the program in case of error. [l. 166](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166) [l. 185](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185) [l. 254](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254)  ## Recommended Mitigation Steps Set the messages with the correct function name.  
# Handle  pauliax   # Vulnerability details  ## Impact convictionless can be set via function setConvictionless, however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like _updateConvictionScore.  ## Recommended Mitigation Steps Either remove this mapping or use it where intended.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The method `purchaseMembership` in `FSDNetwork` contract contains the code below. Inside this method, we are constantly reading from the mapping `membership`, so why not use just one read `Membership userMembership = membership[msg.sender]` and use this instance for everything related to memberships.  Each read we are currently doing has an impact on the gas cost.  ``` function purchaseMembership(uint256 costShareBenefit) external {         require(             costShareBenefit % 10 ether == 0 && costShareBenefit > 0,             "FSDNetwork::purchaseMembership: Invalid cost share benefit specified"         );          if (             membership[msg.sender].creation + MEMBERSHIP_DURATION <             block.timestamp         ) {             membership[msg.sender].creation = 0;             membership[msg.sender].availableCostShareBenefits = 0;         }          uint256 totalCostShareBenefit =             membership[msg.sender].availableCostShareBenefits.add(                 costShareBenefit             );         require(             totalCostShareBenefit <= getMaximumBenefitPerUser(),             "FSDNetwork::purchaseMembership: Exceeds cost share benefit limit per account"         );          totalCostShareBenefits = totalCostShareBenefits.add(costShareBenefit);          // FSHARE = Total Available Cost Share Benefits / Gearing Factor         uint256 fShare = totalCostShareBenefits / GEARING_FACTOR;         // Floor of 7500 ETH         if (fShare < 7500 ether) fShare = 7500 ether;          // FSHARERatio = Capital Pool / FSHARE (scaled by 1e18)         uint256 fShareRatio =             (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare;          // 1 ether = 100%         require(             fShareRatio >= 1 ether,             "FSDNetwork::purchaseMembership: Insufficient Capital to Cover Membership"         );          uint256 membershipFee = costShareBenefit.wmul(MEMBERSHIP_FEE);         uint256 fsdSpotPrice = getFSDPrice();         uint256 fsdFee = membershipFee.wdiv(fsdSpotPrice);          // Automatically locks 65% to the Network by disallowing its retrieval         fsd.safeTransferFrom(msg.sender, address(this), fsdFee);          if (membership[msg.sender].creation == 0) {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;             membership[msg.sender].creation = block.timestamp;             membership[msg.sender].gracePeriod =                 membership[msg.sender].creation +                 MEMBERSHIP_DURATION +                 60 days;         } else {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;              uint256 elapsedDurationPercentage =                 ((block.timestamp - membership[msg.sender].creation) *                     1 ether) / MEMBERSHIP_DURATION;             if (elapsedDurationPercentage < 1 ether) {                 uint256 durationIncrease =                     (costShareBenefit.mul(1 ether) /                         (totalCostShareBenefit - costShareBenefit))                         .mul(MEMBERSHIP_DURATION) / 1 ether;                 membership[msg.sender].creation += durationIncrease;             }         }          uint256 governancePoolRewards =             fsdFee.wmul(GOVERNANCE_FUNDING_POOL_REWARDS);          // Staking Rewards = 20% + [FSHARERatio - 125%] (if FSHARERatio > 125%)         uint256 stakingMultiplier =             fShareRatio >= 1.25 ether                 ? STAKING_REWARDS + fShareRatio - 1.25 ether                 : STAKING_REWARDS;          // Maximum of 75% as we have 15% distributed to governance + funding pool         if (stakingMultiplier > 0.75 ether) stakingMultiplier = 0.75 ether;          uint256 stakingRewards = fsdFee.wmul(stakingMultiplier);          // 20% as staking rewards         fsd.safeTransfer(address(fsd), stakingRewards);         fsd.addRegistrationTribute(stakingRewards);          // 7.5% towards governance         fsd.safeTransfer(address(fsd), governancePoolRewards);         fsd.addRegistrationTributeGovernance(governancePoolRewards);          // 7.5% towards funding pool         fsd.safeTransfer(FUNDING_POOL, governancePoolRewards);     } ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  There are two issues with the governance checks when acquiring them from an NFT:  #### Missing balance check The governance checks in `_updateConvictionScore` are:  ```solidity !isGovernance[user] && userConvictionScore >= governanceThreshold  && balanceOf(user) >= governanceMinimumBalance; ```  Whereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.  ```solidity else if (     !isGovernance[msg.sender] && userNew >= governanceThreshold ) {     isGovernance[msg.sender] = true; } ```  #### the `wasGovernance` might be outdated  The second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now. The NFT's governance state is blindly appplied to the new user:  ```solidity if (wasGovernance && !isGovernance[msg.sender]) {     isGovernance[msg.sender] = true; } ```  This allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation.  ## Impact It's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and backrunning with a redemption.  ## Recommended Mitigation Steps Add the missing balance check in `acquireConviction`. Remove the `wasGovernance` governance transfer from the NFT and solely recompute it based on the current `governanceThreshold` / `governanceMinimumBalance` settings.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors. But any user can directly transfer to this address increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`. It'll first write a snapshot of this address' balance which should be very low:  ```solidity // in _updateConvictionScore _writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta); ```  This address then accumulates a score based on its balance which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.  ## Impact Increasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. (by manipulating `FairSideDAO.totalVotes`). `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Disallow transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  The user could increase their conviction / governance score first in the same block and then lose their status in a second transaction, and the total governance conviction score would only be reduced by the previous score.  Example: Block n - 10000: User is a governor and has a credit score of 1000 which was also contributed to the `TOTAL_GOVERNANCE_SCORE` Block n: - User updates their own conviction score using public `updateConvictionScore` function which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total. - User transfers their whole balance away, the balance drops below `governanceMinimumBalance` and user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score) but it's only `1000` because it takes the snapshot of block n - 1.  ## Impact The `TOTAL_GOVERNANCE_SCORE` score can be inflated this way and break the voting mechanism in the worst case as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Use the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.  In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative but it's positive.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  It then gets added to the new total:  ```solidity uint224 totalGCSNew =     add224(         totalGCSOld,         governanceDelta,         "ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows"     ); ```  ## Impact The `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data which can then be used for anyone to pass proposals in the worst case. Or `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Return a negative, signed integer for this case and add it to the new total.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The error message states:  ```solidity require(     proposal.offchain,     "FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain" ); ```  But it should be "... meant to be voted onchain".   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Besides the conviction scores of users, there appears to be tracking of the FairSide protocol’s tokenized conviction score as a whole (using fscAddress = address(fairSideConviction)). This is evident in the attempted reduction of the protocol’s score when a user acquires conviction back from a NFT. However, the complementary accrual of user's conviction score to fscAddress when user tokenizes their conviction score to mint a NFT is missing in tokenizeConviction().  Because of this missing updation of conviction score to fscAddress on tokenization, there are no checkpoints written for fscAddress and there also doesn’t appear to be any initialization for bootstrapping this address’s conviction score checkpoints. As a result, the sub224() on Line350 of ERC20ConvictionScore.sol will always fail with an underflow because fscOld = 0 (because fscNum = 0) and convictionScore > 0, effectively reverting all calls to acquireConviction().  The impact is that all tokenized NFTs can never be redeemed back to their conviction scores and therefore leads to lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.   ## Proof of Concept  1. Alice tokenizes her conviction score into a NFT. She sells that NFT to Bob who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.   2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on FairSide network. But the call to acquireConviction() fails. Bob is never able to redeem Alice’s NFT and has lost the funds used to buy it.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L343-L355   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add appropriate logic to bootstrap+initialize fscAddress’s tokenized conviction score checkpoints and update it during tokenization.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The tokens optionally locked during tokenization are released twice on acquiring conviction back from a NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and also occurs in a different part of the code.)  When a user wants to acquire back the conviction score captured by a NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in _release() (via acquireConviction -> burn) of FairSideConviction.sol and again immediately after the burn on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  This leads to loss of protocol funds.  ## Proof of Concept  Alice tokenizes her conviction score into a NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L123  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L314-L316   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the redundant transfer of FSD tokens from protocol to user on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  _updateConvictionScore() function returns convictionDelta and governanceDelta which need to be used immediately in a call to _updateConvictionTotals(convictionDelta, governanceDelta) for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.  This updation of totals after a call to _updateConvictionScore() is done on Line70 in _beforeTokenTransfer() and Line367 in updateConvictionScore() of ERC20ConvictionScore.sol.  However, the return values of _updateConvictionScore() are ignored on Line284 in tokenizeConviction() and not used to update the totals using _updateConvictionTotals(convictionDelta, governanceDelta).  The impact is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero which is incorrect and reported separately in a different finding) but the totals are not updated. This leads to incorrect accounting of TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE which are used in the calculation of tributes and therefore will lead to incorrect tribute calculations.  ## Proof of Concept  Alice calls tokenizeConviction() to convert her conviction score into an NFT. Her conviction deltas as returned by _updateConvictionScore() are ignored and TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE values are not updated. As a result, the tributes rewarded are proportionally more than what should have been the case because the conviction score totals are used as the denominator in availableTribute() and availableGovernanceTribute().  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L284  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L108-L110  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L52-L70  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L365-L367  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L73-L106  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L83-L100  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L102-L123   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use the return values of _updateConvictionScore() function (i.e. convictionDelta and governanceDelta) on Line284 of ERC20ConvictionScore.sol and use them in a call to _updateConvictionTotals(convictionDelta, governanceDelta).  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Conviction scores for new addresses/users fail to initialize+bootstrap in ERC20ConvictionScore’s _updateConvictionScore() because a new user’s numCheckpoints will be zero and never gets initialized.   This effectively means that FairSide conviction scoring fails to bootstrap at all, leading to failure of the protocol’s pivotal feature.  ## Proof of Concept  When Alice transfers FSD tokens to Bob for the first time, _beforeTokenTransfer(Alice, Bob, 100) is triggered which calls _updateConvictionScore(Bob, 100) on Line55 of ERC20ConvictionScore.sol.   In function _updateConvictionScore(), given that this is the first time Bob is receiving FSD tokens, numCheckpoints[Bob] will be 0 (Line116) which will make ts = 0 (Line120), and Bob’s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes convictionDelta = 0 (Line122) and not let control go past Line129.   This means that a new checkpoint never gets written, i.e. conviction score never gets initialized, for Bob or for any user for that matter.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  FairSide’s adjustment of Compound’s conviction scoring is based on time and so needs an initialization to take place vs. Compound’s implementation. A new checkpoint therefore needs to be created+initialized for a new user during token transfer.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  liquidateDai() calls Uniswap’s swapExactTokensForETH to swap Dai to ETH. This will work if msg.sender, i.e. FSD contract, has already given the router an allowance of at least amount on the input token Dai.   Given that there is no prior approval, the call to UniswapV2 router for swapping will fail because msg.sender has not approved UniswapV2 with an allowance for the tokens being attempted to swap.  The impact is that updateCostShareRequest() will fail and revert while working with stablecoin Dai.  ## Proof of Concept  https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L191  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L182-L198  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L323  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L307-L329  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L280  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L297   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add FSD approval to UniswapV2 with an allowance for the tokens being attempted to swap.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The addRegistrationTributeGovernance() function is called by the FSD network to update tribute when 7.5% is contributed towards governance as part of purchaseMembership(). However, this function incorrectly calls _addTribute() (as done in addRegistrationTribute) instead of _addGovernanceTribute().  The impact is that governanceTributes never gets updated and the entire tribute accounting logic is rendered incorrect.   ## Proof of Concept  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L140  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L130  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L195  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L30-L48  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L50-L70   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _addGovernanceTribute() instead of _addTribute on L140 of FSD.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function _addTribute can reuse lastTribute to reduce the numbers of storage access: tributes[totalTributes - 1].amount = add224(...) can be replaced with lastTribute.amount = add224(...) as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function _addGovernanceTribute governanceTributes.  ## Recommended Mitigation Steps lastTribute.amount = add224(...)  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions castVote and  castVoteBySig of FairSideDAO.sol have no "returns" parameters, however they do call "return" at the end of the function.  This is confusing for the readers of the code.  ## Proof of Concept // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dao/FairSideDAO.sol#L443  function castVote(uint256 proposalId, bool support) public {         return _castVote(msg.sender, proposalId, support);     }   function castVoteBySig( .. ) public {        ...        return _castVote(signatory, proposalId, support);     }  ## Tools Used Editor  ## Recommended Mitigation Steps  Remove the "return" statements from castVote and castVoteBySig  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function purchaseMembership of FSDNetwork.sol, when the membership is extended then membership[msg.sender].creation is increased, however  membership[msg.sender].gracePeriod is not increased. This might lead to a gracePeriod than is less then expected. It seems logical to also increase the gracePeriod    ## Proof of Concept FSDNetwork.sol // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L171 function purchaseMembership(uint256 costShareBenefit) external {      ...       if (membership[msg.sender].creation == 0) {             ...             membership[msg.sender].creation       = block.timestamp;             membership[msg.sender].gracePeriod =  membership[msg.sender].creation +  MEMBERSHIP_DURATION +  60 days;         } else {           ....           membership[msg.sender].creation += durationIncrease;    }  ## Tools Used Editor  ## Recommended Mitigation Steps Check if gracePeriod has to be increased also.  When that is the case add the logic to do that.  
# Handle  shw   # Vulnerability details  ## Impact  The function `_calculateDeltaOfFSD` of contract `ABC` incorrectly converts an `int256` type parameter, `_reserveDelta`, to `uint256` by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation `sub` at line 43 to revert, and thus the FSD tokens cannot be burned. (`_reserveDelta` is negative when burning FSD tokens)  ## Proof of Concept  Simply calling `fsd.burn` after a successful `fsd.mint` will trigger this bug.  Referenced code: [ABC.sol#L43](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L43) [ABC.sol#L49](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L49) [ABC.sol#L54](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L54)  ## Recommended Mitigation Steps  Use the solidity function `abs` to get the `_reserveDelta` absolute value.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `fShareRatio` in the function `purchaseMembership` of contract `FSDNetwork` is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).  ## Proof of Concept  The `fShareRatio` is calculated (line 136) by:  ```solidity (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare; ```  where `fsd.getReserveBalance()` can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased `fShareRatio` could affect the function `purchaseMembership` results. For example, the user could purchase the membership even if the `fShareRatio` is < 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of `fShareRatio`.  Referenced code: [FSDNetwork.sol#L134-L142](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L134-L142) [FSDNetwork.sol#L178-L182](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L178-L182)  ## Recommended Mitigation Steps  Force users to wait for (at least) a block to prevent flash minting and burning.  
# Handle  shw   # Vulnerability details  ## Impact  The current implementation of the arctan formula in the contract `FairSideFormula` is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function `calculateDeltaOfFSD` and the number of FSD tokens minted or burned.  ## Proof of Concept  The function `_arctan` misses two `abs` on the variable `a`. The correct implementation should be:  ```solidity function _arctan(bytes16 a) private pure returns (bytes16) {     return         a.mul(PI_4).sub(             a.mul(a.abs().sub(ONE)).mul(APPROX_A.add(APPROX_B.mul(a.abs())))         ); } ```  Notice that `_arctan` is called by `arctan`, and `arctan` is called by `arcs` with `ONE.sub(arcInner)` provided as the input parameter. Since `arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)` can be a large number (recall that `x` is the capital pool), it is possible that the parameter `a` is negative.  Referenced code:  [FairSideFormula.sol#L45-L61](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L45-L61) [FairSideFormula.sol#L77-L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L77-L85) [FairSideFormula.sol#L127](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L127) [ABC.sol#L38](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L38)  ## Recommended Mitigation Steps  Modify the `_arctan` function as above.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `pendingWithdrawals` in the contract `Withdrawable` is not decreased after the function `withdraw` is called, which causes the return value of function `getReserveBalance` less than it should be. This bug could cause incorrect results in several critical functions related to FSD token pricing, including `getFSDPrice`, `purchaseMembership`, `getMaximumBenefitPerUser`, `mint`, and `burn` in the `FSDNetwork` and `FSD` contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L14-L19](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L14-L19) [Withdrawable.sol#L26-L28](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L26-L28)  Affected functions: [FSD.sol#L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L85) [FSD.sol#L100](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L100) [FSDNetwork.sol#L136](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L136) [FSDNetwork.sol#L361](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L361) [FSDNetwork.sol#L369](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L369)  ## Recommended Mitigation Steps  Add `pendingWithdrawals = pendingWithdrawals.sub(reserveAmount);` after line 17 in the contract `Withdrawable`.  
# Handle  shw   # Vulnerability details  ## Impact  Gas optimization is possible for the current `rootPows` implementation.  ## Proof of Concept  The original implementation of `rootPows` requires 4 `mul` and 2 `sqrt`:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     // fourth root     x = x.sqrt().sqrt();     // to the power of 3     x = _pow3(x);     // we offset the root on the second arg     return (x, x.mul(x)); } ```  However, the calculation process can be simplified to be more gas-efficient than the original with only 1 `mul` and 2 `sqrt` requried:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     bytes16 x1_2 = x.sqrt();     bytes16 x3_2 = x.mul(x1_2);     bytes16 x3_4 = x3_2.sqrt();     return (x3_4, x3_2); } ```  Referenced code: [FairSideFormula.sol#L67-L75](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L67-L75)  ## Recommended Mitigation Steps  To save gas, change the implementation of `rootPows` as mentioned above.  
# Handle  shw   # Vulnerability details  ## Impact  The `getEtherPrice` function in the contract `FSDNetwork` fetches the ETH price from a Chainlink aggregator using the `latestRoundData` function. However, there are no checks on `roundID` nor `timeStamp`, resulting in stale prices.  ## Proof of Concept  Referenced code: [FSDNetwork.sol#L376-L381](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L376-L381)  ## Recommended Mitigation Steps  Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:  ```solidity (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```  
# Handle  shw   # Vulnerability details  ## Impact  The function `withdraw` in the contract `Withdrawable` uses the Solidity keyword, `transfer`, which is unrecommended since it forwards a fixed amount of 2300 gas to the recipient. The gas cost of opcodes may change during hard forks in the future and thus break the functionalities of existing deployed contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L18](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L18)  Please refer to the following references for more details:  [Solidity issue - Remove .send and .transfer](https://github.com/ethereum/solidity/issues/7455) [Stop Using Solidity's transfer() Now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)   ## Recommended Mitigation Steps  Use `.call{value: 1 ether}("")` instead of `transfer` or `send`. Besides, since the `call` function forwards all gas to the recipient, the contract should add protections (e.g., reentrancy guards) to prevent the recipient from reentering critical functions.  
# Handle  s1m0   # Vulnerability details  ## Impact The following revert messages refer to a different function instead of the one where they actually are, making harder to understand the flow of the program in case of error. [l. 166](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166) [l. 185](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185) [l. 254](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254)  ## Recommended Mitigation Steps Set the messages with the correct function name.  
# Handle  pauliax   # Vulnerability details  ## Impact convictionless can be set via function setConvictionless, however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like _updateConvictionScore.  ## Recommended Mitigation Steps Either remove this mapping or use it where intended.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The method `purchaseMembership` in `FSDNetwork` contract contains the code below. Inside this method, we are constantly reading from the mapping `membership`, so why not use just one read `Membership userMembership = membership[msg.sender]` and use this instance for everything related to memberships.  Each read we are currently doing has an impact on the gas cost.  ``` function purchaseMembership(uint256 costShareBenefit) external {         require(             costShareBenefit % 10 ether == 0 && costShareBenefit > 0,             "FSDNetwork::purchaseMembership: Invalid cost share benefit specified"         );          if (             membership[msg.sender].creation + MEMBERSHIP_DURATION <             block.timestamp         ) {             membership[msg.sender].creation = 0;             membership[msg.sender].availableCostShareBenefits = 0;         }          uint256 totalCostShareBenefit =             membership[msg.sender].availableCostShareBenefits.add(                 costShareBenefit             );         require(             totalCostShareBenefit <= getMaximumBenefitPerUser(),             "FSDNetwork::purchaseMembership: Exceeds cost share benefit limit per account"         );          totalCostShareBenefits = totalCostShareBenefits.add(costShareBenefit);          // FSHARE = Total Available Cost Share Benefits / Gearing Factor         uint256 fShare = totalCostShareBenefits / GEARING_FACTOR;         // Floor of 7500 ETH         if (fShare < 7500 ether) fShare = 7500 ether;          // FSHARERatio = Capital Pool / FSHARE (scaled by 1e18)         uint256 fShareRatio =             (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare;          // 1 ether = 100%         require(             fShareRatio >= 1 ether,             "FSDNetwork::purchaseMembership: Insufficient Capital to Cover Membership"         );          uint256 membershipFee = costShareBenefit.wmul(MEMBERSHIP_FEE);         uint256 fsdSpotPrice = getFSDPrice();         uint256 fsdFee = membershipFee.wdiv(fsdSpotPrice);          // Automatically locks 65% to the Network by disallowing its retrieval         fsd.safeTransferFrom(msg.sender, address(this), fsdFee);          if (membership[msg.sender].creation == 0) {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;             membership[msg.sender].creation = block.timestamp;             membership[msg.sender].gracePeriod =                 membership[msg.sender].creation +                 MEMBERSHIP_DURATION +                 60 days;         } else {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;              uint256 elapsedDurationPercentage =                 ((block.timestamp - membership[msg.sender].creation) *                     1 ether) / MEMBERSHIP_DURATION;             if (elapsedDurationPercentage < 1 ether) {                 uint256 durationIncrease =                     (costShareBenefit.mul(1 ether) /                         (totalCostShareBenefit - costShareBenefit))                         .mul(MEMBERSHIP_DURATION) / 1 ether;                 membership[msg.sender].creation += durationIncrease;             }         }          uint256 governancePoolRewards =             fsdFee.wmul(GOVERNANCE_FUNDING_POOL_REWARDS);          // Staking Rewards = 20% + [FSHARERatio - 125%] (if FSHARERatio > 125%)         uint256 stakingMultiplier =             fShareRatio >= 1.25 ether                 ? STAKING_REWARDS + fShareRatio - 1.25 ether                 : STAKING_REWARDS;          // Maximum of 75% as we have 15% distributed to governance + funding pool         if (stakingMultiplier > 0.75 ether) stakingMultiplier = 0.75 ether;          uint256 stakingRewards = fsdFee.wmul(stakingMultiplier);          // 20% as staking rewards         fsd.safeTransfer(address(fsd), stakingRewards);         fsd.addRegistrationTribute(stakingRewards);          // 7.5% towards governance         fsd.safeTransfer(address(fsd), governancePoolRewards);         fsd.addRegistrationTributeGovernance(governancePoolRewards);          // 7.5% towards funding pool         fsd.safeTransfer(FUNDING_POOL, governancePoolRewards);     } ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  There are two issues with the governance checks when acquiring them from an NFT:  #### Missing balance check The governance checks in `_updateConvictionScore` are:  ```solidity !isGovernance[user] && userConvictionScore >= governanceThreshold  && balanceOf(user) >= governanceMinimumBalance; ```  Whereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.  ```solidity else if (     !isGovernance[msg.sender] && userNew >= governanceThreshold ) {     isGovernance[msg.sender] = true; } ```  #### the `wasGovernance` might be outdated  The second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now. The NFT's governance state is blindly appplied to the new user:  ```solidity if (wasGovernance && !isGovernance[msg.sender]) {     isGovernance[msg.sender] = true; } ```  This allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation.  ## Impact It's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and backrunning with a redemption.  ## Recommended Mitigation Steps Add the missing balance check in `acquireConviction`. Remove the `wasGovernance` governance transfer from the NFT and solely recompute it based on the current `governanceThreshold` / `governanceMinimumBalance` settings.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors. But any user can directly transfer to this address increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`. It'll first write a snapshot of this address' balance which should be very low:  ```solidity // in _updateConvictionScore _writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta); ```  This address then accumulates a score based on its balance which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.  ## Impact Increasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. (by manipulating `FairSideDAO.totalVotes`). `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Disallow transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  The user could increase their conviction / governance score first in the same block and then lose their status in a second transaction, and the total governance conviction score would only be reduced by the previous score.  Example: Block n - 10000: User is a governor and has a credit score of 1000 which was also contributed to the `TOTAL_GOVERNANCE_SCORE` Block n: - User updates their own conviction score using public `updateConvictionScore` function which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total. - User transfers their whole balance away, the balance drops below `governanceMinimumBalance` and user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score) but it's only `1000` because it takes the snapshot of block n - 1.  ## Impact The `TOTAL_GOVERNANCE_SCORE` score can be inflated this way and break the voting mechanism in the worst case as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Use the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.  In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative but it's positive.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  It then gets added to the new total:  ```solidity uint224 totalGCSNew =     add224(         totalGCSOld,         governanceDelta,         "ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows"     ); ```  ## Impact The `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data which can then be used for anyone to pass proposals in the worst case. Or `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Return a negative, signed integer for this case and add it to the new total.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The error message states:  ```solidity require(     proposal.offchain,     "FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain" ); ```  But it should be "... meant to be voted onchain".   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Besides the conviction scores of users, there appears to be tracking of the FairSide protocol’s tokenized conviction score as a whole (using fscAddress = address(fairSideConviction)). This is evident in the attempted reduction of the protocol’s score when a user acquires conviction back from a NFT. However, the complementary accrual of user's conviction score to fscAddress when user tokenizes their conviction score to mint a NFT is missing in tokenizeConviction().  Because of this missing updation of conviction score to fscAddress on tokenization, there are no checkpoints written for fscAddress and there also doesn’t appear to be any initialization for bootstrapping this address’s conviction score checkpoints. As a result, the sub224() on Line350 of ERC20ConvictionScore.sol will always fail with an underflow because fscOld = 0 (because fscNum = 0) and convictionScore > 0, effectively reverting all calls to acquireConviction().  The impact is that all tokenized NFTs can never be redeemed back to their conviction scores and therefore leads to lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.   ## Proof of Concept  1. Alice tokenizes her conviction score into a NFT. She sells that NFT to Bob who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.   2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on FairSide network. But the call to acquireConviction() fails. Bob is never able to redeem Alice’s NFT and has lost the funds used to buy it.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L343-L355   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add appropriate logic to bootstrap+initialize fscAddress’s tokenized conviction score checkpoints and update it during tokenization.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The tokens optionally locked during tokenization are released twice on acquiring conviction back from a NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and also occurs in a different part of the code.)  When a user wants to acquire back the conviction score captured by a NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in _release() (via acquireConviction -> burn) of FairSideConviction.sol and again immediately after the burn on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  This leads to loss of protocol funds.  ## Proof of Concept  Alice tokenizes her conviction score into a NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L123  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L314-L316   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the redundant transfer of FSD tokens from protocol to user on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  _updateConvictionScore() function returns convictionDelta and governanceDelta which need to be used immediately in a call to _updateConvictionTotals(convictionDelta, governanceDelta) for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.  This updation of totals after a call to _updateConvictionScore() is done on Line70 in _beforeTokenTransfer() and Line367 in updateConvictionScore() of ERC20ConvictionScore.sol.  However, the return values of _updateConvictionScore() are ignored on Line284 in tokenizeConviction() and not used to update the totals using _updateConvictionTotals(convictionDelta, governanceDelta).  The impact is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero which is incorrect and reported separately in a different finding) but the totals are not updated. This leads to incorrect accounting of TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE which are used in the calculation of tributes and therefore will lead to incorrect tribute calculations.  ## Proof of Concept  Alice calls tokenizeConviction() to convert her conviction score into an NFT. Her conviction deltas as returned by _updateConvictionScore() are ignored and TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE values are not updated. As a result, the tributes rewarded are proportionally more than what should have been the case because the conviction score totals are used as the denominator in availableTribute() and availableGovernanceTribute().  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L284  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L108-L110  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L52-L70  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L365-L367  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L73-L106  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L83-L100  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L102-L123   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use the return values of _updateConvictionScore() function (i.e. convictionDelta and governanceDelta) on Line284 of ERC20ConvictionScore.sol and use them in a call to _updateConvictionTotals(convictionDelta, governanceDelta).  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Conviction scores for new addresses/users fail to initialize+bootstrap in ERC20ConvictionScore’s _updateConvictionScore() because a new user’s numCheckpoints will be zero and never gets initialized.   This effectively means that FairSide conviction scoring fails to bootstrap at all, leading to failure of the protocol’s pivotal feature.  ## Proof of Concept  When Alice transfers FSD tokens to Bob for the first time, _beforeTokenTransfer(Alice, Bob, 100) is triggered which calls _updateConvictionScore(Bob, 100) on Line55 of ERC20ConvictionScore.sol.   In function _updateConvictionScore(), given that this is the first time Bob is receiving FSD tokens, numCheckpoints[Bob] will be 0 (Line116) which will make ts = 0 (Line120), and Bob’s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes convictionDelta = 0 (Line122) and not let control go past Line129.   This means that a new checkpoint never gets written, i.e. conviction score never gets initialized, for Bob or for any user for that matter.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  FairSide’s adjustment of Compound’s conviction scoring is based on time and so needs an initialization to take place vs. Compound’s implementation. A new checkpoint therefore needs to be created+initialized for a new user during token transfer.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  liquidateDai() calls Uniswap’s swapExactTokensForETH to swap Dai to ETH. This will work if msg.sender, i.e. FSD contract, has already given the router an allowance of at least amount on the input token Dai.   Given that there is no prior approval, the call to UniswapV2 router for swapping will fail because msg.sender has not approved UniswapV2 with an allowance for the tokens being attempted to swap.  The impact is that updateCostShareRequest() will fail and revert while working with stablecoin Dai.  ## Proof of Concept  https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L191  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L182-L198  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L323  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L307-L329  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L280  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L297   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add FSD approval to UniswapV2 with an allowance for the tokens being attempted to swap.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The addRegistrationTributeGovernance() function is called by the FSD network to update tribute when 7.5% is contributed towards governance as part of purchaseMembership(). However, this function incorrectly calls _addTribute() (as done in addRegistrationTribute) instead of _addGovernanceTribute().  The impact is that governanceTributes never gets updated and the entire tribute accounting logic is rendered incorrect.   ## Proof of Concept  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L140  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L130  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L195  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L30-L48  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L50-L70   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _addGovernanceTribute() instead of _addTribute on L140 of FSD.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function _addTribute can reuse lastTribute to reduce the numbers of storage access: tributes[totalTributes - 1].amount = add224(...) can be replaced with lastTribute.amount = add224(...) as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function _addGovernanceTribute governanceTributes.  ## Recommended Mitigation Steps lastTribute.amount = add224(...)  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions castVote and  castVoteBySig of FairSideDAO.sol have no "returns" parameters, however they do call "return" at the end of the function.  This is confusing for the readers of the code.  ## Proof of Concept // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dao/FairSideDAO.sol#L443  function castVote(uint256 proposalId, bool support) public {         return _castVote(msg.sender, proposalId, support);     }   function castVoteBySig( .. ) public {        ...        return _castVote(signatory, proposalId, support);     }  ## Tools Used Editor  ## Recommended Mitigation Steps  Remove the "return" statements from castVote and castVoteBySig  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function purchaseMembership of FSDNetwork.sol, when the membership is extended then membership[msg.sender].creation is increased, however  membership[msg.sender].gracePeriod is not increased. This might lead to a gracePeriod than is less then expected. It seems logical to also increase the gracePeriod    ## Proof of Concept FSDNetwork.sol // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L171 function purchaseMembership(uint256 costShareBenefit) external {      ...       if (membership[msg.sender].creation == 0) {             ...             membership[msg.sender].creation       = block.timestamp;             membership[msg.sender].gracePeriod =  membership[msg.sender].creation +  MEMBERSHIP_DURATION +  60 days;         } else {           ....           membership[msg.sender].creation += durationIncrease;    }  ## Tools Used Editor  ## Recommended Mitigation Steps Check if gracePeriod has to be increased also.  When that is the case add the logic to do that.  
