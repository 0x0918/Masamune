## Gas Optimizations  ### Unchecked math will save on gas ```   function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {     return uint96(block.timestamp) + _lockDuration; //@audit Gas Optimization Unchecked   } ``` The `_computeLockUntil` function in `TWABDelegator.sol` can be optimized by adding the `unchecked` directive as this will never overflow the `uint96` type since it is limited by the `MAX_LOCK` constant (which is currently assigned to 180 days() by the call to `_requireLockDuration(_lockDuration);`. ``` justin@Stealth: 18362 » frf test.sol compiling... Compiling 2 files with 0.8.12 Compilation finished successfully success. Script ran successfully. Gas Used: 5401 == Logs ==  180 days, 15552000 Current timestamp, 1645633955 Current timestamp + 5000 years, 159325633955 Max uint96, 79228162514264337593543950335  ```  ### Unneeded Zero Address Check In the `stake` function of the `TWABDelegator.sol` file, the `_requireRecipientNotZeroAddress` function is called on the `_to` parameter. However, this is unnecessary since the `_mint` function checks for the zero address when called. As such, it would be more gas efficient to not perform this call. ```  function stake(address _to, uint256 _amount) external {     _requireRecipientNotZeroAddress(_to);     //@audit Gas Optimization Above is unneeded since _mint checks whether _to is zero addr or not     _requireAmountGtZero(_amount);      IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);     _mint(_to, _amount); ```   ### More efficient order of operations in `updateDelegatee` In the `updateDelegatee` function of the `TWABDelegator.sol` file the `_lockUntil` variable is defined by calling the `_computeLockUntil` function. However, if the `_lockDuration` is 0, then this value is the same as the current `block.timestamp`. As a result, the following code would be an optimization:  Original Code: ``` uint96 _lockUntil = _computeLockUntil(_lockDuration); //@audit Gas Optimization  if (_lockDuration > 0) {     _delegation.setLockUntil(_lockUntil); }  _delegateCall(_delegation, _delegatee);  emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender); ```  Optimized Code: ``` uint96 _lockUntil = block.timestamp; if (_lockDuration > 0) {     _lockUntil = _computeLockUntil(_lockDuration);     _delegation.setLockUntil(_lockUntil); } _delegateCall(_delegation, _delegatee); emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender); ```  Here are the tests with the optimizations (* indicates Optimized case): ``` ·························|·····························|·············|·············|··············|···············|·············· |  Contract              ·  Method                     ·  Min        ·  Max        ·  Avg         ·  # calls      ·  usd (avg)  │ ·························|·····························|·············|·············|··············|···············|·············· |  TWABDelegatorHarness  ·  updateDelegatee            ·     140113  ·     144124  ·      141911  ·            7  ·          -  │ ·························|·····························|·············|·············|··············|···············|·············· |  *TWABDelegatorHarness ·  updateDelegatee            ·     139965  ·     144126  ·      141806  ·            7  ·          -  │ ·························|·····························|·············|·············|··············|···············|·············· ```   ## Non-Critcal   ### Missing comment for the `to` parameter There is no comment on the `to` parameter for the `TransferredDelegation` event in the `TWABDelegator.sol` file. ```   /**    * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet.    * @param delegator Address of the delegator    * @param slot  Slot of the delegation    * @param amount Amount of tickets withdrawn    */    //@audit Missing comment for the `to` parameter   event TransferredDelegation(     address indexed delegator,     uint256 indexed slot,     uint256 amount,     address indexed to   );   ```     ## Low    ### Incorrect Event Parameters   The `TWABDelegator.sol`'s `TicketsStaked` event's first parameter should be the delegator, as such, it should be `msg.sender` not `_to` as `_to` is the recipient.   ```     /**    * @notice Emitted when tickets have been staked.    * @param delegator Address of the delegator    * @param amount Amount of tickets staked    */   event TicketsStaked(address indexed delegator, uint256 amount);    ...      /**    * @notice Stake `_amount` of tickets in this contract.    * @dev Tickets can be staked on behalf of a `_to` user.    * @param _to Address to which the stake will be attributed    * @param _amount Amount of tickets to stake    */   function stake(address _to, uint256 _amount) external {     _requireRecipientNotZeroAddress(_to); //@audit See here that the _to is the recipient, not the delegator.     _requireAmountGtZero(_amount);      IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);     _mint(_to, _amount);      emit TicketsStaked(_to, _amount);//@audit the first parameter of TicketsStacked should be delegator, not recipient. Should be msg.sender.   }   ```  ### Incorrect Comment Associated with `transferDelegationTo` The comments above the `transferDelegationTo` function are incorrect. The first line, which begins with `@notice`, says `The tickets are transferred to the caller`. However, the tickets are transfered to the `_to` parameter as can be seen by the line `_transfer(_delegation, _to, _amount);` In addition, the comment directly below that states `Will directly send the tickets to the delegator wallet.` This is also incorrect per the above reason. ```   /**    * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. The tickets are transferred to the caller.    * @dev Will directly send the tickets to the delegator wallet.    * @dev Will revert if delegation is still locked.    * @param _slot Slot of the delegation    * @param _amount Amount to withdraw    * @param _to Account to transfer the withdrawn tickets to    * @return The address of the Delegation    */   function transferDelegationTo(     uint256 _slot,     uint256 _amount,     address _to   ) external returns (Delegation) {     _requireRecipientNotZeroAddress(_to);      Delegation _delegation = Delegation(_computeAddress(msg.sender, _slot));     _transfer(_delegation, _to, _amount);      emit TransferredDelegation(msg.sender, _slot, _amount, _to);      return _delegation;   }   ```   
### Using `bool`s for storage incurs overhead ```     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 ```solidity mapping(address => mapping(address => bool)) internal representatives;          ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L159   ### Functions not called by the contract itself should be `external` rather than `public` ```solidity function initialize(uint96 _lockUntil) public {            ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L29   ### Using `> 0` costs more gas than `!= 0` when used on uints in a `require()` statement ```solidity require(_amount > 0, "TWABDelegator/amount-gt-zero");             ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L601   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### It costs less gas to inline the code of functions that are only called once Doing so saves the cost of allocating the function selector, and the cost of the jump when the function is called. ```solidity   function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), "TWABDelegator/dlgtr-not-zero-adr");   } ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L608-L610   ### Using stack copies of variables when repeated access is required uses less gas Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length. `calls.length` can be cached ```solidity     bytes[] memory response = new bytes[](calls.length);     for (uint256 i = 0; i < calls.length; i++) { ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L41-L42 
# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Foreword](#foreword)   - [Summary](#summary)   - [File: PermitAndMulticall.sol](#file-permitandmulticallsol)     - [function _permitAndMulticall()](#function-_permitandmulticall)       - [Missing `@param _permitToken`](#missing-param-_permittoken)   - [File: TWABDelegator.sol](#file-twabdelegatorsol)     - [event TransferredDelegation()](#event-transferreddelegation)       - [Missing `@param to`](#missing-param-to)     - [function _executeCall()](#function-_executecall)       - [Missing `@return bytes[]`](#missing-return-bytes)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Summary  - Only some missing `@param` and `@return` comments were found as low-risk issues according to C4's scale.  - While `Delegator.sol:initialize()` was found to be front-runnable (but not callable multiple times), the issue was severe enough (due to CREATE2) to be sent separately as a medium-risk issue instead of a low-risk one.  ## File: PermitAndMulticall.sol  ### function _permitAndMulticall()  #### Missing `@param _permitToken`  ``` 39:   /** 40:    * @notice Alow a user to approve ticket and run various calls in one transaction. 41:    * @param _from Address of the sender //@audit missing @param _permitToken 42:    * @param _amount Amount of tickets to approve 43:    * @param _permitSignature Permit signature 44:    * @param _data Datas to call with `functionDelegateCall` 45:    */ 46:   function _permitAndMulticall( 47:     IERC20Permit _permitToken, 48:     address _from, 49:     uint256 _amount, 50:     Signature calldata _permitSignature, 51:     bytes[] calldata _data 52:   ) internal { ```  ## File: TWABDelegator.sol  ### event TransferredDelegation()  #### Missing `@param to`  ``` 125:   /** 126:    * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet. 127:    * @param delegator Address of the delegator 128:    * @param slot  Slot of the delegation 129:    * @param amount Amount of tickets withdrawn //@audit missing @param to 130:    */ 131:   event TransferredDelegation( 132:     address indexed delegator, 133:     uint256 indexed slot, 134:     uint256 amount, 135:     address indexed to 136:   ); ```  ### function _executeCall()  #### Missing `@return bytes[]`  ``` File: TWABDelegator.sol 543:   /** 544:    * @notice Execute a function call on the delegation contract. 545:    * @param _delegation Address of the delegation contract 546:    * @param _data The call data that will be executed //@audit missing @return bytes[] 547:    */ 548:   function _executeCall(Delegation _delegation, bytes memory _data) 549:     internal 550:     returns (bytes[] memory) ``` 
## [G-00] Reduce Runtime Gas With Modifiers  **Severity**: _Gas_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`TWABDelegator.sol`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol)  Multiple `internal` functions in `TWABDelegator` can be turned into modifiers to reduce runtime gas costs at the expense of increasing the deployment cost.  Below, we show the gas costs of internal functions (first image) and using modifiers instead (second image).  ![Gas costs when using internal function calls](https://i.imgur.com/nDbGkhS.png) _Gas costs when using internal function calls_  ![Gas Costs when using Modifiers](https://i.imgur.com/07q5nys.png) _Gas costs when using modifiers_  Functions changed to modifiers to achieve the above results:  - [`_requireDelegatorOrRepresentative(address _delegator)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L577-L586) - [`_requireDelegateeNotZeroAddress(address _delegatee)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L588-L594) - [`_requireAmountGtZero(uint256 _amount)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L596-L602) - [`_requireDelegatorNotZeroAddress(address _delegator)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L604-L610) - [`_requireRecipientNotZeroAddress(address _to)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L612-L618) - [`_requireLockDuration(uint256 _lockDuration)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L636-L642)   **Recommendation**: Change the specified internal functions into modifiers to reduce runtime gas costs at the expense of bytecode bloat (increased deployment costs). This also requires changing their usage into modifier syntax rather than _call_.   ## [G-01] Solmate Port  **Severity**: _Gas_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`contracts/*`](https://github.com/pooltogether/v4-twab-delegator/tree/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts)  **Recommendation**: Port contracts over to using [solmate](https://github.com/Rari-Capital/solmate) to significantly reduce openzeppelin bloat (will require a custom write of ERC20Permit and its interface as well as deterministic cloning (ref: https://github.com/Rari-Capital/vaults)).   ## [I-00] Inconsistent Licensing  **Severity**: _Informational_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`contracts/*`](https://github.com/pooltogether/v4-twab-delegator/tree/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts)  `Delegation.sol` has SPDX Identifier: `// SPDX-License-Identifier: MIT` `LowLevelDelegator.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0` `PermitAndMulticall.sol` has SPDX Identifier: `// SPDX-License-Identifier: MIT` `TWABDelegator.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0`  `test/TWABDelegatorHarness.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0`  **Recommendation**: Coalesce SPDX License Identifiers into one canonical license unless necessary.  
# Lines of code  https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L46-L64 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L31-L37 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L438-L445   # Vulnerability details  ## Impact  When the `_from` address is not the `msg.sender` `_multiCall()` will be made on behalf of the `msg.sender`. As a result each of the functions called by `multiCall()` will be made on behalf of `msg.sender` and not `_from`.  If functions such as `transfer()` or `unstake()` are called `msg.sender` will be the original caller which would transfer the attacker the funds if the `to` field is set to an attackers address.  Furthermore, if an attacker we to call `permitAndMulticall()` before the `_from` user they may use their signature and nonce combination. As a nonce is only allowe to be used once the siganture will no longer be valid and `_permitToken.permit()` will fail on the second call.  An attacker may use this as a Denial of Service (DoS) attack by continually front-running `permitAndCall()` using other users signatures.  ## Proof of Concept  ```   function _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {     results = new bytes[](_data.length);     for (uint256 i = 0; i < _data.length; i++) {       results[i] = Address.functionDelegateCall(address(this), _data[i]);     }     return results;   } ```  ```   function _permitAndMulticall(     IERC20Permit _permitToken,     address _from,     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) internal {     _permitToken.permit(       _from,       address(this),       _amount,       _permitSignature.deadline,       _permitSignature.v,       _permitSignature.r,       _permitSignature.s     );      _multicall(_data);   } ```  ## Recommended Mitigation Steps  Consider updating the `_from` field to be the `msg.sender` in `permitAndMulticall()` (or alternatively do this in `_permitAndMulticall()` to save some gas).  ```   function permitAndMulticall(     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) external {     _permitAndMulticall(IERC20Permit(address(ticket)), msg.sender, _amount, _permitSignature, _data);   } ```  
# Codebase Impressions & Summary  Overall, code quality for the TWABDelegator contracts is very high. Functions were well commented and ordered in visibility level, and the documentation provided made it easy to understand the intended functionality.  The test suite could be easily run. Almost 100% test coverage is achieved, where only the `Delegation` contract lacked branch coverage for a couple of edge cases.  The findings I made only involved incorrect comments for a function and couple of events.  # Low Severity Findings  ## L01: Incorrect comment on `transferDelegationTo()`  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L370-L371](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L370-L371)  ### Description  The comments say that the withdrawn tickets are transferred to the caller / delegator wallet, but are actually transferred to the `_to` address.  ### Recommended Mitigation Steps  ```jsx * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. * @dev Tickets are sent directly to the passed `_to` address ```  ## L02: Incorrect comment on `TransferredDelegation` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L125-L136](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L125-L136)  ### Description  In relation to L01, the `TransferredDelegation` event  - is incorrectly commented that the withdrawn tickets are transferred to the caller / delegator wallet - lacks a description about the `to` indexed parameter.  ### Recommended Mitigation Steps  ```jsx /**  * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to a specified wallet.  * @param delegator Address of the delegator  * @param slot  Slot of the delegation  * @param amount Amount of tickets withdrawn  * @param to Recipient address of withdrawn tickets  */   event TransferredDelegation(     address indexed delegator,     uint256 indexed slot,     uint256 amount,     address indexed to   ); ```  ## L03: Incorrect comment on `DelegationFundedFromStake` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L102](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L102)  ### Description  The `DelegationFundedFromStake()` allows a representative or delegator himself to fund a delegation contract using the delegator’s stake. The `user` in the `DelegationFundedFromStake` event refers to `msg.sender`. Since the funds are coming solely from the delegator, its description isn’t entirely correct.  ### Recommended Mitigation Steps  `@param user Address of the user who pulled funds from the delegator to the delegation`  # Non-Critical Findings  ## NC01: Extra whitespace in slot description of `WithdrewDelegationToStake()` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114)  ### Description  There is an additional spacing between `slot` and `Slot`.  ### Recommended Mitigation Steps  Remove the spacing to become: `* @param slot Slot of the delegation`  # Suggestions  ## S01: TWABDelegator: Consider renaming `_delegateCall()` to `_setDelegateeCall()`  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L519](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L519)  ### Description  `_delegateCall()` could easily be confused for the inbuilt `delegatecall()` method. I recommend renaming it to something more distinguishable like `_setDelegateeCall()`.
Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          TWABDelegator.sol, _computeLockUntil         TWABDelegator.sol, _requireDelegateeNotZeroAddress         TWABDelegator.sol, _executeCall         TWABDelegator.sol, _transfer         TWABDelegator.sol, _requireContract         TWABDelegator.sol, _computeAddress         TWABDelegator.sol, _requireAmountGtZero         TWABDelegator.sol, _requireDelegatorNotZeroAddress         LowLevelDelegator.sol, _computeAddress         TWABDelegator.sol, _transferCall         TWABDelegator.sol, _requireRecipientNotZeroAddress         PermitAndMulticall.sol, _permitAndMulticall         TWABDelegator.sol, _requireDelegationUnlocked         TWABDelegator.sol, _requireLockDuration         TWABDelegator.sol, _requireDelegatorOrRepresentative         LowLevelDelegator.sol, _createDelegation         PermitAndMulticall.sol, _multicall         TWABDelegator.sol, _delegateCall         LowLevelDelegator.sol, _computeSalt         Delegation.sol, _executeCall    Title: Unnecessary equals boolean Severity: GAS   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.          TWABDelegator.sol, 583: _delegator == msg.sender || representatives[_delegator][msg.sender] == true,    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           delegationInstance in LowLevelDelegator.sol    Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               Delegation.sol.executeCalls - double load of calls[i]    Title: Unnecessary functions Severity: GAS       The following functions are not used at all. Therefore you can remove them to save deployment gas and improve code clearness.                   LowLevelDelegator.sol, _createDelegation         LowLevelDelegator.sol, _computeSalt         PermitAndMulticall.sol, _permitAndMulticall         LowLevelDelegator.sol, _computeAddress    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           Delegation.sol, calls, 42         PermitAndMulticall.sol, _data, 33    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          PermitAndMulticall.sol, line 4, import "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol";    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: Delegation.sol, i, 42         change to prefix increment and unchecked: PermitAndMulticall.sol, i, 33    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               TWABDelegator.sol, _computeLockUntil, { return uint96(block.timestamp) + _lockDuration; }         LowLevelDelegator.sol, _computeSalt, { return keccak256(abi.encodePacked(_delegator, _slot)); }         TWABDelegator.sol, _computeAddress, { return _computeAddress(_computeSalt(_delegator, bytes32(_slot))); }         LowLevelDelegator.sol, _computeAddress, { return address(delegationInstance).predictDeterministicAddress(_salt, address(this)); }    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           Delegation.sol, initialize    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               TWABDelegator.constructor (name_)         TWABDelegator.constructor (symbol_)         Delegation._executeCall (data)         TWABDelegator._executeCall (_data)    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               TWABDelegator.sol, _transferCall         PermitAndMulticall.sol, _multicall         TWABDelegator.sol, _requireDelegatorNotZeroAddress         Delegation.sol, _executeCall    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          PermitAndMulticall.sol, 33         Delegation.sol, 42    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          TWABDelegator.sol (L#511) - return uint96(block.timestamp) + _lockDuration;    Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TWABDelegator.sol, In line 582, Require message length to shorten: 34, The message: TWABDelegator/not-delegator-or-rep    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           TWABDelegator.sol, 273: change '_lockDuration > 0' to '_lockDuration != 0'         TWABDelegator.sol, 601: change '_amount > 0' to '_amount != 0' 
  Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       TWABDelegator.sol.permitAndMulticall _from         Delegation.sol._executeCall to         PermitAndMulticall.sol._permitAndMulticall _from         TWABDelegator.sol.stake _to         TWABDelegator.sol._requireDelegateeNotZeroAddress _delegatee         TWABDelegator.sol.setRepresentative _representative         TWABDelegator.sol._computeAddress _delegator         TWABDelegator.sol._requireDelegatorNotZeroAddress _delegator         TWABDelegator.sol.updateDelegatee _delegatee         TWABDelegator.sol.isRepresentativeOf _delegator         TWABDelegator.sol._transfer _to         TWABDelegator.sol._requireContract _address         TWABDelegator.sol._transferCall _to         LowLevelDelegator.sol._computeSalt _delegator         TWABDelegator.sol.createDelegation _delegatee         TWABDelegator.sol.transferDelegationTo _to         TWABDelegator.sol.unstake _to         TWABDelegator.sol.computeDelegationAddress _delegator         TWABDelegator.sol.fundDelegation _delegator         TWABDelegator.sol.isRepresentativeOf _representative         TWABDelegator.sol._delegateCall _delegatee         TWABDelegator.sol.getDelegation _delegator         TWABDelegator.sol._requireRecipientNotZeroAddress _to    Title: Named return issue Severity: Low Risk  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           TWABDelegator.sol, multicall         PermitAndMulticall.sol, _multicall    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           Delegation.sol: function _executeCall parameter value isn't used. (_executeCall is internal)         TWABDelegator.sol: function _executeCall parameter _data isn't used. (_executeCall is internal)         Delegation.sol: function _executeCall parameter data isn't used. (_executeCall is internal)         Delegation.sol: function _executeCall parameter to isn't used. (_executeCall is internal)    Title: Mult instead div in compares Severity: Low Risk       To improve algorithm precision instead using division in comparison use multiplication in the following scenario:                          Instead a < b / c use a * c < b.               In all of the big and trusted contracts this rule is maintained.              TWABDelegator.sol, 625, require(block.timestamp >= _delegation.lockUntil(), "TWABDelegator/delegation-locked");         TWABDelegator.sol, 601, require(_amount > 0, "TWABDelegator/amount-gt-zero");         TWABDelegator.sol, 641, require(_lockDuration <= MAX_LOCK, "TWABDelegator/lock-too-long");    Title: Override function but with different argument location Severity: Low/Med Risk                     TWABDelegator.sol._computeAddress inherent LowLevelDelegator.sol._computeAddress but the parameters does not match         TWABDelegator.sol.constructor inherent LowLevelDelegator.sol.constructor but the parameters does not match 
# Low and Non-critical ## tickets can get locked if a user calls `transferDelegationTo` with the address of the `TWABDelegator` contract as the `to` parameter, the tokens will be transferred to the address without minting the user the stake token, so maybe you can think of adding this functionality. I know that there is the `withdrawDelegationToStake` function for that, but that can be nice to enable it that way too.
# Gas Optimizations ## Loop in `Delegation` and `PermitAndMulticall` contracts Loops can be optimized in several ways. Let's take for example the loop in the `executeCalls` function of the `Delegation` contract. ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   for (uint256 i = 0; i < calls.length; i++) {     response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);   }   return response; } ``` To optimize this loop and make it consume less gas, we can do the foloowing things: 1. Use ++i instead of i++, which is a cheaper operation (in this case there is no difference between i++ and ++i because we dont use the return value of this expression, which is the only difference between these two expression). 2. Save the `calls` array length in a local variable instead of accessing it in every iteration. 3. Save `calls[i]` in a local variable instead of accessing it 3 times in every iteration. This will save accssing the array's ith element 3 times in every iteration ,which requires an address calculation. 4. There's no need to initialize i to its default value, it will be done automatically and it will consume more gas if it will be done (I know, sounds stupid, but trust me - it works). So after applying all these changes, the loop will look something like this: ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   uint256 length = calls.length;   Call memory call;   for (uint256 i; i < length; ++i) {     call = calls[i];     response[i] = _executeCall(call.to, call.value, call.data);   }   return response; } ```  ## Inline all these little functions Defining all these little functions cause 2 things: 1. contract's code size gets bigger 2. the function calls consumes more gas than exectuing it as an inlined function (part of the code, without the function call) So in order to save gas, I would reccomend to inline these functions.  ```sol   function _computeAddress(address _delegator, uint256 _slot) internal view returns (address) {     return _computeAddress(_computeSalt(_delegator, bytes32(_slot)));   }    function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {     return uint96(block.timestamp) + _lockDuration;   }    function _requireDelegatorOrRepresentative(address _delegator) internal view {     require(       _delegator == msg.sender || representatives[_delegator][msg.sender] == true,       "TWABDelegator/not-delegator-or-rep"     );   }    function _requireDelegateeNotZeroAddress(address _delegatee) internal pure {     require(_delegatee != address(0), "TWABDelegator/dlgt-not-zero-adr");   }    function _requireAmountGtZero(uint256 _amount) internal pure {     require(_amount > 0, "TWABDelegator/amount-gt-zero");   }    function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), "TWABDelegator/dlgtr-not-zero-adr");   }    function _requireRecipientNotZeroAddress(address _to) internal pure {     require(_to != address(0), "TWABDelegator/to-not-zero-addr");   }    function _requireDelegationUnlocked(Delegation _delegation) internal view {     require(block.timestamp >= _delegation.lockUntil(), "TWABDelegator/delegation-locked");   }    function _requireContract(address _address) internal view {     require(_address.isContract(), "TWABDelegator/not-a-contract");   }    function _requireLockDuration(uint256 _lockDuration) internal pure {     require(_lockDuration <= MAX_LOCK, "TWABDelegator/lock-too-long");   } ```
## Gas Optimizations  ### Unchecked math will save on gas ```   function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {     return uint96(block.timestamp) + _lockDuration; //@audit Gas Optimization Unchecked   } ``` The `_computeLockUntil` function in `TWABDelegator.sol` can be optimized by adding the `unchecked` directive as this will never overflow the `uint96` type since it is limited by the `MAX_LOCK` constant (which is currently assigned to 180 days() by the call to `_requireLockDuration(_lockDuration);`. ``` justin@Stealth: 18362 » frf test.sol compiling... Compiling 2 files with 0.8.12 Compilation finished successfully success. Script ran successfully. Gas Used: 5401 == Logs ==  180 days, 15552000 Current timestamp, 1645633955 Current timestamp + 5000 years, 159325633955 Max uint96, 79228162514264337593543950335  ```  ### Unneeded Zero Address Check In the `stake` function of the `TWABDelegator.sol` file, the `_requireRecipientNotZeroAddress` function is called on the `_to` parameter. However, this is unnecessary since the `_mint` function checks for the zero address when called. As such, it would be more gas efficient to not perform this call. ```  function stake(address _to, uint256 _amount) external {     _requireRecipientNotZeroAddress(_to);     //@audit Gas Optimization Above is unneeded since _mint checks whether _to is zero addr or not     _requireAmountGtZero(_amount);      IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);     _mint(_to, _amount); ```   ### More efficient order of operations in `updateDelegatee` In the `updateDelegatee` function of the `TWABDelegator.sol` file the `_lockUntil` variable is defined by calling the `_computeLockUntil` function. However, if the `_lockDuration` is 0, then this value is the same as the current `block.timestamp`. As a result, the following code would be an optimization:  Original Code: ``` uint96 _lockUntil = _computeLockUntil(_lockDuration); //@audit Gas Optimization  if (_lockDuration > 0) {     _delegation.setLockUntil(_lockUntil); }  _delegateCall(_delegation, _delegatee);  emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender); ```  Optimized Code: ``` uint96 _lockUntil = block.timestamp; if (_lockDuration > 0) {     _lockUntil = _computeLockUntil(_lockDuration);     _delegation.setLockUntil(_lockUntil); } _delegateCall(_delegation, _delegatee); emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender); ```  Here are the tests with the optimizations (* indicates Optimized case): ``` ·························|·····························|·············|·············|··············|···············|·············· |  Contract              ·  Method                     ·  Min        ·  Max        ·  Avg         ·  # calls      ·  usd (avg)  │ ·························|·····························|·············|·············|··············|···············|·············· |  TWABDelegatorHarness  ·  updateDelegatee            ·     140113  ·     144124  ·      141911  ·            7  ·          -  │ ·························|·····························|·············|·············|··············|···············|·············· |  *TWABDelegatorHarness ·  updateDelegatee            ·     139965  ·     144126  ·      141806  ·            7  ·          -  │ ·························|·····························|·············|·············|··············|···············|·············· ```   ## Non-Critcal   ### Missing comment for the `to` parameter There is no comment on the `to` parameter for the `TransferredDelegation` event in the `TWABDelegator.sol` file. ```   /**    * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet.    * @param delegator Address of the delegator    * @param slot  Slot of the delegation    * @param amount Amount of tickets withdrawn    */    //@audit Missing comment for the `to` parameter   event TransferredDelegation(     address indexed delegator,     uint256 indexed slot,     uint256 amount,     address indexed to   );   ```     ## Low    ### Incorrect Event Parameters   The `TWABDelegator.sol`'s `TicketsStaked` event's first parameter should be the delegator, as such, it should be `msg.sender` not `_to` as `_to` is the recipient.   ```     /**    * @notice Emitted when tickets have been staked.    * @param delegator Address of the delegator    * @param amount Amount of tickets staked    */   event TicketsStaked(address indexed delegator, uint256 amount);    ...      /**    * @notice Stake `_amount` of tickets in this contract.    * @dev Tickets can be staked on behalf of a `_to` user.    * @param _to Address to which the stake will be attributed    * @param _amount Amount of tickets to stake    */   function stake(address _to, uint256 _amount) external {     _requireRecipientNotZeroAddress(_to); //@audit See here that the _to is the recipient, not the delegator.     _requireAmountGtZero(_amount);      IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);     _mint(_to, _amount);      emit TicketsStaked(_to, _amount);//@audit the first parameter of TicketsStacked should be delegator, not recipient. Should be msg.sender.   }   ```  ### Incorrect Comment Associated with `transferDelegationTo` The comments above the `transferDelegationTo` function are incorrect. The first line, which begins with `@notice`, says `The tickets are transferred to the caller`. However, the tickets are transfered to the `_to` parameter as can be seen by the line `_transfer(_delegation, _to, _amount);` In addition, the comment directly below that states `Will directly send the tickets to the delegator wallet.` This is also incorrect per the above reason. ```   /**    * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. The tickets are transferred to the caller.    * @dev Will directly send the tickets to the delegator wallet.    * @dev Will revert if delegation is still locked.    * @param _slot Slot of the delegation    * @param _amount Amount to withdraw    * @param _to Account to transfer the withdrawn tickets to    * @return The address of the Delegation    */   function transferDelegationTo(     uint256 _slot,     uint256 _amount,     address _to   ) external returns (Delegation) {     _requireRecipientNotZeroAddress(_to);      Delegation _delegation = Delegation(_computeAddress(msg.sender, _slot));     _transfer(_delegation, _to, _amount);      emit TransferredDelegation(msg.sender, _slot, _amount, _to);      return _delegation;   }   ```   
### Using `bool`s for storage incurs overhead ```     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 ```solidity mapping(address => mapping(address => bool)) internal representatives;          ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L159   ### Functions not called by the contract itself should be `external` rather than `public` ```solidity function initialize(uint96 _lockUntil) public {            ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L29   ### Using `> 0` costs more gas than `!= 0` when used on uints in a `require()` statement ```solidity require(_amount > 0, "TWABDelegator/amount-gt-zero");             ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L601   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### It costs less gas to inline the code of functions that are only called once Doing so saves the cost of allocating the function selector, and the cost of the jump when the function is called. ```solidity   function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), "TWABDelegator/dlgtr-not-zero-adr");   } ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L608-L610   ### Using stack copies of variables when repeated access is required uses less gas Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length. `calls.length` can be cached ```solidity     bytes[] memory response = new bytes[](calls.length);     for (uint256 i = 0; i < calls.length; i++) { ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L41-L42 
# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Foreword](#foreword)   - [Summary](#summary)   - [File: PermitAndMulticall.sol](#file-permitandmulticallsol)     - [function _permitAndMulticall()](#function-_permitandmulticall)       - [Missing `@param _permitToken`](#missing-param-_permittoken)   - [File: TWABDelegator.sol](#file-twabdelegatorsol)     - [event TransferredDelegation()](#event-transferreddelegation)       - [Missing `@param to`](#missing-param-to)     - [function _executeCall()](#function-_executecall)       - [Missing `@return bytes[]`](#missing-return-bytes)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Summary  - Only some missing `@param` and `@return` comments were found as low-risk issues according to C4's scale.  - While `Delegator.sol:initialize()` was found to be front-runnable (but not callable multiple times), the issue was severe enough (due to CREATE2) to be sent separately as a medium-risk issue instead of a low-risk one.  ## File: PermitAndMulticall.sol  ### function _permitAndMulticall()  #### Missing `@param _permitToken`  ``` 39:   /** 40:    * @notice Alow a user to approve ticket and run various calls in one transaction. 41:    * @param _from Address of the sender //@audit missing @param _permitToken 42:    * @param _amount Amount of tickets to approve 43:    * @param _permitSignature Permit signature 44:    * @param _data Datas to call with `functionDelegateCall` 45:    */ 46:   function _permitAndMulticall( 47:     IERC20Permit _permitToken, 48:     address _from, 49:     uint256 _amount, 50:     Signature calldata _permitSignature, 51:     bytes[] calldata _data 52:   ) internal { ```  ## File: TWABDelegator.sol  ### event TransferredDelegation()  #### Missing `@param to`  ``` 125:   /** 126:    * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet. 127:    * @param delegator Address of the delegator 128:    * @param slot  Slot of the delegation 129:    * @param amount Amount of tickets withdrawn //@audit missing @param to 130:    */ 131:   event TransferredDelegation( 132:     address indexed delegator, 133:     uint256 indexed slot, 134:     uint256 amount, 135:     address indexed to 136:   ); ```  ### function _executeCall()  #### Missing `@return bytes[]`  ``` File: TWABDelegator.sol 543:   /** 544:    * @notice Execute a function call on the delegation contract. 545:    * @param _delegation Address of the delegation contract 546:    * @param _data The call data that will be executed //@audit missing @return bytes[] 547:    */ 548:   function _executeCall(Delegation _delegation, bytes memory _data) 549:     internal 550:     returns (bytes[] memory) ``` 
## [G-00] Reduce Runtime Gas With Modifiers  **Severity**: _Gas_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`TWABDelegator.sol`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol)  Multiple `internal` functions in `TWABDelegator` can be turned into modifiers to reduce runtime gas costs at the expense of increasing the deployment cost.  Below, we show the gas costs of internal functions (first image) and using modifiers instead (second image).  ![Gas costs when using internal function calls](https://i.imgur.com/nDbGkhS.png) _Gas costs when using internal function calls_  ![Gas Costs when using Modifiers](https://i.imgur.com/07q5nys.png) _Gas costs when using modifiers_  Functions changed to modifiers to achieve the above results:  - [`_requireDelegatorOrRepresentative(address _delegator)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L577-L586) - [`_requireDelegateeNotZeroAddress(address _delegatee)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L588-L594) - [`_requireAmountGtZero(uint256 _amount)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L596-L602) - [`_requireDelegatorNotZeroAddress(address _delegator)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L604-L610) - [`_requireRecipientNotZeroAddress(address _to)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L612-L618) - [`_requireLockDuration(uint256 _lockDuration)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L636-L642)   **Recommendation**: Change the specified internal functions into modifiers to reduce runtime gas costs at the expense of bytecode bloat (increased deployment costs). This also requires changing their usage into modifier syntax rather than _call_.   ## [G-01] Solmate Port  **Severity**: _Gas_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`contracts/*`](https://github.com/pooltogether/v4-twab-delegator/tree/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts)  **Recommendation**: Port contracts over to using [solmate](https://github.com/Rari-Capital/solmate) to significantly reduce openzeppelin bloat (will require a custom write of ERC20Permit and its interface as well as deterministic cloning (ref: https://github.com/Rari-Capital/vaults)).   ## [I-00] Inconsistent Licensing  **Severity**: _Informational_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`contracts/*`](https://github.com/pooltogether/v4-twab-delegator/tree/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts)  `Delegation.sol` has SPDX Identifier: `// SPDX-License-Identifier: MIT` `LowLevelDelegator.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0` `PermitAndMulticall.sol` has SPDX Identifier: `// SPDX-License-Identifier: MIT` `TWABDelegator.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0`  `test/TWABDelegatorHarness.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0`  **Recommendation**: Coalesce SPDX License Identifiers into one canonical license unless necessary.  
# Lines of code  https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L46-L64 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L31-L37 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L438-L445   # Vulnerability details  ## Impact  When the `_from` address is not the `msg.sender` `_multiCall()` will be made on behalf of the `msg.sender`. As a result each of the functions called by `multiCall()` will be made on behalf of `msg.sender` and not `_from`.  If functions such as `transfer()` or `unstake()` are called `msg.sender` will be the original caller which would transfer the attacker the funds if the `to` field is set to an attackers address.  Furthermore, if an attacker we to call `permitAndMulticall()` before the `_from` user they may use their signature and nonce combination. As a nonce is only allowe to be used once the siganture will no longer be valid and `_permitToken.permit()` will fail on the second call.  An attacker may use this as a Denial of Service (DoS) attack by continually front-running `permitAndCall()` using other users signatures.  ## Proof of Concept  ```   function _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {     results = new bytes[](_data.length);     for (uint256 i = 0; i < _data.length; i++) {       results[i] = Address.functionDelegateCall(address(this), _data[i]);     }     return results;   } ```  ```   function _permitAndMulticall(     IERC20Permit _permitToken,     address _from,     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) internal {     _permitToken.permit(       _from,       address(this),       _amount,       _permitSignature.deadline,       _permitSignature.v,       _permitSignature.r,       _permitSignature.s     );      _multicall(_data);   } ```  ## Recommended Mitigation Steps  Consider updating the `_from` field to be the `msg.sender` in `permitAndMulticall()` (or alternatively do this in `_permitAndMulticall()` to save some gas).  ```   function permitAndMulticall(     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) external {     _permitAndMulticall(IERC20Permit(address(ticket)), msg.sender, _amount, _permitSignature, _data);   } ```  
# Codebase Impressions & Summary  Overall, code quality for the TWABDelegator contracts is very high. Functions were well commented and ordered in visibility level, and the documentation provided made it easy to understand the intended functionality.  The test suite could be easily run. Almost 100% test coverage is achieved, where only the `Delegation` contract lacked branch coverage for a couple of edge cases.  The findings I made only involved incorrect comments for a function and couple of events.  # Low Severity Findings  ## L01: Incorrect comment on `transferDelegationTo()`  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L370-L371](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L370-L371)  ### Description  The comments say that the withdrawn tickets are transferred to the caller / delegator wallet, but are actually transferred to the `_to` address.  ### Recommended Mitigation Steps  ```jsx * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. * @dev Tickets are sent directly to the passed `_to` address ```  ## L02: Incorrect comment on `TransferredDelegation` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L125-L136](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L125-L136)  ### Description  In relation to L01, the `TransferredDelegation` event  - is incorrectly commented that the withdrawn tickets are transferred to the caller / delegator wallet - lacks a description about the `to` indexed parameter.  ### Recommended Mitigation Steps  ```jsx /**  * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to a specified wallet.  * @param delegator Address of the delegator  * @param slot  Slot of the delegation  * @param amount Amount of tickets withdrawn  * @param to Recipient address of withdrawn tickets  */   event TransferredDelegation(     address indexed delegator,     uint256 indexed slot,     uint256 amount,     address indexed to   ); ```  ## L03: Incorrect comment on `DelegationFundedFromStake` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L102](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L102)  ### Description  The `DelegationFundedFromStake()` allows a representative or delegator himself to fund a delegation contract using the delegator’s stake. The `user` in the `DelegationFundedFromStake` event refers to `msg.sender`. Since the funds are coming solely from the delegator, its description isn’t entirely correct.  ### Recommended Mitigation Steps  `@param user Address of the user who pulled funds from the delegator to the delegation`  # Non-Critical Findings  ## NC01: Extra whitespace in slot description of `WithdrewDelegationToStake()` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114)  ### Description  There is an additional spacing between `slot` and `Slot`.  ### Recommended Mitigation Steps  Remove the spacing to become: `* @param slot Slot of the delegation`  # Suggestions  ## S01: TWABDelegator: Consider renaming `_delegateCall()` to `_setDelegateeCall()`  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L519](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L519)  ### Description  `_delegateCall()` could easily be confused for the inbuilt `delegatecall()` method. I recommend renaming it to something more distinguishable like `_setDelegateeCall()`.
Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          TWABDelegator.sol, _computeLockUntil         TWABDelegator.sol, _requireDelegateeNotZeroAddress         TWABDelegator.sol, _executeCall         TWABDelegator.sol, _transfer         TWABDelegator.sol, _requireContract         TWABDelegator.sol, _computeAddress         TWABDelegator.sol, _requireAmountGtZero         TWABDelegator.sol, _requireDelegatorNotZeroAddress         LowLevelDelegator.sol, _computeAddress         TWABDelegator.sol, _transferCall         TWABDelegator.sol, _requireRecipientNotZeroAddress         PermitAndMulticall.sol, _permitAndMulticall         TWABDelegator.sol, _requireDelegationUnlocked         TWABDelegator.sol, _requireLockDuration         TWABDelegator.sol, _requireDelegatorOrRepresentative         LowLevelDelegator.sol, _createDelegation         PermitAndMulticall.sol, _multicall         TWABDelegator.sol, _delegateCall         LowLevelDelegator.sol, _computeSalt         Delegation.sol, _executeCall    Title: Unnecessary equals boolean Severity: GAS   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.          TWABDelegator.sol, 583: _delegator == msg.sender || representatives[_delegator][msg.sender] == true,    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           delegationInstance in LowLevelDelegator.sol    Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               Delegation.sol.executeCalls - double load of calls[i]    Title: Unnecessary functions Severity: GAS       The following functions are not used at all. Therefore you can remove them to save deployment gas and improve code clearness.                   LowLevelDelegator.sol, _createDelegation         LowLevelDelegator.sol, _computeSalt         PermitAndMulticall.sol, _permitAndMulticall         LowLevelDelegator.sol, _computeAddress    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           Delegation.sol, calls, 42         PermitAndMulticall.sol, _data, 33    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          PermitAndMulticall.sol, line 4, import "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol";    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: Delegation.sol, i, 42         change to prefix increment and unchecked: PermitAndMulticall.sol, i, 33    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               TWABDelegator.sol, _computeLockUntil, { return uint96(block.timestamp) + _lockDuration; }         LowLevelDelegator.sol, _computeSalt, { return keccak256(abi.encodePacked(_delegator, _slot)); }         TWABDelegator.sol, _computeAddress, { return _computeAddress(_computeSalt(_delegator, bytes32(_slot))); }         LowLevelDelegator.sol, _computeAddress, { return address(delegationInstance).predictDeterministicAddress(_salt, address(this)); }    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           Delegation.sol, initialize    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               TWABDelegator.constructor (name_)         TWABDelegator.constructor (symbol_)         Delegation._executeCall (data)         TWABDelegator._executeCall (_data)    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               TWABDelegator.sol, _transferCall         PermitAndMulticall.sol, _multicall         TWABDelegator.sol, _requireDelegatorNotZeroAddress         Delegation.sol, _executeCall    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          PermitAndMulticall.sol, 33         Delegation.sol, 42    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          TWABDelegator.sol (L#511) - return uint96(block.timestamp) + _lockDuration;    Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TWABDelegator.sol, In line 582, Require message length to shorten: 34, The message: TWABDelegator/not-delegator-or-rep    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           TWABDelegator.sol, 273: change '_lockDuration > 0' to '_lockDuration != 0'         TWABDelegator.sol, 601: change '_amount > 0' to '_amount != 0' 
  Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       TWABDelegator.sol.permitAndMulticall _from         Delegation.sol._executeCall to         PermitAndMulticall.sol._permitAndMulticall _from         TWABDelegator.sol.stake _to         TWABDelegator.sol._requireDelegateeNotZeroAddress _delegatee         TWABDelegator.sol.setRepresentative _representative         TWABDelegator.sol._computeAddress _delegator         TWABDelegator.sol._requireDelegatorNotZeroAddress _delegator         TWABDelegator.sol.updateDelegatee _delegatee         TWABDelegator.sol.isRepresentativeOf _delegator         TWABDelegator.sol._transfer _to         TWABDelegator.sol._requireContract _address         TWABDelegator.sol._transferCall _to         LowLevelDelegator.sol._computeSalt _delegator         TWABDelegator.sol.createDelegation _delegatee         TWABDelegator.sol.transferDelegationTo _to         TWABDelegator.sol.unstake _to         TWABDelegator.sol.computeDelegationAddress _delegator         TWABDelegator.sol.fundDelegation _delegator         TWABDelegator.sol.isRepresentativeOf _representative         TWABDelegator.sol._delegateCall _delegatee         TWABDelegator.sol.getDelegation _delegator         TWABDelegator.sol._requireRecipientNotZeroAddress _to    Title: Named return issue Severity: Low Risk  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           TWABDelegator.sol, multicall         PermitAndMulticall.sol, _multicall    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           Delegation.sol: function _executeCall parameter value isn't used. (_executeCall is internal)         TWABDelegator.sol: function _executeCall parameter _data isn't used. (_executeCall is internal)         Delegation.sol: function _executeCall parameter data isn't used. (_executeCall is internal)         Delegation.sol: function _executeCall parameter to isn't used. (_executeCall is internal)    Title: Mult instead div in compares Severity: Low Risk       To improve algorithm precision instead using division in comparison use multiplication in the following scenario:                          Instead a < b / c use a * c < b.               In all of the big and trusted contracts this rule is maintained.              TWABDelegator.sol, 625, require(block.timestamp >= _delegation.lockUntil(), "TWABDelegator/delegation-locked");         TWABDelegator.sol, 601, require(_amount > 0, "TWABDelegator/amount-gt-zero");         TWABDelegator.sol, 641, require(_lockDuration <= MAX_LOCK, "TWABDelegator/lock-too-long");    Title: Override function but with different argument location Severity: Low/Med Risk                     TWABDelegator.sol._computeAddress inherent LowLevelDelegator.sol._computeAddress but the parameters does not match         TWABDelegator.sol.constructor inherent LowLevelDelegator.sol.constructor but the parameters does not match 
# Low and Non-critical ## tickets can get locked if a user calls `transferDelegationTo` with the address of the `TWABDelegator` contract as the `to` parameter, the tokens will be transferred to the address without minting the user the stake token, so maybe you can think of adding this functionality. I know that there is the `withdrawDelegationToStake` function for that, but that can be nice to enable it that way too.
# Gas Optimizations ## Loop in `Delegation` and `PermitAndMulticall` contracts Loops can be optimized in several ways. Let's take for example the loop in the `executeCalls` function of the `Delegation` contract. ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   for (uint256 i = 0; i < calls.length; i++) {     response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);   }   return response; } ``` To optimize this loop and make it consume less gas, we can do the foloowing things: 1. Use ++i instead of i++, which is a cheaper operation (in this case there is no difference between i++ and ++i because we dont use the return value of this expression, which is the only difference between these two expression). 2. Save the `calls` array length in a local variable instead of accessing it in every iteration. 3. Save `calls[i]` in a local variable instead of accessing it 3 times in every iteration. This will save accssing the array's ith element 3 times in every iteration ,which requires an address calculation. 4. There's no need to initialize i to its default value, it will be done automatically and it will consume more gas if it will be done (I know, sounds stupid, but trust me - it works). So after applying all these changes, the loop will look something like this: ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   uint256 length = calls.length;   Call memory call;   for (uint256 i; i < length; ++i) {     call = calls[i];     response[i] = _executeCall(call.to, call.value, call.data);   }   return response; } ```  ## Inline all these little functions Defining all these little functions cause 2 things: 1. contract's code size gets bigger 2. the function calls consumes more gas than exectuing it as an inlined function (part of the code, without the function call) So in order to save gas, I would reccomend to inline these functions.  ```sol   function _computeAddress(address _delegator, uint256 _slot) internal view returns (address) {     return _computeAddress(_computeSalt(_delegator, bytes32(_slot)));   }    function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {     return uint96(block.timestamp) + _lockDuration;   }    function _requireDelegatorOrRepresentative(address _delegator) internal view {     require(       _delegator == msg.sender || representatives[_delegator][msg.sender] == true,       "TWABDelegator/not-delegator-or-rep"     );   }    function _requireDelegateeNotZeroAddress(address _delegatee) internal pure {     require(_delegatee != address(0), "TWABDelegator/dlgt-not-zero-adr");   }    function _requireAmountGtZero(uint256 _amount) internal pure {     require(_amount > 0, "TWABDelegator/amount-gt-zero");   }    function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), "TWABDelegator/dlgtr-not-zero-adr");   }    function _requireRecipientNotZeroAddress(address _to) internal pure {     require(_to != address(0), "TWABDelegator/to-not-zero-addr");   }    function _requireDelegationUnlocked(Delegation _delegation) internal view {     require(block.timestamp >= _delegation.lockUntil(), "TWABDelegator/delegation-locked");   }    function _requireContract(address _address) internal view {     require(_address.isContract(), "TWABDelegator/not-a-contract");   }    function _requireLockDuration(uint256 _lockDuration) internal pure {     require(_lockDuration <= MAX_LOCK, "TWABDelegator/lock-too-long");   } ```
