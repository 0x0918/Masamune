# Handle  shw   # Vulnerability details  ## Impact  In contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.  ## Proof of Concept  Referenced code: [MPHMinter.sol#L121](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/rewards/MPHMinter.sol#L121) [DInterest.sol#L1253](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1253) [DInterest.sol#L1420](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1420)  ## Tools Used  None  ## Recommended Mitigation Steps  Add a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).  
# Handle  a_delamo   # Vulnerability details  ## Impact  In `Sponsorable.sol` is using erecover directly to verify the signature. Being such a critical piece of the protocol, I would recommend using the ECDSA from openzeppelin as it does more validations when verifying the signature.   ```  // Currently   address recoveredAddress =       ecrecover(digest, sponsorship.v, sponsorship.r, sponsorship.s);     require(       recoveredAddress != address(0) && recoveredAddress == sponsorship.sender,       "Sponsorable: invalid sig"     );     //ECDSA     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most         // signatures from current libraries generate a unique signature with an s-value in the lower half order.         //         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept         // these malleable signatures as well.         require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");         require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");          // If the signature is valid (and not malleable), return the signer address         address signer = ecrecover(hash, v, r, s);         require(signer != address(0), "ECDSA: invalid signature");          return signer;     }    ``` ## Tools Used  None   
# Handle  gpersoon   # Vulnerability details  ## Impact The function updateAndQuery of EMAOracle.sol subtracts the incomeIndex with the previous incomeIndex. These incomeIndex values are retrieved via the moneyMarket contract from an external contract.  If by accident the previous incomeIndex is larger than the current incomeIndex then the subtraction would be negative and the code halts (reverts), without an error message. Also the updateAndQuery function would not be able to execute (until the current incomeIndex is larger than the previous incomeIndex).  This situation could occur when an error occurs in one of the current or future money markets.  ## Proof of Concept EMAOracle.sol:   function updateAndQuery() {         ...         uint256 _lastIncomeIndex = lastIncomeIndex;         ...         uint256 newIncomeIndex = moneyMarket.incomeIndex();         uint256 incomingValue =             (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /                 timeElapsed;  ## Tools Used Editor  ## Recommended Mitigation Steps Give an error message when the previous incomeIndex is larger than the current incomeIndex. And/or create a way to recover from this erroneous situation.  
# Handle  paulius.eth   # Vulnerability details  ## Impact function payInterestToFunders does not have a re-entrancy modifier. I expect to see this modifier because similar functions (including sponsored version) have it.  ## Recommended Mitigation Steps Add 'nonReentrant' to function payInterestToFunders.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here the comment says that it should transfer from msg.sender but it actually transfers from the sender which is not always the msg.sender (e.g. sponsored txs):   // Transfer `fundAmount` stablecoins from msg.sender   stablecoin.safeTransferFrom(sender, address(this), fundAmount);  ## Recommended Mitigation Steps Update the comment to match the code.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract AaveMarket function setRewards has a misleading revert message:    require(newValue.isContract(), "HarvestMarket: not contract");  ## Recommended Mitigation Steps Should be 'AaveMarket', not 'HarvestMarket'.  
# Handle  shw   # Vulnerability details  ## Impact  In contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.  ## Proof of Concept  Referenced code: [MPHMinter.sol#L121](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/rewards/MPHMinter.sol#L121) [DInterest.sol#L1253](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1253) [DInterest.sol#L1420](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1420)  ## Tools Used  None  ## Recommended Mitigation Steps  Add a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).  
# Handle  a_delamo   # Vulnerability details  ## Impact  In `Sponsorable.sol` is using erecover directly to verify the signature. Being such a critical piece of the protocol, I would recommend using the ECDSA from openzeppelin as it does more validations when verifying the signature.   ```  // Currently   address recoveredAddress =       ecrecover(digest, sponsorship.v, sponsorship.r, sponsorship.s);     require(       recoveredAddress != address(0) && recoveredAddress == sponsorship.sender,       "Sponsorable: invalid sig"     );     //ECDSA     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most         // signatures from current libraries generate a unique signature with an s-value in the lower half order.         //         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept         // these malleable signatures as well.         require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");         require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");          // If the signature is valid (and not malleable), return the signer address         address signer = ecrecover(hash, v, r, s);         require(signer != address(0), "ECDSA: invalid signature");          return signer;     }    ``` ## Tools Used  None   
# Handle  gpersoon   # Vulnerability details  ## Impact The function updateAndQuery of EMAOracle.sol subtracts the incomeIndex with the previous incomeIndex. These incomeIndex values are retrieved via the moneyMarket contract from an external contract.  If by accident the previous incomeIndex is larger than the current incomeIndex then the subtraction would be negative and the code halts (reverts), without an error message. Also the updateAndQuery function would not be able to execute (until the current incomeIndex is larger than the previous incomeIndex).  This situation could occur when an error occurs in one of the current or future money markets.  ## Proof of Concept EMAOracle.sol:   function updateAndQuery() {         ...         uint256 _lastIncomeIndex = lastIncomeIndex;         ...         uint256 newIncomeIndex = moneyMarket.incomeIndex();         uint256 incomingValue =             (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /                 timeElapsed;  ## Tools Used Editor  ## Recommended Mitigation Steps Give an error message when the previous incomeIndex is larger than the current incomeIndex. And/or create a way to recover from this erroneous situation.  
# Handle  paulius.eth   # Vulnerability details  ## Impact function payInterestToFunders does not have a re-entrancy modifier. I expect to see this modifier because similar functions (including sponsored version) have it.  ## Recommended Mitigation Steps Add 'nonReentrant' to function payInterestToFunders.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here the comment says that it should transfer from msg.sender but it actually transfers from the sender which is not always the msg.sender (e.g. sponsored txs):   // Transfer `fundAmount` stablecoins from msg.sender   stablecoin.safeTransferFrom(sender, address(this), fundAmount);  ## Recommended Mitigation Steps Update the comment to match the code.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract AaveMarket function setRewards has a misleading revert message:    require(newValue.isContract(), "HarvestMarket: not contract");  ## Recommended Mitigation Steps Should be 'AaveMarket', not 'HarvestMarket'.  
# Handle  shw   # Vulnerability details  ## Impact  In contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.  ## Proof of Concept  Referenced code: [MPHMinter.sol#L121](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/rewards/MPHMinter.sol#L121) [DInterest.sol#L1253](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1253) [DInterest.sol#L1420](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1420)  ## Tools Used  None  ## Recommended Mitigation Steps  Add a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).  
# Handle  a_delamo   # Vulnerability details  ## Impact  In `Sponsorable.sol` is using erecover directly to verify the signature. Being such a critical piece of the protocol, I would recommend using the ECDSA from openzeppelin as it does more validations when verifying the signature.   ```  // Currently   address recoveredAddress =       ecrecover(digest, sponsorship.v, sponsorship.r, sponsorship.s);     require(       recoveredAddress != address(0) && recoveredAddress == sponsorship.sender,       "Sponsorable: invalid sig"     );     //ECDSA     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most         // signatures from current libraries generate a unique signature with an s-value in the lower half order.         //         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept         // these malleable signatures as well.         require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");         require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");          // If the signature is valid (and not malleable), return the signer address         address signer = ecrecover(hash, v, r, s);         require(signer != address(0), "ECDSA: invalid signature");          return signer;     }    ``` ## Tools Used  None   
# Handle  gpersoon   # Vulnerability details  ## Impact The function updateAndQuery of EMAOracle.sol subtracts the incomeIndex with the previous incomeIndex. These incomeIndex values are retrieved via the moneyMarket contract from an external contract.  If by accident the previous incomeIndex is larger than the current incomeIndex then the subtraction would be negative and the code halts (reverts), without an error message. Also the updateAndQuery function would not be able to execute (until the current incomeIndex is larger than the previous incomeIndex).  This situation could occur when an error occurs in one of the current or future money markets.  ## Proof of Concept EMAOracle.sol:   function updateAndQuery() {         ...         uint256 _lastIncomeIndex = lastIncomeIndex;         ...         uint256 newIncomeIndex = moneyMarket.incomeIndex();         uint256 incomingValue =             (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /                 timeElapsed;  ## Tools Used Editor  ## Recommended Mitigation Steps Give an error message when the previous incomeIndex is larger than the current incomeIndex. And/or create a way to recover from this erroneous situation.  
# Handle  paulius.eth   # Vulnerability details  ## Impact function payInterestToFunders does not have a re-entrancy modifier. I expect to see this modifier because similar functions (including sponsored version) have it.  ## Recommended Mitigation Steps Add 'nonReentrant' to function payInterestToFunders.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here the comment says that it should transfer from msg.sender but it actually transfers from the sender which is not always the msg.sender (e.g. sponsored txs):   // Transfer `fundAmount` stablecoins from msg.sender   stablecoin.safeTransferFrom(sender, address(this), fundAmount);  ## Recommended Mitigation Steps Update the comment to match the code.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract AaveMarket function setRewards has a misleading revert message:    require(newValue.isContract(), "HarvestMarket: not contract");  ## Recommended Mitigation Steps Should be 'AaveMarket', not 'HarvestMarket'.  
