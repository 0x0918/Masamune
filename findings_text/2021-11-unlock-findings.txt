# Handle  pauliax   # Vulnerability details  ## Impact function _assignNewTokenId first increments _totalSupply and then assigns token id, so ids start from 1, not 0. However, function tokenByIndex in MixinERC721Enumerable expects the index to be less than totalSupply: ```solidity   /// @notice Enumerate valid NFTs   /// @dev Throws if `_index` >= `totalSupply()`.   /// @param _index A counter less than `totalSupply()`   /// @return The token identifier for the `_index`th NFT,   ///  (sort order not specified)   function tokenByIndex(     uint256 _index   ) public view     returns (uint256)   {     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index;   } ``` This mismatch between indexes and token ids may trick other platforms or integrations.  ## Recommended Mitigation Steps I think the solution is simply returning index + 1: ```solidity     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index + 1; // index 0 = token id 1 ```  
# Handle  pauliax   # Vulnerability details  ## Impact function purchase is payable, thus it should validate that msg.value is 0 when tokenAddress != address(0) to prevent accidental sent Ether.  ## Recommended Mitigation Steps Check no ether was sent when the token is not a native currency.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L109-L140  ```solidity=109   function tokenURI(     uint256 _tokenId   ) external     view     returns(string memory)   {     string memory URI;     string memory tokenId;     string memory lockAddress = address(this).address2Str();     string memory seperator;      if(_tokenId != 0) {       tokenId = _tokenId.uint2Str();     } else {       tokenId = '';     }      if(bytes(baseTokenURI).length == 0) {       URI = unlockProtocol.globalBaseTokenURI();       seperator = '/';     } else {       URI = baseTokenURI;       seperator = '';       lockAddress = '';     }      return URI.strConcat(         lockAddress,         seperator,         tokenId       );   } ```  `seperator` should be `separator`.  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinRefunds.sol#L40-L43  ```solidity=40 /**    * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation    * of the key    */ ```  `user's ket` should be `user's key`.  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L54-L60  ```solidity=54   function updateLockName(     string calldata _lockName   ) external     onlyLockManager   {     name = _lockName;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L92-L98  ```solidity=92   function setBaseTokenURI(     string calldata _baseTokenURI   ) external     onlyLockManager   {     baseTokenURI = _baseTokenURI;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L204-L214  ```solidity=204   function setEventHooks(     address _onKeyPurchaseHook,     address _onKeyCancelHook   ) external     onlyLockManager()   {     require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');     require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');     onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);     onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);   } ```  
# Handle  WatchPug   # Vulnerability details  The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of thier time to another user using `shareKey`.  This makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.  ### PoC  Given:  - `keyPrice` is 1 ETH; - `expirationDuration` is 360 days; - `freeTrialLength` is 31 days.  The attacker can create two wallet addresses: Alice and Bob.  1. Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times; 2. Bob calls `cancelAndRefund()` and get 1 ETH.  ### Recommendation  Consider disabling `cancelAndRefund()` for users who transferred time to another user.  
# Handle  WatchPug   # Vulnerability details  It's a best practice to limit the visibility to `external` if the function is expected to be called externally only.  ```solidity=180{185}   /**    * Public function which returns the total number of unique owners (both expired    * and valid).  This may be larger than totalSupply.    */   function numberOfOwners()     public     view     returns (uint)   {     return owners.length;   } ```  `numberOfOwners()` can be changed to `external`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152  ```solidity     if (toKey.tokenId == 0) {       toKey.tokenId = _tokenId;       _recordOwner(_recipient, _tokenId);       // Clear any previous approvals       _clearApproval(_tokenId);     }      if (previousExpiration <= block.timestamp) {       // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration       // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID       toKey.expirationTimestamp = fromKey.expirationTimestamp;       toKey.tokenId = _tokenId;        // Reset the key Manager to the key owner       _setKeyManagerOf(_tokenId, address(0));        _recordOwner(_recipient, _tokenId);     } else {       // The recipient has a non expired key. We just add them the corresponding remaining time       // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow       toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;     } ```  Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.  However, in L131-136, the key manager is not being reset.  This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.  ### PoC  Given:  - Alice owns a key that is valid until 1 year later.  1. Alice calls `setKeyManagerOf()`, making herself the keyManager; 2. Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key; 3. Alice calls `transferFrom()` again, transferring the key back from Bob.  ### Recommendation  Consider resetting the key manager regardless of the status of the recipient's key.  
# Handle  cmichel   # Vulnerability details  The `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:  ```solidity uint fee = getTransferFee(keyOwner, _timeShared); uint timePlusFee = _timeShared + fee; ```  However, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**. The fee is now simply taken on the remaining time.  ```solidity if(timePlusFee < timeRemaining) {   // now we can safely set the time   time = _timeShared;   // deduct time from parent key, including transfer fee   _timeMachine(_tokenId, timePlusFee, false); } else {   // we have to recalculate the fee here   fee = getTransferFee(keyOwner, timeRemaining);   // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time   time = timeRemaining - fee; } ```  It should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  #### POC To demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.  The correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.  However, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as: (Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.  They would receive 100 seconds less than what they are owed.  ## Impact When transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).  ## Recommended Mitigation Steps It should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal). In the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  
# Handle  cmichel   # Vulnerability details  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  For the tokens that return a success value, the contract does not check it.  Non-safe transfers are used in: - `MixinLockCore.approveBeneficiary`: `IERC20Upgradeable(tokenAddress).approve(_spender, _amount)`   ## Impact Tokens that return `false` on a failed `approve` or that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  The locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview: - key manager (map `keyManagerOf`) - single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf` - operator approvals (map `managerToOperatorApproved`)  The `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.  Notice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:  ```solidity function transferFrom(   address _from,   address _recipient,   uint _tokenId )   public   onlyIfAlive   hasValidKey(_from)   onlyKeyManagerOrApproved(_tokenId) {   // @audit this is skipped if user had a key that expired   if (toKey.tokenId == 0) {     toKey.tokenId = _tokenId;     _recordOwner(_recipient, _tokenId);     // Clear any previous approvals     _clearApproval(_tokenId);   }    if (previousExpiration <= block.timestamp) {     // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration     // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID     toKey.expirationTimestamp = fromKey.expirationTimestamp;     toKey.tokenId = _tokenId;      // Reset the key Manager to the key owner     // @audit  doesn't clear approval if key manager already was 0     _setKeyManagerOf(_tokenId, address(0));      _recordOwner(_recipient, _tokenId);   }   // ... }  //  function _setKeyManagerOf(   uint _tokenId,   address _keyManager ) internal {   // @audit-ok only clears approved if key manager updated   if(keyManagerOf[_tokenId] != _keyManager) {     keyManagerOf[_tokenId] = _keyManager;     _clearApproval(_tokenId);     emit KeyManagerChanged(_tokenId, address(0));   } } ```  ## Impact It's possible to sell someone a key and then claim it back as the approvals are not always cleared.  ## POC - Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future. - A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`. - A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom` - A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`. - A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.) - A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.  ## Recommended Mitigation Steps The `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types. The `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.   
# Handle  cmichel   # Vulnerability details  The `Unlock.setLockTemplate` function sets the default lock tempalte for new lock creations. However, it does not verify that this lock template is a valid template that was added to `_publicLockVersions` via `addLockTemplate`.  ## Impact A default template with a wrong version number can be set which is incompatible with updating locks through `upgradeLock` (requires `version == currentVersion + 1`).  ## Recommended Mitigation Steps Add new lock templates using `addLockTemplate` first and restrict `setLockTemplate` to only use these templates, not arbitrary code.   
# Handle  cmichel   # Vulnerability details  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter should checked for success.  See `Unlock.recordKeyPurchase` which performs ERC20 transfers without checking for the return value.  ## Impact As the trusted `udt` token is used which supposedly reverts on failed transfers, not checking the return value does not lead to any security issues. We still recommend checking it to abide by the EIP20 standard.  ## Recommended Mitigation Steps Consider using `require(IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward), "transfer failed")` instead.  
# Handle  kenzo   # Vulnerability details  `setLockTemplate` is initializing the new template using hardcoded values. This means that if a new lock version is set which has different/additional `initialize` parameters, Unlock protocol would have to be updated in order to initialize it.  ## Impact Less convenient adding of new locks as Unlock would have to be upgraded if their initialize function has changed.  ## Proof of Concept `setLockTemplate` uses the following code to initialize the template: ```     IPublicLock(_publicLockAddress).initialize(       address(this), 0, address(0), 0, 0, ''     ); ``` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L430:#L432 Which is hardcoded. This is unlike `createLock` for example, where the initialize call is being received as parameter, to allow different future versions. https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L219   ## Recommended Mitigation Steps Change `setLockTemplate` so the initializing parameters would be received as parameter.  
# Handle  elprofesor   # Vulnerability details  ## Impact `UnlockProtocol` attempts to calculate gas reimbursement using tx.gasprice, typically users who falsify tx.gasprice would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the tx.gasprice used. As the following calculation is made; ```     uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice; ```  we can see that arbitrary tx.gasprices can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.  ## Proof of Concept  ## Recommended Mitigation Steps Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact `maxTokens` in Unlock's `recordKeyPurchase` currently rounds more than is required.  ## Proof of Concept Plug the formula in Wolfgram Alpha to simplify from:  ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct; ```  to ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 * (valueInETH + grossNetworkProduct)); ```  Example inputs: ``` balance: 10000 price: 0.012345678912345678 gnp: 1000 + 0.012345678912345678 (for this purchase)  61728394561728390 old formula 61727632492197622 new formula (smaller than old) 61726870441482920.98 actual per wolfgram (smaller than new) 1524120245470 delta old - actual 762050714702 delta new - actual ```  The "new" formula proposed above is closer to the expected value. It's also easier to read and saves 123 gas.  ## Tools Used https://www.wolframalpha.com/  ## Recommended Mitigation Steps  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact KeyManagerChanged does not emit the new manager address as expected. Additionally there's a small gas savings of 1.5k gas by not emitting the event twice in `grantKeys`.  ## Proof of Concept Per the event param names, this event should emit the new keyManager's address. That would allow an indexer such as subgraph to track the current manager for each token. However the event currently emits address(0):  https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinKeys.sol#L229  Change that line to: `emit KeyManagerChanged(_tokenId, _keyManager);`  Additionally this line may be removed: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L48 as the call right before it to `_setKeyManagerOf` will emit the event already.  ## Tools Used `yarn test`  ## Recommended Mitigation Steps When testing this change only one test failed, and it was due to assuming the index of the event: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L80  It would be nice to be more robust like some other tests are, e.g. https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L49   Also add a test to confirm that the keyManager is emitting in the event.  Personally I like Waffle for testing events: https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html?highlight=emits#writing-tests  ```  it('Transfer emits event', async () => {     await expect(token.transfer(walletTo.address, 7))       .to.emit(token, 'Transfer')       .withArgs(wallet.address, walletTo.address, 7);   }); ```  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Wrong comment for withdraw(): modifier onlyLockManagerOrBeneficiary also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123)  Wrong comment for updateBeneficiary(): require statement also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189)  ## Recommended Mitigation Steps - Fix comments, because the implementation seems to be correct    
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact / POC  A single user can become the owner of multiple token ids and break the assumption of the comment [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181) of the function numberOfOwners() that it returns "total number of unique owners"   If a key manager/approved transfers a key with transferFrom() [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109) to a recipient that also owns a valid key then we don't go into the "if block" L131 and also not into the "if block" L138 (this is important s.t. no key owner change happens) and go into the "else block" L148 (not really important).   We end with: fromKey.expirationTimestamp = block.timestamp; and fromKey.tokenId = 0;  If the key owner or someone else buys for this key owner again a "key" [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51) satisfies the condition idTo ==0 (bcs of tokenId = 0) and in _assignNewTokenId(toKey); the key gets a new token id and the owner gets also registered as the new owner of the new token id in _recordOwner(_recipient, idTo);  The "old" key got overwritten but we are now the owner of two token ids.  This breaks the comment of numberOfOwners() that it returns "total number of unique owners" but for this the key owner that owns now two token ids, we executed "_recordOwner" twice and therefore added the same address twice to the owner array  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327)   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  - need to also implement the removal of ownership of a tokenId when it is set 0 zero to be congruent with the state of the key, and also adapt the other logic depending on it  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact Unimplemented calls do not revert, this may cause unexpected behavior in wallets or other contracts.  ## Proof of Concept Locks are ERC721s, they also implement some ERC20 style calls such as `transfer`. If a wallet or another contract attempted to treat the contract as a ERC77, `send` would incorrectly appear to work but nothing happens under the hood. It would be better if this call reverted so that the user was aware the function is not supported before even broadcasting the transaction (Metamask will warn you if estimate gas fails).  This test currently fails (i.e. calling send does not revert).  ```   it("Should fail on unknown calls", async () => {       const mock777 = await erc777.at(lock.address);       await reverts(         mock777.send(destination, 1, '0x', { from: singleKeyOwner })       )     }) ```  ## Tools Used `yarn test`  ## Recommended Mitigation Steps Remove this line https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/PublicLock.sol#L72  Per the comments there is not a clear reason it's currently included. The test suite still passes when it is removed.  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact A contract implementing `ERC721TokenReceiver` is called with a tokenId that was not sent to that address when `shareKey` is used. If the `onERC721Received` implementation included any logic which assumed ownership it may fail, e.g. checking `ownerOf`, `balanceOf` or performing a task such as `transferFrom` to forward the asset to another destination.  ## Proof of Concept `shareKey` accepts a `_tokenId` as the source of expiration time to share. It then either mints a new token for the target account or adds time to their existing key. Either way the receiver has a different tokenId than the one that was passed to the `shareKey` function.  ## Tools Used n/a  ## Recommended Mitigation Steps Change https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinTransfer.sol#L106  from: `require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  to: `require(_checkOnERC721Received(keyOwner, _to, idTo, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  
# Handle  kenzo   # Vulnerability details  Unlock doesn't follow standard ERC721 log emittance. This leads to wrong display values regarding to the lock NFT on Etherscan.  ## Impact Etherscan does not show txs correctly, does not count token holders correctly in token page, does not count tokens correctly in user page.  ## Proof of Concept A scenario: - Create a new lock - User 1 mints 1 token - User 1 uses `shareKey` and transfers some amount to User 2 At this point Etherscan will show that 3 transfers have been made, under user 2's address page user 2 has 2 keys , and under lock's holders tab user 2 has 2 keys. All this is obviously wrong. This is probably because the transfer event is emitted twice during shareKey: [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L87) and [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L100).  Additionally, if user 1 now calls `Cancel And Refund`, user 1 will still have a key under his tokens in his account, and the lock's token page will still list him as a holder, and the transaction won't get shown in Etherscan's token transfers (unlike contract transactions). Probably because it has not emitted any burn event. It just emits a [CancelKey event](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L111).  ## Recommended Mitigation Steps You can align the logs emittance to match regular ERC721 logs if you'd like Etherscan to show correct amounts. It might get confusing to keep it like this.  
# Handle  kenzo   # Vulnerability details  If calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).  ## Impact A key manager or approved might accidently destroy user's token.  Note: this requires user error and so I'm not sure if this is a valid finding. However, few things make me think that it is valid: - Unlock protocol checks for transfer to 0-address, so some input validation is there - Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen. - This scenario manifests a unique and probably unintended behavior   ## Proof of Concept By following `transferFrom`'s execution: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166 One can see that in the case where `_from == _recipient` with a valid key: - The function will deduct transfer fee from the key - The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151)) - The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158)) Therefore, the user will lose his key without getting a refund.  ## Recommended Mitigation Steps Add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`  
# Handle  kenzo   # Vulnerability details  `_setKeyManagerOf` always emits `address(0)` as the new key manager.  ## Impact Wrong event emitted.  ## Proof of Concept The code is: `emit KeyManagerChanged(_tokenId, address(0));` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L229  ## Recommended Mitigation Steps Change line to `emit KeyManagerChanged(_tokenId, _keyManager);`  
# Handle  hagrid   # Vulnerability details  ## Details `UnlockDiscountTokenV2.sol` has override for `_afterTokenTransfer` handler function to control events or operations after token transfers. Also, the `UnlockDiscountTokenV2.sol` uses another token contracts from `ERC20Patched.sol`. In `ERC20Patched.sol` contract there are also `_beforeTokenTransfer` transfer handles. However, the `UnlockDiscountTokenV2.sol`  token does not have any override for `_beforeTokenTransfer` method.   ## Impact Contract will not react to any operations before token transfers. If gas calculations are aimed on UnlockToken's transfer, it will not be possible to calculate correct gas amounts without these both handlers (_beforeTokenTransfer and _afterTokenTransfer)  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Recommended Mitigation Steps Possible fix is implementing additional override for `_beforeTokenTransfer` method:  ```  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {     return ERC20VotesUpgradeable._beforeTokenTransfer(from, to, amount);   } ```  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability Description Some of the implemented functions inside the smart contracts are of type Public, However these functions are not used within the contracts. The function **tokenByIndex()** is part of the EIP721 which define it as external function.  ## Impact Coding style quality.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinERC721Enumerable.sol#L35  ## Tools Used manual code review.  ## Recommended Mitigation Steps Change the function to external and follow the ERC721 Specs when implementing: https://eips.ethereum.org/EIPS/eip-721#specification  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The function **updateBeneficiary** in the **MixinLockCore** smart contract is used to lets the owner of the lock update the beneficiary account which receives funds on withdrawal.   ## Impact Attackers can change the beneficiary address using this function before continue with the withdrawal function. Unlock protocol team and users can't log or monitor this critical changes.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinLockCore.sol#L192  ## Tools Used manual code review  ## Recommended Mitigation Steps define event and emit it to track changes done to the system.  
# Handle  harleythedog   # Vulnerability details  ## Impact The function computeAvailableDiscountFor is left unimplemented in Unlock.sol. Recommend implementing this function or removing it.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L269  ## Tools Used Inspection.  ## Recommended Mitigation Steps Implement function or remove it to save gas.  
# Handle  kenzo   # Vulnerability details  More keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.  ## Impact More keys can be minted than intended.  ## Proof of Concept In both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`. This is unlike `purchase`, which has the `notSoldOut` modifier. `grantKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42 `shareKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84 Both functions call `_assignNewTokenId` which does not check maxNumberOfKeys.  https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322 So you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).  ## Recommended Mitigation Steps Add a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.  
# Handle  pauliax   # Vulnerability details  ## Impact function _assignNewTokenId first increments _totalSupply and then assigns token id, so ids start from 1, not 0. However, function tokenByIndex in MixinERC721Enumerable expects the index to be less than totalSupply: ```solidity   /// @notice Enumerate valid NFTs   /// @dev Throws if `_index` >= `totalSupply()`.   /// @param _index A counter less than `totalSupply()`   /// @return The token identifier for the `_index`th NFT,   ///  (sort order not specified)   function tokenByIndex(     uint256 _index   ) public view     returns (uint256)   {     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index;   } ``` This mismatch between indexes and token ids may trick other platforms or integrations.  ## Recommended Mitigation Steps I think the solution is simply returning index + 1: ```solidity     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index + 1; // index 0 = token id 1 ```  
# Handle  pauliax   # Vulnerability details  ## Impact function purchase is payable, thus it should validate that msg.value is 0 when tokenAddress != address(0) to prevent accidental sent Ether.  ## Recommended Mitigation Steps Check no ether was sent when the token is not a native currency.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L109-L140  ```solidity=109   function tokenURI(     uint256 _tokenId   ) external     view     returns(string memory)   {     string memory URI;     string memory tokenId;     string memory lockAddress = address(this).address2Str();     string memory seperator;      if(_tokenId != 0) {       tokenId = _tokenId.uint2Str();     } else {       tokenId = '';     }      if(bytes(baseTokenURI).length == 0) {       URI = unlockProtocol.globalBaseTokenURI();       seperator = '/';     } else {       URI = baseTokenURI;       seperator = '';       lockAddress = '';     }      return URI.strConcat(         lockAddress,         seperator,         tokenId       );   } ```  `seperator` should be `separator`.  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinRefunds.sol#L40-L43  ```solidity=40 /**    * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation    * of the key    */ ```  `user's ket` should be `user's key`.  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L54-L60  ```solidity=54   function updateLockName(     string calldata _lockName   ) external     onlyLockManager   {     name = _lockName;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L92-L98  ```solidity=92   function setBaseTokenURI(     string calldata _baseTokenURI   ) external     onlyLockManager   {     baseTokenURI = _baseTokenURI;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L204-L214  ```solidity=204   function setEventHooks(     address _onKeyPurchaseHook,     address _onKeyCancelHook   ) external     onlyLockManager()   {     require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');     require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');     onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);     onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);   } ```  
# Handle  WatchPug   # Vulnerability details  The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of thier time to another user using `shareKey`.  This makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.  ### PoC  Given:  - `keyPrice` is 1 ETH; - `expirationDuration` is 360 days; - `freeTrialLength` is 31 days.  The attacker can create two wallet addresses: Alice and Bob.  1. Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times; 2. Bob calls `cancelAndRefund()` and get 1 ETH.  ### Recommendation  Consider disabling `cancelAndRefund()` for users who transferred time to another user.  
# Handle  WatchPug   # Vulnerability details  It's a best practice to limit the visibility to `external` if the function is expected to be called externally only.  ```solidity=180{185}   /**    * Public function which returns the total number of unique owners (both expired    * and valid).  This may be larger than totalSupply.    */   function numberOfOwners()     public     view     returns (uint)   {     return owners.length;   } ```  `numberOfOwners()` can be changed to `external`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152  ```solidity     if (toKey.tokenId == 0) {       toKey.tokenId = _tokenId;       _recordOwner(_recipient, _tokenId);       // Clear any previous approvals       _clearApproval(_tokenId);     }      if (previousExpiration <= block.timestamp) {       // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration       // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID       toKey.expirationTimestamp = fromKey.expirationTimestamp;       toKey.tokenId = _tokenId;        // Reset the key Manager to the key owner       _setKeyManagerOf(_tokenId, address(0));        _recordOwner(_recipient, _tokenId);     } else {       // The recipient has a non expired key. We just add them the corresponding remaining time       // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow       toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;     } ```  Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.  However, in L131-136, the key manager is not being reset.  This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.  ### PoC  Given:  - Alice owns a key that is valid until 1 year later.  1. Alice calls `setKeyManagerOf()`, making herself the keyManager; 2. Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key; 3. Alice calls `transferFrom()` again, transferring the key back from Bob.  ### Recommendation  Consider resetting the key manager regardless of the status of the recipient's key.  
# Handle  cmichel   # Vulnerability details  The `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:  ```solidity uint fee = getTransferFee(keyOwner, _timeShared); uint timePlusFee = _timeShared + fee; ```  However, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**. The fee is now simply taken on the remaining time.  ```solidity if(timePlusFee < timeRemaining) {   // now we can safely set the time   time = _timeShared;   // deduct time from parent key, including transfer fee   _timeMachine(_tokenId, timePlusFee, false); } else {   // we have to recalculate the fee here   fee = getTransferFee(keyOwner, timeRemaining);   // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time   time = timeRemaining - fee; } ```  It should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  #### POC To demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.  The correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.  However, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as: (Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.  They would receive 100 seconds less than what they are owed.  ## Impact When transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).  ## Recommended Mitigation Steps It should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal). In the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  
# Handle  cmichel   # Vulnerability details  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  For the tokens that return a success value, the contract does not check it.  Non-safe transfers are used in: - `MixinLockCore.approveBeneficiary`: `IERC20Upgradeable(tokenAddress).approve(_spender, _amount)`   ## Impact Tokens that return `false` on a failed `approve` or that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  The locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview: - key manager (map `keyManagerOf`) - single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf` - operator approvals (map `managerToOperatorApproved`)  The `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.  Notice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:  ```solidity function transferFrom(   address _from,   address _recipient,   uint _tokenId )   public   onlyIfAlive   hasValidKey(_from)   onlyKeyManagerOrApproved(_tokenId) {   // @audit this is skipped if user had a key that expired   if (toKey.tokenId == 0) {     toKey.tokenId = _tokenId;     _recordOwner(_recipient, _tokenId);     // Clear any previous approvals     _clearApproval(_tokenId);   }    if (previousExpiration <= block.timestamp) {     // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration     // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID     toKey.expirationTimestamp = fromKey.expirationTimestamp;     toKey.tokenId = _tokenId;      // Reset the key Manager to the key owner     // @audit  doesn't clear approval if key manager already was 0     _setKeyManagerOf(_tokenId, address(0));      _recordOwner(_recipient, _tokenId);   }   // ... }  //  function _setKeyManagerOf(   uint _tokenId,   address _keyManager ) internal {   // @audit-ok only clears approved if key manager updated   if(keyManagerOf[_tokenId] != _keyManager) {     keyManagerOf[_tokenId] = _keyManager;     _clearApproval(_tokenId);     emit KeyManagerChanged(_tokenId, address(0));   } } ```  ## Impact It's possible to sell someone a key and then claim it back as the approvals are not always cleared.  ## POC - Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future. - A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`. - A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom` - A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`. - A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.) - A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.  ## Recommended Mitigation Steps The `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types. The `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.   
# Handle  cmichel   # Vulnerability details  The `Unlock.setLockTemplate` function sets the default lock tempalte for new lock creations. However, it does not verify that this lock template is a valid template that was added to `_publicLockVersions` via `addLockTemplate`.  ## Impact A default template with a wrong version number can be set which is incompatible with updating locks through `upgradeLock` (requires `version == currentVersion + 1`).  ## Recommended Mitigation Steps Add new lock templates using `addLockTemplate` first and restrict `setLockTemplate` to only use these templates, not arbitrary code.   
# Handle  cmichel   # Vulnerability details  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter should checked for success.  See `Unlock.recordKeyPurchase` which performs ERC20 transfers without checking for the return value.  ## Impact As the trusted `udt` token is used which supposedly reverts on failed transfers, not checking the return value does not lead to any security issues. We still recommend checking it to abide by the EIP20 standard.  ## Recommended Mitigation Steps Consider using `require(IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward), "transfer failed")` instead.  
# Handle  kenzo   # Vulnerability details  `setLockTemplate` is initializing the new template using hardcoded values. This means that if a new lock version is set which has different/additional `initialize` parameters, Unlock protocol would have to be updated in order to initialize it.  ## Impact Less convenient adding of new locks as Unlock would have to be upgraded if their initialize function has changed.  ## Proof of Concept `setLockTemplate` uses the following code to initialize the template: ```     IPublicLock(_publicLockAddress).initialize(       address(this), 0, address(0), 0, 0, ''     ); ``` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L430:#L432 Which is hardcoded. This is unlike `createLock` for example, where the initialize call is being received as parameter, to allow different future versions. https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L219   ## Recommended Mitigation Steps Change `setLockTemplate` so the initializing parameters would be received as parameter.  
# Handle  elprofesor   # Vulnerability details  ## Impact `UnlockProtocol` attempts to calculate gas reimbursement using tx.gasprice, typically users who falsify tx.gasprice would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the tx.gasprice used. As the following calculation is made; ```     uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice; ```  we can see that arbitrary tx.gasprices can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.  ## Proof of Concept  ## Recommended Mitigation Steps Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact `maxTokens` in Unlock's `recordKeyPurchase` currently rounds more than is required.  ## Proof of Concept Plug the formula in Wolfgram Alpha to simplify from:  ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct; ```  to ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 * (valueInETH + grossNetworkProduct)); ```  Example inputs: ``` balance: 10000 price: 0.012345678912345678 gnp: 1000 + 0.012345678912345678 (for this purchase)  61728394561728390 old formula 61727632492197622 new formula (smaller than old) 61726870441482920.98 actual per wolfgram (smaller than new) 1524120245470 delta old - actual 762050714702 delta new - actual ```  The "new" formula proposed above is closer to the expected value. It's also easier to read and saves 123 gas.  ## Tools Used https://www.wolframalpha.com/  ## Recommended Mitigation Steps  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact KeyManagerChanged does not emit the new manager address as expected. Additionally there's a small gas savings of 1.5k gas by not emitting the event twice in `grantKeys`.  ## Proof of Concept Per the event param names, this event should emit the new keyManager's address. That would allow an indexer such as subgraph to track the current manager for each token. However the event currently emits address(0):  https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinKeys.sol#L229  Change that line to: `emit KeyManagerChanged(_tokenId, _keyManager);`  Additionally this line may be removed: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L48 as the call right before it to `_setKeyManagerOf` will emit the event already.  ## Tools Used `yarn test`  ## Recommended Mitigation Steps When testing this change only one test failed, and it was due to assuming the index of the event: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L80  It would be nice to be more robust like some other tests are, e.g. https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L49   Also add a test to confirm that the keyManager is emitting in the event.  Personally I like Waffle for testing events: https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html?highlight=emits#writing-tests  ```  it('Transfer emits event', async () => {     await expect(token.transfer(walletTo.address, 7))       .to.emit(token, 'Transfer')       .withArgs(wallet.address, walletTo.address, 7);   }); ```  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Wrong comment for withdraw(): modifier onlyLockManagerOrBeneficiary also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123)  Wrong comment for updateBeneficiary(): require statement also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189)  ## Recommended Mitigation Steps - Fix comments, because the implementation seems to be correct    
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact / POC  A single user can become the owner of multiple token ids and break the assumption of the comment [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181) of the function numberOfOwners() that it returns "total number of unique owners"   If a key manager/approved transfers a key with transferFrom() [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109) to a recipient that also owns a valid key then we don't go into the "if block" L131 and also not into the "if block" L138 (this is important s.t. no key owner change happens) and go into the "else block" L148 (not really important).   We end with: fromKey.expirationTimestamp = block.timestamp; and fromKey.tokenId = 0;  If the key owner or someone else buys for this key owner again a "key" [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51) satisfies the condition idTo ==0 (bcs of tokenId = 0) and in _assignNewTokenId(toKey); the key gets a new token id and the owner gets also registered as the new owner of the new token id in _recordOwner(_recipient, idTo);  The "old" key got overwritten but we are now the owner of two token ids.  This breaks the comment of numberOfOwners() that it returns "total number of unique owners" but for this the key owner that owns now two token ids, we executed "_recordOwner" twice and therefore added the same address twice to the owner array  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327)   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  - need to also implement the removal of ownership of a tokenId when it is set 0 zero to be congruent with the state of the key, and also adapt the other logic depending on it  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact Unimplemented calls do not revert, this may cause unexpected behavior in wallets or other contracts.  ## Proof of Concept Locks are ERC721s, they also implement some ERC20 style calls such as `transfer`. If a wallet or another contract attempted to treat the contract as a ERC77, `send` would incorrectly appear to work but nothing happens under the hood. It would be better if this call reverted so that the user was aware the function is not supported before even broadcasting the transaction (Metamask will warn you if estimate gas fails).  This test currently fails (i.e. calling send does not revert).  ```   it("Should fail on unknown calls", async () => {       const mock777 = await erc777.at(lock.address);       await reverts(         mock777.send(destination, 1, '0x', { from: singleKeyOwner })       )     }) ```  ## Tools Used `yarn test`  ## Recommended Mitigation Steps Remove this line https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/PublicLock.sol#L72  Per the comments there is not a clear reason it's currently included. The test suite still passes when it is removed.  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact A contract implementing `ERC721TokenReceiver` is called with a tokenId that was not sent to that address when `shareKey` is used. If the `onERC721Received` implementation included any logic which assumed ownership it may fail, e.g. checking `ownerOf`, `balanceOf` or performing a task such as `transferFrom` to forward the asset to another destination.  ## Proof of Concept `shareKey` accepts a `_tokenId` as the source of expiration time to share. It then either mints a new token for the target account or adds time to their existing key. Either way the receiver has a different tokenId than the one that was passed to the `shareKey` function.  ## Tools Used n/a  ## Recommended Mitigation Steps Change https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinTransfer.sol#L106  from: `require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  to: `require(_checkOnERC721Received(keyOwner, _to, idTo, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  
# Handle  kenzo   # Vulnerability details  Unlock doesn't follow standard ERC721 log emittance. This leads to wrong display values regarding to the lock NFT on Etherscan.  ## Impact Etherscan does not show txs correctly, does not count token holders correctly in token page, does not count tokens correctly in user page.  ## Proof of Concept A scenario: - Create a new lock - User 1 mints 1 token - User 1 uses `shareKey` and transfers some amount to User 2 At this point Etherscan will show that 3 transfers have been made, under user 2's address page user 2 has 2 keys , and under lock's holders tab user 2 has 2 keys. All this is obviously wrong. This is probably because the transfer event is emitted twice during shareKey: [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L87) and [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L100).  Additionally, if user 1 now calls `Cancel And Refund`, user 1 will still have a key under his tokens in his account, and the lock's token page will still list him as a holder, and the transaction won't get shown in Etherscan's token transfers (unlike contract transactions). Probably because it has not emitted any burn event. It just emits a [CancelKey event](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L111).  ## Recommended Mitigation Steps You can align the logs emittance to match regular ERC721 logs if you'd like Etherscan to show correct amounts. It might get confusing to keep it like this.  
# Handle  kenzo   # Vulnerability details  If calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).  ## Impact A key manager or approved might accidently destroy user's token.  Note: this requires user error and so I'm not sure if this is a valid finding. However, few things make me think that it is valid: - Unlock protocol checks for transfer to 0-address, so some input validation is there - Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen. - This scenario manifests a unique and probably unintended behavior   ## Proof of Concept By following `transferFrom`'s execution: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166 One can see that in the case where `_from == _recipient` with a valid key: - The function will deduct transfer fee from the key - The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151)) - The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158)) Therefore, the user will lose his key without getting a refund.  ## Recommended Mitigation Steps Add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`  
# Handle  kenzo   # Vulnerability details  `_setKeyManagerOf` always emits `address(0)` as the new key manager.  ## Impact Wrong event emitted.  ## Proof of Concept The code is: `emit KeyManagerChanged(_tokenId, address(0));` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L229  ## Recommended Mitigation Steps Change line to `emit KeyManagerChanged(_tokenId, _keyManager);`  
# Handle  hagrid   # Vulnerability details  ## Details `UnlockDiscountTokenV2.sol` has override for `_afterTokenTransfer` handler function to control events or operations after token transfers. Also, the `UnlockDiscountTokenV2.sol` uses another token contracts from `ERC20Patched.sol`. In `ERC20Patched.sol` contract there are also `_beforeTokenTransfer` transfer handles. However, the `UnlockDiscountTokenV2.sol`  token does not have any override for `_beforeTokenTransfer` method.   ## Impact Contract will not react to any operations before token transfers. If gas calculations are aimed on UnlockToken's transfer, it will not be possible to calculate correct gas amounts without these both handlers (_beforeTokenTransfer and _afterTokenTransfer)  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Recommended Mitigation Steps Possible fix is implementing additional override for `_beforeTokenTransfer` method:  ```  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {     return ERC20VotesUpgradeable._beforeTokenTransfer(from, to, amount);   } ```  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability Description Some of the implemented functions inside the smart contracts are of type Public, However these functions are not used within the contracts. The function **tokenByIndex()** is part of the EIP721 which define it as external function.  ## Impact Coding style quality.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinERC721Enumerable.sol#L35  ## Tools Used manual code review.  ## Recommended Mitigation Steps Change the function to external and follow the ERC721 Specs when implementing: https://eips.ethereum.org/EIPS/eip-721#specification  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The function **updateBeneficiary** in the **MixinLockCore** smart contract is used to lets the owner of the lock update the beneficiary account which receives funds on withdrawal.   ## Impact Attackers can change the beneficiary address using this function before continue with the withdrawal function. Unlock protocol team and users can't log or monitor this critical changes.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinLockCore.sol#L192  ## Tools Used manual code review  ## Recommended Mitigation Steps define event and emit it to track changes done to the system.  
# Handle  harleythedog   # Vulnerability details  ## Impact The function computeAvailableDiscountFor is left unimplemented in Unlock.sol. Recommend implementing this function or removing it.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L269  ## Tools Used Inspection.  ## Recommended Mitigation Steps Implement function or remove it to save gas.  
# Handle  kenzo   # Vulnerability details  More keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.  ## Impact More keys can be minted than intended.  ## Proof of Concept In both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`. This is unlike `purchase`, which has the `notSoldOut` modifier. `grantKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42 `shareKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84 Both functions call `_assignNewTokenId` which does not check maxNumberOfKeys.  https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322 So you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).  ## Recommended Mitigation Steps Add a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.  
# Handle  pauliax   # Vulnerability details  ## Impact function _assignNewTokenId first increments _totalSupply and then assigns token id, so ids start from 1, not 0. However, function tokenByIndex in MixinERC721Enumerable expects the index to be less than totalSupply: ```solidity   /// @notice Enumerate valid NFTs   /// @dev Throws if `_index` >= `totalSupply()`.   /// @param _index A counter less than `totalSupply()`   /// @return The token identifier for the `_index`th NFT,   ///  (sort order not specified)   function tokenByIndex(     uint256 _index   ) public view     returns (uint256)   {     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index;   } ``` This mismatch between indexes and token ids may trick other platforms or integrations.  ## Recommended Mitigation Steps I think the solution is simply returning index + 1: ```solidity     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index + 1; // index 0 = token id 1 ```  
# Handle  pauliax   # Vulnerability details  ## Impact function purchase is payable, thus it should validate that msg.value is 0 when tokenAddress != address(0) to prevent accidental sent Ether.  ## Recommended Mitigation Steps Check no ether was sent when the token is not a native currency.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L109-L140  ```solidity=109   function tokenURI(     uint256 _tokenId   ) external     view     returns(string memory)   {     string memory URI;     string memory tokenId;     string memory lockAddress = address(this).address2Str();     string memory seperator;      if(_tokenId != 0) {       tokenId = _tokenId.uint2Str();     } else {       tokenId = '';     }      if(bytes(baseTokenURI).length == 0) {       URI = unlockProtocol.globalBaseTokenURI();       seperator = '/';     } else {       URI = baseTokenURI;       seperator = '';       lockAddress = '';     }      return URI.strConcat(         lockAddress,         seperator,         tokenId       );   } ```  `seperator` should be `separator`.  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinRefunds.sol#L40-L43  ```solidity=40 /**    * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation    * of the key    */ ```  `user's ket` should be `user's key`.  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L54-L60  ```solidity=54   function updateLockName(     string calldata _lockName   ) external     onlyLockManager   {     name = _lockName;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockMetadata.sol#L92-L98  ```solidity=92   function setBaseTokenURI(     string calldata _baseTokenURI   ) external     onlyLockManager   {     baseTokenURI = _baseTokenURI;   } ```  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L204-L214  ```solidity=204   function setEventHooks(     address _onKeyPurchaseHook,     address _onKeyCancelHook   ) external     onlyLockManager()   {     require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');     require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');     onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);     onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);   } ```  
# Handle  WatchPug   # Vulnerability details  The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of thier time to another user using `shareKey`.  This makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.  ### PoC  Given:  - `keyPrice` is 1 ETH; - `expirationDuration` is 360 days; - `freeTrialLength` is 31 days.  The attacker can create two wallet addresses: Alice and Bob.  1. Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times; 2. Bob calls `cancelAndRefund()` and get 1 ETH.  ### Recommendation  Consider disabling `cancelAndRefund()` for users who transferred time to another user.  
# Handle  WatchPug   # Vulnerability details  It's a best practice to limit the visibility to `external` if the function is expected to be called externally only.  ```solidity=180{185}   /**    * Public function which returns the total number of unique owners (both expired    * and valid).  This may be larger than totalSupply.    */   function numberOfOwners()     public     view     returns (uint)   {     return owners.length;   } ```  `numberOfOwners()` can be changed to `external`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152  ```solidity     if (toKey.tokenId == 0) {       toKey.tokenId = _tokenId;       _recordOwner(_recipient, _tokenId);       // Clear any previous approvals       _clearApproval(_tokenId);     }      if (previousExpiration <= block.timestamp) {       // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration       // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID       toKey.expirationTimestamp = fromKey.expirationTimestamp;       toKey.tokenId = _tokenId;        // Reset the key Manager to the key owner       _setKeyManagerOf(_tokenId, address(0));        _recordOwner(_recipient, _tokenId);     } else {       // The recipient has a non expired key. We just add them the corresponding remaining time       // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow       toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;     } ```  Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.  However, in L131-136, the key manager is not being reset.  This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.  ### PoC  Given:  - Alice owns a key that is valid until 1 year later.  1. Alice calls `setKeyManagerOf()`, making herself the keyManager; 2. Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key; 3. Alice calls `transferFrom()` again, transferring the key back from Bob.  ### Recommendation  Consider resetting the key manager regardless of the status of the recipient's key.  
# Handle  cmichel   # Vulnerability details  The `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:  ```solidity uint fee = getTransferFee(keyOwner, _timeShared); uint timePlusFee = _timeShared + fee; ```  However, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**. The fee is now simply taken on the remaining time.  ```solidity if(timePlusFee < timeRemaining) {   // now we can safely set the time   time = _timeShared;   // deduct time from parent key, including transfer fee   _timeMachine(_tokenId, timePlusFee, false); } else {   // we have to recalculate the fee here   fee = getTransferFee(keyOwner, timeRemaining);   // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time   time = timeRemaining - fee; } ```  It should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  #### POC To demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.  The correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.  However, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as: (Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.  They would receive 100 seconds less than what they are owed.  ## Impact When transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).  ## Recommended Mitigation Steps It should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal). In the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  
# Handle  cmichel   # Vulnerability details  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  For the tokens that return a success value, the contract does not check it.  Non-safe transfers are used in: - `MixinLockCore.approveBeneficiary`: `IERC20Upgradeable(tokenAddress).approve(_spender, _amount)`   ## Impact Tokens that return `false` on a failed `approve` or that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  The locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview: - key manager (map `keyManagerOf`) - single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf` - operator approvals (map `managerToOperatorApproved`)  The `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.  Notice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:  ```solidity function transferFrom(   address _from,   address _recipient,   uint _tokenId )   public   onlyIfAlive   hasValidKey(_from)   onlyKeyManagerOrApproved(_tokenId) {   // @audit this is skipped if user had a key that expired   if (toKey.tokenId == 0) {     toKey.tokenId = _tokenId;     _recordOwner(_recipient, _tokenId);     // Clear any previous approvals     _clearApproval(_tokenId);   }    if (previousExpiration <= block.timestamp) {     // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration     // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID     toKey.expirationTimestamp = fromKey.expirationTimestamp;     toKey.tokenId = _tokenId;      // Reset the key Manager to the key owner     // @audit  doesn't clear approval if key manager already was 0     _setKeyManagerOf(_tokenId, address(0));      _recordOwner(_recipient, _tokenId);   }   // ... }  //  function _setKeyManagerOf(   uint _tokenId,   address _keyManager ) internal {   // @audit-ok only clears approved if key manager updated   if(keyManagerOf[_tokenId] != _keyManager) {     keyManagerOf[_tokenId] = _keyManager;     _clearApproval(_tokenId);     emit KeyManagerChanged(_tokenId, address(0));   } } ```  ## Impact It's possible to sell someone a key and then claim it back as the approvals are not always cleared.  ## POC - Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future. - A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`. - A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom` - A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`. - A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.) - A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.  ## Recommended Mitigation Steps The `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types. The `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.   
# Handle  cmichel   # Vulnerability details  The `Unlock.setLockTemplate` function sets the default lock tempalte for new lock creations. However, it does not verify that this lock template is a valid template that was added to `_publicLockVersions` via `addLockTemplate`.  ## Impact A default template with a wrong version number can be set which is incompatible with updating locks through `upgradeLock` (requires `version == currentVersion + 1`).  ## Recommended Mitigation Steps Add new lock templates using `addLockTemplate` first and restrict `setLockTemplate` to only use these templates, not arbitrary code.   
# Handle  cmichel   # Vulnerability details  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter should checked for success.  See `Unlock.recordKeyPurchase` which performs ERC20 transfers without checking for the return value.  ## Impact As the trusted `udt` token is used which supposedly reverts on failed transfers, not checking the return value does not lead to any security issues. We still recommend checking it to abide by the EIP20 standard.  ## Recommended Mitigation Steps Consider using `require(IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward), "transfer failed")` instead.  
# Handle  kenzo   # Vulnerability details  `setLockTemplate` is initializing the new template using hardcoded values. This means that if a new lock version is set which has different/additional `initialize` parameters, Unlock protocol would have to be updated in order to initialize it.  ## Impact Less convenient adding of new locks as Unlock would have to be upgraded if their initialize function has changed.  ## Proof of Concept `setLockTemplate` uses the following code to initialize the template: ```     IPublicLock(_publicLockAddress).initialize(       address(this), 0, address(0), 0, 0, ''     ); ``` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L430:#L432 Which is hardcoded. This is unlike `createLock` for example, where the initialize call is being received as parameter, to allow different future versions. https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L219   ## Recommended Mitigation Steps Change `setLockTemplate` so the initializing parameters would be received as parameter.  
# Handle  elprofesor   # Vulnerability details  ## Impact `UnlockProtocol` attempts to calculate gas reimbursement using tx.gasprice, typically users who falsify tx.gasprice would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the tx.gasprice used. As the following calculation is made; ```     uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice; ```  we can see that arbitrary tx.gasprices can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.  ## Proof of Concept  ## Recommended Mitigation Steps Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact `maxTokens` in Unlock's `recordKeyPurchase` currently rounds more than is required.  ## Proof of Concept Plug the formula in Wolfgram Alpha to simplify from:  ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct; ```  to ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 * (valueInETH + grossNetworkProduct)); ```  Example inputs: ``` balance: 10000 price: 0.012345678912345678 gnp: 1000 + 0.012345678912345678 (for this purchase)  61728394561728390 old formula 61727632492197622 new formula (smaller than old) 61726870441482920.98 actual per wolfgram (smaller than new) 1524120245470 delta old - actual 762050714702 delta new - actual ```  The "new" formula proposed above is closer to the expected value. It's also easier to read and saves 123 gas.  ## Tools Used https://www.wolframalpha.com/  ## Recommended Mitigation Steps  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact KeyManagerChanged does not emit the new manager address as expected. Additionally there's a small gas savings of 1.5k gas by not emitting the event twice in `grantKeys`.  ## Proof of Concept Per the event param names, this event should emit the new keyManager's address. That would allow an indexer such as subgraph to track the current manager for each token. However the event currently emits address(0):  https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinKeys.sol#L229  Change that line to: `emit KeyManagerChanged(_tokenId, _keyManager);`  Additionally this line may be removed: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L48 as the call right before it to `_setKeyManagerOf` will emit the event already.  ## Tools Used `yarn test`  ## Recommended Mitigation Steps When testing this change only one test failed, and it was due to assuming the index of the event: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L80  It would be nice to be more robust like some other tests are, e.g. https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L49   Also add a test to confirm that the keyManager is emitting in the event.  Personally I like Waffle for testing events: https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html?highlight=emits#writing-tests  ```  it('Transfer emits event', async () => {     await expect(token.transfer(walletTo.address, 7))       .to.emit(token, 'Transfer')       .withArgs(wallet.address, walletTo.address, 7);   }); ```  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Wrong comment for withdraw(): modifier onlyLockManagerOrBeneficiary also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123)  Wrong comment for updateBeneficiary(): require statement also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189)  ## Recommended Mitigation Steps - Fix comments, because the implementation seems to be correct    
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact / POC  A single user can become the owner of multiple token ids and break the assumption of the comment [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181) of the function numberOfOwners() that it returns "total number of unique owners"   If a key manager/approved transfers a key with transferFrom() [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109) to a recipient that also owns a valid key then we don't go into the "if block" L131 and also not into the "if block" L138 (this is important s.t. no key owner change happens) and go into the "else block" L148 (not really important).   We end with: fromKey.expirationTimestamp = block.timestamp; and fromKey.tokenId = 0;  If the key owner or someone else buys for this key owner again a "key" [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51) satisfies the condition idTo ==0 (bcs of tokenId = 0) and in _assignNewTokenId(toKey); the key gets a new token id and the owner gets also registered as the new owner of the new token id in _recordOwner(_recipient, idTo);  The "old" key got overwritten but we are now the owner of two token ids.  This breaks the comment of numberOfOwners() that it returns "total number of unique owners" but for this the key owner that owns now two token ids, we executed "_recordOwner" twice and therefore added the same address twice to the owner array  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327)   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  - need to also implement the removal of ownership of a tokenId when it is set 0 zero to be congruent with the state of the key, and also adapt the other logic depending on it  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact Unimplemented calls do not revert, this may cause unexpected behavior in wallets or other contracts.  ## Proof of Concept Locks are ERC721s, they also implement some ERC20 style calls such as `transfer`. If a wallet or another contract attempted to treat the contract as a ERC77, `send` would incorrectly appear to work but nothing happens under the hood. It would be better if this call reverted so that the user was aware the function is not supported before even broadcasting the transaction (Metamask will warn you if estimate gas fails).  This test currently fails (i.e. calling send does not revert).  ```   it("Should fail on unknown calls", async () => {       const mock777 = await erc777.at(lock.address);       await reverts(         mock777.send(destination, 1, '0x', { from: singleKeyOwner })       )     }) ```  ## Tools Used `yarn test`  ## Recommended Mitigation Steps Remove this line https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/PublicLock.sol#L72  Per the comments there is not a clear reason it's currently included. The test suite still passes when it is removed.  
# Handle  HardlyDifficult   # Vulnerability details  ## Impact A contract implementing `ERC721TokenReceiver` is called with a tokenId that was not sent to that address when `shareKey` is used. If the `onERC721Received` implementation included any logic which assumed ownership it may fail, e.g. checking `ownerOf`, `balanceOf` or performing a task such as `transferFrom` to forward the asset to another destination.  ## Proof of Concept `shareKey` accepts a `_tokenId` as the source of expiration time to share. It then either mints a new token for the target account or adds time to their existing key. Either way the receiver has a different tokenId than the one that was passed to the `shareKey` function.  ## Tools Used n/a  ## Recommended Mitigation Steps Change https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinTransfer.sol#L106  from: `require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  to: `require(_checkOnERC721Received(keyOwner, _to, idTo, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  
# Handle  kenzo   # Vulnerability details  Unlock doesn't follow standard ERC721 log emittance. This leads to wrong display values regarding to the lock NFT on Etherscan.  ## Impact Etherscan does not show txs correctly, does not count token holders correctly in token page, does not count tokens correctly in user page.  ## Proof of Concept A scenario: - Create a new lock - User 1 mints 1 token - User 1 uses `shareKey` and transfers some amount to User 2 At this point Etherscan will show that 3 transfers have been made, under user 2's address page user 2 has 2 keys , and under lock's holders tab user 2 has 2 keys. All this is obviously wrong. This is probably because the transfer event is emitted twice during shareKey: [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L87) and [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L100).  Additionally, if user 1 now calls `Cancel And Refund`, user 1 will still have a key under his tokens in his account, and the lock's token page will still list him as a holder, and the transaction won't get shown in Etherscan's token transfers (unlike contract transactions). Probably because it has not emitted any burn event. It just emits a [CancelKey event](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L111).  ## Recommended Mitigation Steps You can align the logs emittance to match regular ERC721 logs if you'd like Etherscan to show correct amounts. It might get confusing to keep it like this.  
# Handle  kenzo   # Vulnerability details  If calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).  ## Impact A key manager or approved might accidently destroy user's token.  Note: this requires user error and so I'm not sure if this is a valid finding. However, few things make me think that it is valid: - Unlock protocol checks for transfer to 0-address, so some input validation is there - Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen. - This scenario manifests a unique and probably unintended behavior   ## Proof of Concept By following `transferFrom`'s execution: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166 One can see that in the case where `_from == _recipient` with a valid key: - The function will deduct transfer fee from the key - The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151)) - The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158)) Therefore, the user will lose his key without getting a refund.  ## Recommended Mitigation Steps Add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`  
# Handle  kenzo   # Vulnerability details  `_setKeyManagerOf` always emits `address(0)` as the new key manager.  ## Impact Wrong event emitted.  ## Proof of Concept The code is: `emit KeyManagerChanged(_tokenId, address(0));` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L229  ## Recommended Mitigation Steps Change line to `emit KeyManagerChanged(_tokenId, _keyManager);`  
# Handle  hagrid   # Vulnerability details  ## Details `UnlockDiscountTokenV2.sol` has override for `_afterTokenTransfer` handler function to control events or operations after token transfers. Also, the `UnlockDiscountTokenV2.sol` uses another token contracts from `ERC20Patched.sol`. In `ERC20Patched.sol` contract there are also `_beforeTokenTransfer` transfer handles. However, the `UnlockDiscountTokenV2.sol`  token does not have any override for `_beforeTokenTransfer` method.   ## Impact Contract will not react to any operations before token transfers. If gas calculations are aimed on UnlockToken's transfer, it will not be possible to calculate correct gas amounts without these both handlers (_beforeTokenTransfer and _afterTokenTransfer)  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Recommended Mitigation Steps Possible fix is implementing additional override for `_beforeTokenTransfer` method:  ```  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {     return ERC20VotesUpgradeable._beforeTokenTransfer(from, to, amount);   } ```  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability Description Some of the implemented functions inside the smart contracts are of type Public, However these functions are not used within the contracts. The function **tokenByIndex()** is part of the EIP721 which define it as external function.  ## Impact Coding style quality.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinERC721Enumerable.sol#L35  ## Tools Used manual code review.  ## Recommended Mitigation Steps Change the function to external and follow the ERC721 Specs when implementing: https://eips.ethereum.org/EIPS/eip-721#specification  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The function **updateBeneficiary** in the **MixinLockCore** smart contract is used to lets the owner of the lock update the beneficiary account which receives funds on withdrawal.   ## Impact Attackers can change the beneficiary address using this function before continue with the withdrawal function. Unlock protocol team and users can't log or monitor this critical changes.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinLockCore.sol#L192  ## Tools Used manual code review  ## Recommended Mitigation Steps define event and emit it to track changes done to the system.  
# Handle  harleythedog   # Vulnerability details  ## Impact The function computeAvailableDiscountFor is left unimplemented in Unlock.sol. Recommend implementing this function or removing it.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L269  ## Tools Used Inspection.  ## Recommended Mitigation Steps Implement function or remove it to save gas.  
# Handle  kenzo   # Vulnerability details  More keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.  ## Impact More keys can be minted than intended.  ## Proof of Concept In both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`. This is unlike `purchase`, which has the `notSoldOut` modifier. `grantKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42 `shareKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84 Both functions call `_assignNewTokenId` which does not check maxNumberOfKeys.  https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322 So you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).  ## Recommended Mitigation Steps Add a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.  
