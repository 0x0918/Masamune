## Low Risk Issues  ### Loans can be created and paid with non-existent/destructed tokens `@rari-capital/solmate/src/utils/SafeTransferLib.sol` has functions named similarly to functions that OpenZeppelin has, but they act differently. At the top of the file is the following comment: ```solidity /// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller. ``` https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/utils/SafeTransferLib.sol#L9  If the caller of these functions does not check that the token has code, calls to these functions will be no-ops, since low level calls to non-contracts always return success. There are many instances of these calls throughout the file with no code existence checks: ``` contracts/NFTLoanFacilitator.sol:155:            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount); contracts/NFTLoanFacilitator.sol:157:            ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:200:                ERC20(loanAssetContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:205:                ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:210:                ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:215:                ERC20(loan.loanAssetContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:241:        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); contracts/NFTLoanFacilitator.sol:242:        IERC721(loan.collateralContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:262:        IERC721(loan.collateralContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:297:        ERC20(asset).safeTransfer(to, amount); ```  ### `originationFeeRate`s of less than 1000 may charge no fees if amounts are small 1. File: contracts/NFTLoanFacilitator.sol (line [156](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L156)) ```solidity             uint256 facilitatorTake = amount * originationFeeRate / SCALAR; ``` Add a `require()` for `facilitatorTake` to be non-zero if `originationFeeRate` is non-zero, or state the fee logic for small amounts  ### A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum 1. File: contracts/NFTLoanFacilitator.sol (lines [306-312](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L306-L312)) ```solidity     function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%");                  originationFeeRate = _originationFeeRate;          emit UpdateOriginationFeeRate(_originationFeeRate);     } ``` Store the fee rate during loan creation, along with the maximum fee rate the user will allow, and update to the new rate for that particular loan only when loans are bought out  ### A malicious owner can set an effectively infinite improvement rate with `type(uint256).max` after he/she has entered into a loan to prevent others from buying them out 1. File: contracts/NFTLoanFacilitator.sol (lines [320-326](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L320-L326)) ```solidity     function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {         require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');          requiredImprovementRate = _improvementRate;          emit UpdateRequiredImprovementRate(_improvementRate);     } ``` Have a sane upper limit to the improvement rate, and don't allow it to change as above  ### `tokenURI()` reverts for tokens that don't implement `IERC20Metadata` While the ticket descriptors are not in scope, the code calling them is. `NFTLoanTicket.tokenURI()`, which is in scope, ends up calling descriptor code which casts the asset to `IERC20Metadata`. This interface is separate from `IERC20` because EIP-20 does not require those functions to exist. If a valid ERC20 token does not implement this interface, casting it and attempting to call non-existant functions will cause the code to revert, which will cause `tokenURI()` to revert. https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L65 https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L69 https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L83 Use [`safeDecimals()`](https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L33-L55) etc  ### `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both open [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function so that NFTs aren't lost if they're minted to contracts that cannot transfer them back out.  1. File: contracts/NFTLoanTicket.sol (line [34](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanTicket.sol#L34)) ```solidity         _mint(to, tokenId); ```  ### `loanFacilitatorTransfer()` does not verify that the receiver is capable of handling an NFT EIP-721 states: ```solidity     /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE     ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE     ///  THEY MAY BE PERMANENTLY LOST ``` https://github.com/ethereum/EIPs/blob/904be2534386631358766607f4a098e11a401e95/EIPS/eip-721.md?plain=1#L103-L105  The code below was copied from `transferFrom()`, so any function calling `_transfer()` needs to confirm that `to` is capable of receiving NFTs. `loanFacilitatorTransfer()` calls `_transfer()` without completing this check, which can lead to the loss of NFTs. Checking if the address is zero or not is not sufficient; it needs the other checks in [`safeTransferFrom()`](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L105-L110). 1. File: contracts/LendTicket.sol (lines [24-34](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/LendTicket.sol#L24-L34)) ```solidity     /// @dev exact copy of      /// https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L69-L96     /// with L78 - L81 removed to enable loanFacilitatorTransfer     function _transfer(         address from,         address to,         uint256 id     ) internal {         require(from == ownerOf[id], "WRONG_FROM");          require(to != address(0), "INVALID_RECIPIENT"); ```  ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: contracts/NFTLoanFacilitator.sol (line [282](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L282)) ```solidity         lendTicketContract = _contract; ``` 2. File: contracts/NFTLoanFacilitator.sol (line [292](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L292)) ```solidity         borrowTicketContract = _contract; ```  ## Non-critical Issues   ### `constant`s should be defined rather than using magic numbers  1. File: contracts/NFTLoanFacilitator.sol (line [307](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L307)) ```solidity         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%"); ``` 2. File: contracts/NFTLoanFacilitator.sol (line [384](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L384)) ```solidity             * (perAnumInterestRate * 1e18 / 365 days) ``` 3. File: contracts/NFTLoanFacilitator.sol (line [384](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L384)) ```solidity             * (perAnumInterestRate * 1e18 / 365 days) ``` 4. File: contracts/NFTLoanFacilitator.sol (line [385](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L385)) ```solidity             / 1e21 // SCALAR * 1e18 ```  ### Typos  1. File: contracts/NFTLoanFacilitator.sol (line [303](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L303)) ```solidity      * @notice Updates originationFeeRate the faciliator keeps of each loan amount ``` faciliator  2. File: contracts/interfaces/INFTLoanFacilitator.sol (line [65](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L65)) ```solidity      * @param minLoanAmount mimimum loan amount ``` mimimum   ### NatSpec is incomplete  1. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [286-288](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L286-L288)) ```solidity      * @param loanId The loan id      */     function totalOwed(uint256 loanId) view external returns (uint256); ``` Missing: `@return`   2. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [292-294](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L292-L294)) ```solidity      * @param loanId The loan id      */     function interestOwed(uint256 loanId) view external returns (uint256); ``` Missing: `@return`   3. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [298-300](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L298-L300)) ```solidity      * @param loanId The loan id      */     function loanEndSeconds(uint256 loanId) view external returns (uint256); ``` Missing: `@return`    ### Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  1. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [68-77](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L68-L77)) ```solidity     event CreateLoan(         uint256 indexed id,         address indexed minter,         uint256 collateralTokenId,         address collateralContract,         uint256 maxInterestRate,         address loanAssetContract,         uint256 minLoanAmount,         uint256 minDurationSeconds         ); ``` 2. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [93-99](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L93-L99)) ```solidity     event Lend(         uint256 indexed id,         address indexed lender,         uint256 interestRate,         uint256 loanAmount,         uint256 durationSeconds     ); ``` 3. File: contracts/interfaces/INFTLoanFacilitator.sol (line [145](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L145)) ```solidity      event WithdrawOriginationFees(address asset, uint256 amount, address to); ``` 4. File: contracts/interfaces/INFTLoanFacilitator.sol (line [152](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L152)) ```solidity      event UpdateOriginationFeeRate(uint32 feeRate); ``` 5. File: contracts/interfaces/INFTLoanFacilitator.sol (line [159](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L159)) ```solidity      event UpdateRequiredImprovementRate(uint256 improvementRate); ```
# QA Report  1. Immutable addresses should be 0-checked  Consider adding an `address(0)` check here:  ```solidity File: NFTLoanTicket.sol 20:     constructor( 21:         string memory name,  22:         string memory symbol,  23:         NFTLoanFacilitator _nftLoanFacilitator,  24:         NFTLoansTicketDescriptor _descriptor 25:     )  26:         ERC721(name, symbol)  27:     { 28:         nftLoanFacilitator = _nftLoanFacilitator;  //@audit low: should be 0 checked 29:         descriptor = _descriptor;  //@audit low: should be 0 checked 30:     } ```  2. `NFTLoanFacilitator.sol` uses `Ownable`'s default `transferOwnership()` instead of implementing a 2-step ownership transfer pattern  3. `renounceOwnership()` can be called in `NFTLoanFacilitator.sol`. Consider overriding the method to always keep an owner.  4. Comment says "private" instead of "internal" :  ```solidity File: NFTLoanFacilitator.sol 369:     // === private === //@audit should say internal 370:  371:     /// @dev Returns the total interest owed on loan 372:     function _interestOwed( 373:         uint256 loanAmount, 374:         uint256 lastAccumulatedTimestamp, 375:         uint256 perAnumInterestRate, 376:         uint256 accumulatedInterest 377:     )  378:         internal  379:         view  380:         returns (uint256)  381:     { ```  5. `onERC721Received` not implemented in `borrowTicketContract` (`BorrowTicket.sol`)  The `IERC721.safeTransferFrom` call will trigger `onERC721Received` here:  ```solidity File: NFTLoanFacilitator.sol 242:         IERC721(loan.collateralContractAddress).safeTransferFrom( 243:             address(this), 244:             IERC721(borrowTicketContract).ownerOf(loanId), 245:             loan.collateralTokenId 246:         ); ```  It must return its Solidity `selector` to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.  The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.  6. Code style: some strings are declared with `''`, others with `""`. I suggest only using one style.  Strings with `''`:  ``` contracts/NFTLoanFacilitator.sol:    81:         require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');    82:         require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');    84:         'NFTLoanFacilitator: cannot use tickets as collateral');    86:         'NFTLoanFacilitator: cannot use tickets as collateral');   146:             require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');   147:             require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');   148:             require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');   171:                 require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');   172:                 require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');   280:         require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');   290:         require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');   321:         require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); ```  Strings with `""`:  ``` contracts/LendTicket.sol:   32:         require(from == ownerOf[id], "WRONG_FROM");   34:         require(to != address(0), "INVALID_RECIPIENT");  contracts/NFTLoanFacilitator.sol:    53:         require(!loanInfo[loanId].closed, "NFTLoanFacilitator: loan closed");   118:         "NFTLoanFacilitator: borrow ticket holder only");   121:         require(loan.lastAccumulatedTimestamp == 0, "NFTLoanFacilitator: has lender, use repayAndCloseLoan");   144:             require(loanAssetContractAddress != address(0), "NFTLoanFacilitator: invalid loan");   178:                 "NFTLoanFacilitator: proposed terms must be better than existing terms");   189:             "NFTLoanFacilitator: accumulated interest exceeds uint128");   255:         "NFTLoanFacilitator: lend ticket holder only");   259:         "NFTLoanFacilitator: payment is not late");   307:         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%");   contracts/NFTLoanTicket.sol:   15:         require(msg.sender == address(nftLoanFacilitator), "NFTLoanTicket: only loan facilitator"); ``` 
Thanks for a very well documented and tested codebase.  Just one note to pass on here: there's a typo in the terms `maxPerAnumInterest` and `perAnumInterestRate`, which are used in a few places in the codebase. This should be "per annum" to mean "per year." (Or just consider "per year" or "annual" in English instead). The phrase "per anum" is a medical term that means something entirely different :)
# Gas optimization report  ## Keep revert strings below 32 bytes  Strings are stored in slots of 32 bytes, and hence the length of the revert string should be at max 32 bytes to fit inside 1 slot. If the string is just 33 bytes it will occupy 2 slots (64 bytes). Keeping the string size at 32 bytes or below will save gas on both deployment and when the revert condition is met.  Since the used version of Solidity is `>=0.8.4` it would also be worth considering using [Custom Errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) which is both more gas efficient and allows thorough error descriptions using [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html).  The relevant code:  ``` NFTLoanFacilitator.sol line 84:   "NFTLoanFacilitator: cannot use tickets as collateral" NFTLoanFacilitator.sol line 86:   "NFTLoanFacilitator: cannot use tickets as collateral" NFTLoanFacilitator.sol line 118:  "NFTLoanFacilitator: borrow ticket holder only" NFTLoanFacilitator.sol line 121:  "NFTLoanFacilitator: has lender, use repayAndCloseLoan" NFTLoanFacilitator.sol line 146:  "NFTLoanFacilitator: rate too high" NFTLoanFacilitator.sol line 147:  "NFTLoanFacilitator: duration too low" NFTLoanFacilitator.sol line 148:  "NFTLoanFacilitator: amount too low" NFTLoanFacilitator.sol line 171:  "NFTLoanFacilitator: rate too high" NFTLoanFacilitator.sol line 172:  "NFTLoanFacilitator: duration too low" NFTLoanFacilitator.sol line 178:  "NFTLoanFacilitator: proposed terms must be better than existing terms" NFTLoanFacilitator.sol line 189:  "NFTLoanFacilitator: accumulated interest exceeds uint128" NFTLoanFacilitator.sol line 255:  "NFTLoanFacilitator: lend ticket holder only" NFTLoanFacilitator.sol line 259:  "NFTLoanFacilitator: payment is not late" NFTLoanFacilitator.sol line 321:  "NFTLoanFacilitator: 0 improvement rate" NFTLoanFacilitator.sol line 86:  NFTLoanTicket.sol line 15:        "NFTLoanTicket: only loan facilitator" ```  ## Cache loanAmount  In the following code the variable `loanInfo[loanId].loanAmount` is read from storage 3 times (see audit-info comments), and hence should be cached so it is only read from storage once.  ```solidity function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];          uint256 interest = _interestOwed(             loan.loanAmount, @audit-info SLOAD1             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); @audit-info SLOAD2         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );          emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); @audit-info SLOAD3         emit Close(loanId);     } ```  Change this into   ```solidity function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];         uint128 loanAmount = loan.loanAmount;          uint256 interest = _interestOwed(             loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );          emit Repay(loanId, msg.sender, lender, interest, loanAmount);         emit Close(loanId);     } ```  The change is passing the provided test suite, and the `.gas-snapshot` reflected the change by reducing the gas costs from:  ```solidity NFTLoanFacilitatorGasBenchMarkTest:testRepayAndClose() (gas: 81320 -> 81064) NFTLoanFacilitatorTest:testRepayAndCloseSuccessful() (gas: 447725 -> 447469) NFTLoanFacilitatorTest:testRepayInterestOwedExceedingUint128() (gas: 465901 -> 465645) ```
Summary: The codebase and security practices are well implemented, with no comments on that apart from some low and non-critical findings.    Low  findings :   [N01]  Inconsistent use of safeTransferFrom and transferFrom for ERC721:  NFTLoanFacilitator.sol uses both,  for example in line 88 it uses transferFrom and in line 242 it uses safeTransferFrom.  It is a bit confusing for the reader the intentions of using the 2 of them in the same contract. Try to choose one of them for better consistency in the code.   [N02] Leap-years considerations  The function _interestOwed in line 372 of NFTLoanFacilitator.sol calculates interest always considering a year like 365 days. Try 36525 instead for more precision and multiply the numerator by 100.     Non-critical findings:    [N03] Confusing comment  In line 164 of NFTLoanFacilitator.sol there is a confusing or maybe incomplete comment. Since solidity 0.8 underflows and overflows reverts, so consider adding to the comment that the operation will throw an error. The comment just says "will underflow if amount < previousAmount".    
# Use private variables to save gas  Those can be declared as private for gas savings, only creating view functions for variables that should be read externally.  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L17-L44  ## Recommendation  Declare these variables to private.   # Fetch loan fields into memory to save gas  If storage is accessed more than once, it should be fetch into memory to save gas. `loan.lastAccumulatedTimestamp` is accessed twice in `totalOwed` and `interestOwed`  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L339  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L343  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L352  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L356   ## Recommendation  Fetch loan.lastAccumulatedTimestamp into memory  `uint40 lastAccumulatedTimestamp = loan.lastAccumulatedTimestamp;` 
# Summary  We list 2 non-critical findings here:  * (Non) loanEndSeconds does not check valid loanId * (Non) Should use safe version of ERC721 functions  In conclusion, it's better to check the validity of the mapping’s key. And using a safe version of ERC721 functions is usually a better choice.  # (Non) loanEndSeconds does not check valid loanId ## Impact  In `NFTLoanFacilitator.sol/loanEndSeconds()`, it doesn’t check whether loanId is valid  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L363  ## Recommended Mitigation Steps  Add check for loanId # (Non) Should use safe version of ERC721 functions  ## Impact  In `NFTLoanFacilitator.sol`, it uses `IERC721Mintable(borrowTicketContract).mint` which is not a good practice.  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L102  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L161   ## Recommended Mitigation Steps  Use `safeMint` instead of `mint` 
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.  ## Proof of Concept  1. A victim calls `lend()`, trying to buyout the loan of the attacker. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. If the `transfer` of `loanAssetContractAddress` is ERC777, it will call `_callTokensReceived` that the attacker can manipulate and always revert it. 4. Because `NFTLoanFacilitator` uses `safeTransfer` and `safeTransferFrom` to check return value, the transaction of the victim will also be reverted. It makes anyone can not buyout the loan of the attacker.  In `_callTokensReceived`, the attacker just wants to revert the buyout transaction, but keep `repayAndCloseLoan` successful. The attacker can call `loanInfoStruct(uint256 loanId)` in `_callTokensReceived` to check if the value of `loanInfo` is changed or not to decide to revert it.  ## Tools Used  vim  ## Recommended Mitigation Steps  Don't transfer `ERC20(loanAssetContractAddress)` to `currentLoanOwner` in `lend()`, use a global mapping to record redemption of lenders and add an external function `redeem` for lenders to transfer `ERC20(loanAssetContractAddress)`.   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of `lendInfo` (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.  ## Proof of Concept  An attacker lends a loan, and `loanAssetContractAddress` in `loanInfo` is ERC777 which is suffering from reentrancy attack. When a lender (victim) try to buyout the loan of the attacker:  1. The victim called `lend()`. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. The `transfer` of `loanAssetContractAddress` ERC777 will call `_callTokensReceived` so that the attacker can call `lend()` again in reentrancy with parameters:     * loanId: same loan Id     * interestRate: set to bad value (e.g. 0)     * amount: same amount     * durationSeconds: set to bad value (e.g. a long durationSeconds)     * sendLendTicketTo: same address of the attacker (`currentLoanOwner`) 4. Now the variables in `loanInfo` are changed to bad value, and the victim will get the lend ticket but the loan term is manipulated, and can not set it back (because it requires a better term).  ## Tools Used  vim  ## Recommended Mitigation Steps  Use `nonReentrant` modifier on `lend()` to prevent reentrancy attack:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L214-L221 https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L230-L250   # Vulnerability details  ## Impact If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.  ## Proof of Concept This exploit requires that the `loanAssetContractAddress` token transfers control to the receiver.  ### Steps of exploit:  - Borrower creates loan with `createLoan()`. - The same Borrower calls `lend()`, funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself. - A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower). - Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call `repayAndCloseLoan()` before the lend ticket is transferred to the new lender.  The following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.  ```             } else {                 ERC20(loan.loanAssetContractAddress).safeTransferFrom(                     msg.sender,                     currentLoanOwner,                     accumulatedInterest + previousLoanAmount                 );             }             ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId); ```  The original lender/borrower calls the following `repayAndCloseLoan()` function so that they receive their collateral NFT from the protocol.  ```     function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];           uint256 interest = _interestOwed(             loan.loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );           emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);         emit Close(loanId);     } ```  Finally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely.  If desired, also require that the lender cannot be the same account as the borrower of a loan.  
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179   # Vulnerability details   https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179  ```solidity {     uint256 previousInterestRate = loan.perAnumInterestRate;     uint256 previousDurationSeconds = loan.durationSeconds;      require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');     require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');      require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease     || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds      || (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),      "NFTLoanFacilitator: proposed terms must be better than existing terms"); } ```  The `requiredImprovementRate` represents the percentage of improvement required of at least one of the terms when buying out from a previous lender.  However, when `previousInterestRate` is less than `10` and `requiredImprovementRate` is `100`, due to precision loss, the new `interestRate` is allowed to be the same as the previous one.  Making such an expected constraint absent.  ### PoC  1. Alice `createLoan()` with `maxPerAnumInterest` = 10, received `loanId` = 1 2. Bob `lend()` with `interestRate` = 9  for `loanId` = 1 3. Charlie `lend()` with `interestRate` = 9 (and all the same other terms with Bob) and buys out `loanId` = 1  Charlie is expected to provide at least 10% better terms, but actually bought out Bob with the same terms.  ### Recommendation  Consider using: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/math/Math.sol#L39-L42  And change the check to:  ```solidity (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR) >= interestRate) ```   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L155-L160   # Vulnerability details  ## Impact Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.  It is my belief that this is a medium severity vulnerability due to its ability to impact core protocol functionality.  ## Proof of Concept  For the first lender to call `lend()`, if the transfer fee % of the asset token is larger than the origination fee %, the second transfer will fail in the following code:  ```             ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);             uint256 facilitatorTake = amount * originationFeeRate / SCALAR;             ERC20(loanAssetContractAddress).safeTransfer(                 IERC721(borrowTicketContract).ownerOf(loanId),                 amount - facilitatorTake             ); ```  Example: - `originationFee = 2%` Max fee is 5% per comments - `feeOnTransfer = 3%` - `amount = 100 tokens`  - Lender transfers `amount` - `NFTLoanFacilitator` receives `97`. - `facilitatorTake = 2` - `NFTLoanFacilitator` attempts to send `100 - 2` to borrower, but only has `97`. - Execution reverts.  ### Other considerations: If the originationFee is less than or equal to the transferFee, the transfers will succeed but will be received at a loss for the borrower and lender. Specifically for the lender, it might be unwanted functionality for a lender to lend 100 and receive 97 following a successful repayment (excluding interest for this example).  ## Tools Used Manual review.  ## Recommended Mitigation Steps Since the `originationFee` is calculated based on the `amount` sent by the lender, this calculation will always underflow given the example above. Instead, a potential solution would be to calculate the `originationFee` based on the requested loan amount, allowing the lender to send a greater value so that `feeOnTransfer <= originationFee`.  Oppositely, the protocol can instead calculate the amount received from the initial transfer and use this amount to calculate the `originationFee`. The issue with this option is that the borrower will receive less than the desired loan amount.  
The overall Backed codebase quality is good. Functionalities are very well documented; explanatory comments are well placed. State changing functions follow the Checks-Effects-Interactions pattern and properly validate inputs. Tests are comprehensive.  The permissionless nature of the system allows anyone to use malicious NFTs/collaterals in the system to trick users or cause irregular states. Consider applying a guarded launch approach by having a whitelist—or alternatively—a blacklist for certain NFTs/collaterals. It can be deactivated after the protocol has been sufficiently battle-tested in production.  ## Low Risk Vulnerabilities ### 1. Missing sanity check on `minDurationSeconds` Mistakenly inputting a very low value of `minDurationSeconds` when [creating a loan](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L81) could lead to the NFT being lent and seized before the borrower is able to react.  **Mitigation**  Consider adding a reasonable minimum duration check when creating a loan.      ### 2. Missing `safeTransferFrom` in `closeLoan` Unlike seizeCollateral which implements `safeTransferFrom`, [closeLoan](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L124) only uses `safeTransfer` which could lead to irregular state for contract recipient.  **Mitigation**  Recommend using `safeTransferFrom` to transfer out the NFT when closing loan.  ### 3. Unclear `updateRequiredImprovementRate`  example [Comments](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L316) on updateRequiredImprovementRate stated that `E.g. setting this value to 10` would set improvement rate to 10%, while in reality inputting `10`  would set the rate to 1%.  **Mitigation**  Consider updating the comment example to include the scale calculation.  ### 4. Missing support for legacy NFTs Popular legacy NFT like CryptoPunks (which is used as the mock NFT when running tests) doesn't conform to ERC721 standard, which will exclude them from being able to be loaned.  **Mitigation**  Consider adding a transfer module or utility function that could handle transferring of non-standard ERC721 NFTs.   ## Non Critical Vulnerabilities ### 1. Redundant variable naming Redundant variable names `collateralContractAddress` and `loanAssetContractAddress` make the code less readable. Consider removing the `ContractAddress` as the type and name already imply it is a contract address.
# Backed Contest April 06, 2022  @securerodd # ## Gas Optimizations ### 1. != 0 Instead of > 0 in Require Statement  Contract: `NFTLoanFacilitator.sol`   Function: `updateRequiredImprovementRate(uint256 _improvementRate)`   Code: `require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');` Gas: testUpdateRequiredImprovementRateRevertsIf0() (gas: 13310)   Recommended Code: `require(_improvementRate != 0, 'NFTLoanFacilitator: 0 improvement rate');` Gas: testUpdateRequiredImprovementRateRevertsIf0() (gas: 13304) 
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L144   # Vulnerability details  ## Impact  Backed uses `solmate`'s `SafeTransferLib` to safely transfer non-standard ERC20 tokens:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L5  Notably, `SafeTransferLib` does not revert if the token being transferred has no code at all:  https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/utils/SafeTransferLib.sol#L9  This means transferring `address(0)` as a token will succeed, which could confuse users. As a result, Backed checks that the token is not `address(0)` on this line:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L144  However, this check is insufficient to protect users from accidentally creating loans with invalid tokens, as any address without code will be accepted as a valid token. One particularly consequential example of how this could go wrong for users would be inputting the address of a common token like DAI or USDC for another network on accident, but having the loan creation succeed as if it was the correct token. See the proof of concept for more details:  ## Proof of Concept  - Alice wants to create a DAI loan on Ethereum - Alice googles the DAI address and mistakenly copies the address of DAI on Optimism - Alice creates a the loan using Optimistic DAI and it succeeds - Alice is annoyed and confused why no one is lending to her - Alice closes the loan in anger and does not return to use Backed protocol  ## Recommended Mitigation Steps  Rewrite the require like so:  ```solidity    require(loanAssetContractAddress.code.length != 0, "NFTLoanFacilitator: invalid loan"); ```  
Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               NFTLoanTicket.constructor (name)         NFTLoanTicket.constructor (symbol)    Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: NFTLoanFacilitator.sol, In line 258, Require message length to shorten: 39, The message: NFTLoanFacilitator: payment is not late         Solidity file: NFTLoanFacilitator.sol, In line 82, Require message length to shorten: 33, The message: NFTLoanFacilitator: 0 loan amount         Solidity file: NFTLoanFacilitator.sol, In line 321, Require message length to shorten: 38, The message: NFTLoanFacilitator: 0 improvement rate    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           NFTLoanFacilitator.sol, 321: change '_improvementRate > 0' to '_improvementRate != 0'    Title: Storage double reading. Could save SLOAD Severity: GAS  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           NFTLoanFacilitator.sol: originationFeeRate is read twice in lend   Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          LendTicket.sol, _transfer         NFTLoanFacilitator.sol, _interestOwed    Title: Unnecessary constructor Severity: GAS  The following constructors are empty.      (A similar issue https://github.com/code-423n4/2021-11-fei-findings/issues/12)              LendTicket.sol.constructor         BorrowTicket.sol.constructor    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          NFTLoanFacilitator.sol (L#382) - return loanAmount * (block.timestamp - lastAccumulatedTimestamp) * (perAnumInterestRate * 1e18 / 365 days) / 1e21 + accumulatedInterest;         NFTLoanFacilitator.sol (L#258) - require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp, "NFTLoanFacilitator: payment is not late");     Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In NFTLoanFacilitator.sol,rearranging the storage fields can optimize to: 6 slots from: 7 slots. The new order of types (you choose the actual variables):         1. uint256         2. uint256         3. uint256         4. uint256         5. address         6. uint8         7. address     Title: Change transferFrom to transfer Severity: GAS  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.          NFTLoanFacilitator.sol, 124 : IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               LendTicket.sol, _transfer    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               NFTLoanFacilitator.sol, _interestOwed, { return loanAmount * (block.timestamp - lastAccumulatedTimestamp) * (perAnumInterestRate * 1e18 / 365 days) / 1e21 // SCALAR * 1e18 + accumulatedInterest; }    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           NFTLoanTicket.sol, tokenURI
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L309   # Vulnerability details  ## Impact Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in `createLoan`, they only receive `(1 - originationFee) * minLoanAmount`, see [`lend`](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L159). Therefore, they need to precalculate the `minLoanAmount` using the **current** origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.  ## Recommended Mitigation Steps Reconsider how the min loan amount works. Imo, this `minLoanAmount` should be the post-fee amount, not the pre-fee amount. It's also more intuitive for the borrower when creating the loan.   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L241   # Vulnerability details  ## Impact The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use `closeLoan` in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.  It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where `interest` will be a high value accumulated from timestamp 0 and the `loan.loanAmount` is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).  ## Recommended Mitigation Steps Add a check that there actually is something to repay.  ```solidity require(loan.lastAccumulatedTimestamp > 0, "loan was never matched by a lender. use closeLoan instead"); ```   
## Inefficient safe cast  A safe cast check is done here:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L188  The check uses `<=`, which compiles down to 2 opcodes (`ISZERO`, `GT`). This check can be done in a single opcode like so:  ```solidity require(accumulatedInterest < 1 << 128, "NFTLoanFacilitator: accumulated interest exceeds uint128"); ```  because `1 << 128` is equivalent to `2 ** 128` which is equal to `type(uin128).max + 1`  ## Unnecessary ownerOf check  A check that the `from` address equals `ownerOf[id]` is performed here:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/LendTicket.sol#L32  This is unnecessary as the only place where the internal `_transfer` is ever called (via the access controlled public version: `loanFacilitatorTransfer`) will only ever pass the owner of the token as ensured by this line:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L197  Therefore the check can be removed to save an SLOAD.
# Gas Report **Table of Contents:** - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Storage](#storage)       - [Caching storage values in memory](#caching-storage-values-in-memory)     - [Comparisons](#comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [Arithmetics](#arithmetics)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Visibility](#visibility)       - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings ### Storage  #### Caching storage values in memory The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):  ```solidity contracts/NFTLoanFacilitator.sol:   174:                 require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease //@audit gas: should cache requiredImprovementRate   175:                 || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds   //@audit gas: should use cached requiredImprovementRate   176                  || (previousInterestRate != 0 // do not allow rate improvement if rate already 0   177:                     && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), //@audit gas: should use cached requiredImprovementRate      231          Loan storage loan = loanInfo[loanId];   232     233          uint256 interest = _interestOwed(   234:             loan.loanAmount, //@audit gas: should cache loan.loanAmount   235              loan.lastAccumulatedTimestamp,   236              loan.perAnumInterestRate,   237              loan.accumulatedInterest   238          );   239          address lender = IERC721(lendTicketContract).ownerOf(loanId);   240          loan.closed = true;   241:         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); //@audit gas: should use cached loan.loanAmount   242          IERC721(loan.collateralContractAddress).safeTransferFrom(   243              address(this),   244              IERC721(borrowTicketContract).ownerOf(loanId),   245              loan.collateralTokenId   246          );   247     248:         emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); //@audit gas: should use cached loan.loanAmount   249          emit Close(loanId);   250      }    338          Loan storage loan = loanInfo[loanId];   339          if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;   340     341:         return loanInfo[loanId].loanAmount + _interestOwed( //@audit gas: should use loan.loanAmount instead of loanInfo[loanId].loanAmount   342              loan.loanAmount,   343              loan.lastAccumulatedTimestamp,   344              loan.perAnumInterestRate,   345              loan.accumulatedInterest   346          ); ```  ### Comparisons  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof) `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: https://twitter.com/gzeon/status/1485428085885640706  I suggest changing `> 0` with `!= 0` here: ```solidity NFTLoanFacilitator.sol:321:        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); ```  Also, please enable the Optimizer.  ### Arithmetics    #### `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:   ```solidity LendTicket.sol:39:            balanceOf[from]--; LendTicket.sol:41:            balanceOf[to]++; ```   I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  #### Unchecking arithmetics operations that can't underflow/overflow Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity contracts/NFTLoanFacilitator.sol:   156              uint256 facilitatorTake = amount * originationFeeRate / SCALAR;   157              ERC20(loanAssetContractAddress).safeTransfer(   158                  IERC721(borrowTicketContract).ownerOf(loanId),   159:                 amount - facilitatorTake //@audit gas: should be unchecked as facilitatorTake is < amount and can't underflow L156 (originationFeeRate is upper bounded and always < SCALAR)    209                  uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);   210                  ERC20(loanAssetContractAddress).safeTransfer(   211                      IERC721(borrowTicketContract).ownerOf(loanId),   212:                     amountIncrease - facilitatorTake //@audit gas: should be unchecked as facilitatorTake is < amount and can't underflow L209 (originationFeeRate is upper bounded and always < SCALAR) ``` ### Visibility  #### Consider making some constants as non-public to save gas Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here: ```solidity NFTLoanFacilitator.sol:21:    uint8 public constant override INTEREST_RATE_DECIMALS = 3; NFTLoanFacilitator.sol:24:    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS; ```  ### Errors  #### Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.   Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   Revert strings > 32 bytes:   ```solidity NFTLoanFacilitator.sol:118:        "NFTLoanFacilitator: borrow ticket holder only"); NFTLoanFacilitator.sol:121:        require(loan.lastAccumulatedTimestamp == 0, "NFTLoanFacilitator: has lender, use repayAndCloseLoan"); NFTLoanFacilitator.sol:178:                "NFTLoanFacilitator: proposed terms must be better than existing terms"); NFTLoanFacilitator.sol:189:            "NFTLoanFacilitator: accumulated interest exceeds uint128"); NFTLoanFacilitator.sol:255:        "NFTLoanFacilitator: lend ticket holder only"); NFTLoanFacilitator.sol:259:        "NFTLoanFacilitator: payment is not late"); NFTLoanTicket.sol:15:        require(msg.sender == address(nftLoanFacilitator), "NFTLoanTicket: only loan facilitator");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```solidity LendTicket.sol:32:        require(from == ownerOf[id], "WRONG_FROM"); LendTicket.sol:34:        require(to != address(0), "INVALID_RECIPIENT"); NFTLoanFacilitator.sol:53:        require(!loanInfo[loanId].closed, "NFTLoanFacilitator: loan closed"); NFTLoanFacilitator.sol:81:        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration'); NFTLoanFacilitator.sol:82:        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount'); NFTLoanFacilitator.sol:83:        require(collateralContractAddress != lendTicketContract, NFTLoanFacilitator.sol:85:        require(collateralContractAddress != borrowTicketContract,  NFTLoanFacilitator.sol:117:        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender, NFTLoanFacilitator.sol:121:        require(loan.lastAccumulatedTimestamp == 0, "NFTLoanFacilitator: has lender, use repayAndCloseLoan"); NFTLoanFacilitator.sol:144:            require(loanAssetContractAddress != address(0), "NFTLoanFacilitator: invalid loan"); NFTLoanFacilitator.sol:146:            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high'); NFTLoanFacilitator.sol:147:            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low'); NFTLoanFacilitator.sol:148:            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low'); NFTLoanFacilitator.sol:171:                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high'); NFTLoanFacilitator.sol:172:                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low'); NFTLoanFacilitator.sol:174:                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease NFTLoanFacilitator.sol:188:            require(accumulatedInterest <= type(uint128).max, NFTLoanFacilitator.sol:254:        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender,  NFTLoanFacilitator.sol:258:        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp, NFTLoanFacilitator.sol:280:        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set'); NFTLoanFacilitator.sol:290:        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set'); NFTLoanFacilitator.sol:307:        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%"); NFTLoanFacilitator.sol:321:        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); NFTLoanTicket.sol:15:        require(msg.sender == address(nftLoanFacilitator), "NFTLoanTicket: only loan facilitator"); ```  I suggest replacing revert strings with custom errors.
-- 1  All functions that receive uints which are not uint256 could be changed to uint256 and only casted to the intended size when storing it.  More info at: https://github.com/ourzora/v3/pull/125#issuecomment-1034238815  Just swapped the `lend()` function and consequent related tests resulting in: ```(...) Overall gas change: -11839 (-0.041%)``` But there are many other functions (eg. `createLoan`) which could use such change, so the gas saving should be way more than that.  -- 2 cache `borrowTicketContract` at `createLoan` to save one SLOAD on a successful transaction.  -- 3 use cached `previousInterestRate` on calling `_interestOwed`  Overall gas change: -60 (-0.000%)  ```diff diff --git a/contracts/NFTLoanFacilitator.sol b/contracts/NFTLoanFacilitator.sol index 46d6ef5..bb25958 100644 --- a/contracts/NFTLoanFacilitator.sol +++ b/contracts/NFTLoanFacilitator.sol @@ -165,6 +165,7 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {              // will underflow if amount < previousAmount              uint256 amountIncrease = amount - previousLoanAmount;   +            uint256 accumulatedInterest;              {                  uint256 previousInterestRate = loan.perAnumInterestRate;                  uint256 previousDurationSeconds = loan.durationSeconds; @@ -177,14 +178,14 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {                  || (previousInterestRate != 0 // do not allow rate improvement if rate already 0                      && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),                   "NFTLoanFacilitator: proposed terms must be better than existing terms"); -            }   -            uint256 accumulatedInterest = _interestOwed( -                previousLoanAmount, -                loan.lastAccumulatedTimestamp, -                loan.perAnumInterestRate, -                loan.accumulatedInterest -            ); +                 = _interestOwed( +                    previousLoanAmount, +                    loan.lastAccumulatedTimestamp, +                    previousInterestRate, +                    loan.accumulatedInterest +                ); +            }              require(accumulatedInterest <= type(uint128).max,              "NFTLoanFacilitator: accumulated interest exceeds uint128"); ```  -- 4  cache `loan.loanAmount` on `repayAndCloseLoan`  ``` testRepayInterestOwedExceedingUint128() (gas: -253 (-0.001%))  testRepayAndCloseSuccessful() (gas: -253 (-0.001%))  testRepayAndClose() (gas: -253 (-0.003%))  Overall gas change: -759 (-0.004%) ``` ```diff diff --git a/contracts/NFTLoanFacilitator.sol b/contracts/NFTLoanFacilitator.sol index f1f570f..ff2e3f7 100644 --- a/contracts/NFTLoanFacilitator.sol +++ b/contracts/NFTLoanFacilitator.sol @@ -231,23 +231,24 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {      /// See {INFTLoanFacilitator-repayAndCloseLoan}.      function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {          Loan storage loan = loanInfo[loanId]; +        uint256 _loanAmount = loan.loanAmount;            uint256 interest = _interestOwed( -            loan.loanAmount, +            _loanAmount,              loan.lastAccumulatedTimestamp,              loan.perAnumInterestRate,              loan.accumulatedInterest          );          address lender = IERC721(lendTicketContract).ownerOf(loanId);          loan.closed = true; -        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); +        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + _loanAmount);          IERC721(loan.collateralContractAddress).safeTransferFrom(              address(this),              IERC721(borrowTicketContract).ownerOf(loanId),              loan.collateralTokenId          );   -        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); +        emit Repay(loanId, msg.sender, lender, interest, _loanAmount);          emit Close(loanId);      } ```
## Low Risk Issues  ### Loans can be created and paid with non-existent/destructed tokens `@rari-capital/solmate/src/utils/SafeTransferLib.sol` has functions named similarly to functions that OpenZeppelin has, but they act differently. At the top of the file is the following comment: ```solidity /// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller. ``` https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/utils/SafeTransferLib.sol#L9  If the caller of these functions does not check that the token has code, calls to these functions will be no-ops, since low level calls to non-contracts always return success. There are many instances of these calls throughout the file with no code existence checks: ``` contracts/NFTLoanFacilitator.sol:155:            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount); contracts/NFTLoanFacilitator.sol:157:            ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:200:                ERC20(loanAssetContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:205:                ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:210:                ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:215:                ERC20(loan.loanAssetContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:241:        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); contracts/NFTLoanFacilitator.sol:242:        IERC721(loan.collateralContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:262:        IERC721(loan.collateralContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:297:        ERC20(asset).safeTransfer(to, amount); ```  ### `originationFeeRate`s of less than 1000 may charge no fees if amounts are small 1. File: contracts/NFTLoanFacilitator.sol (line [156](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L156)) ```solidity             uint256 facilitatorTake = amount * originationFeeRate / SCALAR; ``` Add a `require()` for `facilitatorTake` to be non-zero if `originationFeeRate` is non-zero, or state the fee logic for small amounts  ### A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum 1. File: contracts/NFTLoanFacilitator.sol (lines [306-312](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L306-L312)) ```solidity     function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%");                  originationFeeRate = _originationFeeRate;          emit UpdateOriginationFeeRate(_originationFeeRate);     } ``` Store the fee rate during loan creation, along with the maximum fee rate the user will allow, and update to the new rate for that particular loan only when loans are bought out  ### A malicious owner can set an effectively infinite improvement rate with `type(uint256).max` after he/she has entered into a loan to prevent others from buying them out 1. File: contracts/NFTLoanFacilitator.sol (lines [320-326](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L320-L326)) ```solidity     function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {         require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');          requiredImprovementRate = _improvementRate;          emit UpdateRequiredImprovementRate(_improvementRate);     } ``` Have a sane upper limit to the improvement rate, and don't allow it to change as above  ### `tokenURI()` reverts for tokens that don't implement `IERC20Metadata` While the ticket descriptors are not in scope, the code calling them is. `NFTLoanTicket.tokenURI()`, which is in scope, ends up calling descriptor code which casts the asset to `IERC20Metadata`. This interface is separate from `IERC20` because EIP-20 does not require those functions to exist. If a valid ERC20 token does not implement this interface, casting it and attempting to call non-existant functions will cause the code to revert, which will cause `tokenURI()` to revert. https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L65 https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L69 https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L83 Use [`safeDecimals()`](https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L33-L55) etc  ### `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both open [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function so that NFTs aren't lost if they're minted to contracts that cannot transfer them back out.  1. File: contracts/NFTLoanTicket.sol (line [34](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanTicket.sol#L34)) ```solidity         _mint(to, tokenId); ```  ### `loanFacilitatorTransfer()` does not verify that the receiver is capable of handling an NFT EIP-721 states: ```solidity     /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE     ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE     ///  THEY MAY BE PERMANENTLY LOST ``` https://github.com/ethereum/EIPs/blob/904be2534386631358766607f4a098e11a401e95/EIPS/eip-721.md?plain=1#L103-L105  The code below was copied from `transferFrom()`, so any function calling `_transfer()` needs to confirm that `to` is capable of receiving NFTs. `loanFacilitatorTransfer()` calls `_transfer()` without completing this check, which can lead to the loss of NFTs. Checking if the address is zero or not is not sufficient; it needs the other checks in [`safeTransferFrom()`](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L105-L110). 1. File: contracts/LendTicket.sol (lines [24-34](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/LendTicket.sol#L24-L34)) ```solidity     /// @dev exact copy of      /// https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L69-L96     /// with L78 - L81 removed to enable loanFacilitatorTransfer     function _transfer(         address from,         address to,         uint256 id     ) internal {         require(from == ownerOf[id], "WRONG_FROM");          require(to != address(0), "INVALID_RECIPIENT"); ```  ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: contracts/NFTLoanFacilitator.sol (line [282](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L282)) ```solidity         lendTicketContract = _contract; ``` 2. File: contracts/NFTLoanFacilitator.sol (line [292](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L292)) ```solidity         borrowTicketContract = _contract; ```  ## Non-critical Issues   ### `constant`s should be defined rather than using magic numbers  1. File: contracts/NFTLoanFacilitator.sol (line [307](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L307)) ```solidity         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%"); ``` 2. File: contracts/NFTLoanFacilitator.sol (line [384](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L384)) ```solidity             * (perAnumInterestRate * 1e18 / 365 days) ``` 3. File: contracts/NFTLoanFacilitator.sol (line [384](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L384)) ```solidity             * (perAnumInterestRate * 1e18 / 365 days) ``` 4. File: contracts/NFTLoanFacilitator.sol (line [385](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L385)) ```solidity             / 1e21 // SCALAR * 1e18 ```  ### Typos  1. File: contracts/NFTLoanFacilitator.sol (line [303](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L303)) ```solidity      * @notice Updates originationFeeRate the faciliator keeps of each loan amount ``` faciliator  2. File: contracts/interfaces/INFTLoanFacilitator.sol (line [65](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L65)) ```solidity      * @param minLoanAmount mimimum loan amount ``` mimimum   ### NatSpec is incomplete  1. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [286-288](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L286-L288)) ```solidity      * @param loanId The loan id      */     function totalOwed(uint256 loanId) view external returns (uint256); ``` Missing: `@return`   2. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [292-294](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L292-L294)) ```solidity      * @param loanId The loan id      */     function interestOwed(uint256 loanId) view external returns (uint256); ``` Missing: `@return`   3. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [298-300](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L298-L300)) ```solidity      * @param loanId The loan id      */     function loanEndSeconds(uint256 loanId) view external returns (uint256); ``` Missing: `@return`    ### Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  1. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [68-77](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L68-L77)) ```solidity     event CreateLoan(         uint256 indexed id,         address indexed minter,         uint256 collateralTokenId,         address collateralContract,         uint256 maxInterestRate,         address loanAssetContract,         uint256 minLoanAmount,         uint256 minDurationSeconds         ); ``` 2. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [93-99](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L93-L99)) ```solidity     event Lend(         uint256 indexed id,         address indexed lender,         uint256 interestRate,         uint256 loanAmount,         uint256 durationSeconds     ); ``` 3. File: contracts/interfaces/INFTLoanFacilitator.sol (line [145](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L145)) ```solidity      event WithdrawOriginationFees(address asset, uint256 amount, address to); ``` 4. File: contracts/interfaces/INFTLoanFacilitator.sol (line [152](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L152)) ```solidity      event UpdateOriginationFeeRate(uint32 feeRate); ``` 5. File: contracts/interfaces/INFTLoanFacilitator.sol (line [159](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L159)) ```solidity      event UpdateRequiredImprovementRate(uint256 improvementRate); ```
# QA Report  1. Immutable addresses should be 0-checked  Consider adding an `address(0)` check here:  ```solidity File: NFTLoanTicket.sol 20:     constructor( 21:         string memory name,  22:         string memory symbol,  23:         NFTLoanFacilitator _nftLoanFacilitator,  24:         NFTLoansTicketDescriptor _descriptor 25:     )  26:         ERC721(name, symbol)  27:     { 28:         nftLoanFacilitator = _nftLoanFacilitator;  //@audit low: should be 0 checked 29:         descriptor = _descriptor;  //@audit low: should be 0 checked 30:     } ```  2. `NFTLoanFacilitator.sol` uses `Ownable`'s default `transferOwnership()` instead of implementing a 2-step ownership transfer pattern  3. `renounceOwnership()` can be called in `NFTLoanFacilitator.sol`. Consider overriding the method to always keep an owner.  4. Comment says "private" instead of "internal" :  ```solidity File: NFTLoanFacilitator.sol 369:     // === private === //@audit should say internal 370:  371:     /// @dev Returns the total interest owed on loan 372:     function _interestOwed( 373:         uint256 loanAmount, 374:         uint256 lastAccumulatedTimestamp, 375:         uint256 perAnumInterestRate, 376:         uint256 accumulatedInterest 377:     )  378:         internal  379:         view  380:         returns (uint256)  381:     { ```  5. `onERC721Received` not implemented in `borrowTicketContract` (`BorrowTicket.sol`)  The `IERC721.safeTransferFrom` call will trigger `onERC721Received` here:  ```solidity File: NFTLoanFacilitator.sol 242:         IERC721(loan.collateralContractAddress).safeTransferFrom( 243:             address(this), 244:             IERC721(borrowTicketContract).ownerOf(loanId), 245:             loan.collateralTokenId 246:         ); ```  It must return its Solidity `selector` to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.  The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.  6. Code style: some strings are declared with `''`, others with `""`. I suggest only using one style.  Strings with `''`:  ``` contracts/NFTLoanFacilitator.sol:    81:         require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');    82:         require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');    84:         'NFTLoanFacilitator: cannot use tickets as collateral');    86:         'NFTLoanFacilitator: cannot use tickets as collateral');   146:             require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');   147:             require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');   148:             require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');   171:                 require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');   172:                 require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');   280:         require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');   290:         require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');   321:         require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); ```  Strings with `""`:  ``` contracts/LendTicket.sol:   32:         require(from == ownerOf[id], "WRONG_FROM");   34:         require(to != address(0), "INVALID_RECIPIENT");  contracts/NFTLoanFacilitator.sol:    53:         require(!loanInfo[loanId].closed, "NFTLoanFacilitator: loan closed");   118:         "NFTLoanFacilitator: borrow ticket holder only");   121:         require(loan.lastAccumulatedTimestamp == 0, "NFTLoanFacilitator: has lender, use repayAndCloseLoan");   144:             require(loanAssetContractAddress != address(0), "NFTLoanFacilitator: invalid loan");   178:                 "NFTLoanFacilitator: proposed terms must be better than existing terms");   189:             "NFTLoanFacilitator: accumulated interest exceeds uint128");   255:         "NFTLoanFacilitator: lend ticket holder only");   259:         "NFTLoanFacilitator: payment is not late");   307:         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%");   contracts/NFTLoanTicket.sol:   15:         require(msg.sender == address(nftLoanFacilitator), "NFTLoanTicket: only loan facilitator"); ``` 
Thanks for a very well documented and tested codebase.  Just one note to pass on here: there's a typo in the terms `maxPerAnumInterest` and `perAnumInterestRate`, which are used in a few places in the codebase. This should be "per annum" to mean "per year." (Or just consider "per year" or "annual" in English instead). The phrase "per anum" is a medical term that means something entirely different :)
# Gas optimization report  ## Keep revert strings below 32 bytes  Strings are stored in slots of 32 bytes, and hence the length of the revert string should be at max 32 bytes to fit inside 1 slot. If the string is just 33 bytes it will occupy 2 slots (64 bytes). Keeping the string size at 32 bytes or below will save gas on both deployment and when the revert condition is met.  Since the used version of Solidity is `>=0.8.4` it would also be worth considering using [Custom Errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) which is both more gas efficient and allows thorough error descriptions using [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html).  The relevant code:  ``` NFTLoanFacilitator.sol line 84:   "NFTLoanFacilitator: cannot use tickets as collateral" NFTLoanFacilitator.sol line 86:   "NFTLoanFacilitator: cannot use tickets as collateral" NFTLoanFacilitator.sol line 118:  "NFTLoanFacilitator: borrow ticket holder only" NFTLoanFacilitator.sol line 121:  "NFTLoanFacilitator: has lender, use repayAndCloseLoan" NFTLoanFacilitator.sol line 146:  "NFTLoanFacilitator: rate too high" NFTLoanFacilitator.sol line 147:  "NFTLoanFacilitator: duration too low" NFTLoanFacilitator.sol line 148:  "NFTLoanFacilitator: amount too low" NFTLoanFacilitator.sol line 171:  "NFTLoanFacilitator: rate too high" NFTLoanFacilitator.sol line 172:  "NFTLoanFacilitator: duration too low" NFTLoanFacilitator.sol line 178:  "NFTLoanFacilitator: proposed terms must be better than existing terms" NFTLoanFacilitator.sol line 189:  "NFTLoanFacilitator: accumulated interest exceeds uint128" NFTLoanFacilitator.sol line 255:  "NFTLoanFacilitator: lend ticket holder only" NFTLoanFacilitator.sol line 259:  "NFTLoanFacilitator: payment is not late" NFTLoanFacilitator.sol line 321:  "NFTLoanFacilitator: 0 improvement rate" NFTLoanFacilitator.sol line 86:  NFTLoanTicket.sol line 15:        "NFTLoanTicket: only loan facilitator" ```  ## Cache loanAmount  In the following code the variable `loanInfo[loanId].loanAmount` is read from storage 3 times (see audit-info comments), and hence should be cached so it is only read from storage once.  ```solidity function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];          uint256 interest = _interestOwed(             loan.loanAmount, @audit-info SLOAD1             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); @audit-info SLOAD2         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );          emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); @audit-info SLOAD3         emit Close(loanId);     } ```  Change this into   ```solidity function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];         uint128 loanAmount = loan.loanAmount;          uint256 interest = _interestOwed(             loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );          emit Repay(loanId, msg.sender, lender, interest, loanAmount);         emit Close(loanId);     } ```  The change is passing the provided test suite, and the `.gas-snapshot` reflected the change by reducing the gas costs from:  ```solidity NFTLoanFacilitatorGasBenchMarkTest:testRepayAndClose() (gas: 81320 -> 81064) NFTLoanFacilitatorTest:testRepayAndCloseSuccessful() (gas: 447725 -> 447469) NFTLoanFacilitatorTest:testRepayInterestOwedExceedingUint128() (gas: 465901 -> 465645) ```
Summary: The codebase and security practices are well implemented, with no comments on that apart from some low and non-critical findings.    Low  findings :   [N01]  Inconsistent use of safeTransferFrom and transferFrom for ERC721:  NFTLoanFacilitator.sol uses both,  for example in line 88 it uses transferFrom and in line 242 it uses safeTransferFrom.  It is a bit confusing for the reader the intentions of using the 2 of them in the same contract. Try to choose one of them for better consistency in the code.   [N02] Leap-years considerations  The function _interestOwed in line 372 of NFTLoanFacilitator.sol calculates interest always considering a year like 365 days. Try 36525 instead for more precision and multiply the numerator by 100.     Non-critical findings:    [N03] Confusing comment  In line 164 of NFTLoanFacilitator.sol there is a confusing or maybe incomplete comment. Since solidity 0.8 underflows and overflows reverts, so consider adding to the comment that the operation will throw an error. The comment just says "will underflow if amount < previousAmount".    
# Use private variables to save gas  Those can be declared as private for gas savings, only creating view functions for variables that should be read externally.  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L17-L44  ## Recommendation  Declare these variables to private.   # Fetch loan fields into memory to save gas  If storage is accessed more than once, it should be fetch into memory to save gas. `loan.lastAccumulatedTimestamp` is accessed twice in `totalOwed` and `interestOwed`  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L339  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L343  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L352  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L356   ## Recommendation  Fetch loan.lastAccumulatedTimestamp into memory  `uint40 lastAccumulatedTimestamp = loan.lastAccumulatedTimestamp;` 
# Summary  We list 2 non-critical findings here:  * (Non) loanEndSeconds does not check valid loanId * (Non) Should use safe version of ERC721 functions  In conclusion, it's better to check the validity of the mapping’s key. And using a safe version of ERC721 functions is usually a better choice.  # (Non) loanEndSeconds does not check valid loanId ## Impact  In `NFTLoanFacilitator.sol/loanEndSeconds()`, it doesn’t check whether loanId is valid  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L363  ## Recommended Mitigation Steps  Add check for loanId # (Non) Should use safe version of ERC721 functions  ## Impact  In `NFTLoanFacilitator.sol`, it uses `IERC721Mintable(borrowTicketContract).mint` which is not a good practice.  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L102  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L161   ## Recommended Mitigation Steps  Use `safeMint` instead of `mint` 
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.  ## Proof of Concept  1. A victim calls `lend()`, trying to buyout the loan of the attacker. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. If the `transfer` of `loanAssetContractAddress` is ERC777, it will call `_callTokensReceived` that the attacker can manipulate and always revert it. 4. Because `NFTLoanFacilitator` uses `safeTransfer` and `safeTransferFrom` to check return value, the transaction of the victim will also be reverted. It makes anyone can not buyout the loan of the attacker.  In `_callTokensReceived`, the attacker just wants to revert the buyout transaction, but keep `repayAndCloseLoan` successful. The attacker can call `loanInfoStruct(uint256 loanId)` in `_callTokensReceived` to check if the value of `loanInfo` is changed or not to decide to revert it.  ## Tools Used  vim  ## Recommended Mitigation Steps  Don't transfer `ERC20(loanAssetContractAddress)` to `currentLoanOwner` in `lend()`, use a global mapping to record redemption of lenders and add an external function `redeem` for lenders to transfer `ERC20(loanAssetContractAddress)`.   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of `lendInfo` (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.  ## Proof of Concept  An attacker lends a loan, and `loanAssetContractAddress` in `loanInfo` is ERC777 which is suffering from reentrancy attack. When a lender (victim) try to buyout the loan of the attacker:  1. The victim called `lend()`. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. The `transfer` of `loanAssetContractAddress` ERC777 will call `_callTokensReceived` so that the attacker can call `lend()` again in reentrancy with parameters:     * loanId: same loan Id     * interestRate: set to bad value (e.g. 0)     * amount: same amount     * durationSeconds: set to bad value (e.g. a long durationSeconds)     * sendLendTicketTo: same address of the attacker (`currentLoanOwner`) 4. Now the variables in `loanInfo` are changed to bad value, and the victim will get the lend ticket but the loan term is manipulated, and can not set it back (because it requires a better term).  ## Tools Used  vim  ## Recommended Mitigation Steps  Use `nonReentrant` modifier on `lend()` to prevent reentrancy attack:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L214-L221 https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L230-L250   # Vulnerability details  ## Impact If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.  ## Proof of Concept This exploit requires that the `loanAssetContractAddress` token transfers control to the receiver.  ### Steps of exploit:  - Borrower creates loan with `createLoan()`. - The same Borrower calls `lend()`, funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself. - A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower). - Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call `repayAndCloseLoan()` before the lend ticket is transferred to the new lender.  The following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.  ```             } else {                 ERC20(loan.loanAssetContractAddress).safeTransferFrom(                     msg.sender,                     currentLoanOwner,                     accumulatedInterest + previousLoanAmount                 );             }             ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId); ```  The original lender/borrower calls the following `repayAndCloseLoan()` function so that they receive their collateral NFT from the protocol.  ```     function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];           uint256 interest = _interestOwed(             loan.loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );           emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);         emit Close(loanId);     } ```  Finally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely.  If desired, also require that the lender cannot be the same account as the borrower of a loan.  
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179   # Vulnerability details   https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179  ```solidity {     uint256 previousInterestRate = loan.perAnumInterestRate;     uint256 previousDurationSeconds = loan.durationSeconds;      require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');     require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');      require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease     || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds      || (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),      "NFTLoanFacilitator: proposed terms must be better than existing terms"); } ```  The `requiredImprovementRate` represents the percentage of improvement required of at least one of the terms when buying out from a previous lender.  However, when `previousInterestRate` is less than `10` and `requiredImprovementRate` is `100`, due to precision loss, the new `interestRate` is allowed to be the same as the previous one.  Making such an expected constraint absent.  ### PoC  1. Alice `createLoan()` with `maxPerAnumInterest` = 10, received `loanId` = 1 2. Bob `lend()` with `interestRate` = 9  for `loanId` = 1 3. Charlie `lend()` with `interestRate` = 9 (and all the same other terms with Bob) and buys out `loanId` = 1  Charlie is expected to provide at least 10% better terms, but actually bought out Bob with the same terms.  ### Recommendation  Consider using: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/math/Math.sol#L39-L42  And change the check to:  ```solidity (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR) >= interestRate) ```   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L155-L160   # Vulnerability details  ## Impact Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.  It is my belief that this is a medium severity vulnerability due to its ability to impact core protocol functionality.  ## Proof of Concept  For the first lender to call `lend()`, if the transfer fee % of the asset token is larger than the origination fee %, the second transfer will fail in the following code:  ```             ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);             uint256 facilitatorTake = amount * originationFeeRate / SCALAR;             ERC20(loanAssetContractAddress).safeTransfer(                 IERC721(borrowTicketContract).ownerOf(loanId),                 amount - facilitatorTake             ); ```  Example: - `originationFee = 2%` Max fee is 5% per comments - `feeOnTransfer = 3%` - `amount = 100 tokens`  - Lender transfers `amount` - `NFTLoanFacilitator` receives `97`. - `facilitatorTake = 2` - `NFTLoanFacilitator` attempts to send `100 - 2` to borrower, but only has `97`. - Execution reverts.  ### Other considerations: If the originationFee is less than or equal to the transferFee, the transfers will succeed but will be received at a loss for the borrower and lender. Specifically for the lender, it might be unwanted functionality for a lender to lend 100 and receive 97 following a successful repayment (excluding interest for this example).  ## Tools Used Manual review.  ## Recommended Mitigation Steps Since the `originationFee` is calculated based on the `amount` sent by the lender, this calculation will always underflow given the example above. Instead, a potential solution would be to calculate the `originationFee` based on the requested loan amount, allowing the lender to send a greater value so that `feeOnTransfer <= originationFee`.  Oppositely, the protocol can instead calculate the amount received from the initial transfer and use this amount to calculate the `originationFee`. The issue with this option is that the borrower will receive less than the desired loan amount.  
The overall Backed codebase quality is good. Functionalities are very well documented; explanatory comments are well placed. State changing functions follow the Checks-Effects-Interactions pattern and properly validate inputs. Tests are comprehensive.  The permissionless nature of the system allows anyone to use malicious NFTs/collaterals in the system to trick users or cause irregular states. Consider applying a guarded launch approach by having a whitelist—or alternatively—a blacklist for certain NFTs/collaterals. It can be deactivated after the protocol has been sufficiently battle-tested in production.  ## Low Risk Vulnerabilities ### 1. Missing sanity check on `minDurationSeconds` Mistakenly inputting a very low value of `minDurationSeconds` when [creating a loan](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L81) could lead to the NFT being lent and seized before the borrower is able to react.  **Mitigation**  Consider adding a reasonable minimum duration check when creating a loan.      ### 2. Missing `safeTransferFrom` in `closeLoan` Unlike seizeCollateral which implements `safeTransferFrom`, [closeLoan](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L124) only uses `safeTransfer` which could lead to irregular state for contract recipient.  **Mitigation**  Recommend using `safeTransferFrom` to transfer out the NFT when closing loan.  ### 3. Unclear `updateRequiredImprovementRate`  example [Comments](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L316) on updateRequiredImprovementRate stated that `E.g. setting this value to 10` would set improvement rate to 10%, while in reality inputting `10`  would set the rate to 1%.  **Mitigation**  Consider updating the comment example to include the scale calculation.  ### 4. Missing support for legacy NFTs Popular legacy NFT like CryptoPunks (which is used as the mock NFT when running tests) doesn't conform to ERC721 standard, which will exclude them from being able to be loaned.  **Mitigation**  Consider adding a transfer module or utility function that could handle transferring of non-standard ERC721 NFTs.   ## Non Critical Vulnerabilities ### 1. Redundant variable naming Redundant variable names `collateralContractAddress` and `loanAssetContractAddress` make the code less readable. Consider removing the `ContractAddress` as the type and name already imply it is a contract address.
# Backed Contest April 06, 2022  @securerodd # ## Gas Optimizations ### 1. != 0 Instead of > 0 in Require Statement  Contract: `NFTLoanFacilitator.sol`   Function: `updateRequiredImprovementRate(uint256 _improvementRate)`   Code: `require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');` Gas: testUpdateRequiredImprovementRateRevertsIf0() (gas: 13310)   Recommended Code: `require(_improvementRate != 0, 'NFTLoanFacilitator: 0 improvement rate');` Gas: testUpdateRequiredImprovementRateRevertsIf0() (gas: 13304) 
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L144   # Vulnerability details  ## Impact  Backed uses `solmate`'s `SafeTransferLib` to safely transfer non-standard ERC20 tokens:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L5  Notably, `SafeTransferLib` does not revert if the token being transferred has no code at all:  https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/utils/SafeTransferLib.sol#L9  This means transferring `address(0)` as a token will succeed, which could confuse users. As a result, Backed checks that the token is not `address(0)` on this line:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L144  However, this check is insufficient to protect users from accidentally creating loans with invalid tokens, as any address without code will be accepted as a valid token. One particularly consequential example of how this could go wrong for users would be inputting the address of a common token like DAI or USDC for another network on accident, but having the loan creation succeed as if it was the correct token. See the proof of concept for more details:  ## Proof of Concept  - Alice wants to create a DAI loan on Ethereum - Alice googles the DAI address and mistakenly copies the address of DAI on Optimism - Alice creates a the loan using Optimistic DAI and it succeeds - Alice is annoyed and confused why no one is lending to her - Alice closes the loan in anger and does not return to use Backed protocol  ## Recommended Mitigation Steps  Rewrite the require like so:  ```solidity    require(loanAssetContractAddress.code.length != 0, "NFTLoanFacilitator: invalid loan"); ```  
Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               NFTLoanTicket.constructor (name)         NFTLoanTicket.constructor (symbol)    Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: NFTLoanFacilitator.sol, In line 258, Require message length to shorten: 39, The message: NFTLoanFacilitator: payment is not late         Solidity file: NFTLoanFacilitator.sol, In line 82, Require message length to shorten: 33, The message: NFTLoanFacilitator: 0 loan amount         Solidity file: NFTLoanFacilitator.sol, In line 321, Require message length to shorten: 38, The message: NFTLoanFacilitator: 0 improvement rate    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           NFTLoanFacilitator.sol, 321: change '_improvementRate > 0' to '_improvementRate != 0'    Title: Storage double reading. Could save SLOAD Severity: GAS  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           NFTLoanFacilitator.sol: originationFeeRate is read twice in lend   Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          LendTicket.sol, _transfer         NFTLoanFacilitator.sol, _interestOwed    Title: Unnecessary constructor Severity: GAS  The following constructors are empty.      (A similar issue https://github.com/code-423n4/2021-11-fei-findings/issues/12)              LendTicket.sol.constructor         BorrowTicket.sol.constructor    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          NFTLoanFacilitator.sol (L#382) - return loanAmount * (block.timestamp - lastAccumulatedTimestamp) * (perAnumInterestRate * 1e18 / 365 days) / 1e21 + accumulatedInterest;         NFTLoanFacilitator.sol (L#258) - require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp, "NFTLoanFacilitator: payment is not late");     Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In NFTLoanFacilitator.sol,rearranging the storage fields can optimize to: 6 slots from: 7 slots. The new order of types (you choose the actual variables):         1. uint256         2. uint256         3. uint256         4. uint256         5. address         6. uint8         7. address     Title: Change transferFrom to transfer Severity: GAS  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.          NFTLoanFacilitator.sol, 124 : IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               LendTicket.sol, _transfer    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               NFTLoanFacilitator.sol, _interestOwed, { return loanAmount * (block.timestamp - lastAccumulatedTimestamp) * (perAnumInterestRate * 1e18 / 365 days) / 1e21 // SCALAR * 1e18 + accumulatedInterest; }    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           NFTLoanTicket.sol, tokenURI
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L309   # Vulnerability details  ## Impact Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in `createLoan`, they only receive `(1 - originationFee) * minLoanAmount`, see [`lend`](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L159). Therefore, they need to precalculate the `minLoanAmount` using the **current** origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.  ## Recommended Mitigation Steps Reconsider how the min loan amount works. Imo, this `minLoanAmount` should be the post-fee amount, not the pre-fee amount. It's also more intuitive for the borrower when creating the loan.   
# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L241   # Vulnerability details  ## Impact The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use `closeLoan` in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.  It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where `interest` will be a high value accumulated from timestamp 0 and the `loan.loanAmount` is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).  ## Recommended Mitigation Steps Add a check that there actually is something to repay.  ```solidity require(loan.lastAccumulatedTimestamp > 0, "loan was never matched by a lender. use closeLoan instead"); ```   
## Inefficient safe cast  A safe cast check is done here:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L188  The check uses `<=`, which compiles down to 2 opcodes (`ISZERO`, `GT`). This check can be done in a single opcode like so:  ```solidity require(accumulatedInterest < 1 << 128, "NFTLoanFacilitator: accumulated interest exceeds uint128"); ```  because `1 << 128` is equivalent to `2 ** 128` which is equal to `type(uin128).max + 1`  ## Unnecessary ownerOf check  A check that the `from` address equals `ownerOf[id]` is performed here:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/LendTicket.sol#L32  This is unnecessary as the only place where the internal `_transfer` is ever called (via the access controlled public version: `loanFacilitatorTransfer`) will only ever pass the owner of the token as ensured by this line:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L197  Therefore the check can be removed to save an SLOAD.
# Gas Report **Table of Contents:** - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Storage](#storage)       - [Caching storage values in memory](#caching-storage-values-in-memory)     - [Comparisons](#comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [Arithmetics](#arithmetics)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Visibility](#visibility)       - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings ### Storage  #### Caching storage values in memory The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):  ```solidity contracts/NFTLoanFacilitator.sol:   174:                 require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease //@audit gas: should cache requiredImprovementRate   175:                 || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds   //@audit gas: should use cached requiredImprovementRate   176                  || (previousInterestRate != 0 // do not allow rate improvement if rate already 0   177:                     && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), //@audit gas: should use cached requiredImprovementRate      231          Loan storage loan = loanInfo[loanId];   232     233          uint256 interest = _interestOwed(   234:             loan.loanAmount, //@audit gas: should cache loan.loanAmount   235              loan.lastAccumulatedTimestamp,   236              loan.perAnumInterestRate,   237              loan.accumulatedInterest   238          );   239          address lender = IERC721(lendTicketContract).ownerOf(loanId);   240          loan.closed = true;   241:         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); //@audit gas: should use cached loan.loanAmount   242          IERC721(loan.collateralContractAddress).safeTransferFrom(   243              address(this),   244              IERC721(borrowTicketContract).ownerOf(loanId),   245              loan.collateralTokenId   246          );   247     248:         emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); //@audit gas: should use cached loan.loanAmount   249          emit Close(loanId);   250      }    338          Loan storage loan = loanInfo[loanId];   339          if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;   340     341:         return loanInfo[loanId].loanAmount + _interestOwed( //@audit gas: should use loan.loanAmount instead of loanInfo[loanId].loanAmount   342              loan.loanAmount,   343              loan.lastAccumulatedTimestamp,   344              loan.perAnumInterestRate,   345              loan.accumulatedInterest   346          ); ```  ### Comparisons  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof) `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: https://twitter.com/gzeon/status/1485428085885640706  I suggest changing `> 0` with `!= 0` here: ```solidity NFTLoanFacilitator.sol:321:        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); ```  Also, please enable the Optimizer.  ### Arithmetics    #### `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:   ```solidity LendTicket.sol:39:            balanceOf[from]--; LendTicket.sol:41:            balanceOf[to]++; ```   I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  #### Unchecking arithmetics operations that can't underflow/overflow Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity contracts/NFTLoanFacilitator.sol:   156              uint256 facilitatorTake = amount * originationFeeRate / SCALAR;   157              ERC20(loanAssetContractAddress).safeTransfer(   158                  IERC721(borrowTicketContract).ownerOf(loanId),   159:                 amount - facilitatorTake //@audit gas: should be unchecked as facilitatorTake is < amount and can't underflow L156 (originationFeeRate is upper bounded and always < SCALAR)    209                  uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);   210                  ERC20(loanAssetContractAddress).safeTransfer(   211                      IERC721(borrowTicketContract).ownerOf(loanId),   212:                     amountIncrease - facilitatorTake //@audit gas: should be unchecked as facilitatorTake is < amount and can't underflow L209 (originationFeeRate is upper bounded and always < SCALAR) ``` ### Visibility  #### Consider making some constants as non-public to save gas Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here: ```solidity NFTLoanFacilitator.sol:21:    uint8 public constant override INTEREST_RATE_DECIMALS = 3; NFTLoanFacilitator.sol:24:    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS; ```  ### Errors  #### Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.   Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   Revert strings > 32 bytes:   ```solidity NFTLoanFacilitator.sol:118:        "NFTLoanFacilitator: borrow ticket holder only"); NFTLoanFacilitator.sol:121:        require(loan.lastAccumulatedTimestamp == 0, "NFTLoanFacilitator: has lender, use repayAndCloseLoan"); NFTLoanFacilitator.sol:178:                "NFTLoanFacilitator: proposed terms must be better than existing terms"); NFTLoanFacilitator.sol:189:            "NFTLoanFacilitator: accumulated interest exceeds uint128"); NFTLoanFacilitator.sol:255:        "NFTLoanFacilitator: lend ticket holder only"); NFTLoanFacilitator.sol:259:        "NFTLoanFacilitator: payment is not late"); NFTLoanTicket.sol:15:        require(msg.sender == address(nftLoanFacilitator), "NFTLoanTicket: only loan facilitator");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```solidity LendTicket.sol:32:        require(from == ownerOf[id], "WRONG_FROM"); LendTicket.sol:34:        require(to != address(0), "INVALID_RECIPIENT"); NFTLoanFacilitator.sol:53:        require(!loanInfo[loanId].closed, "NFTLoanFacilitator: loan closed"); NFTLoanFacilitator.sol:81:        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration'); NFTLoanFacilitator.sol:82:        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount'); NFTLoanFacilitator.sol:83:        require(collateralContractAddress != lendTicketContract, NFTLoanFacilitator.sol:85:        require(collateralContractAddress != borrowTicketContract,  NFTLoanFacilitator.sol:117:        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender, NFTLoanFacilitator.sol:121:        require(loan.lastAccumulatedTimestamp == 0, "NFTLoanFacilitator: has lender, use repayAndCloseLoan"); NFTLoanFacilitator.sol:144:            require(loanAssetContractAddress != address(0), "NFTLoanFacilitator: invalid loan"); NFTLoanFacilitator.sol:146:            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high'); NFTLoanFacilitator.sol:147:            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low'); NFTLoanFacilitator.sol:148:            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low'); NFTLoanFacilitator.sol:171:                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high'); NFTLoanFacilitator.sol:172:                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low'); NFTLoanFacilitator.sol:174:                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease NFTLoanFacilitator.sol:188:            require(accumulatedInterest <= type(uint128).max, NFTLoanFacilitator.sol:254:        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender,  NFTLoanFacilitator.sol:258:        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp, NFTLoanFacilitator.sol:280:        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set'); NFTLoanFacilitator.sol:290:        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set'); NFTLoanFacilitator.sol:307:        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), "NFTLoanFacilitator: max fee 5%"); NFTLoanFacilitator.sol:321:        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); NFTLoanTicket.sol:15:        require(msg.sender == address(nftLoanFacilitator), "NFTLoanTicket: only loan facilitator"); ```  I suggest replacing revert strings with custom errors.
-- 1  All functions that receive uints which are not uint256 could be changed to uint256 and only casted to the intended size when storing it.  More info at: https://github.com/ourzora/v3/pull/125#issuecomment-1034238815  Just swapped the `lend()` function and consequent related tests resulting in: ```(...) Overall gas change: -11839 (-0.041%)``` But there are many other functions (eg. `createLoan`) which could use such change, so the gas saving should be way more than that.  -- 2 cache `borrowTicketContract` at `createLoan` to save one SLOAD on a successful transaction.  -- 3 use cached `previousInterestRate` on calling `_interestOwed`  Overall gas change: -60 (-0.000%)  ```diff diff --git a/contracts/NFTLoanFacilitator.sol b/contracts/NFTLoanFacilitator.sol index 46d6ef5..bb25958 100644 --- a/contracts/NFTLoanFacilitator.sol +++ b/contracts/NFTLoanFacilitator.sol @@ -165,6 +165,7 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {              // will underflow if amount < previousAmount              uint256 amountIncrease = amount - previousLoanAmount;   +            uint256 accumulatedInterest;              {                  uint256 previousInterestRate = loan.perAnumInterestRate;                  uint256 previousDurationSeconds = loan.durationSeconds; @@ -177,14 +178,14 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {                  || (previousInterestRate != 0 // do not allow rate improvement if rate already 0                      && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),                   "NFTLoanFacilitator: proposed terms must be better than existing terms"); -            }   -            uint256 accumulatedInterest = _interestOwed( -                previousLoanAmount, -                loan.lastAccumulatedTimestamp, -                loan.perAnumInterestRate, -                loan.accumulatedInterest -            ); +                 = _interestOwed( +                    previousLoanAmount, +                    loan.lastAccumulatedTimestamp, +                    previousInterestRate, +                    loan.accumulatedInterest +                ); +            }              require(accumulatedInterest <= type(uint128).max,              "NFTLoanFacilitator: accumulated interest exceeds uint128"); ```  -- 4  cache `loan.loanAmount` on `repayAndCloseLoan`  ``` testRepayInterestOwedExceedingUint128() (gas: -253 (-0.001%))  testRepayAndCloseSuccessful() (gas: -253 (-0.001%))  testRepayAndClose() (gas: -253 (-0.003%))  Overall gas change: -759 (-0.004%) ``` ```diff diff --git a/contracts/NFTLoanFacilitator.sol b/contracts/NFTLoanFacilitator.sol index f1f570f..ff2e3f7 100644 --- a/contracts/NFTLoanFacilitator.sol +++ b/contracts/NFTLoanFacilitator.sol @@ -231,23 +231,24 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {      /// See {INFTLoanFacilitator-repayAndCloseLoan}.      function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {          Loan storage loan = loanInfo[loanId]; +        uint256 _loanAmount = loan.loanAmount;            uint256 interest = _interestOwed( -            loan.loanAmount, +            _loanAmount,              loan.lastAccumulatedTimestamp,              loan.perAnumInterestRate,              loan.accumulatedInterest          );          address lender = IERC721(lendTicketContract).ownerOf(loanId);          loan.closed = true; -        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); +        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + _loanAmount);          IERC721(loan.collateralContractAddress).safeTransferFrom(              address(this),              IERC721(borrowTicketContract).ownerOf(loanId),              loan.collateralTokenId          );   -        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); +        emit Repay(loanId, msg.sender, lender, interest, _loanAmount);          emit Close(loanId);      } ```
