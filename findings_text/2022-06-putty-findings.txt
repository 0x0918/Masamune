# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497   # Vulnerability details  ## Impact Fees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.  ## Proof of Concept The scenario would be:   - Alice and Bob agrees to fill an order at a time fees are 0.1%  - During the duration of the option, fees are increased to 3%  - At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees   ## Recommended Mitigation Steps Mitigation could be:  - Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct  - Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup  - Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437   # Vulnerability details  Some non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.  Marking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.  ## Proof of Concept  Currently system do not check the strike value, unconditionally attempting to transfer it:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437  ```solidity             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             } ```  As a part of call exercise logic:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443  ```solidity     function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {         ...          if (order.isCall) {             // -- exercising a call option              // transfer strike from exerciser to putty             // handle the case where the taker uses native ETH instead of WETH to pay the strike             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the strike                 require(msg.value == order.strike, "Incorrect ETH amount sent");                  // convert ETH to WETH                 // we convert the strike ETH to WETH so that the logic in withdraw() works                 // - because withdraw() assumes an ERC20 interface on the base asset.                 IWETH(weth).deposit{value: msg.value}();             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             }              // transfer assets from putty to exerciser             _transferERC20sOut(order.erc20Assets);             _transferERC721sOut(order.erc721Assets);             _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);         } ```  Some tokens do not allow zero amount transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  This way for such a token and zero strike option the maker can create short call order, receive the premium:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339  ```solidity             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the premium                 require(msg.value == order.premium, "Incorrect ETH amount sent");                  // convert ETH to WETH and send premium to maker                 // converting to WETH instead of forwarding native ETH to the maker has two benefits;                 // 1) active market makers will mostly be using WETH not native ETH                 // 2) attack surface for re-entrancy is reduced                 IWETH(weth).deposit{value: msg.value}();                 IWETH(weth).transfer(order.maker, msg.value);             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);             } ```  Transfer in the assets:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371  ```solidity         // filling short call: transfer assets from maker to contract         if (!order.isLong && order.isCall) {             _transferERC20sIn(order.erc20Assets, order.maker);             _transferERC721sIn(order.erc721Assets, order.maker);             return positionId;         } ```  And wait for expiration, knowing that all attempts to exercise will revert:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437  ```solidity             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             } ```  Then recover her assets:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519  ```solidity         // transfer assets from putty to owner if put is exercised or call is expired         if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {             _transferERC20sOut(order.erc20Assets);             _transferERC721sOut(order.erc721Assets);              // for call options the floor token ids are saved in the long position in fillOrder(),             // and for put options the floor tokens ids are saved in the short position in exercise()             uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);             _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);              return;         } ```  ## Recommended Mitigation Steps  Consider checking that strike is positive before transfer in all the cases, for example:  ```solidity             } else { +               if (order.strike > 0) {                     ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike); +               }             } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526   # Vulnerability details  ## Impact An **order** could be canceled even after the **order** was filled. Even if this does not affect any other part of the process, the mapping `cancelledOrders` still gets updated and a `CancelledOrder` event is emitted, this could cause issues on a front-end or monitoring tools working with the protocol.  ## Proof of Concept  ```solidity function cancel(Order memory order) public {         require(msg.sender == order.maker, "Not your order");          bytes32 orderHash = hashOrder(order);          // mark the order as cancelled         cancelledOrders[orderHash] = true;          emit CancelledOrder(orderHash, order);     } ```  ## Recommended Mitigation Steps Check if the order was already filled before. This could be done by checking if an `nft` with the order id was created before.  ```diff function cancel(Order memory order) public {         require(msg.sender == order.maker, "Not your order");          bytes32 orderHash = hashOrder(order);          +       require(ownerOf(uint256(orderHash)) == address(0), "This order was already filled");          // mark the order as cancelled         cancelledOrders[orderHash] = true;          emit CancelledOrder(orderHash, order);     } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506   # Vulnerability details  Zero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.  Also, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.  Marking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.  ## Proof of Concept  Currently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506  ```solidity         // transfer strike to owner if put is expired or call is exercised         if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {             // send the fee to the admin/DAO if fee is greater than 0%             uint256 feeAmount = 0;             if (fee > 0) {                 feeAmount = (order.strike * fee) / 1000;                 ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);             }              ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);              return;         } ```  ## Recommended Mitigation Steps  Consider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.  I.e. consider moving fee gathering to fillOrder:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340  ```solidity         // transfer premium to whoever is short from whomever is long         if (order.isLong) {             ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);         } else {             // handle the case where the user uses native ETH instead of WETH to pay the premium             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the premium                 require(msg.value == order.premium, "Incorrect ETH amount sent");                  // convert ETH to WETH and send premium to maker                 // converting to WETH instead of forwarding native ETH to the maker has two benefits;                 // 1) active market makers will mostly be using WETH not native ETH                 // 2) attack surface for re-entrancy is reduced                 IWETH(weth).deposit{value: msg.value}();                 IWETH(weth).transfer(order.maker, msg.value);             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);             }         } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298   # Vulnerability details  ## Impact  **HIGH** - assets can be lost If a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s. This bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the `Create a short put order with zero tokenAmount makes the option impossible to exercise`, therefore reported separately.   ## Proof of Concept  - [proof of concept](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202) - [reference case](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)  The proof of concept shows a scenario where babe makes an short call order with non empty `floorTokens` array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls `exercise`. There are two cases. - case 1: he calls exercise with empty `floorAssetTokenIds` array - case 2: he calls exercise with non-empty `floorAssetTokenIds` array with matching length to the `orders.floorTokens`  In the case1, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually `_transferFloorsIn` was called and he gets `Index out of bounds` error, because `floorTokens` is not empty [which does not match with empty `floorAssetTokenIds`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629). ```solidity // case 1   // PuttyV2.sol: _transferFloorsIn called by exercise   // The floorTokens and floorTokenIds do not match the lenghts   // floorTokens.length is not zero, while floorTokenIds.length is zero         ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]); ```  In the case2, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts. ``` // case2 // PuttyV2.sol: exercise // non empty floorAssetTokenIds array is passed for put option, it will revert          !order.isCall             ? require(floorAssetTokenIds.length == order.floorTokens.length, "Wrong amount of floor tokenIds")             : require(floorAssetTokenIds.length == 0, "Invalid floor tokenIds length"); ```  After the option is expired, the maker - babe is trying to withdraw but fails due to the [same issue with the case1](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516). ```solidity // maker trying to withdraw // PuttyV2.sol: withdraw    _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]); ```  Note on the poc: - The [test for case1 is commented out](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with `Index out of bounds`. - For the same reason the [withdraw](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out - The reference case just shows that it works as intended when the order does not contain non-empty `floorTokens`.  ## Tools Used  foundry  ## Recommended Mitigation Steps  It happens because the [`fillOrder` does not ensure](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the `order.floorTokens` to be empty when the order is short call.    
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L2   # Vulnerability details  The solidity version 0.8.13 has below two issues applicable to PuttyV2 1) Vulnerability related to ABI-encoding. ref : https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/ This vulnerability can be misused since the function hashOrder() and hashOppositeOrder() has applicable conditions. "...pass a nested array directly to another external function call or use abi.encode on it."  2) Vulnerability related to 'Optimizer Bug Regarding Memory Side Effects of Inline Assembly' ref : https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/ PuttyV2 inherits solidity contracts from openzeppelin and solmate, and both these uses inline assembly, and optimization is enabled while compiling.  ## Recommended Mitigation Steps Use recent Solidity version 0.8.15 which has the fix for these issues    
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500   # Vulnerability details  ## Proof-of-Concept  When users withdraw their strike escrowed in Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users.  [https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500)  ```solidity function withdraw(Order memory order) public {  ..SNIP..   // transfer strike to owner if put is expired or call is exercised  if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {   // send the fee to the admin/DAO if fee is greater than 0%   uint256 feeAmount = 0;   if (fee > 0) {    feeAmount = (order.strike * fee) / 1000;    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);   }    ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);    return;  }  ..SNIP.. } ```  There are two methods on how the owner can deny user from withdrawing their strike amount from the contract  #### Method #1 - Set the `owner()` to `zero` address  Many of the token implementations do not allow transfer to `zero` address ([Reference](https://github.com/d-xo/weird-erc20#revert-on-transfer-to-the-zero-address)). Popular ERC20 implementations such as the following Openzeppelin's ERC20 implementation do not allow transfer to `zero` address, and will revert immediately if the `to` address (recipient) points to a `zero` address during a transfer.  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226)  ```solidity function _transfer(     address from,     address to,     uint256 amount ) internal virtual {     require(from != address(0), "ERC20: transfer from the zero address");     require(to != address(0), "ERC20: transfer to the zero address");      _beforeTokenTransfer(from, to, amount);      uint256 fromBalance = _balances[from];     require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");     unchecked {         _balances[from] = fromBalance - amount;         // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by         // decrementing then incrementing.         _balances[to] += amount;     }      emit Transfer(from, to, amount);      _afterTokenTransfer(from, to, amount); } ```  It is possible for the owner to transfer the ownership to a `zero` address, thus causing the fee transfer to the contract owner to always revert. When the fee transfer always reverts, no one can withdraw their strike amount from the contract.  This issue will affect all orders that adopt a `baseAsset` that reverts when transferring to `zero` address.  #### Method #2 - If `baseAsset` is a ERC777 token  > Note: `owner()` could point to a contract or EOA account. By pointing to a contract, the contract could implement logic to revert whenever someone send tokens to it.  ERC777 contains a `tokensReceived` hook that will notify the recipient whenever someone sends some tokens to the recipient .   Assuming that the `baseAsset` is a ERC77 token, the recipient, which is the `owner()` in this case, could always revert whenever `PuttyV2` contract attempts to send the fee to recipient. This will cause the `withdraw` function to revert too. As a result, no one can withdraw their strike amount from the contract.  This issue will affect all orders that has ERC777 token as its `baseAsset`.  ## Impact  User cannot withdraw their strike amount and their asset will be stuck in the contract.  ## Recommended Mitigation Steps  It is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.  Instead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.  Consider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process.   This will give users more assurance and confidence about the security of their funds stored within Putty.  ```solidity mapping(address => uint256) public ownerFees;  function withdraw(Order memory order) public {  ..SNIP..     // transfer strike to owner if put is expired or call is exercised     if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {         // send the fee to the admin/DAO if fee is greater than 0%         uint256 feeAmount = 0;         if (fee > 0) {             feeAmount = (order.strike * fee) / 1000;             ownerFees[order.baseAsset] += feeAmount         }          ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);          return;     }     ..SNIP.. }  function withdrawFee(address baseAsset) public onlyOwner {  uint256 _feeAmount = ownerFees[baseAsset];  ownerFees[baseAsset] = 0;  ERC20(baseAsset).safeTransfer(owner(), _feeAmount); } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451   # Vulnerability details  ## Impact  Fees are expected to be paid whenever an option is exercised (as per the function comment on [L235](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L235)).  ### Put options  If a put option is exercised, the exerciser receives the strike price (initially deposited by the short position holder) denominated in `order.baseAsset`.  ### Call options  If a call option is exercised, the exerciser sends the strike price to Putty and the short position holder is able to withdraw the strike amount.  However, the current protocol implementation is missing to deduct fees for exercised put options. Put options are free of any fees.  ## Proof of Concept  The protocol fee is correctly charged for exercised calls:  [PuttyV2.withdraw](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506)  ```solidity // transfer strike to owner if put is expired or call is exercised if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {     // send the fee to the admin/DAO if fee is greater than 0%     uint256 feeAmount = 0;     if (fee > 0) {         feeAmount = (order.strike * fee) / 1000;         ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit DoS due to reverting erc20 token transfer (weird erc20 tokens, blacklisted or paused owner; erc777 hook on owner receiver side can prevent transfer hence reverting and preventing withdrawal) - use pull pattern @high  // @audit zero value token transfers can revert. Small strike prices and low fee can lead to rounding down to 0 - check feeAmount > 0 @high  // @audit should not take fees if renounced owner (zero address) as fees can not be withdrawn @medium     }      ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); // @audit fee should not be paid if strike is simply returned to short owner for expired put @high      return; } ```  Contrary, put options are free of any fees:  [PuttyV2.sol#L450-L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451)  ```solidity // transfer strike from putty to exerciser ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike); ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Charge fees also for exercised put options.   
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500   # Vulnerability details  ## Impact  Certain ERC-20 tokens do not support zero-value token transfers and revert. Using such a token as a `order.baseAsset` for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.  ## Proof of Concept  [PuttyV2.sol#L499-L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500)  ```solidity // send the fee to the admin/DAO if fee is greater than 0% uint256 feeAmount = 0; if (fee > 0) {     feeAmount = (order.strike * fee) / 1000;     ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit-info zero-value ERC20 token transfers can revert for certain tokens } ```  Some ERC20 tokens revert for zero-value transfers (e.g. `LEND`). If used as a `order.baseAsset` and a small strike price, the fee token transfer will revert. Hence, assets and the strike can not be withdrawn and remain locked in the contract.  See [Weird ERC20 Tokens - Revert on Zero Value Transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)  **Example:**  - `order.baseAsset` is one of those weird ERC-20 tokens - `order.strike = 999` (depending on the token decimals, a very small option position) - `fee = 1` (0.1%)  $((999 * 1) / 1000 = 0.999)$ rounded down to 0 -> zero-value transfer reverting transaction  ## Tools Used  Manual review  ## Recommended mitigation steps  Add a simple check for zero-value token transfers:  ```solidity // send the fee to the admin/DAO if fee is greater than 0% uint256 feeAmount = 0; if (fee > 0) {     feeAmount = (order.strike * fee) / 1000;      if (feeAmount > 0) {         ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);     } } ```   
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451   # Vulnerability details  ## Impact Fee is being deducted when Put is expired and not when it is exercised in `PuttyV2.sol`. Comment section of the `setFee()` function mentions `"fee rate that is applied on exercise"` which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).  But, in function `withdraw()` at [PuttyV2.solL#495-L503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired.   Also, in function `exercise()` there is no fee deduction from the `order.strike` when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).  This unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.  ## Proof of Concept `if` condition present at [PuttyV2.solL#495](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if `order.isCall` is `false` and `isExercised` is false.  `feeAmount` becomes positive if `fee > 0` and it gets deducted from the `order.strike` which gets transferred to `msg.sender` at line number [PuttyV2.solL#503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps 1. Update `if` condition at [PuttyV2.sol#L498](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with `(fee > 0 && order.isCall && isExercised)`  2. Add feeAmount calculation and deduction after put is exercised and strike is transferred at [PuttyV2.sol#L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:  ```solidity uint256 feeAmount = 0; if (fee > 0) {     feeAmount = (order.strike * fee) / 1000;     ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); } ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436   # Vulnerability details  ## Impact `fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.   ## Proof of Concept Ether can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here: ```solidity File: contracts/src/PuttyV2.sol   #1  323           if (order.isLong) { 324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium); 325           } else { ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325   If the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused: ```solidity File: contracts/src/PuttyV2.sol   #2  337               } else { 338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium); 339               } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339   Same for the exercise of call options: ```solidity File: contracts/src/PuttyV2.sol   #3  435               } else { 436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike); 437               } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437   ## Tools Used Code inspection  ## Recommended Mitigation Steps Add a `require(0 == msg.value)` for the above three conditions   
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454   # Vulnerability details  ## Impact Put option buyers pay an option premium to the seller for the privilege of being able to 'put' assets to the seller and get the strike price for it rather than the current market price. If they're unable to perform the 'put', they've paid the premium for nothing, and essentially have had funds stolen from them.   ## Proof of Concept If the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing: ```solidity File: contracts/src/PuttyV2.sol   #1  453               // transfer assets from exerciser to putty 454               _transferERC20sIn(order.erc20Assets, msg.sender); ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454   The function reverts if any amount is equal to zero, or the asset doesn't exist: ```solidity File: contracts/src/PuttyV2.sol   #2  593       function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal { 594           for (uint256 i = 0; i < assets.length; i++) { 595               address token = assets[i].token; 596               uint256 tokenAmount = assets[i].tokenAmount; 597    598               require(token.code.length > 0, "ERC20: Token is not contract"); 599               require(tokenAmount > 0, "ERC20: Amount too small"); 600    601               ERC20(token).safeTransferFrom(from, address(this), tokenAmount); 602           } 603       } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593-L603    ## Tools Used Code inspection   ## Recommended Mitigation Steps Verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time    
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535   # Vulnerability details  ## Impact  Order cancellation requires makers to call `cancel()`, inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.  This first issue is that it is an on-chain signal for MEV users to frontrun the cancellation and fill the order.  The second issue is the dependency to a centralized service for cancelling the order. As orders are signed off chain, they would be stored in a centralized database. It is unlikely that an end user would locally record all the orders they make. This means that when cancelling an order, maker needs to request the order parameters from the centralized service. If the centralized service goes offline, it could allow malicious parties who have a copy of the order database to fill orders that would have been cancelled otherwise.  ## Proof of Concept  1. Bob signs an order which gets recorded in Putty servers. 2. Alice mirrors all the orders using Putty APIs. 3. Putty servers go offline. 4. Bob wants to cancel his order because changing token prices makes his order less favourable to him. 5. Bob cannot cancel his order because Putty servers are down and he does not remember the exact amounts of tokens he used. 6. Alice goes through all the orders in her local mirror and fulfills the non-cancelled orders, including Bob's, with extremely favourable terms for herself.  ## Tools Used  Pen & paper.  ## Recommended Mitigation Steps  Aside from the standard order cancellation method, have an extra method to cancel all orders of a caller. This can be achieved using a "minimum valid nonce" state variable, as a mapping from user address to nonce.  ```solidity mapping(address => uint256) minimumValidNonce; ```  Allow users to increment their `minimumValidNonce`. Make sure the incrementation function do not allow incrementing more than `2**64` such that callers cannot lock themselves out of creating orders by increasing `minimumValidNonce` to `2**256-1` by mistake. Then, prevent filling orders if `order.nonce < minimumValidNonce`.  Another method to achieve bulk cancelling is using counters. For example, Seaport [uses counters](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/CounterManager.sol), which is an extra order parameter that has to match the corresponding counter state variable. It allows maker to cancel all his orders by [incrementing the counter state variable by one](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/Consideration.sol#L475-L478).   Either of these extra cancellation methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/main/contracts/src/PuttyV2.sol#L287   # Vulnerability details  ## Impact A malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction  ## Proof of Concept !. Maker creates an order with zero Order duration 2. Taker fills this order but the order instantly expires since duration was 0 3. Taker gets the only option to withdraw with fees on strike price  ## Recommended Mitigation Steps Enforce atleast x days of duration  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584   # Vulnerability details  ## Impact  When a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.  The impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.  ## Proof of Concept  [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled. ```solidity     function acceptCounterOffer(         Order memory order,         bytes calldata signature,         Order memory originalOrder     ) public payable returns (uint256 positionId) {         // cancel the original order         cancel(originalOrder);           // accept the counter offer         uint256[] memory floorAssetTokenIds = new uint256[](0);         positionId = fillOrder(order, signature, floorAssetTokenIds);     } ```  [cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding. ```solidity     function cancel(Order memory order) public {         require(msg.sender == order.maker, "Not your order");           bytes32 orderHash = hashOrder(order);           // mark the order as cancelled         cancelledOrders[orderHash] = true;           emit CancelledOrder(orderHash, order);     } ```  Therefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.  ## Recommended Mitigation Steps  Consider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497   # Vulnerability details  ## Impact Fees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.  ## Proof of Concept The scenario would be:   - Alice and Bob agrees to fill an order at a time fees are 0.1%  - During the duration of the option, fees are increased to 3%  - At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees   ## Recommended Mitigation Steps Mitigation could be:  - Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct  - Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup  - Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437   # Vulnerability details  Some non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.  Marking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.  ## Proof of Concept  Currently system do not check the strike value, unconditionally attempting to transfer it:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437  ```solidity             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             } ```  As a part of call exercise logic:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443  ```solidity     function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {         ...          if (order.isCall) {             // -- exercising a call option              // transfer strike from exerciser to putty             // handle the case where the taker uses native ETH instead of WETH to pay the strike             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the strike                 require(msg.value == order.strike, "Incorrect ETH amount sent");                  // convert ETH to WETH                 // we convert the strike ETH to WETH so that the logic in withdraw() works                 // - because withdraw() assumes an ERC20 interface on the base asset.                 IWETH(weth).deposit{value: msg.value}();             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             }              // transfer assets from putty to exerciser             _transferERC20sOut(order.erc20Assets);             _transferERC721sOut(order.erc721Assets);             _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);         } ```  Some tokens do not allow zero amount transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  This way for such a token and zero strike option the maker can create short call order, receive the premium:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339  ```solidity             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the premium                 require(msg.value == order.premium, "Incorrect ETH amount sent");                  // convert ETH to WETH and send premium to maker                 // converting to WETH instead of forwarding native ETH to the maker has two benefits;                 // 1) active market makers will mostly be using WETH not native ETH                 // 2) attack surface for re-entrancy is reduced                 IWETH(weth).deposit{value: msg.value}();                 IWETH(weth).transfer(order.maker, msg.value);             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);             } ```  Transfer in the assets:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371  ```solidity         // filling short call: transfer assets from maker to contract         if (!order.isLong && order.isCall) {             _transferERC20sIn(order.erc20Assets, order.maker);             _transferERC721sIn(order.erc721Assets, order.maker);             return positionId;         } ```  And wait for expiration, knowing that all attempts to exercise will revert:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437  ```solidity             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             } ```  Then recover her assets:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519  ```solidity         // transfer assets from putty to owner if put is exercised or call is expired         if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {             _transferERC20sOut(order.erc20Assets);             _transferERC721sOut(order.erc721Assets);              // for call options the floor token ids are saved in the long position in fillOrder(),             // and for put options the floor tokens ids are saved in the short position in exercise()             uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);             _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);              return;         } ```  ## Recommended Mitigation Steps  Consider checking that strike is positive before transfer in all the cases, for example:  ```solidity             } else { +               if (order.strike > 0) {                     ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike); +               }             } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526   # Vulnerability details  ## Impact An **order** could be canceled even after the **order** was filled. Even if this does not affect any other part of the process, the mapping `cancelledOrders` still gets updated and a `CancelledOrder` event is emitted, this could cause issues on a front-end or monitoring tools working with the protocol.  ## Proof of Concept  ```solidity function cancel(Order memory order) public {         require(msg.sender == order.maker, "Not your order");          bytes32 orderHash = hashOrder(order);          // mark the order as cancelled         cancelledOrders[orderHash] = true;          emit CancelledOrder(orderHash, order);     } ```  ## Recommended Mitigation Steps Check if the order was already filled before. This could be done by checking if an `nft` with the order id was created before.  ```diff function cancel(Order memory order) public {         require(msg.sender == order.maker, "Not your order");          bytes32 orderHash = hashOrder(order);          +       require(ownerOf(uint256(orderHash)) == address(0), "This order was already filled");          // mark the order as cancelled         cancelledOrders[orderHash] = true;          emit CancelledOrder(orderHash, order);     } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506   # Vulnerability details  Zero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.  Also, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.  Marking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.  ## Proof of Concept  Currently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506  ```solidity         // transfer strike to owner if put is expired or call is exercised         if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {             // send the fee to the admin/DAO if fee is greater than 0%             uint256 feeAmount = 0;             if (fee > 0) {                 feeAmount = (order.strike * fee) / 1000;                 ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);             }              ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);              return;         } ```  ## Recommended Mitigation Steps  Consider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.  I.e. consider moving fee gathering to fillOrder:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340  ```solidity         // transfer premium to whoever is short from whomever is long         if (order.isLong) {             ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);         } else {             // handle the case where the user uses native ETH instead of WETH to pay the premium             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the premium                 require(msg.value == order.premium, "Incorrect ETH amount sent");                  // convert ETH to WETH and send premium to maker                 // converting to WETH instead of forwarding native ETH to the maker has two benefits;                 // 1) active market makers will mostly be using WETH not native ETH                 // 2) attack surface for re-entrancy is reduced                 IWETH(weth).deposit{value: msg.value}();                 IWETH(weth).transfer(order.maker, msg.value);             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);             }         } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298   # Vulnerability details  ## Impact  **HIGH** - assets can be lost If a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s. This bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the `Create a short put order with zero tokenAmount makes the option impossible to exercise`, therefore reported separately.   ## Proof of Concept  - [proof of concept](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202) - [reference case](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)  The proof of concept shows a scenario where babe makes an short call order with non empty `floorTokens` array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls `exercise`. There are two cases. - case 1: he calls exercise with empty `floorAssetTokenIds` array - case 2: he calls exercise with non-empty `floorAssetTokenIds` array with matching length to the `orders.floorTokens`  In the case1, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually `_transferFloorsIn` was called and he gets `Index out of bounds` error, because `floorTokens` is not empty [which does not match with empty `floorAssetTokenIds`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629). ```solidity // case 1   // PuttyV2.sol: _transferFloorsIn called by exercise   // The floorTokens and floorTokenIds do not match the lenghts   // floorTokens.length is not zero, while floorTokenIds.length is zero         ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]); ```  In the case2, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts. ``` // case2 // PuttyV2.sol: exercise // non empty floorAssetTokenIds array is passed for put option, it will revert          !order.isCall             ? require(floorAssetTokenIds.length == order.floorTokens.length, "Wrong amount of floor tokenIds")             : require(floorAssetTokenIds.length == 0, "Invalid floor tokenIds length"); ```  After the option is expired, the maker - babe is trying to withdraw but fails due to the [same issue with the case1](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516). ```solidity // maker trying to withdraw // PuttyV2.sol: withdraw    _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]); ```  Note on the poc: - The [test for case1 is commented out](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with `Index out of bounds`. - For the same reason the [withdraw](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out - The reference case just shows that it works as intended when the order does not contain non-empty `floorTokens`.  ## Tools Used  foundry  ## Recommended Mitigation Steps  It happens because the [`fillOrder` does not ensure](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the `order.floorTokens` to be empty when the order is short call.    
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L2   # Vulnerability details  The solidity version 0.8.13 has below two issues applicable to PuttyV2 1) Vulnerability related to ABI-encoding. ref : https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/ This vulnerability can be misused since the function hashOrder() and hashOppositeOrder() has applicable conditions. "...pass a nested array directly to another external function call or use abi.encode on it."  2) Vulnerability related to 'Optimizer Bug Regarding Memory Side Effects of Inline Assembly' ref : https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/ PuttyV2 inherits solidity contracts from openzeppelin and solmate, and both these uses inline assembly, and optimization is enabled while compiling.  ## Recommended Mitigation Steps Use recent Solidity version 0.8.15 which has the fix for these issues    
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500   # Vulnerability details  ## Proof-of-Concept  When users withdraw their strike escrowed in Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users.  [https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500)  ```solidity function withdraw(Order memory order) public {  ..SNIP..   // transfer strike to owner if put is expired or call is exercised  if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {   // send the fee to the admin/DAO if fee is greater than 0%   uint256 feeAmount = 0;   if (fee > 0) {    feeAmount = (order.strike * fee) / 1000;    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);   }    ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);    return;  }  ..SNIP.. } ```  There are two methods on how the owner can deny user from withdrawing their strike amount from the contract  #### Method #1 - Set the `owner()` to `zero` address  Many of the token implementations do not allow transfer to `zero` address ([Reference](https://github.com/d-xo/weird-erc20#revert-on-transfer-to-the-zero-address)). Popular ERC20 implementations such as the following Openzeppelin's ERC20 implementation do not allow transfer to `zero` address, and will revert immediately if the `to` address (recipient) points to a `zero` address during a transfer.  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226)  ```solidity function _transfer(     address from,     address to,     uint256 amount ) internal virtual {     require(from != address(0), "ERC20: transfer from the zero address");     require(to != address(0), "ERC20: transfer to the zero address");      _beforeTokenTransfer(from, to, amount);      uint256 fromBalance = _balances[from];     require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");     unchecked {         _balances[from] = fromBalance - amount;         // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by         // decrementing then incrementing.         _balances[to] += amount;     }      emit Transfer(from, to, amount);      _afterTokenTransfer(from, to, amount); } ```  It is possible for the owner to transfer the ownership to a `zero` address, thus causing the fee transfer to the contract owner to always revert. When the fee transfer always reverts, no one can withdraw their strike amount from the contract.  This issue will affect all orders that adopt a `baseAsset` that reverts when transferring to `zero` address.  #### Method #2 - If `baseAsset` is a ERC777 token  > Note: `owner()` could point to a contract or EOA account. By pointing to a contract, the contract could implement logic to revert whenever someone send tokens to it.  ERC777 contains a `tokensReceived` hook that will notify the recipient whenever someone sends some tokens to the recipient .   Assuming that the `baseAsset` is a ERC77 token, the recipient, which is the `owner()` in this case, could always revert whenever `PuttyV2` contract attempts to send the fee to recipient. This will cause the `withdraw` function to revert too. As a result, no one can withdraw their strike amount from the contract.  This issue will affect all orders that has ERC777 token as its `baseAsset`.  ## Impact  User cannot withdraw their strike amount and their asset will be stuck in the contract.  ## Recommended Mitigation Steps  It is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.  Instead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.  Consider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process.   This will give users more assurance and confidence about the security of their funds stored within Putty.  ```solidity mapping(address => uint256) public ownerFees;  function withdraw(Order memory order) public {  ..SNIP..     // transfer strike to owner if put is expired or call is exercised     if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {         // send the fee to the admin/DAO if fee is greater than 0%         uint256 feeAmount = 0;         if (fee > 0) {             feeAmount = (order.strike * fee) / 1000;             ownerFees[order.baseAsset] += feeAmount         }          ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);          return;     }     ..SNIP.. }  function withdrawFee(address baseAsset) public onlyOwner {  uint256 _feeAmount = ownerFees[baseAsset];  ownerFees[baseAsset] = 0;  ERC20(baseAsset).safeTransfer(owner(), _feeAmount); } ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451   # Vulnerability details  ## Impact  Fees are expected to be paid whenever an option is exercised (as per the function comment on [L235](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L235)).  ### Put options  If a put option is exercised, the exerciser receives the strike price (initially deposited by the short position holder) denominated in `order.baseAsset`.  ### Call options  If a call option is exercised, the exerciser sends the strike price to Putty and the short position holder is able to withdraw the strike amount.  However, the current protocol implementation is missing to deduct fees for exercised put options. Put options are free of any fees.  ## Proof of Concept  The protocol fee is correctly charged for exercised calls:  [PuttyV2.withdraw](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506)  ```solidity // transfer strike to owner if put is expired or call is exercised if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {     // send the fee to the admin/DAO if fee is greater than 0%     uint256 feeAmount = 0;     if (fee > 0) {         feeAmount = (order.strike * fee) / 1000;         ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit DoS due to reverting erc20 token transfer (weird erc20 tokens, blacklisted or paused owner; erc777 hook on owner receiver side can prevent transfer hence reverting and preventing withdrawal) - use pull pattern @high  // @audit zero value token transfers can revert. Small strike prices and low fee can lead to rounding down to 0 - check feeAmount > 0 @high  // @audit should not take fees if renounced owner (zero address) as fees can not be withdrawn @medium     }      ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); // @audit fee should not be paid if strike is simply returned to short owner for expired put @high      return; } ```  Contrary, put options are free of any fees:  [PuttyV2.sol#L450-L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451)  ```solidity // transfer strike from putty to exerciser ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike); ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Charge fees also for exercised put options.   
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500   # Vulnerability details  ## Impact  Certain ERC-20 tokens do not support zero-value token transfers and revert. Using such a token as a `order.baseAsset` for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.  ## Proof of Concept  [PuttyV2.sol#L499-L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500)  ```solidity // send the fee to the admin/DAO if fee is greater than 0% uint256 feeAmount = 0; if (fee > 0) {     feeAmount = (order.strike * fee) / 1000;     ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit-info zero-value ERC20 token transfers can revert for certain tokens } ```  Some ERC20 tokens revert for zero-value transfers (e.g. `LEND`). If used as a `order.baseAsset` and a small strike price, the fee token transfer will revert. Hence, assets and the strike can not be withdrawn and remain locked in the contract.  See [Weird ERC20 Tokens - Revert on Zero Value Transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)  **Example:**  - `order.baseAsset` is one of those weird ERC-20 tokens - `order.strike = 999` (depending on the token decimals, a very small option position) - `fee = 1` (0.1%)  $((999 * 1) / 1000 = 0.999)$ rounded down to 0 -> zero-value transfer reverting transaction  ## Tools Used  Manual review  ## Recommended mitigation steps  Add a simple check for zero-value token transfers:  ```solidity // send the fee to the admin/DAO if fee is greater than 0% uint256 feeAmount = 0; if (fee > 0) {     feeAmount = (order.strike * fee) / 1000;      if (feeAmount > 0) {         ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);     } } ```   
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451   # Vulnerability details  ## Impact Fee is being deducted when Put is expired and not when it is exercised in `PuttyV2.sol`. Comment section of the `setFee()` function mentions `"fee rate that is applied on exercise"` which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).  But, in function `withdraw()` at [PuttyV2.solL#495-L503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired.   Also, in function `exercise()` there is no fee deduction from the `order.strike` when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).  This unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.  ## Proof of Concept `if` condition present at [PuttyV2.solL#495](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if `order.isCall` is `false` and `isExercised` is false.  `feeAmount` becomes positive if `fee > 0` and it gets deducted from the `order.strike` which gets transferred to `msg.sender` at line number [PuttyV2.solL#503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps 1. Update `if` condition at [PuttyV2.sol#L498](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with `(fee > 0 && order.isCall && isExercised)`  2. Add feeAmount calculation and deduction after put is exercised and strike is transferred at [PuttyV2.sol#L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:  ```solidity uint256 feeAmount = 0; if (fee > 0) {     feeAmount = (order.strike * fee) / 1000;     ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); } ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); ```  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436   # Vulnerability details  ## Impact `fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.   ## Proof of Concept Ether can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here: ```solidity File: contracts/src/PuttyV2.sol   #1  323           if (order.isLong) { 324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium); 325           } else { ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325   If the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused: ```solidity File: contracts/src/PuttyV2.sol   #2  337               } else { 338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium); 339               } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339   Same for the exercise of call options: ```solidity File: contracts/src/PuttyV2.sol   #3  435               } else { 436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike); 437               } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437   ## Tools Used Code inspection  ## Recommended Mitigation Steps Add a `require(0 == msg.value)` for the above three conditions   
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454   # Vulnerability details  ## Impact Put option buyers pay an option premium to the seller for the privilege of being able to 'put' assets to the seller and get the strike price for it rather than the current market price. If they're unable to perform the 'put', they've paid the premium for nothing, and essentially have had funds stolen from them.   ## Proof of Concept If the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing: ```solidity File: contracts/src/PuttyV2.sol   #1  453               // transfer assets from exerciser to putty 454               _transferERC20sIn(order.erc20Assets, msg.sender); ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454   The function reverts if any amount is equal to zero, or the asset doesn't exist: ```solidity File: contracts/src/PuttyV2.sol   #2  593       function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal { 594           for (uint256 i = 0; i < assets.length; i++) { 595               address token = assets[i].token; 596               uint256 tokenAmount = assets[i].tokenAmount; 597    598               require(token.code.length > 0, "ERC20: Token is not contract"); 599               require(tokenAmount > 0, "ERC20: Amount too small"); 600    601               ERC20(token).safeTransferFrom(from, address(this), tokenAmount); 602           } 603       } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593-L603    ## Tools Used Code inspection   ## Recommended Mitigation Steps Verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time    
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535   # Vulnerability details  ## Impact  Order cancellation requires makers to call `cancel()`, inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.  This first issue is that it is an on-chain signal for MEV users to frontrun the cancellation and fill the order.  The second issue is the dependency to a centralized service for cancelling the order. As orders are signed off chain, they would be stored in a centralized database. It is unlikely that an end user would locally record all the orders they make. This means that when cancelling an order, maker needs to request the order parameters from the centralized service. If the centralized service goes offline, it could allow malicious parties who have a copy of the order database to fill orders that would have been cancelled otherwise.  ## Proof of Concept  1. Bob signs an order which gets recorded in Putty servers. 2. Alice mirrors all the orders using Putty APIs. 3. Putty servers go offline. 4. Bob wants to cancel his order because changing token prices makes his order less favourable to him. 5. Bob cannot cancel his order because Putty servers are down and he does not remember the exact amounts of tokens he used. 6. Alice goes through all the orders in her local mirror and fulfills the non-cancelled orders, including Bob's, with extremely favourable terms for herself.  ## Tools Used  Pen & paper.  ## Recommended Mitigation Steps  Aside from the standard order cancellation method, have an extra method to cancel all orders of a caller. This can be achieved using a "minimum valid nonce" state variable, as a mapping from user address to nonce.  ```solidity mapping(address => uint256) minimumValidNonce; ```  Allow users to increment their `minimumValidNonce`. Make sure the incrementation function do not allow incrementing more than `2**64` such that callers cannot lock themselves out of creating orders by increasing `minimumValidNonce` to `2**256-1` by mistake. Then, prevent filling orders if `order.nonce < minimumValidNonce`.  Another method to achieve bulk cancelling is using counters. For example, Seaport [uses counters](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/CounterManager.sol), which is an extra order parameter that has to match the corresponding counter state variable. It allows maker to cancel all his orders by [incrementing the counter state variable by one](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/Consideration.sol#L475-L478).   Either of these extra cancellation methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/main/contracts/src/PuttyV2.sol#L287   # Vulnerability details  ## Impact A malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction  ## Proof of Concept !. Maker creates an order with zero Order duration 2. Taker fills this order but the order instantly expires since duration was 0 3. Taker gets the only option to withdraw with fees on strike price  ## Recommended Mitigation Steps Enforce atleast x days of duration  
# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584   # Vulnerability details  ## Impact  When a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.  The impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.  ## Proof of Concept  [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled. ```solidity     function acceptCounterOffer(         Order memory order,         bytes calldata signature,         Order memory originalOrder     ) public payable returns (uint256 positionId) {         // cancel the original order         cancel(originalOrder);           // accept the counter offer         uint256[] memory floorAssetTokenIds = new uint256[](0);         positionId = fillOrder(order, signature, floorAssetTokenIds);     } ```  [cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding. ```solidity     function cancel(Order memory order) public {         require(msg.sender == order.maker, "Not your order");           bytes32 orderHash = hashOrder(order);           // mark the order as cancelled         cancelledOrders[orderHash] = true;           emit CancelledOrder(orderHash, order);     } ```  Therefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.  ## Recommended Mitigation Steps  Consider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.  
