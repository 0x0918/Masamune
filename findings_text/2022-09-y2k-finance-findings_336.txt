# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64   # Vulnerability details  ## Impact When calling the following `triggerEndEpoch` function, `tvl`, which is a `VaultTVL` type, is created as a part of the emitted `DepegInsurance` `event` after `idClaimTVL` and `idFinalTVL` are already updated for both the hedge and risk vaults. However, comparing to the fields of the `VaultTVL` `struct` definition below, `insrVault.idClaimTVL(epochEnd)` is incorrectly used as `RISK_finalTVL` and `riskVault.idFinalTVL(epochEnd)` is incorrectly used as `INSR_claimTVL` because `insrVault.setClaimTVL(epochEnd, 0)` has been executed, which does not occur when calling the `triggerDepeg` function. Because of the incorrect `tvl` used in the emitted `DepegInsurance` `event`, the frontend can display misleading information that confuse users, and debugging with incorrect data will be hard for developers.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 ```solidity     function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {         if(             vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)                 revert MarketDoesNotExist(marketIndex);         if(             block.timestamp < epochEnd)             revert EpochNotExpired();          address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);          Vault insrVault = Vault(vaultsAddress[0]);         Vault riskVault = Vault(vaultsAddress[1]);          if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)             revert EpochNotExist();          //require this function cannot be called twice in the same epoch for the same vault         if(insrVault.idFinalTVL(epochEnd) != 0)             revert NotZeroTVL();         if(riskVault.idFinalTVL(epochEnd) != 0)              revert NotZeroTVL();          insrVault.endEpoch(epochEnd, false);         riskVault.endEpoch(epochEnd, false);          insrVault.setClaimTVL(epochEnd, 0);         riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));         insrVault.sendTokens(epochEnd, address(riskVault));          VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         );          emit DepegInsurance(             keccak256(                 abi.encodePacked(                     marketIndex,                     insrVault.idEpochBegin(epochEnd),                     epochEnd                 )             ),             tvl,             false,             epochEnd,             block.timestamp,             getLatestPrice(insrVault.tokenInsured())         );     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64 ```solidity     struct VaultTVL {         uint256 RISK_claimTVL;         uint256 RISK_finalTVL;         uint256 INSR_claimTVL;         uint256 INSR_finalTVL;     } ```  ## Proof of Concept Please append the following test in `test\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testCallingtriggerEndEpochCreatesIncorrectVaultTVL() public{         testDeposit();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];          Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          vm.warp(endEpoch + 1 days);          controller.triggerEndEpoch(SINGLE_MARKET_INDEX, endEpoch);          /* VaultTVL struct has the following structure              struct VaultTVL {                 uint256 RISK_claimTVL;                 uint256 RISK_finalTVL;                 uint256 INSR_claimTVL;                 uint256 INSR_finalTVL;             }          */          /* in controller.triggerEndEpoch, VaultTVL is created as follows after idClaimTVL and idFinalTVL for both vaults are already updated              VaultTVL memory tvl = VaultTVL(                 riskVault.idClaimTVL(epochEnd),                 insrVault.idClaimTVL(epochEnd),                 riskVault.idFinalTVL(epochEnd),                 insrVault.idFinalTVL(epochEnd)             );          */          // insrVault.idClaimTVL(epochEnd), which is vHedge.idClaimTVL(endEpoch), does not correspond to RISK_finalTVL, which should be vRisk.idFinalTVL(endEpoch)         assertTrue(vRisk.idFinalTVL(endEpoch) != vHedge.idClaimTVL(endEpoch));          // riskVault.idFinalTVL(epochEnd), which is vRisk.idFinalTVL(endEpoch), does not correspond to INSR_claimTVL, which should be vHedge.idClaimTVL(endEpoch)          assertTrue(vHedge.idClaimTVL(endEpoch) != vRisk.idFinalTVL(endEpoch));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L227-L232 can be updated to the following code. ```solidity         VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         ); ```
