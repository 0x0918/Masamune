# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple files within the contracts/basket/contracts/singleJoinExit/ directory call `token.approve()` for an ERC20 token, but these calls do not verify whether the `approve()` call failed. Some ERC20 tokens do not revert if an approval fails, and because the return value is not checked, the contract would not be aware of this failure, potentially causing malfunctions in later operations. Using a function from SafeERC20 that checks the return value would mitigate this edge case.  ## Proof of Concept  token.approve() is found in several locations: - singleJoinExit/SingleTokenJoin.sol [line 43](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L43) - singleJoinExit/SingleNativeTokenExitV2.sol [line 55](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExitV2.sol#L55) - singleJoinExit/SingleNativeTokenExit.sol [line 44](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L44) - singleJoinExit/SingleTokenJoinV2.sol [line 53](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L53)  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  While the OpenZeppelin SafeERC20 `safeApprove()` function could be used to revert on approve failures unlike the standard `approve()`, the `safeApprove()` function [is deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ac4d93ae318cdf6c8a1125dff3a439a2aeabb63/contracts/token/ERC20/utils/SafeERC20.sol#L39-L44) and instead OpenZeppelin recommends either `safeIncreaseAllowance()` or `safeDecreaseAllowance()`. Because uint256(-1) should be an increase, replace each instance of `token.approve(spender, uint256(-1))` with `token.safeIncreaseAllowance(spender, uint256(-1))`.  
# Handle  pauliax   # Vulnerability details  ## Impact Contracts SingleTokenJoinV2 and SingleNativeTokenExitV2 initialize uniSwapLikeRouter, but never actually use it, as swap.exchange is used instead. So it basically trusts the user input. Consider removing uniSwapLikeRouter if that was the intention to save some gas.  
# Handle  Czar102   # Vulnerability details  ## Impact The initialization status is defined by the [name and symbol](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/ERC20/ERC20Facet.sol#L25-L28). It is possible it set them back to an empty string, uninitializing the contract and letting the `initialize(..)` function be called again. This way, the owner may, for example, hide minting additional tokens. Or, after accidentally setting name and symbol to empty strings, anyone can take control over the contract and mint any number of tokens.  In general, it shouldn't be possible to initialize more than once.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider adding empty string checks in `setName(...)` and `setSymbol(...)` functions.   
# Handle  pauliax   # Vulnerability details  ## Impact I am sorry if I incorrectly understood the intentions of contract PolygonERC20Wrapper but the comments and the code do not align here:  Function deposit:   "Should handle deposit by minting the required amount for user. Make sure minting is done only by this function". However, the code does not perform any minting and just transfers the underlying tokens to the user.  On the other hand, functions withdraw and withdrawTo state:   "Should burn user's tokens"  but it actually performs both, minting and burning: ```solidity   _mint(recipient, amount);   _burn(recipient, amount); ```  ## Recommended Mitigation Steps I was late to verify this with the sponsor, so make sure this is the intended behavior, and update comments to match the codebase.  
# Handle  Czar102   # Vulnerability details  ## Impact To save gas it is recommended it call function internally, if possible.  ## Proof of Concept Function [`BasketFacet::getLock()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L282-L286) is defined externally and calls from [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L148) and [`BasketFacet::exitPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L194) are not internal, but message calls.  The same applies to function [`BasketFacet::getCap()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L328-L330) usage in [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L154).  ## Recommended Mitigation Steps Consider changing visibility of `BasketFacet::getLock()` to public and calling the above function internally. Alternative solution shall be implemented with `BasketFacet::getCap()`.   
# Handle  JMukesh   # Vulnerability details  ## Impact The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  ## Proof of Concept  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ## Tools Used  manual review  ## Recommended Mitigation Steps  add condition to check return value   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L51-L57  ```solidity IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);  inputToken.safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  `inputToken` is unnecessary as it's being used only once. Can be changed to:  ```solidity IERC20(_joinTokenStruct.inputToken).safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  
# Handle  WatchPug   # Vulnerability details  Under certain circumstances, e.g. `annualizedFee` being minted to `feeBeneficiary` between the time user sent the transaction and the transaction being packed into the block and causing amounts of underlying tokens for each basketToken to decrease. It's possible or even most certainly that there will be some leftover basket underlying tokens, as `BasketFacet.sol#joinPool()` will only transfer required amounts of basket tokens from Join contracts.  However, in the current implementation, only the leftover inputToken is returned.  As a result, the leftover underlying tokens won't be returned to the user, which constitutes users' fund loss.  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L57-L78  ```solidity function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)     external {     // ######## INIT TOKEN #########     IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);      inputToken.safeTransferFrom(         msg.sender,         address(this),         _joinTokenStruct.inputAmount     );      _joinTokenSingle(_joinTokenStruct);      // ######## SEND TOKEN #########     uint256 remainingIntermediateBalance = inputToken.balanceOf(         address(this)     );     if (remainingIntermediateBalance > 0) {         inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);     } } ```  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L143-L168  ```solidity function joinPool(uint256 _amount, uint16 _referral)     external     override     noReentry {     require(!this.getLock(), "POOL_LOCKED");     chargeOutstandingAnnualizedFee();     LibBasketStorage.BasketStorage storage bs =         LibBasketStorage.basketStorage();     uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;     require(         totalSupply.add(_amount) <= this.getCap(),         "MAX_POOL_CAP_REACHED"     );      uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);      for (uint256 i; i < bs.tokens.length; i++) {         IERC20 token = bs.tokens[i];         uint256 tokenAmount =             balance(address(token)).mul(_amount.add(feeAmount)).div(                 totalSupply             );         require(tokenAmount != 0, "AMOUNT_TOO_SMALL");         token.safeTransferFrom(msg.sender, address(this), tokenAmount);     }     ... ```  Furthermore, the leftover tokens in the `SingleTokenJoinV2` contract can be stolen by calling `joinTokenSingle()` with fake `outputBasket` contract and `swap.exchange` contract.  ### Recomandation  Consider changing to:   1. Calling `IBasketFacet.calcTokensForAmount()` first and only swap for exactly the desired amounts of tokens (like `SingleTokenJoin.sol`); 2. Or, refund leftover tokens.  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Use of transfer() might render ETH impossible to withdraw becuase after istanbul hardfork , there is increases in the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they’ll now consume more, since 2300 the amount of gas a contract’s fallback function receives if it’s called via Solidity’s transfer() or send() methods. Any smart contract that uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept  2021-12-amun\contracts\basket\contracts\singleJoinExit\EthSingleTokenJoin.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\EthSingleTokenJoinV2.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\SingleNativeTokenExit.sol: msg.sender.transfer(intermediateTokenBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\SingleNativeTokenExitV2.sol: msg.sender.transfer(intermediateTokenBalance);.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps -use call() to send ETH  
# Handle  kenzo   # Vulnerability details  An early division in `calcOutStandingAnnualizedFee` will lose accuracy of the fees calculation.  ## Impact Lost fees for the protocol.  ## Proof of Concept `calcOutStandingAnnualizedFee` uses the following formula to calculate the fees: [(Code ref)](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L259:#L262) ``` return             totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(                 365 days             ); ```  Since it is dividing by 10**18 in the middle of the calculation, the remainder of that division will be lost. This is why in Solidity, division should come in the end.  ## Recommended Mitigation Steps Move `div(10**18)` to the end of the calculation.  By the way, you might wanna consider changing your fee structure to a smaller basis. Making the base 1e18 gives you granularity that you might not need. For example, if the annualized fee is planned to be 1%, instead of it being 1e15 out of 1e18 it can be 100 out of 10000. This will help prevent overflow if that was the reason you chose to divide in the midst of the calculation.  
# Handle  defsec   # Vulnerability details  ## Impact  In the contract there is no re-entrancy mitigations. Contracts interact with various outside sources (tokens, aave pools, other possible strategies that may be added in the future, etc). so, for instance, now you have to be careful and do not allow tokens that have a receiver callback (e.g. erc777) or untrustable sources of yield (strategies).   ## Proof of Concept  1. Navigate to the following contract functions. (https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26)  ```          // ######## Wrap TOKEN #########         address(INTERMEDIATE_TOKEN).call{value: msg.value}("");          _joinTokenSingle(_joinTokenStruct);          uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(             address(this)         );         if (remainingIntermediateBalance > 0) {             IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(                 remainingIntermediateBalance             );             msg.sender.transfer(remainingIntermediateBalance);         }  ```  2. The contract does not follow Check Effect Interaction Pattern. It is vulnerable to re-entrancy.    3. Locations  ``` https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Consider using ReentrancyGuard on main action functions: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  
# Handle  defsec   # Vulnerability details  ## Impact  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L218"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L234"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV2.sol#L155"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV3.sol#L166"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/factories/PieFactoryContract.sol#L88"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Call/CallFacet.sol#L55"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L50"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L160"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L321"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L348"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L381"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L69"   ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  There's a griefing attack vulnerability in the function `joinTokenSingle` in  `SingleTokenJoin.sol` as well as `SingleTokenJoinV2.sol` which makes any user transaction fail with "FAILED_OUTPUT_AMOUNT".  ### Proof of Concept  The `JoinTokenStruct` argument for `joinTokenSingle` includes a field `outputAmount` to indicate the amount of tokens the user should receive after joining a basket (see line [135](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L135) and [130](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L130)).  However, this amount is compared to the contract's balance of the token and reverts if the amount is unequal.  If an attacker sends some amount of a basket's token to the contract, every call to this function will fail as long as the output token equals the attacker's token send.  ## Recommended Mitigation Steps  Refactor the `require` statement to expect at least the `outputAmount` of tokens, i.e. `require(outputAmount >= _joinTokenStruct.outputAmount)`.  
# Handle  harleythedog   # Vulnerability details  ## Impact The `CallFacet.sol` contract has the function `_call` : ``` function  _call(  address  _target,  bytes  memory  _calldata,  uint256  _value ) internal {  require(address(this).balance >= _value, "ETH_BALANCE_TOO_LOW");  (bool success, ) = _target.call{value: _value}(_calldata);  require(success, "CALL_FAILED");  emit  Call(msg.sender, _target, _calldata, _value); } ``` This function is utilized in a lot of different places. According to the [Solidity docs]([https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions)), "The low-level functions `call`, `delegatecall` and `staticcall` return `true` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed".      As a result, it is possible that this call will not work but `_call` will not notice anything went wrong. It could be possible that a user is interacting with an exchange or token that has been deleted, but `_call` will not notice that something has gone wrong and as a result, ether can become stuck in the contract. For this reason, it would be better to also check for the contract's existence prior to executing `_target.call`.   For reference, see a similar high severity reported in a Uniswap audit here (report # 9): https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf    ## Proof of Concept See `_call` here: https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/facets/Call/CallFacet.sol#L108.  ## Tools Used Inspection  ## Recommended Mitigation Steps To ensure tokens don't get stuck in edge case where user is interacting with a deleted contract, make sure to check that contract actually exists before calling it.   
# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:           basket in RebalanceManagerV2.sol         uniSwapLikeRouter in SingleNativeTokenExit.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExit.sol         uniSwapLikeRouter in SingleNativeTokenExitV2.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExitV2.sol         uniSwapLikeRouter in SingleTokenJoin.sol         INTERMEDIATE_TOKEN in SingleTokenJoin.sol         uniSwapLikeRouter in SingleTokenJoinV2.sol         INTERMEDIATE_TOKEN in SingleTokenJoinV2.sol         predicateProxy in MintableERC20.sol         underlying in PolygonERC20Wrapper.sol         childChainManager in PolygonERC20Wrapper.sol  
# Handle  jayjonah8   # Vulnerability details  ## Impact Floating pragmas are used throughout the codebase.  Contracts should be deployed with the same compiler version that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated or different compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  Floating pragmas are used throughout the protocol   ## Tools Used Manual code review   ## Recommended Mitigation Steps pragma solidity 0.7.5;  should be used in all files instead of  pragma solidity ^0.7.5; The pragma version should be locked on a specific version while considering know bugs for the chosen compiler version.    
# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple files within the contracts/basket/contracts/singleJoinExit/ directory call `token.approve()` for an ERC20 token, but these calls do not verify whether the `approve()` call failed. Some ERC20 tokens do not revert if an approval fails, and because the return value is not checked, the contract would not be aware of this failure, potentially causing malfunctions in later operations. Using a function from SafeERC20 that checks the return value would mitigate this edge case.  ## Proof of Concept  token.approve() is found in several locations: - singleJoinExit/SingleTokenJoin.sol [line 43](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L43) - singleJoinExit/SingleNativeTokenExitV2.sol [line 55](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExitV2.sol#L55) - singleJoinExit/SingleNativeTokenExit.sol [line 44](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L44) - singleJoinExit/SingleTokenJoinV2.sol [line 53](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L53)  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  While the OpenZeppelin SafeERC20 `safeApprove()` function could be used to revert on approve failures unlike the standard `approve()`, the `safeApprove()` function [is deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ac4d93ae318cdf6c8a1125dff3a439a2aeabb63/contracts/token/ERC20/utils/SafeERC20.sol#L39-L44) and instead OpenZeppelin recommends either `safeIncreaseAllowance()` or `safeDecreaseAllowance()`. Because uint256(-1) should be an increase, replace each instance of `token.approve(spender, uint256(-1))` with `token.safeIncreaseAllowance(spender, uint256(-1))`.  
# Handle  pauliax   # Vulnerability details  ## Impact Contracts SingleTokenJoinV2 and SingleNativeTokenExitV2 initialize uniSwapLikeRouter, but never actually use it, as swap.exchange is used instead. So it basically trusts the user input. Consider removing uniSwapLikeRouter if that was the intention to save some gas.  
# Handle  Czar102   # Vulnerability details  ## Impact The initialization status is defined by the [name and symbol](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/ERC20/ERC20Facet.sol#L25-L28). It is possible it set them back to an empty string, uninitializing the contract and letting the `initialize(..)` function be called again. This way, the owner may, for example, hide minting additional tokens. Or, after accidentally setting name and symbol to empty strings, anyone can take control over the contract and mint any number of tokens.  In general, it shouldn't be possible to initialize more than once.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider adding empty string checks in `setName(...)` and `setSymbol(...)` functions.   
# Handle  pauliax   # Vulnerability details  ## Impact I am sorry if I incorrectly understood the intentions of contract PolygonERC20Wrapper but the comments and the code do not align here:  Function deposit:   "Should handle deposit by minting the required amount for user. Make sure minting is done only by this function". However, the code does not perform any minting and just transfers the underlying tokens to the user.  On the other hand, functions withdraw and withdrawTo state:   "Should burn user's tokens"  but it actually performs both, minting and burning: ```solidity   _mint(recipient, amount);   _burn(recipient, amount); ```  ## Recommended Mitigation Steps I was late to verify this with the sponsor, so make sure this is the intended behavior, and update comments to match the codebase.  
# Handle  Czar102   # Vulnerability details  ## Impact To save gas it is recommended it call function internally, if possible.  ## Proof of Concept Function [`BasketFacet::getLock()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L282-L286) is defined externally and calls from [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L148) and [`BasketFacet::exitPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L194) are not internal, but message calls.  The same applies to function [`BasketFacet::getCap()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L328-L330) usage in [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L154).  ## Recommended Mitigation Steps Consider changing visibility of `BasketFacet::getLock()` to public and calling the above function internally. Alternative solution shall be implemented with `BasketFacet::getCap()`.   
# Handle  JMukesh   # Vulnerability details  ## Impact The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  ## Proof of Concept  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ## Tools Used  manual review  ## Recommended Mitigation Steps  add condition to check return value   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L51-L57  ```solidity IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);  inputToken.safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  `inputToken` is unnecessary as it's being used only once. Can be changed to:  ```solidity IERC20(_joinTokenStruct.inputToken).safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  
# Handle  WatchPug   # Vulnerability details  Under certain circumstances, e.g. `annualizedFee` being minted to `feeBeneficiary` between the time user sent the transaction and the transaction being packed into the block and causing amounts of underlying tokens for each basketToken to decrease. It's possible or even most certainly that there will be some leftover basket underlying tokens, as `BasketFacet.sol#joinPool()` will only transfer required amounts of basket tokens from Join contracts.  However, in the current implementation, only the leftover inputToken is returned.  As a result, the leftover underlying tokens won't be returned to the user, which constitutes users' fund loss.  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L57-L78  ```solidity function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)     external {     // ######## INIT TOKEN #########     IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);      inputToken.safeTransferFrom(         msg.sender,         address(this),         _joinTokenStruct.inputAmount     );      _joinTokenSingle(_joinTokenStruct);      // ######## SEND TOKEN #########     uint256 remainingIntermediateBalance = inputToken.balanceOf(         address(this)     );     if (remainingIntermediateBalance > 0) {         inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);     } } ```  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L143-L168  ```solidity function joinPool(uint256 _amount, uint16 _referral)     external     override     noReentry {     require(!this.getLock(), "POOL_LOCKED");     chargeOutstandingAnnualizedFee();     LibBasketStorage.BasketStorage storage bs =         LibBasketStorage.basketStorage();     uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;     require(         totalSupply.add(_amount) <= this.getCap(),         "MAX_POOL_CAP_REACHED"     );      uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);      for (uint256 i; i < bs.tokens.length; i++) {         IERC20 token = bs.tokens[i];         uint256 tokenAmount =             balance(address(token)).mul(_amount.add(feeAmount)).div(                 totalSupply             );         require(tokenAmount != 0, "AMOUNT_TOO_SMALL");         token.safeTransferFrom(msg.sender, address(this), tokenAmount);     }     ... ```  Furthermore, the leftover tokens in the `SingleTokenJoinV2` contract can be stolen by calling `joinTokenSingle()` with fake `outputBasket` contract and `swap.exchange` contract.  ### Recomandation  Consider changing to:   1. Calling `IBasketFacet.calcTokensForAmount()` first and only swap for exactly the desired amounts of tokens (like `SingleTokenJoin.sol`); 2. Or, refund leftover tokens.  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Use of transfer() might render ETH impossible to withdraw becuase after istanbul hardfork , there is increases in the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they’ll now consume more, since 2300 the amount of gas a contract’s fallback function receives if it’s called via Solidity’s transfer() or send() methods. Any smart contract that uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept  2021-12-amun\contracts\basket\contracts\singleJoinExit\EthSingleTokenJoin.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\EthSingleTokenJoinV2.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\SingleNativeTokenExit.sol: msg.sender.transfer(intermediateTokenBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\SingleNativeTokenExitV2.sol: msg.sender.transfer(intermediateTokenBalance);.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps -use call() to send ETH  
# Handle  kenzo   # Vulnerability details  An early division in `calcOutStandingAnnualizedFee` will lose accuracy of the fees calculation.  ## Impact Lost fees for the protocol.  ## Proof of Concept `calcOutStandingAnnualizedFee` uses the following formula to calculate the fees: [(Code ref)](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L259:#L262) ``` return             totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(                 365 days             ); ```  Since it is dividing by 10**18 in the middle of the calculation, the remainder of that division will be lost. This is why in Solidity, division should come in the end.  ## Recommended Mitigation Steps Move `div(10**18)` to the end of the calculation.  By the way, you might wanna consider changing your fee structure to a smaller basis. Making the base 1e18 gives you granularity that you might not need. For example, if the annualized fee is planned to be 1%, instead of it being 1e15 out of 1e18 it can be 100 out of 10000. This will help prevent overflow if that was the reason you chose to divide in the midst of the calculation.  
# Handle  defsec   # Vulnerability details  ## Impact  In the contract there is no re-entrancy mitigations. Contracts interact with various outside sources (tokens, aave pools, other possible strategies that may be added in the future, etc). so, for instance, now you have to be careful and do not allow tokens that have a receiver callback (e.g. erc777) or untrustable sources of yield (strategies).   ## Proof of Concept  1. Navigate to the following contract functions. (https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26)  ```          // ######## Wrap TOKEN #########         address(INTERMEDIATE_TOKEN).call{value: msg.value}("");          _joinTokenSingle(_joinTokenStruct);          uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(             address(this)         );         if (remainingIntermediateBalance > 0) {             IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(                 remainingIntermediateBalance             );             msg.sender.transfer(remainingIntermediateBalance);         }  ```  2. The contract does not follow Check Effect Interaction Pattern. It is vulnerable to re-entrancy.    3. Locations  ``` https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Consider using ReentrancyGuard on main action functions: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  
# Handle  defsec   # Vulnerability details  ## Impact  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L218"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L234"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV2.sol#L155"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV3.sol#L166"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/factories/PieFactoryContract.sol#L88"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Call/CallFacet.sol#L55"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L50"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L160"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L321"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L348"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L381"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L69"   ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  There's a griefing attack vulnerability in the function `joinTokenSingle` in  `SingleTokenJoin.sol` as well as `SingleTokenJoinV2.sol` which makes any user transaction fail with "FAILED_OUTPUT_AMOUNT".  ### Proof of Concept  The `JoinTokenStruct` argument for `joinTokenSingle` includes a field `outputAmount` to indicate the amount of tokens the user should receive after joining a basket (see line [135](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L135) and [130](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L130)).  However, this amount is compared to the contract's balance of the token and reverts if the amount is unequal.  If an attacker sends some amount of a basket's token to the contract, every call to this function will fail as long as the output token equals the attacker's token send.  ## Recommended Mitigation Steps  Refactor the `require` statement to expect at least the `outputAmount` of tokens, i.e. `require(outputAmount >= _joinTokenStruct.outputAmount)`.  
# Handle  harleythedog   # Vulnerability details  ## Impact The `CallFacet.sol` contract has the function `_call` : ``` function  _call(  address  _target,  bytes  memory  _calldata,  uint256  _value ) internal {  require(address(this).balance >= _value, "ETH_BALANCE_TOO_LOW");  (bool success, ) = _target.call{value: _value}(_calldata);  require(success, "CALL_FAILED");  emit  Call(msg.sender, _target, _calldata, _value); } ``` This function is utilized in a lot of different places. According to the [Solidity docs]([https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions)), "The low-level functions `call`, `delegatecall` and `staticcall` return `true` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed".      As a result, it is possible that this call will not work but `_call` will not notice anything went wrong. It could be possible that a user is interacting with an exchange or token that has been deleted, but `_call` will not notice that something has gone wrong and as a result, ether can become stuck in the contract. For this reason, it would be better to also check for the contract's existence prior to executing `_target.call`.   For reference, see a similar high severity reported in a Uniswap audit here (report # 9): https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf    ## Proof of Concept See `_call` here: https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/facets/Call/CallFacet.sol#L108.  ## Tools Used Inspection  ## Recommended Mitigation Steps To ensure tokens don't get stuck in edge case where user is interacting with a deleted contract, make sure to check that contract actually exists before calling it.   
# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:           basket in RebalanceManagerV2.sol         uniSwapLikeRouter in SingleNativeTokenExit.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExit.sol         uniSwapLikeRouter in SingleNativeTokenExitV2.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExitV2.sol         uniSwapLikeRouter in SingleTokenJoin.sol         INTERMEDIATE_TOKEN in SingleTokenJoin.sol         uniSwapLikeRouter in SingleTokenJoinV2.sol         INTERMEDIATE_TOKEN in SingleTokenJoinV2.sol         predicateProxy in MintableERC20.sol         underlying in PolygonERC20Wrapper.sol         childChainManager in PolygonERC20Wrapper.sol  
# Handle  jayjonah8   # Vulnerability details  ## Impact Floating pragmas are used throughout the codebase.  Contracts should be deployed with the same compiler version that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated or different compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  Floating pragmas are used throughout the protocol   ## Tools Used Manual code review   ## Recommended Mitigation Steps pragma solidity 0.7.5;  should be used in all files instead of  pragma solidity ^0.7.5; The pragma version should be locked on a specific version while considering know bugs for the chosen compiler version.    
# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple files within the contracts/basket/contracts/singleJoinExit/ directory call `token.approve()` for an ERC20 token, but these calls do not verify whether the `approve()` call failed. Some ERC20 tokens do not revert if an approval fails, and because the return value is not checked, the contract would not be aware of this failure, potentially causing malfunctions in later operations. Using a function from SafeERC20 that checks the return value would mitigate this edge case.  ## Proof of Concept  token.approve() is found in several locations: - singleJoinExit/SingleTokenJoin.sol [line 43](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L43) - singleJoinExit/SingleNativeTokenExitV2.sol [line 55](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExitV2.sol#L55) - singleJoinExit/SingleNativeTokenExit.sol [line 44](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L44) - singleJoinExit/SingleTokenJoinV2.sol [line 53](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L53)  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  While the OpenZeppelin SafeERC20 `safeApprove()` function could be used to revert on approve failures unlike the standard `approve()`, the `safeApprove()` function [is deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ac4d93ae318cdf6c8a1125dff3a439a2aeabb63/contracts/token/ERC20/utils/SafeERC20.sol#L39-L44) and instead OpenZeppelin recommends either `safeIncreaseAllowance()` or `safeDecreaseAllowance()`. Because uint256(-1) should be an increase, replace each instance of `token.approve(spender, uint256(-1))` with `token.safeIncreaseAllowance(spender, uint256(-1))`.  
# Handle  pauliax   # Vulnerability details  ## Impact Contracts SingleTokenJoinV2 and SingleNativeTokenExitV2 initialize uniSwapLikeRouter, but never actually use it, as swap.exchange is used instead. So it basically trusts the user input. Consider removing uniSwapLikeRouter if that was the intention to save some gas.  
# Handle  Czar102   # Vulnerability details  ## Impact The initialization status is defined by the [name and symbol](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/ERC20/ERC20Facet.sol#L25-L28). It is possible it set them back to an empty string, uninitializing the contract and letting the `initialize(..)` function be called again. This way, the owner may, for example, hide minting additional tokens. Or, after accidentally setting name and symbol to empty strings, anyone can take control over the contract and mint any number of tokens.  In general, it shouldn't be possible to initialize more than once.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider adding empty string checks in `setName(...)` and `setSymbol(...)` functions.   
# Handle  pauliax   # Vulnerability details  ## Impact I am sorry if I incorrectly understood the intentions of contract PolygonERC20Wrapper but the comments and the code do not align here:  Function deposit:   "Should handle deposit by minting the required amount for user. Make sure minting is done only by this function". However, the code does not perform any minting and just transfers the underlying tokens to the user.  On the other hand, functions withdraw and withdrawTo state:   "Should burn user's tokens"  but it actually performs both, minting and burning: ```solidity   _mint(recipient, amount);   _burn(recipient, amount); ```  ## Recommended Mitigation Steps I was late to verify this with the sponsor, so make sure this is the intended behavior, and update comments to match the codebase.  
# Handle  Czar102   # Vulnerability details  ## Impact To save gas it is recommended it call function internally, if possible.  ## Proof of Concept Function [`BasketFacet::getLock()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L282-L286) is defined externally and calls from [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L148) and [`BasketFacet::exitPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L194) are not internal, but message calls.  The same applies to function [`BasketFacet::getCap()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L328-L330) usage in [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L154).  ## Recommended Mitigation Steps Consider changing visibility of `BasketFacet::getLock()` to public and calling the above function internally. Alternative solution shall be implemented with `BasketFacet::getCap()`.   
# Handle  JMukesh   # Vulnerability details  ## Impact The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  ## Proof of Concept  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ## Tools Used  manual review  ## Recommended Mitigation Steps  add condition to check return value   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L51-L57  ```solidity IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);  inputToken.safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  `inputToken` is unnecessary as it's being used only once. Can be changed to:  ```solidity IERC20(_joinTokenStruct.inputToken).safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  
# Handle  WatchPug   # Vulnerability details  Under certain circumstances, e.g. `annualizedFee` being minted to `feeBeneficiary` between the time user sent the transaction and the transaction being packed into the block and causing amounts of underlying tokens for each basketToken to decrease. It's possible or even most certainly that there will be some leftover basket underlying tokens, as `BasketFacet.sol#joinPool()` will only transfer required amounts of basket tokens from Join contracts.  However, in the current implementation, only the leftover inputToken is returned.  As a result, the leftover underlying tokens won't be returned to the user, which constitutes users' fund loss.  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L57-L78  ```solidity function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)     external {     // ######## INIT TOKEN #########     IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);      inputToken.safeTransferFrom(         msg.sender,         address(this),         _joinTokenStruct.inputAmount     );      _joinTokenSingle(_joinTokenStruct);      // ######## SEND TOKEN #########     uint256 remainingIntermediateBalance = inputToken.balanceOf(         address(this)     );     if (remainingIntermediateBalance > 0) {         inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);     } } ```  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L143-L168  ```solidity function joinPool(uint256 _amount, uint16 _referral)     external     override     noReentry {     require(!this.getLock(), "POOL_LOCKED");     chargeOutstandingAnnualizedFee();     LibBasketStorage.BasketStorage storage bs =         LibBasketStorage.basketStorage();     uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;     require(         totalSupply.add(_amount) <= this.getCap(),         "MAX_POOL_CAP_REACHED"     );      uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);      for (uint256 i; i < bs.tokens.length; i++) {         IERC20 token = bs.tokens[i];         uint256 tokenAmount =             balance(address(token)).mul(_amount.add(feeAmount)).div(                 totalSupply             );         require(tokenAmount != 0, "AMOUNT_TOO_SMALL");         token.safeTransferFrom(msg.sender, address(this), tokenAmount);     }     ... ```  Furthermore, the leftover tokens in the `SingleTokenJoinV2` contract can be stolen by calling `joinTokenSingle()` with fake `outputBasket` contract and `swap.exchange` contract.  ### Recomandation  Consider changing to:   1. Calling `IBasketFacet.calcTokensForAmount()` first and only swap for exactly the desired amounts of tokens (like `SingleTokenJoin.sol`); 2. Or, refund leftover tokens.  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Use of transfer() might render ETH impossible to withdraw becuase after istanbul hardfork , there is increases in the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they’ll now consume more, since 2300 the amount of gas a contract’s fallback function receives if it’s called via Solidity’s transfer() or send() methods. Any smart contract that uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept  2021-12-amun\contracts\basket\contracts\singleJoinExit\EthSingleTokenJoin.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\EthSingleTokenJoinV2.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\SingleNativeTokenExit.sol: msg.sender.transfer(intermediateTokenBalance);  2021-12-amun\contracts\basket\contracts\singleJoinExit\SingleNativeTokenExitV2.sol: msg.sender.transfer(intermediateTokenBalance);.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps -use call() to send ETH  
# Handle  kenzo   # Vulnerability details  An early division in `calcOutStandingAnnualizedFee` will lose accuracy of the fees calculation.  ## Impact Lost fees for the protocol.  ## Proof of Concept `calcOutStandingAnnualizedFee` uses the following formula to calculate the fees: [(Code ref)](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L259:#L262) ``` return             totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(                 365 days             ); ```  Since it is dividing by 10**18 in the middle of the calculation, the remainder of that division will be lost. This is why in Solidity, division should come in the end.  ## Recommended Mitigation Steps Move `div(10**18)` to the end of the calculation.  By the way, you might wanna consider changing your fee structure to a smaller basis. Making the base 1e18 gives you granularity that you might not need. For example, if the annualized fee is planned to be 1%, instead of it being 1e15 out of 1e18 it can be 100 out of 10000. This will help prevent overflow if that was the reason you chose to divide in the midst of the calculation.  
# Handle  defsec   # Vulnerability details  ## Impact  In the contract there is no re-entrancy mitigations. Contracts interact with various outside sources (tokens, aave pools, other possible strategies that may be added in the future, etc). so, for instance, now you have to be careful and do not allow tokens that have a receiver callback (e.g. erc777) or untrustable sources of yield (strategies).   ## Proof of Concept  1. Navigate to the following contract functions. (https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26)  ```          // ######## Wrap TOKEN #########         address(INTERMEDIATE_TOKEN).call{value: msg.value}("");          _joinTokenSingle(_joinTokenStruct);          uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(             address(this)         );         if (remainingIntermediateBalance > 0) {             IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(                 remainingIntermediateBalance             );             msg.sender.transfer(remainingIntermediateBalance);         }  ```  2. The contract does not follow Check Effect Interaction Pattern. It is vulnerable to re-entrancy.    3. Locations  ``` https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Consider using ReentrancyGuard on main action functions: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  
# Handle  defsec   # Vulnerability details  ## Impact  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L218"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L234"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV2.sol#L155"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV3.sol#L166"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/factories/PieFactoryContract.sol#L88"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Call/CallFacet.sol#L55"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L50"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L160"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L321"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L348"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L381"  "https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L69"   ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  There's a griefing attack vulnerability in the function `joinTokenSingle` in  `SingleTokenJoin.sol` as well as `SingleTokenJoinV2.sol` which makes any user transaction fail with "FAILED_OUTPUT_AMOUNT".  ### Proof of Concept  The `JoinTokenStruct` argument for `joinTokenSingle` includes a field `outputAmount` to indicate the amount of tokens the user should receive after joining a basket (see line [135](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L135) and [130](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L130)).  However, this amount is compared to the contract's balance of the token and reverts if the amount is unequal.  If an attacker sends some amount of a basket's token to the contract, every call to this function will fail as long as the output token equals the attacker's token send.  ## Recommended Mitigation Steps  Refactor the `require` statement to expect at least the `outputAmount` of tokens, i.e. `require(outputAmount >= _joinTokenStruct.outputAmount)`.  
# Handle  harleythedog   # Vulnerability details  ## Impact The `CallFacet.sol` contract has the function `_call` : ``` function  _call(  address  _target,  bytes  memory  _calldata,  uint256  _value ) internal {  require(address(this).balance >= _value, "ETH_BALANCE_TOO_LOW");  (bool success, ) = _target.call{value: _value}(_calldata);  require(success, "CALL_FAILED");  emit  Call(msg.sender, _target, _calldata, _value); } ``` This function is utilized in a lot of different places. According to the [Solidity docs]([https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions)), "The low-level functions `call`, `delegatecall` and `staticcall` return `true` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed".      As a result, it is possible that this call will not work but `_call` will not notice anything went wrong. It could be possible that a user is interacting with an exchange or token that has been deleted, but `_call` will not notice that something has gone wrong and as a result, ether can become stuck in the contract. For this reason, it would be better to also check for the contract's existence prior to executing `_target.call`.   For reference, see a similar high severity reported in a Uniswap audit here (report # 9): https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf    ## Proof of Concept See `_call` here: https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/facets/Call/CallFacet.sol#L108.  ## Tools Used Inspection  ## Recommended Mitigation Steps To ensure tokens don't get stuck in edge case where user is interacting with a deleted contract, make sure to check that contract actually exists before calling it.   
# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:           basket in RebalanceManagerV2.sol         uniSwapLikeRouter in SingleNativeTokenExit.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExit.sol         uniSwapLikeRouter in SingleNativeTokenExitV2.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExitV2.sol         uniSwapLikeRouter in SingleTokenJoin.sol         INTERMEDIATE_TOKEN in SingleTokenJoin.sol         uniSwapLikeRouter in SingleTokenJoinV2.sol         INTERMEDIATE_TOKEN in SingleTokenJoinV2.sol         predicateProxy in MintableERC20.sol         underlying in PolygonERC20Wrapper.sol         childChainManager in PolygonERC20Wrapper.sol  
# Handle  jayjonah8   # Vulnerability details  ## Impact Floating pragmas are used throughout the codebase.  Contracts should be deployed with the same compiler version that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated or different compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  Floating pragmas are used throughout the protocol   ## Tools Used Manual code review   ## Recommended Mitigation Steps pragma solidity 0.7.5;  should be used in all files instead of  pragma solidity ^0.7.5; The pragma version should be locked on a specific version while considering know bugs for the chosen compiler version.    
