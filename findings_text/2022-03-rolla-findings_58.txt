# Low 1 Deprecated `_setupRole` function used  ## Impact  The _setupRole function is deprecated according to the Open Zeppelin comment `NOTE: This function is deprecated in favor of {_grantRole}`  Use the recommended _grantRole function instead.  ## Proof of concept  Where _setupRole is used in rolla https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L160-L161 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L79-L90  Open Zeppelin comment https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L195  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Avoid using deprecated functions. Replace _setupRole with _grantRole  # Low 2 _timestamps variable shadowing  ## Impact  ConfigTimelockController.sol inherits TimelockController.sol but declares a new _timestamps mapping equivalent to the mapping in TimelockController.sol. This shadowing of the mapping will cause problems in calls to parent functions that use the _timestamps mapping, because the _timestamps mapping in ConfigTimelockController.sol is not used.  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Proof of concept  _timestamps is declared in TimelockController.sol https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L29  An identical _timestamps mapping is declared in ConfigTimelockController.sol, which inherits TimelockController.sol and does not need to declare an identical mapping with the same name https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Tools Used  Slither https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing  ## Recommended Mitigation Steps  Remove the line of code declaring the _timestamps mapping in ConfigTimelockController.sol so that the _timestamps mapping from TimelockController.sol is used throughout.  # Low 3 Roles not added to quantRoles  ## Impact  The quantRoles mapping is intended to store all roles used by QuantConfig.sol. Other contracts import the IQuantConfig.sol interface and call config.quantRoles. Most of the contracts calling config.quantRoles do so for a role that is never added to the quantRoles mapping in QuantConfig.sol. Because solidity variables has a default value, querying an entity of a `string => bytes32` mapping that does not exist with return an empty bytes32 value of bytes32(0). This interferes with the intended logic of the contracts and in some cases will result in if statements that always return one condition because the quantRoles mapping is never updated outside of the _setProtocolRole function.  ## Proof of concept  Observe that the quantRoles mapping has a new role added in the _setProtocolRole function of QuantConfig.sol, and this is the only function in QuantConfig.sol that modifies this mapping https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L177  Because the _setProtocolRole is an internal function, another contract would need to inherit QuantConfig.sol in order to modify the quantRoles mapping. But no other contract in the Rolla project does this. There are several roles, such as FALLBACK_PRICE_ROLE, which are queried in the quantRoles mapping but will never return a value other than bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L81  Another example is the COLLATERAL_MINTER_ROLE role, which is queried twice but never set and will always return bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L108 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L145  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The simplest approach is a manual one that may result in error. The owner of QuantConfig.sol can call setProtocolRole to set these roles after QuantConfig is deployed. This may even be the intended approach with this code, but there is no test or other code that demonstrates setting the FALLBACK_PRICE_ROLE in the quantRoles mapping.  A more robust solution is to call _setProtocolRole with all the hardcoded roles in the initialize function of QuantConfig.sol, like what is done for oracleManagerRole in this line https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L164  # Low 4 Missing reentrancy guard on ERC1155 _mint  ## Impact  The ERC1155 _mint function is vulnerable to reentrancy. A nonreentrant modifier or lock modifier should be applied to functions that have reentrancy weaknesses for protection from this attack vector. Even though no direct reentrancy attack may exist on these Rolla functions today, that could change in the future and proper defensive measures are crucial.  ## Proof of concept  The ERC1155 _mint function is used in mintCollateralToken https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L116  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the nonReentrant modifier from the Open Zeppelin library https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol
