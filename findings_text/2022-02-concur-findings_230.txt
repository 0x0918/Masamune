1. Tittle execute() should revert, instead of returning false on failing low level call   # Vulnerability details  ## Impact When an owner want to execute something, make sure to revert the transaction when the low level call is failing, this execute() will still returning a success transaction, eventhough the actual execution is failing when doing the low level call  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L33 --------------------------------------------------------------------------------------------------------------------------- 2. Tittle claimRewards() didnt follow the safe check effect pattern  ## Impact a user can claim a reward by calling the claimRewards(), however this function didnt follow the correct check effect pattern, where the zero address is set after making an external call, lets say the reward token is erc777 which will make an external during transfer, the user can reenter this function since this function didnt follow the check effect pattern and didnt have a noreentrant modifier, the user can claim token with reentrancy.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L37 --------------------------------------------------------------------------------------------------------------------------- 3. Tittle Unsafe cast from uint256 to uint192  ## Impact  the max value of uint192 is 6277101735386680763835789423207666416102355444464034512895, however when you input the _amount to 6277101735386680763835789423207666416102355444464034512896 value, since it doing an unsafe cast from uint256 to uint192, the _amount value would be 0.  ##Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235 --------------------------------------------------------------------------------------------------------------------------- 4. Tittle this check can be bypassed  ## Impact this check is useless, since the usdm is allowed a user to flashmint the token, in the usdm contract, the usdm is allowed the user to flashmint the token instead of the usual flashloan, in flashmint you are minting a token instead of borrowing an existing token, therefore the flashmint is allowed the user to borrow up to 115792089237316195423570985008687907853269984665640517394379403123841238667621 usdm token, then deposit the pool3 token.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 1. unlockable state is true and totalliquidity usdm is bellow 4m 2. a user/whale is flashmint 4m usdm 3. user deposit 4m usdm token 4. user deposit pool3 token 5. withdraw the 4m usdm that was already deposited 6. pay the fee 7. now the user/whale has deposited the pool3 token eventhough the totalliqudity of usdm still below 4m ------------------------------------------------------------------------------------------------------------------------- 5. Tittle mismatch between description and actual code  ## Impact the actual value in the https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 is 4m usdm, but the description said that it is 40m usdm.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 
