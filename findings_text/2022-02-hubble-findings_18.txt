1. In processWithdrawals function at VUSD.sol#L64, modify i+=1 to ++i  2. In processWithdrawals function at VUSD.sol#L63, use unchecked at reserve -= withdrawal.amount; since we already know that reserve > withdrawal.amount  3. In withdraw function at VUSD.sol#L48, add a check require(amount!=0, "Invalid amount");  4. In mintWithReserve function at VUSD.sol#L43, add below require  ``` require(amount!=0, "Invalid amount"); require(to!=address(0), "Invalid address"); ```  5. getRoundData function at Oracle.sol#L124 is not required. Simply change the if(latestPrice < 0) to while(latestPrice < 0) at Oracle.sol#L117 which will eliminate the need of getRoundData function  ``` function getLatestRoundData(AggregatorV3Interface _aggregator)         internal         view         returns (             uint80,             uint256 finalPrice,             uint256         )     {         (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();         finalPrice = uint256(latestPrice);         while (latestPrice < 0) {             requireEnoughHistory(round);             (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);         }         return (round, finalPrice, latestTimestamp);     } ```  6. In deposit function at InsuranceFund.sol#L39, add a condition require(amount!=0, "Invalid amount")  7. In withdraw function at InsuranceFund.sol#L62, add a check require( _shares!=0,"Invalid shares");  8. In liquidate function at ClearingHouse.sol#L140, updatePositions function is not required since this is already called in _liquidateMaker and _liquidateTaker function  9. In addMarginFor function at MarginAccount.sol#L149, add new check   ``` require(idx >= supportedCollateral.length,"Invalid index"); ```  10. In removeMargin function at MarginAccount.sol#L177, margin[idx][trader] -= amount.toInt256(); can be unchecked since contract has already checked margin[idx][trader] >= amount.toInt256()  11. In removeMargin function at MarginAccount.sol#L168, add a check require(amount!=0,"Invalid amount");  12. In settleBadDebt function at MarginAccount.sol#L362, modify require(vusdBal < 0, "Nothing to repay"); to require(vusdBal <= 0, "Nothing to repay"); since if vusdBal is 0 then also there is nothing to repay  13. In weightedAndSpotCollateral function at MarginAccount.sol#L524 add a check to see margin[i][trader]==0 as shown below  ``` function weightedAndSpotCollateral(address trader)         public         view         returns (int256 weighted, int256 spot)     {         ...          for (uint i = 0; i < assets.length; i++) {             _collateral = assets[i];   if(margin[i][trader]==0){continue}             int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));             ...         }     } ```  14. In liquidateFlexible function at MarginAccount.sol#L328, before entering loop check if trader can be liquidated  ``` function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {         clearingHouse.updatePositions(trader); // credits/debits funding (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false); if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {return}  for (uint i = 0; i < idxs.length; i++){         ...     } ```
