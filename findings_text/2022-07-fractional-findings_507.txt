## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | [G&#x2011;01] | Check the first bit of the number rather than using the modulo operator, to save gas | 1 | | [G&#x2011;02] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 2 | | [G&#x2011;03] | State variables only set in the constructor should be declared `immutable` | 70 | | [G&#x2011;04] | Structs can be packed into fewer storage slots | 1 | | [G&#x2011;05] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 15 | | [G&#x2011;06] | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | [G&#x2011;07] | State variables should be cached in stack variables rather than re-reading them from storage | 27 | | [G&#x2011;08] | Multiple accesses of a mapping/array should use a local variable cache | 1 | | [G&#x2011;09] | `internal` functions only called once can be inlined to save gas | 3 | | [G&#x2011;10] | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | [G&#x2011;11] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 2 | | [G&#x2011;12] | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 2 | | [G&#x2011;13] | Optimize names to save gas | 28 | | [G&#x2011;14] | Using `bool`s for storage incurs overhead | 1 | | [G&#x2011;15] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 3 | | [G&#x2011;16] | Using `private` rather than `public` for constants, saves gas | 5 | | [G&#x2011;17] | Division by two should use bit shifting | 3 | | [G&#x2011;18] | Empty blocks should be removed or emit something | 3 | | [G&#x2011;19] | Use custom errors rather than `revert()`/`require()` strings to save gas | 5 | | [G&#x2011;20] | Functions guaranteed to revert when called by normal users can be marked `payable` | 6 |  Total: 188 instances over 20 issues   ## Gas Optimizations  ### [G&#x2011;01]  Check the first bit of the number rather than using the modulo operator, to save gas Do the same sort of bit check as is on line 135  *There is 1 instance of this issue:* ```solidity File: src/utils/MerkleBase.sol  91:                  if (_node % 2 == 1) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L91  ### [G&#x2011;02]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There are 2 instances of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24            public isApproved; 25        /// @notice Mapping of metadata contracts for token ID types => metadata address 26        mapping(uint256 => address) public metadata; 27        /// @notice Mapping to track account nonces for metadata txs owner => nonces 28        mapping(address => uint256) public nonces; 29        /// @notice Mapping to track total supply for token ID types => totalSupply 30        mapping(uint256 => uint256) public totalSupply; 31        /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress 32        mapping(uint256 => address) private royaltyAddress; 33        /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent 34:       mapping(uint256 => uint256) private royaltyPercent;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L34  ```solidity File: src/modules/Migration.sol  45        mapping(address => mapping(uint256 => Proposal)) public migrationInfo; 46        /// @notice Mapping of a proposal ID to a user's ether contribution 47        mapping(uint256 => mapping(address => uint256)) private userProposalEth; 48        /// @notice Mapping of a proposal ID to a user's fractions contribution 49        mapping(uint256 => mapping(address => uint256)) 50:           private userProposalFractions;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L45-L50  ### [G&#x2011;03]  State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).  *There are 70 instances of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit registry 47:           registry = _registry;  /// @audit registry 61:           (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 114:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 151:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 186:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry 246:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 280:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 319:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 351:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 387:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 424:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit supply 48:           supply = _supply;  /// @audit supply 219:              IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 264:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 294:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 476:              supply,  /// @audit supply 477:              ISupply(supply).burn.selector  /// @audit transfer 49:           transfer = _transfer;  /// @audit transfer 334:          IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);  /// @audit transfer 366:          IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);  /// @audit transfer 403:          IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);  /// @audit transfer 441:              transfer,  /// @audit transfer 482:              transfer,  /// @audit transfer 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer 488:              transfer,  /// @audit transfer 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer 494:              transfer,  /// @audit transfer 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer 500:              transfer,  /// @audit transfer 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L47  ```solidity File: src/modules/Migration.sol  /// @audit buyout 58:           buyout = payable(_buyout);  /// @audit buyout 84:           (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 116:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 148:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 189:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout 225:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 263:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 301:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 343:          IBuyout(buyout).withdrawERC20(  /// @audit buyout 367:          IBuyout(buyout).withdrawERC721(  /// @audit buyout 393:          IBuyout(buyout).withdrawERC1155(  /// @audit buyout 420:          IBuyout(buyout).batchWithdrawERC1155(  /// @audit buyout 438:          (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(  /// @audit buyout 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry 59:           registry = _registry;  /// @audit registry 81:           (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry 111:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 143:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 184:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry 235:          address newVault = IVaultRegistry(registry).create(  /// @audit registry 296:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 435:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L58  ```solidity File: src/modules/Minter.sol  /// @audit supply 18:           supply = _supply;  /// @audit supply 40:               supply,  /// @audit supply 60:           IVault(payable(_vault)).execute(supply, data, _mintProof);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L18  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit registry 25:           registry = _registry;  /// @audit registry 43:           vault = IVaultRegistry(registry).create(  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L25  ```solidity File: src/VaultFactory.sol  /// @audit implementation 21:           implementation = address(new Vault());  /// @audit implementation 39:           (uint256 creationPtr, uint256 creationSize) = implementation  /// @audit implementation 69:           vault = implementation.clone(salt, data);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L21  ### [G&#x2011;04]  Structs can be packed into fewer storage slots Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings  *There is 1 instance of this issue:* ```solidity File: src/interfaces/IMigration.sol  /// @audit Variable ordering with 10 slots instead of the current 11: ///           uint256(32):startTime, uint256(32):targetPrice, uint256(32):totalEth, uint256(32):totalFractions, address[](32):modules, address[](32):plugins, bytes4[](32):selectors, uint256(32):oldFractionSupply, uint256(32):newFractionSupply, address(20):newVault, bool(1):isCommited, bool(1):fractionsMigrated 8     struct Proposal { 9         // Start time of the migration proposal 10        uint256 startTime; 11        // Target buyout price for the migration 12        uint256 targetPrice; 13        // Total ether contributed to the migration 14        uint256 totalEth; 15        // Total fractions contributed to the migration 16        uint256 totalFractions; 17        // Module contract addresses proposed for the migration 18        address[] modules; 19        // Plugin contract addresses proposed for the migration 20        address[] plugins; 21        // Function selectors for the proposed plugins 22        bytes4[] selectors; 23        // Address for the new vault to migrate to (if buyout is succesful) 24        address newVault; 25        // Boolean status to check if the propoal is active 26        bool isCommited; 27        // Old fraction supply for a given vault 28        uint256 oldFractionSupply; 29        // New fraction supply for a given vault that has succesfully migrated 30        uint256 newFractionSupply; 31        // Boolean status to check that the fractions have already been migrated 32        bool fractionsMigrated; 33:   }  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L8-L33  ### [G&#x2011;05]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  Note that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved  *There are 15 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _uri 68:       function emitSetURI(uint256 _id, string memory _uri) external {  /// @audit _data 79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68  ```solidity File: src/utils/MerkleBase.sol  /// @audit _proof 43        function verifyProof( 44            bytes32 _root, 45            bytes32[] memory _proof, 46            bytes32 _valueToProve 47:       ) public pure returns (bool) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ```solidity File: src/utils/Metadata.sol  /// @audit _uri 24:       function setURI(uint256 _id, string memory _uri) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24  ```solidity File: src/VaultRegistry.sol  /// @audit _plugins /// @audit _selectors 51        function create( 52            bytes32 _merkleRoot, 53            address[] memory _plugins, 54            bytes4[] memory _selectors 55:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 67        function createFor( 68            bytes32 _merkleRoot, 69            address _owner, 70            address[] memory _plugins, 71            bytes4[] memory _selectors 72:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 83        function createCollection( 84            bytes32 _merkleRoot, 85            address[] memory _plugins, 86            bytes4[] memory _selectors 87:       ) external returns (address vault, address token) {  /// @audit _plugins /// @audit _selectors 102       function createInCollection( 103           bytes32 _merkleRoot, 104           address _token, 105           address[] memory _plugins, 106           bytes4[] memory _selectors 107:      ) external returns (address vault) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L55  ```solidity File: src/Vault.sol  /// @audit _selectors /// @audit _plugins 73:       function install(bytes4[] memory _selectors, address[] memory _plugins)  /// @audit _selectors 101:      function uninstall(bytes4[] memory _selectors) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73  ### [G&#x2011;06]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: src/VaultRegistry.sol  40:           VaultInfo memory info = vaultToToken[msg.sender];  118:          VaultInfo memory info = vaultToToken[msg.sender];  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L40  ### [G&#x2011;07]  State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 27 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _controller on line 303 305:              : controllerAddress = _controller;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L305  ```solidity File: src/modules/Buyout.sol  /// @audit registry on line 61 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry on line 186 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry on line 246 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry on line 280 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit supply on line 476 477:              ISupply(supply).burn.selector  /// @audit transfer on line 482 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer on line 483 488:              transfer,  /// @audit transfer on line 488 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer on line 489 494:              transfer,  /// @audit transfer on line 494 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer on line 495 500:              transfer,  /// @audit transfer on line 500 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L71  ```solidity File: src/modules/Migration.sol  /// @audit buyout on line 189 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout on line 208 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout on line 438 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry on line 81 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry on line 184 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry on line 435 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry on line 467 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L208  ```solidity File: src/Vault.sol  /// @audit owner on line 76 76:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 87 87:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 94 94:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 102 102:          if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 126 /// @audit owner on line 132 132:          if (owner_ != owner) revert OwnerChanged(owner_, owner);  /// @audit nonce on line 25 25:           if (nonce != 0) revert Initialized(owner, msg.sender, nonce);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L76  ### [G&#x2011;08]  Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata  *There is 1 instance of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit buyoutInfo[_vault] on line 297 297:          (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L297  ### [G&#x2011;09]  `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 3 instances of this issue:* ```solidity File: src/FERC1155.sol  324       function _computePermitStructHash( 325           address _owner, 326           address _operator, 327           uint256 _id, 328           bool _approved, 329           uint256 _deadline 330:      ) internal returns (bytes32) {  350       function _computePermitAllStructHash( 351           address _owner, 352           address _operator, 353           bool _approved, 354           uint256 _deadline 355:      ) internal returns (bytes32) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324-L330  ```solidity File: src/Vault.sol  142:      function _revertedWithReason(bytes memory _response) internal pure {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L142  ### [G&#x2011;10]  `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: src/modules/Buyout.sol  454:          for (uint256 i; i < permissions.length; ) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454  ```solidity File: src/modules/protoforms/BaseVault.sol  64:           for (uint256 i = 0; i < _tokens.length; ) {  83:           for (uint256 i = 0; i < _tokens.length; ) {  107:              for (uint256 i = 0; i < _tokens.length; ++i) {  130:              for (uint256 i; i < _modules.length; ++i) {  132:                  for (uint256 j; j < leaves.length; ++j) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L64  ```solidity File: src/utils/MerkleBase.sol  51:               for (uint256 i = 0; i < _proof.length; ++i) {  110:              for (uint256 i; i < result.length; ++i) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51  ### [G&#x2011;11]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 2 instances of this issue:* ```solidity File: src/Vault.sol  78:           for (uint256 i = 0; i < length; i++) {  104:          for (uint256 i = 0; i < length; i++) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ### [G&#x2011;12]  `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 2 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  62:           require(_data.length > 1, "wont generate root for single leaf");  78:           require(_data.length > 1, "wont generate proof for single leaf");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62  ### [G&#x2011;13]  Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 28 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit burn(), emitSetURI(), mint(), permit(), permitAll(), setApprovalFor(), setContractURI(), setMetadata(), setRoyalties(), transferController(), royaltyInfo(), controller(), INITIAL_CONTROLLER(), VAULT_REGISTRY() 13:   contract FERC1155 is Clone, ERC1155, IFERC1155 {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L13  ```solidity File: src/interfaces/IBaseVault.sol  /// @audit batchDepositERC20(), batchDepositERC721(), batchDepositERC1155(), deployVault(), registry() 8:    interface IBaseVault is IProtoform {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IBaseVault.sol#L8  ```solidity File: src/interfaces/IBuyout.sol  /// @audit PROPOSAL_PERIOD(), REJECTION_PERIOD(), batchWithdrawERC1155(), buyFractions(), buyoutInfo(), cash(), end(), getLeafNodes(), getPermissions(), redeem(), registry(), sellFractions(), start(), supply(), transfer(), withdrawERC20(), withdrawERC721(), withdrawERC1155() 31:   interface IBuyout is IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IBuyout.sol#L31  ```solidity File: src/interfaces/IFERC1155.sol  /// @audit INITIAL_CONTROLLER(), NAME(), VAULT_REGISTRY(), VERSION(), burn(), contractURI(), controller(), emitSetURI(), isApproved(), metadata(), mint(), permit(), permitAll(), royaltyInfo(), setApprovalFor(), setContractURI(), setMetadata(), setRoyalties(), totalSupply(), transferController() 5:    interface IFERC1155 {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IFERC1155.sol#L5  ```solidity File: src/interfaces/IMigration.sol  /// @audit PROPOSAL_PERIOD(), batchMigrateVaultERC1155(), buyout(), commit(), generateMerkleTree(), join(), leave(), migrateFractions(), migrateVaultERC20(), migrateVaultERC721(), migrationInfo(), nextId(), propose(), registry(), settleFractions(), settleVault(), withdrawContribution() 36:   interface IMigration {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L36  ```solidity File: src/interfaces/IMinter.sol  /// @audit supply() 8:    interface IMinter is IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMinter.sol#L8  ```solidity File: src/interfaces/IModule.sol  /// @audit getLeafNodes(), getPermissions() 7:    interface IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IModule.sol#L7  ```solidity File: src/interfaces/IProtoform.sol  /// @audit deployVault(), generateMerkleTree() 7:    interface IProtoform {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IProtoform.sol#L7  ```solidity File: src/interfaces/ISupply.sol  /// @audit mint(), burn() 5:    interface ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/ISupply.sol#L5  ```solidity File: src/interfaces/ITransfer.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 5:    interface ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/ITransfer.sol#L5  ```solidity File: src/interfaces/IVaultFactory.sol  /// @audit deploy(), deployFor(), getNextAddress(), getNextSeed(), implementation() 5:    interface IVaultFactory {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVaultFactory.sol#L5  ```solidity File: src/interfaces/IVaultRegistry.sol  /// @audit burn(), create(), createCollection(), createCollectionFor(), createFor(), createInCollection(), factory(), fNFT(), fNFTImplementation(), mint(), nextId(), totalSupply(), uri(), vaultToToken() 23:   interface IVaultRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVaultRegistry.sol#L23  ```solidity File: src/interfaces/IVault.sol  /// @audit execute(), init(), install(), merkleRoot(), methods(), nonce(), setMerkleRoot(), uninstall() 5:    interface IVault {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVault.sol#L5  ```solidity File: src/modules/Buyout.sol  /// @audit start(), sellFractions(), buyFractions(), end(), cash(), redeem(), withdrawERC20(), withdrawERC721(), withdrawERC1155(), batchWithdrawERC1155(), getLeafNodes(), getPermissions() 27:   contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L27  ```solidity File: src/modules/Migration.sol  /// @audit propose(), join(), leave(), commit(), settleVault(), settleFractions(), withdrawContribution(), migrateVaultERC20(), migrateVaultERC721(), migrateVaultERC1155(), batchMigrateVaultERC1155(), migrateFractions(), generateMerkleTree() 28:   contract Migration is  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L28  ```solidity File: src/modules/Minter.sol  /// @audit getLeafNodes(), getPermissions() 12:   contract Minter is IMinter {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L12  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit deployVault(), batchDepositERC20(), batchDepositERC721(), batchDepositERC1155(), generateMerkleTree() 17:   contract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L17  ```solidity File: src/references/SupplyReference.sol  /// @audit mint(), burn() 10:   contract SupplyReference is ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/references/SupplyReference.sol#L10  ```solidity File: src/references/TransferReference.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 12:   contract TransferReference is ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/references/TransferReference.sol#L12  ```solidity File: src/targets/Supply.sol  /// @audit mint(), burn() 11:   contract Supply is ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/targets/Supply.sol#L11  ```solidity File: src/targets/Transfer.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 13:   contract Transfer is ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/targets/Transfer.sol#L13  ```solidity File: src/utils/MerkleBase.sol  /// @audit hashLeafPairs(), verifyProof(), getRoot(), getProof(), log2ceil_naive() 7:    abstract contract MerkleBase {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L7  ```solidity File: src/utils/Metadata.sol  /// @audit setURI() 9:    contract Metadata {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L9  ```solidity File: src/utils/Multicall.sol  /// @audit multicall() 7:    abstract contract Multicall {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Multicall.sol#L7  ```solidity File: src/utils/SelfPermit.sol  /// @audit selfPermit(), selfPermitAll() 9:    abstract contract SelfPermit {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/SelfPermit.sol#L9  ```solidity File: src/VaultFactory.sol  /// @audit deploy(), getNextAddress(), getNextSeed(), deployFor() 11:   contract VaultFactory is IVaultFactory {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L11  ```solidity File: src/VaultRegistry.sol  /// @audit burn(), create(), createFor(), createCollection(), createInCollection(), mint(), totalSupply(), uri(), createCollectionFor() 13:   contract VaultRegistry is IVaultRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L13  ```solidity File: src/Vault.sol  /// @audit init(), execute(), install(), setMerkleRoot(), uninstall() 11:   contract Vault is IVault, NFTReceiver {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L11  ### [G&#x2011;14]  Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past  *There is 1 instance of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24:           public isApproved;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L24  ### [G&#x2011;15]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **5 gas per loop**  *There are 3 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  188:                  ceil++;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L188  ```solidity File: src/Vault.sol  78:           for (uint256 i = 0; i < length; i++) {  104:          for (uint256 i = 0; i < length; i++) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ### [G&#x2011;16]  Using `private` rather than `public` for constants, saves gas If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 5 instances of this issue:* ```solidity File: src/FERC1155.sol  15:       string public constant NAME = "FERC1155";  17:       string public constant VERSION = "1";  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L15  ```solidity File: src/modules/Buyout.sol  35:       uint256 public constant PROPOSAL_PERIOD = 2 days;  37:       uint256 public constant REJECTION_PERIOD = 4 days;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L35  ```solidity File: src/modules/Migration.sol  43:       uint256 public constant PROPOSAL_PERIOD = 7 days;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L43  ### [G&#x2011;17]  Division by two should use bit shifting `<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two  *There are 3 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  100:                  _node = _node / 2;  136:                  result = new bytes32[](length / 2 + 1);  142:                  result = new bytes32[](length / 2);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100  ### [G&#x2011;18]  Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`). Empty `receive()`/`fallback() payable` functions that are not used, can be removed to save deployment gas.  *There are 3 instances of this issue:* ```solidity File: src/modules/Buyout.sol  53:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L53  ```solidity File: src/modules/Migration.sol  63:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L63  ```solidity File: src/Vault.sol  32:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L32  ### [G&#x2011;19]  Use custom errors rather than `revert()`/`require()` strings to save gas Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  *There are 5 instances of this issue:* ```solidity File: src/FERC1155.sol  263           require( 264               msg.sender == _from || 265                   isApprovedForAll[_from][msg.sender] || 266                   isApproved[_from][msg.sender][_id], 267               "NOT_AUTHORIZED" 268:          );  275           require( 276               _to.code.length == 0 277                   ? _to != address(0) 278                   : INFTReceiver(_to).onERC1155Received( 279                       msg.sender, 280                       _from, 281                       _id, 282                       _amount, 283                       _data 284                   ) == INFTReceiver.onERC1155Received.selector, 285               "UNSAFE_RECIPIENT" 286:          );  297:          require(metadata[_id] != address(0), "NO METADATA");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L268  ```solidity File: src/utils/MerkleBase.sol  62:           require(_data.length > 1, "wont generate root for single leaf");  78:           require(_data.length > 1, "wont generate proof for single leaf");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62  ### [G&#x2011;20]  Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 6 instances of this issue:* ```solidity File: src/FERC1155.sol  56        function burn( 57            address _from, 58            uint256 _id, 59            uint256 _amount 60:       ) external onlyRegistry {  79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  198:      function setContractURI(string calldata _uri) external onlyController {  205       function setMetadata(address _metadata, uint256 _id) 206           external 207:          onlyController  217       function setRoyalties( 218           uint256 _id, 219           address _receiver, 220           uint256 _percentage 221:      ) external onlyController {  229       function transferController(address _newController) 230           external 231:          onlyController  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L56-L60  
