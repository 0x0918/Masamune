* different pragma versions - the core-contracts use `pragma solidity ^0.8.0` and the rest of the contracts use `pragma solidity ^0.8.4`  * use a specific solidity version instead of using `^`, to prevent future solidity versions impacting your code and creating issues.  * In the comments and variable names you wrote ETH instead of wETH, which is un-correct (that's an ERC20 so it must be wETH) ```sol function transferSplitAsset(address to, uint256 value)     private     returns (bool didSucceed) {     // Try to transfer ETH to the given recipient.     didSucceed = IERC20(splitAsset).transfer(to, value);     require(didSucceed, "Failed to transfer ETH");     emit TransferETH(to, value, didSucceed); } ```  * In the comment before the function, you wrote returns instead of the known `@return` tag ```sol /**  * @notice Mint token  * @dev A starting index is calculated at the time of first mint  * returns a tokenId  * @param _to Token recipient  */ function mint(address _to) private returns (uint256 tokenId) {     if (startingIndex == 0) {         setStartingIndex();     }     tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;     _mint(_to, tokenId); } ```  * Low level calls (call, delegate call and static call) return success if the called contract doesnâ€™t exist (not deployed or destructed), can be seen here https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf (report #9) and here https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions.  That means that in `attemptETHTransfer`, if `to` doesn't exist the call will fail but success will be set to true, which will act like the call was successful. ```sol function attemptETHTransfer(address to, uint256 value)     private     returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}("");         return success;     } ```  * add `onlyUnInitialized` modifier to the `initialize` function, otherwise the owner can initialize the contract more than one time  * `HASHED_PROOF` - upper case variable name that is not constant  * if `startingIndex + totalSupply()` will reach `type(uint256).max` the system will be in a stuck state, that's because the calculation in the _mint function will overflow  * contracts not declaring that they implement their interfaces - for example `CoreCollection` and `CoreFactory` don't declare that they implement `ICoreCollection` and `ICoreFactory`  * `ICoreFactory` is imported but not used in `CoreProxy`  * didn't check that the address of the given vault is not zero in the `setPlatformFee` function  * wrong comment in `RoyaltyVaultFactory` and `SplitFactory` ```sol /**  * @dev Set Platform fee for collection contract.  * @param _platformFee Platform fee in scaled percentage. (5% = 200)  * @param _vault vault address.  */ function setPlatformFee(address _vault, uint256 _platformFee) external {     IRoyaltyVault(_vault).setPlatformFee(_platformFee); }  /**  * @dev Set Platform fee recipient for collection contract.  * @param _vault vault address.  * @param _platformFeeRecipient Platform fee recipient.  */ function setPlatformFeeRecipient(     address _vault,     address _platformFeeRecipient ) external {     require(_vault != address(0), "Invalid vault");     require(         _platformFeeRecipient != address(0),         "Invalid platform fee recipient"     );     IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient); } ```
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol   # Vulnerability details  ## Impact  The Joyn documentation mentions that Joyn royalty vaults should be equipped to handle revenue generated on a collection's primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, however, there is no existing implementation which allows the owner of a collection to receive fees on secondary sales.   After discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. As such, each collection will need to be added manually on Opensea, introducing further centralisation risk. It is also possible for users to avoid paying the secondary fee by using other marketplaces such as Foundation.   ## Recommended Mitigation Steps  Consider implementing the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the approiate behaviour for this.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56   # Vulnerability details  ## Impact  The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.  ## Proof of Concept  For the sake of this example, let's say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.  ## Recommended Mitigation Steps  Consider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.  
# QA Report  1. Immutable addresses should be 0-checked  Consider adding an `address(0)` check in the constructors for these variables:  ```solidity core-contracts/contracts/CoreFactory.sol:   22:   address public immutable collection;   23:   address public immutable splitFactory;  core-contracts/contracts/CoreProxy.sol:   9:     address private immutable _implement;  splits/contracts/SplitFactory.sol:   11:   /**** Immutable storage ****/   13:   address public immutable splitter;   14:   address public immutable royaltyVault; ```  2. Missing comments  The following comments are missing (see `@audit` tags):  ```solidity core-contracts/contracts/CoreCollection.sol:   254      /**   255       * @notice Mint token   256       * @dev A starting index is calculated at the time of first mint   257       * returns a tokenId   258:      * @param _to Token recipient //@audit missing @return uint256 tokenId   259       */   260      function mint(address _to) private returns (uint256 tokenId) {  core-contracts/contracts/CoreFactory.sol:   101    /**   102     * @notice Allows to add a collection to a project   103     * @dev Can only be called by project creator   104     * Collection's ownership is transferred to the caller   105     * @param _projectId Project id which is a unique identifier   106:    * @param _collection Collection that needs to be deployed //@audit missing @return address   107     */   108    function addCollection(   109      string memory _projectId,   110      Collection memory _collection     111    ) external onlyProjectOwner(_projectId) returns (address) {    138    /**   139     * @notice Instanciates/Deploys a collection   140:    * @param _collection Collection that needs to be deployed //@audit missing @return address   141     */   142    function _createCollection(Collection memory _collection)   143      private   144      onlyAvailableCollection(_collection.id)   145      returns (address)  core-contracts/contracts/ERC721Claimable.sol:   49    /**   50     * @notice Verifies whether an address can claim tokens   51     * @dev    52     * @param who Claimer address   53     * @param claimableAmount Amount airdropped to claimer   54     * @param claimedAmount Amount of tokens claimer wants to claim   55:    * @param merkleProof Proof //@audit missing @return bool   56     */   57    function canClaim(   58      address who,   59      uint256 claimableAmount,   60      uint256 claimedAmount,   61      bytes32[] calldata merkleProof   62    ) public view returns (bool) {  splits/contracts/SplitFactory.sol:    55    /**    56     * @dev Constructor    57:    * @param _splitter The address of the Splitter contract. //@audit missing @param _royaltyVault    58     */    59    constructor(address _splitter, address _royaltyVault) {     68    /**    69     * @dev Deploys a new SplitProxy and initializes collection's royalty vault.    70     * @param _merkleRoot The merkle root of the asset.    71     * @param _splitAsset The address of the asset to split.    72     * @param _collectionContract The address of the collection contract.    73:    * @param _splitId The split identifier. //@audit missing @return address splitProxy    74     */    75    function createSplit(    76      bytes32 _merkleRoot,    77      address _splitAsset,    78      address _collectionContract,    79      string memory _splitId    80    ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {     96    /**    97     * @dev Deploys a new SplitProxy.    98     * @param _merkleRoot The merkle root of the asset.    99     * @param _splitAsset The address of the asset to split.   100:    * @param _splitId The split identifier. //@audit missing @return address splitProxy   101     */   102    function createSplit(   103      bytes32 _merkleRoot,   104      address _splitAsset,   105      string memory _splitId   106    ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {  splits/contracts/Splitter.sol:   226      /**   227       * @dev Function to transfer split asset to the given address.   228       * @param to {address} Address to transfer the split asset to.   229:      * @param value {uint256} Amount to transfer. //@audit missing @return bool didSucceed   230       */   231      function transferSplitAsset(address to, uint256 value)   232          private   233          returns (bool didSucceed) ```  3. Avoid floating pragmas / The pragmas used are not the same everywhere: the version should be locked mandatorily at >= `0.8.4` as Custom Errors are only introduced there and several contracts wouldn't compile at an older version than this:  ```solidity core-contracts/contracts/CoreCollection.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/CoreFactory.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/CoreProxy.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/ERC721Claimable.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/ERC721Payable.sol:   2: pragma solidity ^0.8.0;  royalty-vault/contracts/ProxyVault.sol:   2: pragma solidity ^0.8.4;  royalty-vault/contracts/RoyaltyVault.sol:   2: pragma solidity ^0.8.4;  splits/contracts/SplitFactory.sol:   2: pragma solidity ^0.8.4;  splits/contracts/SplitProxy.sol:   2: pragma solidity ^0.8.4;  splits/contracts/Splitter.sol:   2: pragma solidity ^0.8.4; ```  4. `CoreCollection.sol` should use implement a 2-step ownership transfer pattern instead of using `Ownable`'s default one.  5. `platformFee` should be upper bounded to avoid DoS and excessive fees  `platformFee` can take a value of 10000 (100%) which could be seen as a trust issue:  ```solidity File: RoyaltyVault.sol 67:     function setPlatformFee(uint256 _platformFee) external override onlyOwner { 68:         platformFee = _platformFee; //@audit low should be upperbounded to 10000 or L41 will get DOSed by an underflow. A reasonable upperbound should be declared for trust 69:         emit NewRoyaltyVaultPlatformFee(_platformFee); 70:     } ```  Also, although unlikely and remediable by calling again `setPlatformFee` with another value, `sendToSplitter` can get DOSed by the admin by setting `platformFee` to more than 10000:  ```solidity File: RoyaltyVault.sol 40:         uint256 platformShare = (balanceOfVault * platformFee) / 10000; 41:         uint256 splitterShare = balanceOfVault - platformShare; //@audit DOSed by the admin if platformFee > 10000, which is possible ```
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L9   # Vulnerability details  ## Impact Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables  ## Proof of Concept      contract CoreProxy is Ownable {            address private immutable _implement;  When you implement proxies, logic and implementation share the same storage layout.    In order to avoid storage conflicts  EIP1967 was proposed.(https://eips.ethereum.org/EIPS/eip-1967)   The idea is to set proxy variables at fixed positions (like  `impl` and `admin` ).    For example, according to the standard,  the slot for for logic address should be  `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`  ).  In this case, for example, as you inherits from `Ownable` the variable _owner is at the first slot and can be overwritten in the implementation.   There is a table at OZ site that explains this scenario more in detail  https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies  section  "Unstructured Storaged Proxies"  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using EIP1967     
# QA Report  ## Low Issues  ### Unsafe ERC20 transfers  ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard.  It is therefore recommended to always either use OpenZeppelin's SafeERC20 library or at least to wrap each operation in a require statement.  Following functions have unsafe ERC20 transfers: - CoreCollection::withdraw - ERC721Payable::_handlePayment  ### Missing upper limit for platform fee  The platform fee can be set to arbitraty values in the `RoyaltyVault::setPlatformFee` function. The highest logical value is 10,000 = 100%.  Consider introducing an upper limit for the platform fee through a `require` statement.  Note that it's recommended to set the upper limit far lower than 100% to disable rug vectors.  ### Issues with comments  The `Splitter::transferSplitAsset` function has a faulty comment stating `// Try to transfer ETH to the given recipient.`, eventhough an ERC20 token is transfered. The error message in case of failure is off too.  A parameter document for function `RoyaltyVaultFactory::setPlatformFee` states `5% = 200` as example for the percentage scale. This conversion rate is false.  ## Gas Optimizations  ### Don't Initialize Variables with Default Value  Issue Information: [G001](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g001---dont-initialize-variables-with-default-value)  #### Findings: ``` core-contracts/contracts/CoreCollection.sol::280 => for (uint256 i = 0; i < _amount; i++) { splits/contracts/Splitter.sol::52 => uint256 amount = 0; splits/contracts/Splitter.sol::53 => for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol::278 => for (uint256 i = 0; i < proof.length; i++) { ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Cache Array Length Outside of Loop  Issue Information: [G002](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g002---cache-array-length-outside-of-loop)  #### Findings: ``` core-contracts/contracts/CoreFactory.sol::79 => for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol::278 => for (uint256 i = 0; i < proof.length; i++) { ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Long Revert Strings  Issue Information: [G007](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g007---long-revert-strings)  #### Findings: ``` core-contracts/contracts/CoreCollection.sol::47 => require(!initialized, "CoreCollection: Already initialized"); core-contracts/contracts/CoreCollection.sol::146 => require(amount > 0, "CoreCollection: Amount should be greater than 0"); core-contracts/contracts/CoreCollection.sol::192 => "CoreCollection: Only Split Factory or owner can initialize vault." core-contracts/contracts/CoreCollection.sol::207 => "CoreCollection: Hashed Proof is set" core-contracts/contracts/CoreCollection.sol::223 => "CoreCollection: Starting index is already set" royalty-vault/contracts/RoyaltyVault.sol::36 => "Vault does not have enough royalty Asset to send" royalty-vault/contracts/RoyaltyVault.sol::45 => "Failed to transfer royalty Asset to splitter" royalty-vault/contracts/RoyaltyVault.sol::49 => "Failed to increment splitter window" royalty-vault/contracts/RoyaltyVault.sol::56 => "Failed to transfer royalty Asset to platform fee recipient" splits/contracts/Splitter.sol::123 => "NFT has already claimed the given window" ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Unspecific Compiler Version Pragma  Issue Information: [L003](https://github.com/byterocket/c4-common-issues/blob/main/2-Low-Risk.md#l003---unspecific-compiler-version-pragma)  All contracts use a floating pragma. Consider specifying a concrete solidity version for non-interface contracts.  #### Tools used [c4udit](https://github.com/byterocket/c4udit) 
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L156-L159   # Vulnerability details  ## Proof of Concept  ```solidity         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             "Unauthorised to increment window"         ); ```  The authorization check in `incrementWindow` can be easily passed. However, `incrementWindow` can change the value of `currentWindow` which is used for loop. It should be guard properly.  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L50   ```solidity for (uint256 i = 0; i < currentWindow; i++) { ```   ## Recommended Mitigation Steps  Consider using white list for this task.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57   # Vulnerability details   Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.  Recommendation: Consider using OpenZeppelinâ€™s SafeERC20  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55   # Vulnerability details  The below transferFrom command is called at two places in the core contracts, followed by an emit event ``` payableToken.transferFrom(msg.sender,recipient,_amount) emit ...(...); ``` The return value is not checked during the payableToken.transferFrom  ## Impact In the event of failure of payableToken.transferFrom(...), the emit event is still generated causing the downstream applications to capture wrong transaction / state of the protocol.  ## Proof of Concept 1. Contract CoreCollection.sol      function withdraw()  2. Contract ERC721Payable.sol    function _handlePayment   ## Recommended Mitigation Steps Add a require statement as being used in the RoyaltyVault.sol ``` require( payableToken.transferFrom(msg.sender,recipient,_amount) == true,             "Failed to transfer amount to recipient" ); ```  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175   # Vulnerability details   The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` ( who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.  Recommendation : replace `transferFrom` with `transfer`  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31   # Vulnerability details  ## Impact  Each CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.  ## Proof of Concept  Each RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.  ```     function sendToSplitter() external override {         ...         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         );         ...         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             "Failed to transfer royalty Asset to platform fee recipient"         );         ...     } ```  Considering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.  ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          ...          royaltyVault = _royaltyVault;          ...      }       function _handlePayment(uint256 _amount) internal {          address recipient = royaltyVaultInitialized()              ? royaltyVault              : address(this);          payableToken.transferFrom(msg.sender, recipient, _amount);          ...      } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  While assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`   ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          require(              payableToken == _royaltyVault.royaltyAsset(),              "CoreCollection : payableToken must be same as royaltyAsset."          );          ...          royaltyVault = _royaltyVault;          ...      } ```   
**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] Avoid unnecessary external call can save gas  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, avoiding unnecessary external call can save gas if possible.  For example:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVaultFactory.sol#L37-L50  ```solidity     function createVault(address _splitter, address _royaltyAsset)         external         returns (address vault)     {         splitterProxy = _splitter;         royaltyAsset = _royaltyAsset;          vault = address(             new ProxyVault{salt: keccak256(abi.encode(_splitter))}()         );          delete splitterProxy;         delete royaltyAsset;     } ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L16-L22  ```solidity     constructor() {         royaltyVault = IVaultFactory(msg.sender).royaltyVault();         splitterProxy = IVaultFactory(msg.sender).splitterProxy();         royaltyAsset = IVaultFactory(msg.sender).royaltyAsset();         platformFee = IVaultFactory(msg.sender).platformFee();         platformFeeRecipient = IVaultFactory(msg.sender).platformFeeRecipient();     } ```  Can be changed to:  ```solidity     constructor(address _royaltyVault, address _splitterProxy, address _royaltyAsset, uint256 _platformFee, address _platformFeeRecipient) {         royaltyVault = _royaltyVault;         splitterProxy = _splitterProxy;         royaltyAsset = _royaltyAsset;         platformFee = _platformFee;         platformFeeRecipient = _platformFeeRecipient;     } ```  ```solidity     function createVault(address _splitter, address _royaltyAsset)         external         returns (address vault)     {         splitterProxy = _splitter;         royaltyAsset = _royaltyAsset;          vault = address(             new ProxyVault{salt: keccak256(abi.encode(_splitter))}(royaltyVault, splitterProxy, royaltyAsset, platformFee, platformFeeRecipient)         );          delete splitterProxy;         delete royaltyAsset;     } ```  It can save 5 times of external calls.  ## [M] Setting `uint256` variables to `0` is redundant  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49-L49  ```solidity         uint256 amount = 0; ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  Other examples include:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279-L279  ## [S] Cache array length in for loops can save gas  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `CoreFactory.sol#createProject()`      https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79-L92  - `Splitter.sol#verifyProof()`      https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274-L288  ## [M] `++i` is more efficient than `i++`  Using `++i` is more gas efficient than `i++`, especially in for loops.  For example:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274-L274  ```solidity         for (uint256 i = 0; i < proof.length; i++) ```  Change to:  ```solidity         for (uint256 i = 0; i < proof.length; +i) ```  ## [M] Unused constant variable  Unused constant variables in contracts increase contract size and gas usage at deployment.   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14-L15  ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5;  ```  In the contract, the constant variable `PERCENTAGE_SCALE` is set once but has never been read, therefore it can be removed.  ## [M] Use short reason strings can save gas  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146-L146  ```solidity require(amount > 0, "CoreCollection: Amount should be greater than 0"); ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192  ```solidity         require(             msg.sender == splitFactory || msg.sender == owner(),             "CoreCollection: Only Split Factory or owner can initialize vault."         ); ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223  ```solidity         require(             startingIndex == 0,             "CoreCollection: Starting index is already set"         ); ```  ## [M] Unused events  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVaultFactory.sol#L19-L19  ```solidity     event VaultCreated(address vault); ```  `VaultCreated` is unused.  ## [M] Unused function parameters  Unused private function increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257  ```solidity     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}("");         return success;     } ```  `attemptETHTransfer()` is unused.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L224  ```solidity     function amountFromPercent(uint256 amount, uint32 percent)         private         pure         returns (uint256)     {         // Solidity 0.8.0 lets us do this without SafeMath.         return (amount * percent) / 100;     } ```  `amountFromPercent()` is unused.  ## [S] Use `immutable` instead of getter to save gas  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L8-L37  ```solidity contract CoreProxy is Ownable {     address private immutable _implement;      constructor(address _imp) {         _implement = _imp;     }      fallback() external {         address _impl = implement();         assembly {             let ptr := mload(0x40)             calldatacopy(ptr, 0, calldatasize())             let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)             let size := returndatasize()             returndatacopy(ptr, 0, size)              switch result             case 0 {                 revert(ptr, size)             }             default {                 return(ptr, size)             }         }     }      function implement() public view returns (address) {         return _implement;     } } ```  ### Recommendation  Change to:  ```solidity contract CoreProxy is Ownable {     address private immutable _implement;      constructor(address _imp) {         _implement = _imp;     }      fallback() external {         address _impl = _implement;         assembly {             let ptr := mload(0x40)             calldatacopy(ptr, 0, calldatasize())             let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)             let size := returndatasize()             returndatacopy(ptr, 0, size)              switch result             case 0 {                 revert(ptr, size)             }             default {                 return(ptr, size)             }         }     }      function implement() external view returns (address) {         return _implement;     } } ``` 
# QA Report  ## Low severity findings  ### token transfer in `CoreCollection:withdraw` will fail  In function `CoreCollection` mintfee is transfered to same address if vault is not initialized, these tokens can be withdrawn by owner using `withdraw` function, but transferFrom function will fail due to lack of allowance  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173  ``` function withdraw() external onlyOwner {     uint256 amount = payableToken.balanceOf(address(this));     payableToken.transferFrom(address(this), msg.sender, amount);      emit NewWithdrawal(msg.sender, amount); } ```  #### Mitigation  `transferFrom` can be replaced with `transfer`  ### Increment window and transfer funds  Function `Splitter:incrementWindow` is executed by `vault:sendToSplitter` transfered tokens is pushed into `balanceForWindow` array and window is incremented, but the function can be executed by any contract and more than allowed share of tokens can be transfered by whitelisted users  #### Proof of concept  ``` bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;  function incrementWindow(uint256 royaltyAmount) public returns (bool) {     uint256 wethBalance;      require(         IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),         "Royalty Vault not supported"     );     require(         IRoyaltyVault(msg.sender).getSplitter() == address(this),         "Unauthorised to increment window"     );      wethBalance = IERC20(splitAsset).balanceOf(address(this));     require(wethBalance >= royaltyAmount, "Insufficient funds");      require(royaltyAmount > 0, "No additional funds for window");     balanceForWindow.push(royaltyAmount);     currentWindow += 1;     emit WindowIncremented(currentWindow, royaltyAmount);     return true; } ``` The function can be executed by any contract with function `supportsInterface` and `getSplitter` that returns splitter address     royaltyAmount equivalent to current unclaimed balance can be added to window and the window can be incremented to add windows  `claimForAllWindows` can be executed by whitelisted user to transfer percent allocated tokens from each new window    #### Mitigation  A storage variable with tokens added to the window can be added, and `total-windowBalance` can be added to next window, and when token is transfered windowBalance can be decremented  ### `CoreCollection` can be re-initialized by owner  Function `CoreCollection:initialize` can be executed by owner after initialisation and state variables like mintFee, maxSupply can be changed to increase/decrease fee and supply, isForSale can be set to false to stop token sale  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L97  #### Mitigation   require statement can be added to revert if function is already initialized   ## Non-critical findings  ### Unused import  Imported file is not used in the contract and can be removed  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L6  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L6  #### Mitigation  import statement can be removed  ### Lack of input validation  #### Impact  Input validation is absent for address variables which may result in re-deployment if address is wrong in constructor or value transfer to wrong address, it is recommended to add validation statements in all address inputs especially in value transfers and immutable variable initialisation.  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L27   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L140  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L59-64  #### Mitigation  Add address validation statement    ### Lack of comments  #### Impact  Some functions in the code are not commented or missing parts of comments. Adding comments can improve readability of the code   #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128  missing return comment https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L33  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L41  missing param comment https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L57  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L230  #### Mitigation  Comments can be added to the functions  ### boolean comparison with constant  In function `RoyaltyVault:sentToSplitter` external function return value boolean is compared with boolean constant. The return value can be directly used in the require statement  #### Proof of concept   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51  #### Mitigation  The return value of the function can be directly used in the require statement  ### Code Layout  #### Impact   Code can be structed in order type declarations, state variables, events and functions which can improve readability Refer: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#order-of-layout  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol
1. There are a lack of input checks around the contracts: - [CoreCollection.sol#L88-L96](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L88-L96) - [CoreCollection.sol#L125-L126](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L125-L126) - [CoreCollection.sol#L193](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L193) and [CoreCollection.sol#L209](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L209) could be critical because only can be assigned once. - [CoreFactory.sol#L28-L29](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L28-L29)  2. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of approve methods. - [CoreCollection.sol#L175](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175) - [ERC721Payable.sol#L54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54)  
### `require()`/`revert()` strings longer than 32 bytes cost extra gas  1. File: core-contracts/contracts/ERC721Payable.sol (lines [21-24](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L21-L24)) ```solidity     require(       !royaltyVaultInitialized(),       'CoreCollection: Royalty Vault already initialized'     ); ``` 2. File: core-contracts/contracts/ERC721Payable.sol (lines [29-32](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L29-L32)) ```solidity     require(       royaltyVaultInitialized(),       'CoreCollection: Royalty Vault not initialized'     ); ``` 3. File: core-contracts/contracts/ERC721Claimable.sol (line [23](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L23)) ```solidity     require(!claimableSet(), 'ERC721Claimable: Claimable is already set'); ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [47](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L47)) ```solidity         require(!initialized, "CoreCollection: Already initialized"); ``` 5. File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55)) ```solidity         require(             _maxSupply > 0,             "CoreCollection: Max supply should be greater than 0"         ); ``` 6. File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146)) ```solidity         require(amount > 0, "CoreCollection: Amount should be greater than 0"); ``` 7. File: core-contracts/contracts/CoreCollection.sol (lines [189-192](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192)) ```solidity         require(             msg.sender == splitFactory || msg.sender == owner(),             "CoreCollection: Only Split Factory or owner can initialize vault."         ); ``` 8. File: core-contracts/contracts/CoreCollection.sol (lines [204-207](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L204-L207)) ```solidity         require(             bytes(HASHED_PROOF).length == 0,             "CoreCollection: Hashed Proof is set"         ); ``` 9. File: core-contracts/contracts/CoreCollection.sol (lines [220-223](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223)) ```solidity         require(             startingIndex == 0,             "CoreCollection: Starting index is already set"         ); ``` 10. File: core-contracts/contracts/CoreFactory.sol (lines [35-38](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L35-L38)) ```solidity     require(       projects[_projectId].creator == address(0),       'CoreFactory: Unavailable project id'     ); ``` 11. File: core-contracts/contracts/CoreFactory.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L43-L46)) ```solidity     require(       projects[_projectId].creator == msg.sender,       'CoreFactory: Not an owner of the project'     ); ``` 12. File: core-contracts/contracts/CoreFactory.sol (lines [51-54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L51-L54)) ```solidity     require(       collections[_collectionId] == address(0),       'CoreFactory: Unavailable collection id'     ); ``` 13. File: core-contracts/contracts/CoreFactory.sol (lines [74-77](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L74-L77)) ```solidity     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ``` 14. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37)) ```solidity         require(             balanceOfVault > 0,             "Vault does not have enough royalty Asset to send"         ); ``` 15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L46)) ```solidity         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         ); ``` 16. File: royalty-vault/contracts/RoyaltyVault.sol (lines [47-50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47-L50)) ```solidity         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             "Failed to increment splitter window"         ); ``` 17. File: royalty-vault/contracts/RoyaltyVault.sol (lines [51-57](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57)) ```solidity         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             "Failed to transfer royalty Asset to platform fee recipient"         ); ``` 18. File: splits/contracts/SplitFactory.sol (lines [48-51](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L48-L51)) ```solidity     require(       splits[_splitId] == address(0),       'SplitFactory : Split ID already in use'     ); ``` 19. File: splits/contracts/SplitFactory.sol (lines [81-84](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L81-L84)) ```solidity     require(       ICoreCollection(_collectionContract).owner() == msg.sender,       'Transaction sender is not collection owner'     ); ``` 20. File: splits/contracts/Splitter.sol (lines [118-121](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L118-L121)) ```solidity         require(             !isClaimed(msg.sender, window),             "NFT has already claimed the given window"         ); ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  1. File: royalty-vault/contracts/RoyaltyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 2. File: royalty-vault/contracts/ProxyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 3. File: splits/contracts/SplitFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 4. File: splits/contracts/SplitProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitProxy.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 5. File: splits/contracts/Splitter.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L2)) ```solidity pragma solidity ^0.8.4; ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  1. File: core-contracts/contracts/ERC721Payable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 2. File: core-contracts/contracts/CoreProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 3. File: core-contracts/contracts/ERC721Claimable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 5. File: core-contracts/contracts/CoreFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L2)) ```solidity pragma solidity ^0.8.0; ```  ### Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27  1. File: core-contracts/contracts/ERC721Payable.sol (line [8](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L8)) ```solidity   bool public isForSale; ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [20](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L20)) ```solidity     bool public initialized; ```  ### Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement  1. File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55)) ```solidity         require(             _maxSupply > 0,             "CoreCollection: Max supply should be greater than 0"         ); ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146)) ```solidity         require(amount > 0, "CoreCollection: Amount should be greater than 0"); ``` 3. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37)) ```solidity         require(             balanceOfVault > 0,             "Vault does not have enough royalty Asset to send"         ); ``` 4. File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164)) ```solidity         require(royaltyAmount > 0, "No additional funds for window"); ```  ### `<array>.length` should not be looked up in every loop of a `for`-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length  1. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 2. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### It costs more gas to initialize variables to zero than to let the default of zero be applied  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: splits/contracts/Splitter.sol (line [49](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49)) ```solidity         uint256 amount = 0; ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second access of a state variable within a function. Less obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.  1. File: core-contracts/contracts/CoreCollection.sol (line [231](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L231)) ```solidity         emit StartingIndexSet(startingIndex); ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [264](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L264)) ```solidity         tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1; ``` 3. File: splits/contracts/SplitFactory.sol (line [161](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L161)) ```solidity     delete merkleRoot; ``` 4. File: splits/contracts/SplitFactory.sol (line [171](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L171)) ```solidity     delete splitterProxy; ```  ### Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas  1. File: core-contracts/contracts/CoreCollection.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L79)) ```solidity         string memory _collectionName, ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L80)) ```solidity         string memory _collectionSymbol, ``` 3. File: core-contracts/contracts/CoreCollection.sol (line [81](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L81)) ```solidity         string memory _collectionURI, ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L122)) ```solidity         string memory _collectionName, ``` 5. File: core-contracts/contracts/CoreCollection.sol (line [123](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L123)) ```solidity         string memory _collectionSymbol ``` 6. File: core-contracts/contracts/CoreFactory.sol (line [71](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L71)) ```solidity     string memory _projectId, ``` 7. File: core-contracts/contracts/CoreFactory.sol (line [72](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L72)) ```solidity     Collection[] memory _collections ``` 8. File: core-contracts/contracts/CoreFactory.sol (line [109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L109)) ```solidity     string memory _projectId, ``` 9. File: core-contracts/contracts/CoreFactory.sol (line [110](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L110)) ```solidity     Collection memory _collection ``` 10. File: core-contracts/contracts/CoreFactory.sol (line [128](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128)) ```solidity   function getProject(string memory _projectId) ``` 11. File: splits/contracts/SplitFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L79)) ```solidity     string memory _splitId ``` 12. File: splits/contracts/SplitFactory.sol (line [105](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L105)) ```solidity     string memory _splitId ```  ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### `++i` costs less gas than `++i`, especially when it's used in `for`-loops (`--i`/`i--` too)  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  1. File: splits/contracts/Splitter.sol (line [217](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217)) ```solidity     function amountFromPercent(uint256 amount, uint32 percent) ```  ### Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code  1. File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14)) ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5; ``` 2. File: splits/contracts/Splitter.sol (line [15](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L15)) ```solidity     bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId; ```  ### Don't compare boolean expressions to boolean literals `if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`  1. File: royalty-vault/contracts/RoyaltyVault.sol (line [44](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L44)) ```solidity             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, ``` 2. File: royalty-vault/contracts/RoyaltyVault.sol (line [48](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L48)) ```solidity             ISplitter(splitterProxy).incrementWindow(splitterShare) == true, ``` 3. File: royalty-vault/contracts/RoyaltyVault.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L52-L55)) ```solidity             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true, ```  ### Remove unused variables  1. File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14)) ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5; ```  ### State variables only set in the constructor should be declared `immutable`  1. File: royalty-vault/contracts/ProxyVault.sol (line [9](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L9)) ```solidity     address internal royaltyVault; ```  ### `require()` or `revert()` statements that check input arguments should be at the top of the function  1. File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164)) ```solidity         require(royaltyAmount > 0, "No additional funds for window"); ```  ### `private` functions not called by the contract should be removed to save deployment gas  1. File: splits/contracts/Splitter.sol (lines [217-220](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L220)) ```solidity     function amountFromPercent(uint256 amount, uint32 percent)         private         pure         returns (uint256) ``` 2. File: splits/contracts/Splitter.sol (lines [248-250](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L250)) ```solidity     function attemptETHTransfer(address to, uint256 value)         private         returns (bool) ```  ### `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`. 1. File: royalty-vault/contracts/RoyaltyVault.sol (lines [95-100](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L95-L100)) ```solidity     function supportsInterface(bytes4 interfaceId)         public         view         virtual         override(IRoyaltyVault, ERC165)         returns (bool) ``` 2. File: royalty-vault/contracts/RoyaltyVault.sol (line [88](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L88)) ```solidity     function getSplitter() public view override returns (address) { ```  ### Use custom errors rather than `revert()`/`require()` strings to save deployment gas  1. File: royalty-vault/contracts/RoyaltyVault.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol)) 2. File: splits/contracts/SplitFactory.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol)) 3. File: splits/contracts/Splitter.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol))  ### Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  1. File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87)) ```solidity     function initialize(         string memory _collectionName,         string memory _collectionSymbol,         string memory _collectionURI,         uint256 _maxSupply,         uint256 _mintFee,         address _payableToken,         bool _isForSale,         address _splitFactory     ) external onlyOwner onlyValidSupply(_maxSupply) { ``` 2. File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87)) ```solidity     function initialize(         string memory _collectionName,         string memory _collectionSymbol,         string memory _collectionURI,         uint256 _maxSupply,         uint256 _mintFee,         address _payableToken,         bool _isForSale,         address _splitFactory     ) external onlyOwner onlyValidSupply(_maxSupply) { ``` 3. File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109)) ```solidity     function initializeClaims(bytes32 _root)         external         onlyOwner         onlyNotClaimableSet         onlyValidRoot(_root) ``` 4. File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109)) ```solidity     function initializeClaims(bytes32 _root)         external         onlyOwner         onlyNotClaimableSet         onlyValidRoot(_root) ``` 5. File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109)) ```solidity     function initializeClaims(bytes32 _root)         external         onlyOwner         onlyNotClaimableSet         onlyValidRoot(_root) ``` 6. File: core-contracts/contracts/CoreCollection.sol (lines [121-124](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L121-L124)) ```solidity     function setCollectionMeta(         string memory _collectionName,         string memory _collectionSymbol     ) external onlyOwner { ``` 7. File: core-contracts/contracts/CoreCollection.sol (lines [139-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L139-L145)) ```solidity     function mintToken(         address to,         bool isClaim,         uint256 claimableAmount,         uint256 amount,         bytes32[] calldata merkleProof     ) external onlyInitialized { ``` 8. File: core-contracts/contracts/CoreCollection.sol (line [173](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173)) ```solidity     function withdraw() external onlyOwner { ``` 9. File: core-contracts/contracts/CoreCollection.sol (lines [185-187](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L185-L187)) ```solidity     function setRoyaltyVault(address _royaltyVault)         external         onlyVaultUninitialized ``` 10. File: core-contracts/contracts/CoreCollection.sol (line [203](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L203)) ```solidity     function setHashedProof(string calldata _proof) external onlyOwner { ``` 11. File: core-contracts/contracts/CoreFactory.sol (lines [70-73](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L70-L73)) ```solidity   function createProject(     string memory _projectId,     Collection[] memory _collections   ) external onlyAvailableProject(_projectId) { ``` 12. File: core-contracts/contracts/CoreFactory.sol (lines [108-111](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108-L111)) ```solidity   function addCollection(     string memory _projectId,     Collection memory _collection   ) external onlyProjectOwner(_projectId) returns (address) { ``` 13. File: core-contracts/contracts/CoreFactory.sol (lines [142-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L142-L145)) ```solidity   function _createCollection(Collection memory _collection)     private     onlyAvailableCollection(_collection.id)     returns (address) ``` 14. File: royalty-vault/contracts/RoyaltyVault.sol (line [67](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L67)) ```solidity     function setPlatformFee(uint256 _platformFee) external override onlyOwner { ``` 15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [76-79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L79)) ```solidity     function setPlatformFeeRecipient(address _platformFeeRecipient)         external         override         onlyOwner ``` 16. File: splits/contracts/SplitFactory.sol (lines [75-80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L75-L80)) ```solidity   function createSplit(     bytes32 _merkleRoot,     address _splitAsset,     address _collectionContract,     string memory _splitId   ) external onlyAvailableSplit(_splitId) returns (address splitProxy) { ``` 17. File: splits/contracts/SplitFactory.sol (lines [102-106](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L102-L106)) ```solidity   function createSplit(     bytes32 _merkleRoot,     address _splitAsset,     string memory _splitId   ) external onlyAvailableSplit(_splitId) returns (address splitProxy) { ``` 18. File: splits/contracts/SplitFactory.sol (lines [120-122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L120-L122)) ```solidity   function setPlatformFee(address _vault, uint256 _platformFee)     external     onlyOwner ``` 19. File: splits/contracts/SplitFactory.sol (lines [132-135](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L132-L135)) ```solidity   function setPlatformFeeRecipient(     address _vault,     address _platformFeeRecipient   ) external onlyOwner { ```
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103   # Vulnerability details  ## Details & Impact  There is a `PERCENTAGE_SCALE = 10e5` defined, but the actual denominator used is `10000`. This is aggravated by the following factors:  1. Split contracts are created by collection owners, not the factory owner. Hence, there is a likelihood for someone to mistakenly use `PERCENTAGE_SCALE` instead of `10000`. 2. The merkle root for split distribution can only be set once, and a collectionâ€™s split and royalty vault canâ€™t be changed once created.  Thus, if an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.  ## Recommended Mitigation Steps  Remove `PERCENTAGE_SCALE` because it is unused, or replace its value with `10_000` and use that instead.   P.S: there is an issue with the example scaled percentage given for platform fees `(5% = 200)`. Should be `500` instead of `200`.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54   # Vulnerability details  ## Details  The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.  Some tokens like [EURS](https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and [BAT](https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will **not** revert if the transfer failed but return `false` instead. Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.  ## Impact  Users would be able to mint NFTs for free regardless of mint fee if tokens that donâ€™t revert on failed transfers were used.  ## Recommended Mitigation Steps  Check theÂ `success` boolean of allÂ `transferFrom()` calls. Alternatively, use OZâ€™s `SafeERC20`â€™s `safeTransferFrom()` function.  
# 1. Low - transfer return value is ignored  ## Impact  Some ERC20 tokens, such as USDT, don't revert when transfer/transferFrom fails. The transfer return value has to be checked (as there are some other tokens that returns false instead revert). safeTransfer should be used instead of transfer  ## Proof of Concept  safeTransferFrom should be used instead of transferFrom on this line https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use safeTransfer instead of transfer or check the return value of transfer. The return value of transfer is checked properly in these locations https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L44 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L52 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L237  # 2. Low - onlyUnInitialized modifier missing from initialize function  ## Impact  The CoreCollection initialize function is missing the onlyUnInitialized function. The onlyUnInitialized modifier is not used in the contract right now and this allows the initialize function to be called more than once.  ## Proof of Concept  The onlyUnInitialized modifier prevents functions from being run if the initialized is set to true https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46  This modifier is missing from the initialize function https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the onlyUnInitialized modifier to the initialize function
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50   # Vulnerability details  ## Impact  Certain ERC20 tokens may change user's balances over time (positively or negatively) or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by `RoyaltyVault.sol` or `Splitter.sol` and may result in tokens being stuck in `Splitter` or overstating the balance of a user   Thus, for FoT tokens if all users tried to claim from the Splitter there would be insufficient funds and the last user could not withdraw their tokens.  ## Proof of Concept  The function `RoyaltyVault.sendToSplitter()` will transfer `splitterShare` tokens to the `Splitter` and then call `incrementWindow(splitterShare)` which tells the contract to split `splitterShare` between each of the users.  ```         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         );         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             "Failed to increment splitter window"         ); ```  Since the `Splitter` may receive less than `splitterShare` tokens if there is a fee on transfer the `Splitter` will overstate the amount split and each user can claim more than their value (except the last user who claims nothing as the contract will have insufficient funds to transfer them the full amount).  Furthermore, if the token rebase their value of the tokens down while they are sitting in the `Splitter` the same issue will occur. If the tokens rebase their value up then this will not be accounted for in the protocol.  ## Recommended Mitigation Steps  It is recommend documenting clearly that rebasing token should not be used in the protocol.  Alternatively, if it is a requirement to handle rebasing tokens balance checks should be done before and after the transfer to ensure accurate accounting. Note: this makes the contract vulnerable to reentrancy and so a [reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) must be placed over the function `sendToSplitter()`.  ```         uint256 balanceBefore = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         );         uint256 balanceAfter = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             ISplitter(splitterProxy).incrementWindow(balanceAfter - balanceBefore) == true,             "Failed to increment splitter window"         ); ```  
### l01: Event emission is missing CoreCollection.initialize() (core-contracts/contracts/CoreCollection.sol#78-97) should emit an event for:           - maxSupply = _maxSupply (core-contracts/contracts/CoreCollection.sol#91)    ### l02: lack of zero checks CoreCollection.initialize()._splitFactory (core-contracts/contracts/CoreCollection.sol#86) lacks a zero-check on :                  - splitFactory = _splitFactory (core-contracts/contracts/CoreCollection.sol#95)  CoreCollection.setRoyaltyVault()._royaltyVault (core-contracts/contracts/CoreCollection.sol#185) lacks a zero-check on :                  - royaltyVault = _royaltyVault (core-contracts/contracts/CoreCollection.sol#193)   ### l03: use safe erc20 functions  ERC721Payable._handlePayment() (core-contracts/contracts/ERC721Payable.sol#50-56)  ignores return value by payableToken.transferFrom() (core-contracts/contracts/ERC721Payable.sol#54)  consider safeTransferFrom to prevent any locks or loss of funds 
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164   # Vulnerability details  ## Impact  When royaltyAsset is an ERC20 that doesn't allow zero amount transfers, the following griefing attack is possible, entirely disabling CoreCollection token transfer by precision degradation as both reward distribution and vault balance can be manipulated.  Suppose splitterProxy is set, all addresses and fees are configured correctly, system is in normal operating state.  POC:  Bob the attacker setup a bot which every time it observes positive royaltyVault balance:  1) runs `sendToSplitter()`, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so vault balance becomes zero  2) sends `1 wei` of royaltyAsset to the royaltyVault balance  3) each next CoreCollection token transfer will calculate `platformShare = (balanceOfVault * platformFee) / 10000`, which will be 0 as platformFee is supposed to be less than 100%, and then there will be an attempt to transfer it to `platformFeeRecipient`  If royaltyAsset reverts on zero amount transfers, the whole operation will fail as the success of `IERC20(royaltyAsset).transfer(platformFeeRecipient, platformShare)` is required for each CoreCollection token transfer, which invokes `sendToSplitter()` in `_beforeTokenTransfer()` as vault balance is positive in (3).  Notice, that Bob needn't to front run the transfer, it is enough to empty the balance in a lazy way, so cumulative gas cost of the attack can be kept moderate.  Setting severity to medium as on one hand, the attack is easy to setup and completely blocks token transfers, making the system inoperable, and it looks like system has to be redeployed on such type of attack with some manual management of user funds, which means additional operational costs and reputational damage. On the another, it is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.  That is, as an another corner case, if platformFee is set to 100%, `platformShare` will be `1 wei` and `splitterShare` be zero in (3), so this attack be valid for any royaltyAsset as it is required in Splitter's `incrementWindow` that `splitterShare` be positive.  ## Proof of Concept  As royaltyAsset can be an arbitrary ERC20 it can be reverting on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  `_beforeTokenTransfer` runs `IRoyaltyVault(royaltyVault).sendToSplitter()` whenever royaltyVault is set and have positive balance:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307  `sendToSplitter()` leaves vault balance as exactly zero as `splitterShare = balanceOfVault - platformShare`, i.e. no dust is left behind:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41  This way the balance opens up for the tiny amount manipulation.  One require that can fail the whole operation is `platformShare` transfer:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  Another is positive `royaltyAmount` = `splitterShare` requirement:  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164  ## Recommended Mitigation Steps  The issue is that token transfer, which is core system operation, require fee splitting to be done on the spot. More failsafe design is to try to send the fees and record the amounts not yet distributed, not requiring immediate success. The logic here is that transfer itself is more important than fee distribution, which is simple enough and can be performed in a variety of ways later.  Another issue is a combination of direct balance usage and the lack of access controls of the sendToSplitter function, but it only affects fee splitting and is somewhat harder to address.  As one approach consider trying, but not requiring `IRoyaltyVault(royaltyVault).sendToSplitter()` to run successfully as it can be executed later with the same result.  Another, a simpler one (the same is in `Griefing attack is possible making Splitter's claimForAllWindows inaccessible` issue), is to introduce action threshold, `MIN_ROYALTY_AMOUNT`, to `sendToSplitter()`, for example:  Now: ``` /**  * @dev Send accumulated royalty to splitter.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      require(         balanceOfVault > 0,         "Vault does not have enough royalty Asset to send"     );  ...      emit RoyaltySentToSplitter(...);     emit FeeSentToPlatform(...); } ```  To be: ``` /**  * @dev Send accumulated royalty to splitter if it's above MIN_ROYALTY_AMOUNT threshold.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      if (balanceOfVault > MIN_ROYALTY_AMOUNT) {   ...       emit RoyaltySentToSplitter(...);      emit FeeSentToPlatform(...);     } } ```  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L153-L155   # Vulnerability details  ## Impact  A `merkleRoot` may only be used once in `createSplit()` since it is used as `salt` to the deployment of a `SplitProxy`.   The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`.  The original transaction will revert and the user will not be able to send any more transaction with this `merkleRoot`.  The user would therefore have to generate a new merkle tree with different address, different allocations or a different order of leaves in the tree to create a new merkle root. However, the attack is repeateable and there is no guarantee this new merkle root will be successfully added to a split without the attacker front-running the transaction again.  ## Proof of Concept  The excerpt from `createSplitProxy()` shows the `merkleRoot()` being used as a `salt`.  ```   splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()   ); ```  ## Recommended Mitigation Steps  As seems to be the case here if the transaction address does NOT need to be known ahead of time consider removing the `salt` parameter from the contract deployment.  Otherwise, if the transaction address does need to be known ahead of time then consider concatenating `msg.sender` to the `merkleRoot`. e.g.  ``` splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(msg.sender, merkleRoot))}()   ) ```  
## Issue 1 (Low) - All function inputs should verify address != address(0)  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L193 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L60-L61 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76  There are several input addresses that should be verified != address(0). Most notably, the royaltyVault and platformFeeRecipient.  ## Issue 2 (Low) - platformFeeRecipient must be trusted  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  In the event that `royaltyAsset` gives control on transfer such as with an ERC777, a malicious `platformFeeRecipient` will have the power to stop all executions of `sendToSplitter()`  ## Issue 3 (Low) - Function definition doesn't match purpose  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L231-L240  The `transferSplitAsset()` function contains comments about sending ETH, and the event that is emitted is called `TransferETH` despite only ERC20 transfers.  ## Issue 4 (Non-critical) - Private attemptETHTransfer() never used  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248  Since `attemptETHTransfer()` is private and not used in the contract, it can safely be removed.  ## Issue 5 (non-critical) - Internal functions should start with underscore  Example: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/MultiSigWallet.sol#L284  Code style best practice.  ## Issue 6 (non-critical) - Unnecessary bool in TransferETH event  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L237-L239   The function reverts if transfer fails, so bool in event will always be true.    
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact  Collection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).  ## Proof of Concept  Consider a new `Collection` with a `RoyaltyVault` and `Splitter` set and a nonzero mint fee.  When calling `mintToken`, the `_handlePayment` function is called https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163  This will transfer the minting fee to the `RoyaltyVault` contract.  On each transfer of an NFT within the collection (for instance in the `_mint` call which occurs directly after calling `_handlePayment`), the `Collection` contract will call `sendToSplitter` on the `RoyaltyVault`: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307  This function will forward the collection owners' portion of the minting on to the `Splitter` contract but another important thing to note is that we call `Splitter.incrementWindow`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50  This results in the fees newly deposited into the `Splitter` contract being held in a separate "window" to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169  From this we can see that the `claim` function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142  Note that we can attempt to claim from multiple windows in a single transaction using `claimForAllWindow` but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with `claim`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62  We're then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to `claim` incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.  Compound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.  Medium risk as it's gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.  ## Recommended Mitigation Steps  It doesn't seem like the "window" mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77   # Vulnerability details  ## Impact  This is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that _collections.isForSale can be change by frontrunner)  ## Proof of Concept  1. Anyone can call `createProject`.  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77  ```solidity   function createProject(     string memory _projectId,     Collection[] memory _collections   ) external onlyAvailableProject(_projectId) {     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ```  ## Recommended Mitigation Steps  Two way to mitigate.  1. Consider use white list on project creation. 2. Ask user to sign their address and check the signature against `msg.sender`.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102  
# Report  ## Don't ignore ERC20 transfer return values  You're ignoring the return value of an ERC20 transfer twice:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54  Either use SafeERC20 or check the return value as you do in other places in the code base.  ## Add a max boundary for the platform fee  Fees should have a boundary of 100% (10000): https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L68  Otherwise the contract will try to transfer more than possible which will result in reverts: https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L40  It might also be helpful the have an fixed upper boundary that doesn't allow the platform to collect more than a set amount of fees, e.g. 10%.  ## No connection between a project & collection  When creating a project with collections, there is no ID linking the collections to that specific project. Both entities exist independent of each other. There seems to be no way of associating them with each other after the creation (besides the emitted event).  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L99
 Title: Does not validate the input fee parameter Severity: Low Risk   Some fee parameters of functions are not checked for invalid values. Validate the parameters:                           RoyaltyVaultFactory.setPlatformFeeRecipient (_platformFeeRecipient)         RoyaltyVaultFactory.setPlatformFee (_platformFee)         SplitFactory.setPlatformFeeRecipient (_platformFeeRecipient)         CoreCollection.initialize (_mintFee)         RoyaltyVault.setPlatformFeeRecipient (_platformFeeRecipient)         RoyaltyVault.setPlatformFee (_platformFee)         SplitFactory.setPlatformFee (_platformFee)    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           Splitter.sol: function attemptETHTransfer parameter value isn't used. (attemptETHTransfer is private)    Title: Not verified claimer Severity: Low Risk   If a functions gets as input a claimer param, then it should make sure the claimer address is not address(0). Otherwise it will cause to loss of the funds or access.           ERC721Claimable.sol._claim claimer    Title: Missing commenting Severity: Low Risk           The following functions are missing commenting as describe below:                  MultiSigWallet.sol, external_call (private), parameters destination, value, dataLength, data not commented         SplitProxy.sol, splitter (public), @return is missing         MultiSigWallet.sol, external_call (private), @return is missing    Title: Two Steps Verification before Transferring Ownership Severity: Low Risk  The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ICoreCollection.sol    Title: Not verified owner Severity: Low Risk           owner param should be validated to make sure the owner address is not address(0).         Otherwise if not given the right input all only owner accessible functions will be unaccessible.                           MultiSigWallet.sol.replaceOwner owner         MultiSigWallet.sol.removeOwner owner         MultiSigWallet.sol.addOwner owner         MultiSigWallet.sol.replaceOwner newOwner    Title: Duplicates in array Severity: Low Risk  You allow in some arrays to have duplicates. Sometimes you assumes there are no duplicates in the array.              MultiSigWallet.addOwner pushed (owner)    Title: Solidity compiler versions mismatch Severity: Low Risk   The project is compiled with different versions of solidity, which is not recommended because it can lead to undefined behaviors.                      Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       MockCollection.sol.setRoyaltyVault _royaltyVault         Splitter.sol.setClaimed who         CoreCollection.sol.setRoyaltyVault _royaltyVault         RoyaltyVault.sol.setPlatformFeeRecipient _platformFeeRecipient    Title: Require with empty message Severity: Low Risk  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: MultiSigWallet.sol, In line 99 with Empty Require message.         Solidity file: CoreMultiSig.sol, In line 21 with Empty Require message.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L83   # Vulnerability details  ## Impact  The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.  As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.  ## Proof of Concept  ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  ## Recommended Mitigation Steps  This issue may be mitigated by add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform).  Also consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.  Consider the following code. ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         require(_platformFee < MAX_FEE);         sendToSplitter(); // @audit this will need to be public rather than external         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257   # Vulnerability details  ## Impact  The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the `receive()` function. As a result the user would be unable to receive funds from this function.  ## Proof of Concept  ```     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}("");         return success;     } ```  ## Recommended Mitigation Steps  Consider removing the `gas` field to use the default amount and protect from reentrancy by using reentrancy guards and the [check-effects-interaction pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html). Note this pattern is already applied correctly.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50-L59   # Vulnerability details  ## Impact  When the value of `currentWindow` is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.  `currentWindow` can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.  Furthermore, an attacker can continually increment `currentWindow` by calling `incrementWindow()`. An attacker can impersonate a `IRoyaltyVault` and send 1 WEI worth of WETH to pass the required checks.  ## Proof of Concept  Excerpt from `Splitter.claimForAllWindows()` demonstrating the for loop over `currentWindow` that will grow indefinitely. ```         for (uint256 i = 0; i < currentWindow; i++) {             if (!isClaimed(msg.sender, i)) {                 setClaimed(msg.sender, i);                  amount += scaleAmountByPercentage(                     balanceForWindow[i],                     percentageAllocation                 );             }         } ```  `Splitter.incrementWindow()` may be called by an attacker increasing `currentWindow`. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             "Royalty Vault not supported"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             "Unauthorised to increment window"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, "Insufficient funds");          require(royaltyAmount > 0, "No additional funds for window");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ```  ## Recommended Mitigation Steps  Consider modifying the function `claimForAllWindows()` to instead claim for range of windows. Pass the function a `startWindow` and `endWindow` and only iterate through windows in that range. Ensure that `endWindow < currentWindow`.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L78-L97   # Vulnerability details  ## Impact  Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.  Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.  However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.  ## Proof of Concept  `initialize` doesn't control for repetitive runs:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Recommended Mitigation Steps  Add `onlyUnInitialized` modifier to the `initialize` function:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49   
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact In general, the Splitter contract's incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             "Royalty Vault not supported"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             "Unauthorised to increment window"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, "Insufficient funds");          require(royaltyAmount > 0, "No additional funds for window");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169 ## Tools Used None ## Recommended Mitigation Steps Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.  
# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Version](#version)       - [Upgrade pragma to at least 0.8.4](#upgrade-pragma-to-at-least-084)     - [Contract size](#contract-size)       - [Contract is Ownable but owner capabilites are not used](#contract-is-ownable-but-owner-capabilites-are-not-used)     - [Storage](#storage)       - [Caching storage values in memory](#caching-storage-values-in-memory)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)     - [Comparisons](#comparisons)       - [Boolean comparisons](#boolean-comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Visibility](#visibility)       - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings  ### Version  #### Upgrade pragma to at least 0.8.4  Using newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.  The advantages here are:  - **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions). - **Optimizer improvements in packed structs** (>= 0.8.3) - **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  Consider upgrading pragma to at least 0.8.4:  ```jsx core-contracts/contracts/CoreCollection.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/CoreFactory.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/CoreProxy.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/ERC721Claimable.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/ERC721Payable.sol:2:pragma solidity ^0.8.0; ```  ### Contract size  #### Contract is Ownable but owner capabilites are not used  Reduce contract size by removing Ownable given that its functionalities are not used here:  ```solidity core-contracts/contracts/CoreProxy.sol:4:import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol"; core-contracts/contracts/CoreProxy.sol:8:contract CoreProxy is Ownable { royalty-vault/contracts/ProxyVault.sol:6:import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol"; royalty-vault/contracts/ProxyVault.sol:8:contract ProxyVault is VaultStorage, Ownable { ```  ### Storage  #### Caching storage values in memory  The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):  ```solidity core-contracts/contracts/CoreCollection.sol:   225          startingIndex =   226              (uint256(   227                  keccak256(abi.encodePacked("CoreCollection", block.number))   228              ) % maxSupply) +   229:             1; //@audit gas: this calculation should be cached and saved in memory before being saved in startingIndex, so that the cached value can be emitted Line L231   230          startingIndexBlock = uint256(block.number);   231:         emit StartingIndexSet(startingIndex); //@audit gas: should emit the suggested cached memory variable in comment L229 instead of making a storage read (SLOAD) here    304:             royaltyVault != address(0) && //@audit gas: royaltyVault should get cached in memory   305:             IRoyaltyVault(royaltyVault).getVaultBalance() > 0 //@audit gas: should use the suggested cached royaltyVault   306          ) {   307:             IRoyaltyVault(royaltyVault).sendToSplitter(); //@audit gas: should use the suggested cached royaltyVault  royalty-vault/contracts/RoyaltyVault.sol:   38:         require(splitterProxy != address(0), "Splitter is not set"); //@audit gas: splitterProxy should get cached in memory      44:             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, //@audit gas: should use the suggested cached splitterProxy //@audit gas: royaltyAsset should get cached in memory    45              "Failed to transfer royalty Asset to splitter"   46          );   47          require(   48:             ISplitter(splitterProxy).incrementWindow(splitterShare) == true, //@audit gas: should use the suggested cached splitterProxy   49              "Failed to increment splitter window"   50          );   51          require(   52:             IERC20(royaltyAsset).transfer( //@audit gas: should use the suggested cached royaltyAsset    53:                 platformFeeRecipient, //@audit gas: platformFeeRecipient should get cached in memory   54                  platformShare   55              ) == true,   56              "Failed to transfer royalty Asset to platform fee recipient"   57          );   58     59:         emit RoyaltySentToSplitter(splitterProxy, splitterShare); //@audit gas: should use the suggested cached splitterProxy   60:         emit FeeSentToPlatform(platformFeeRecipient, platformShare); //@audit gas: should use the suggested cached platformFeeRecipient ```  ### Variables  #### No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { splits/contracts/Splitter.sol:49:        uint256 amount = 0; splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  I suggest removing explicit initializations for default values.  ### Comparisons  #### Boolean comparisons  Comparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value. I suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here:  ```solidity royalty-vault/contracts/RoyaltyVault.sol:44:            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, royalty-vault/contracts/RoyaltyVault.sol:48:            ISplitter(splitterProxy).incrementWindow(splitterShare) == true, royalty-vault/contracts/RoyaltyVault.sol:55:            ) == true, ```  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity core-contracts/contracts/CoreCollection.sol:    52          require(    53:             _maxSupply > 0,    146:         require(amount > 0, "CoreCollection: Amount should be greater than 0");  core-contracts/contracts/CoreFactory.sol:   74      require(   75:       _collections.length > 0,  royalty-vault/contracts/RoyaltyVault.sol:   34          require(   35:             balanceOfVault > 0,  splits/contracts/Splitter.sol:   164:         require(royaltyAmount > 0, "No additional funds for window"); ```  Also, please enable the Optimizer.  ### For-Loops  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```solidity core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  #### `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:166:        currentWindow += 1; splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  The code would go from:      ```solidity for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ```solidity for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ### Arithmetics    #### Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity File: RoyaltyVault.sol 40:         uint256 platformShare = (balanceOfVault * platformFee) / 10000; 41:         uint256 splitterShare = balanceOfVault - platformShare; //@audit gas: should be unchecked (as L40: platformFee == 500 < 10000 so platformShare < balanceOfVault and I don't believe platformFee would ever be set to >= 10000) ```  ### Visibility  #### Consider making some constants as non-public to save gas  Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here:  ```solidity splits/contracts/Splitter.sol:14:    uint256 public constant PERCENTAGE_SCALE = 10e5; splits/contracts/Splitter.sol:15:    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId; ```  ### Errors  #### Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity core-contracts/contracts/CoreCollection.sol:47:        require(!initialized, "CoreCollection: Already initialized"); core-contracts/contracts/CoreCollection.sol:54:            "CoreCollection: Max supply should be greater than 0" core-contracts/contracts/CoreCollection.sol:146:        require(amount > 0, "CoreCollection: Amount should be greater than 0"); core-contracts/contracts/CoreCollection.sol:191:            "CoreCollection: Only Split Factory or owner can initialize vault." core-contracts/contracts/CoreCollection.sol:206:            "CoreCollection: Hashed Proof is set" core-contracts/contracts/CoreCollection.sol:222:            "CoreCollection: Starting index is already set" royalty-vault/contracts/RoyaltyVault.sol:36:            "Vault does not have enough royalty Asset to send" royalty-vault/contracts/RoyaltyVault.sol:45:            "Failed to transfer royalty Asset to splitter" royalty-vault/contracts/RoyaltyVault.sol:49:            "Failed to increment splitter window" royalty-vault/contracts/RoyaltyVault.sol:56:            "Failed to transfer royalty Asset to platform fee recipient" splits/contracts/Splitter.sol:120:            "NFT has already claimed the given window"  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```solidity core-contracts/contracts/CoreCollection.sol:42:        require(initialized, "CoreCollection: Not initialized"); core-contracts/contracts/CoreCollection.sol:47:        require(!initialized, "CoreCollection: Already initialized"); core-contracts/contracts/CoreCollection.sol:52:        require( core-contracts/contracts/CoreCollection.sol:60:        require(_exists(_tokenId), "CoreCollection: Invalid token id"); core-contracts/contracts/CoreCollection.sol:146:        require(amount > 0, "CoreCollection: Amount should be greater than 0"); core-contracts/contracts/CoreCollection.sol:147:        require( core-contracts/contracts/CoreCollection.sol:153:            require(claimableSet(), "CoreCollection: No claimable"); core-contracts/contracts/CoreCollection.sol:154:            require( core-contracts/contracts/CoreCollection.sol:160:            require(isForSale, "CoreCollection: Not for sale"); core-contracts/contracts/CoreCollection.sol:189:        require( core-contracts/contracts/CoreCollection.sol:204:        require( core-contracts/contracts/CoreCollection.sol:220:        require( core-contracts/contracts/CoreFactory.sol:35:    require( core-contracts/contracts/CoreFactory.sol:43:    require( core-contracts/contracts/CoreFactory.sol:51:    require( core-contracts/contracts/CoreFactory.sol:74:    require( core-contracts/contracts/ERC721Claimable.sol:13:    require(root != bytes32(0), 'ERC721Claimable: Not valid root'); core-contracts/contracts/ERC721Claimable.sol:18:    require(claimableSet(), 'ERC721Claimable: No claimable'); core-contracts/contracts/ERC721Claimable.sol:23:    require(!claimableSet(), 'ERC721Claimable: Claimable is already set'); core-contracts/contracts/ERC721Claimable.sol:63:    require( core-contracts/contracts/ERC721Payable.sol:21:    require( core-contracts/contracts/ERC721Payable.sol:29:    require( royalty-vault/contracts/RoyaltyVault.sol:34:        require( royalty-vault/contracts/RoyaltyVault.sol:38:        require(splitterProxy != address(0), "Splitter is not set"); royalty-vault/contracts/RoyaltyVault.sol:43:        require( royalty-vault/contracts/RoyaltyVault.sol:47:        require( royalty-vault/contracts/RoyaltyVault.sol:51:        require( splits/contracts/SplitFactory.sol:48:    require( splits/contracts/SplitFactory.sol:81:    require( splits/contracts/SplitFactory.sol:136:    require(_vault != address(0), 'Invalid vault'); splits/contracts/SplitFactory.sol:137:    require( splits/contracts/Splitter.sol:40:        require( splits/contracts/Splitter.sol:117:        require(currentWindow > window, "cannot claim for a future window"); splits/contracts/Splitter.sol:118:        require( splits/contracts/Splitter.sol:125:        require( splits/contracts/Splitter.sol:152:        require( splits/contracts/Splitter.sol:156:        require( splits/contracts/Splitter.sol:162:        require(wethBalance >= royaltyAmount, "Insufficient funds"); splits/contracts/Splitter.sol:164:        require(royaltyAmount > 0, "No additional funds for window"); splits/contracts/Splitter.sol:237:        require(didSucceed, "Failed to transfer ETH"); ```  I suggest replacing revert strings with custom errors. 
* different pragma versions - the core-contracts use `pragma solidity ^0.8.0` and the rest of the contracts use `pragma solidity ^0.8.4`  * use a specific solidity version instead of using `^`, to prevent future solidity versions impacting your code and creating issues.  * In the comments and variable names you wrote ETH instead of wETH, which is un-correct (that's an ERC20 so it must be wETH) ```sol function transferSplitAsset(address to, uint256 value)     private     returns (bool didSucceed) {     // Try to transfer ETH to the given recipient.     didSucceed = IERC20(splitAsset).transfer(to, value);     require(didSucceed, "Failed to transfer ETH");     emit TransferETH(to, value, didSucceed); } ```  * In the comment before the function, you wrote returns instead of the known `@return` tag ```sol /**  * @notice Mint token  * @dev A starting index is calculated at the time of first mint  * returns a tokenId  * @param _to Token recipient  */ function mint(address _to) private returns (uint256 tokenId) {     if (startingIndex == 0) {         setStartingIndex();     }     tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;     _mint(_to, tokenId); } ```  * Low level calls (call, delegate call and static call) return success if the called contract doesnâ€™t exist (not deployed or destructed), can be seen here https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf (report #9) and here https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions.  That means that in `attemptETHTransfer`, if `to` doesn't exist the call will fail but success will be set to true, which will act like the call was successful. ```sol function attemptETHTransfer(address to, uint256 value)     private     returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}("");         return success;     } ```  * add `onlyUnInitialized` modifier to the `initialize` function, otherwise the owner can initialize the contract more than one time  * `HASHED_PROOF` - upper case variable name that is not constant  * if `startingIndex + totalSupply()` will reach `type(uint256).max` the system will be in a stuck state, that's because the calculation in the _mint function will overflow  * contracts not declaring that they implement their interfaces - for example `CoreCollection` and `CoreFactory` don't declare that they implement `ICoreCollection` and `ICoreFactory`  * `ICoreFactory` is imported but not used in `CoreProxy`  * didn't check that the address of the given vault is not zero in the `setPlatformFee` function  * wrong comment in `RoyaltyVaultFactory` and `SplitFactory` ```sol /**  * @dev Set Platform fee for collection contract.  * @param _platformFee Platform fee in scaled percentage. (5% = 200)  * @param _vault vault address.  */ function setPlatformFee(address _vault, uint256 _platformFee) external {     IRoyaltyVault(_vault).setPlatformFee(_platformFee); }  /**  * @dev Set Platform fee recipient for collection contract.  * @param _vault vault address.  * @param _platformFeeRecipient Platform fee recipient.  */ function setPlatformFeeRecipient(     address _vault,     address _platformFeeRecipient ) external {     require(_vault != address(0), "Invalid vault");     require(         _platformFeeRecipient != address(0),         "Invalid platform fee recipient"     );     IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient); } ```
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol   # Vulnerability details  ## Impact  The Joyn documentation mentions that Joyn royalty vaults should be equipped to handle revenue generated on a collection's primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, however, there is no existing implementation which allows the owner of a collection to receive fees on secondary sales.   After discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. As such, each collection will need to be added manually on Opensea, introducing further centralisation risk. It is also possible for users to avoid paying the secondary fee by using other marketplaces such as Foundation.   ## Recommended Mitigation Steps  Consider implementing the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the approiate behaviour for this.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56   # Vulnerability details  ## Impact  The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.  ## Proof of Concept  For the sake of this example, let's say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.  ## Recommended Mitigation Steps  Consider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.  
# QA Report  1. Immutable addresses should be 0-checked  Consider adding an `address(0)` check in the constructors for these variables:  ```solidity core-contracts/contracts/CoreFactory.sol:   22:   address public immutable collection;   23:   address public immutable splitFactory;  core-contracts/contracts/CoreProxy.sol:   9:     address private immutable _implement;  splits/contracts/SplitFactory.sol:   11:   /**** Immutable storage ****/   13:   address public immutable splitter;   14:   address public immutable royaltyVault; ```  2. Missing comments  The following comments are missing (see `@audit` tags):  ```solidity core-contracts/contracts/CoreCollection.sol:   254      /**   255       * @notice Mint token   256       * @dev A starting index is calculated at the time of first mint   257       * returns a tokenId   258:      * @param _to Token recipient //@audit missing @return uint256 tokenId   259       */   260      function mint(address _to) private returns (uint256 tokenId) {  core-contracts/contracts/CoreFactory.sol:   101    /**   102     * @notice Allows to add a collection to a project   103     * @dev Can only be called by project creator   104     * Collection's ownership is transferred to the caller   105     * @param _projectId Project id which is a unique identifier   106:    * @param _collection Collection that needs to be deployed //@audit missing @return address   107     */   108    function addCollection(   109      string memory _projectId,   110      Collection memory _collection     111    ) external onlyProjectOwner(_projectId) returns (address) {    138    /**   139     * @notice Instanciates/Deploys a collection   140:    * @param _collection Collection that needs to be deployed //@audit missing @return address   141     */   142    function _createCollection(Collection memory _collection)   143      private   144      onlyAvailableCollection(_collection.id)   145      returns (address)  core-contracts/contracts/ERC721Claimable.sol:   49    /**   50     * @notice Verifies whether an address can claim tokens   51     * @dev    52     * @param who Claimer address   53     * @param claimableAmount Amount airdropped to claimer   54     * @param claimedAmount Amount of tokens claimer wants to claim   55:    * @param merkleProof Proof //@audit missing @return bool   56     */   57    function canClaim(   58      address who,   59      uint256 claimableAmount,   60      uint256 claimedAmount,   61      bytes32[] calldata merkleProof   62    ) public view returns (bool) {  splits/contracts/SplitFactory.sol:    55    /**    56     * @dev Constructor    57:    * @param _splitter The address of the Splitter contract. //@audit missing @param _royaltyVault    58     */    59    constructor(address _splitter, address _royaltyVault) {     68    /**    69     * @dev Deploys a new SplitProxy and initializes collection's royalty vault.    70     * @param _merkleRoot The merkle root of the asset.    71     * @param _splitAsset The address of the asset to split.    72     * @param _collectionContract The address of the collection contract.    73:    * @param _splitId The split identifier. //@audit missing @return address splitProxy    74     */    75    function createSplit(    76      bytes32 _merkleRoot,    77      address _splitAsset,    78      address _collectionContract,    79      string memory _splitId    80    ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {     96    /**    97     * @dev Deploys a new SplitProxy.    98     * @param _merkleRoot The merkle root of the asset.    99     * @param _splitAsset The address of the asset to split.   100:    * @param _splitId The split identifier. //@audit missing @return address splitProxy   101     */   102    function createSplit(   103      bytes32 _merkleRoot,   104      address _splitAsset,   105      string memory _splitId   106    ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {  splits/contracts/Splitter.sol:   226      /**   227       * @dev Function to transfer split asset to the given address.   228       * @param to {address} Address to transfer the split asset to.   229:      * @param value {uint256} Amount to transfer. //@audit missing @return bool didSucceed   230       */   231      function transferSplitAsset(address to, uint256 value)   232          private   233          returns (bool didSucceed) ```  3. Avoid floating pragmas / The pragmas used are not the same everywhere: the version should be locked mandatorily at >= `0.8.4` as Custom Errors are only introduced there and several contracts wouldn't compile at an older version than this:  ```solidity core-contracts/contracts/CoreCollection.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/CoreFactory.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/CoreProxy.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/ERC721Claimable.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/ERC721Payable.sol:   2: pragma solidity ^0.8.0;  royalty-vault/contracts/ProxyVault.sol:   2: pragma solidity ^0.8.4;  royalty-vault/contracts/RoyaltyVault.sol:   2: pragma solidity ^0.8.4;  splits/contracts/SplitFactory.sol:   2: pragma solidity ^0.8.4;  splits/contracts/SplitProxy.sol:   2: pragma solidity ^0.8.4;  splits/contracts/Splitter.sol:   2: pragma solidity ^0.8.4; ```  4. `CoreCollection.sol` should use implement a 2-step ownership transfer pattern instead of using `Ownable`'s default one.  5. `platformFee` should be upper bounded to avoid DoS and excessive fees  `platformFee` can take a value of 10000 (100%) which could be seen as a trust issue:  ```solidity File: RoyaltyVault.sol 67:     function setPlatformFee(uint256 _platformFee) external override onlyOwner { 68:         platformFee = _platformFee; //@audit low should be upperbounded to 10000 or L41 will get DOSed by an underflow. A reasonable upperbound should be declared for trust 69:         emit NewRoyaltyVaultPlatformFee(_platformFee); 70:     } ```  Also, although unlikely and remediable by calling again `setPlatformFee` with another value, `sendToSplitter` can get DOSed by the admin by setting `platformFee` to more than 10000:  ```solidity File: RoyaltyVault.sol 40:         uint256 platformShare = (balanceOfVault * platformFee) / 10000; 41:         uint256 splitterShare = balanceOfVault - platformShare; //@audit DOSed by the admin if platformFee > 10000, which is possible ```
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L9   # Vulnerability details  ## Impact Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables  ## Proof of Concept      contract CoreProxy is Ownable {            address private immutable _implement;  When you implement proxies, logic and implementation share the same storage layout.    In order to avoid storage conflicts  EIP1967 was proposed.(https://eips.ethereum.org/EIPS/eip-1967)   The idea is to set proxy variables at fixed positions (like  `impl` and `admin` ).    For example, according to the standard,  the slot for for logic address should be  `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`  ).  In this case, for example, as you inherits from `Ownable` the variable _owner is at the first slot and can be overwritten in the implementation.   There is a table at OZ site that explains this scenario more in detail  https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies  section  "Unstructured Storaged Proxies"  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using EIP1967     
# QA Report  ## Low Issues  ### Unsafe ERC20 transfers  ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard.  It is therefore recommended to always either use OpenZeppelin's SafeERC20 library or at least to wrap each operation in a require statement.  Following functions have unsafe ERC20 transfers: - CoreCollection::withdraw - ERC721Payable::_handlePayment  ### Missing upper limit for platform fee  The platform fee can be set to arbitraty values in the `RoyaltyVault::setPlatformFee` function. The highest logical value is 10,000 = 100%.  Consider introducing an upper limit for the platform fee through a `require` statement.  Note that it's recommended to set the upper limit far lower than 100% to disable rug vectors.  ### Issues with comments  The `Splitter::transferSplitAsset` function has a faulty comment stating `// Try to transfer ETH to the given recipient.`, eventhough an ERC20 token is transfered. The error message in case of failure is off too.  A parameter document for function `RoyaltyVaultFactory::setPlatformFee` states `5% = 200` as example for the percentage scale. This conversion rate is false.  ## Gas Optimizations  ### Don't Initialize Variables with Default Value  Issue Information: [G001](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g001---dont-initialize-variables-with-default-value)  #### Findings: ``` core-contracts/contracts/CoreCollection.sol::280 => for (uint256 i = 0; i < _amount; i++) { splits/contracts/Splitter.sol::52 => uint256 amount = 0; splits/contracts/Splitter.sol::53 => for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol::278 => for (uint256 i = 0; i < proof.length; i++) { ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Cache Array Length Outside of Loop  Issue Information: [G002](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g002---cache-array-length-outside-of-loop)  #### Findings: ``` core-contracts/contracts/CoreFactory.sol::79 => for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol::278 => for (uint256 i = 0; i < proof.length; i++) { ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Long Revert Strings  Issue Information: [G007](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g007---long-revert-strings)  #### Findings: ``` core-contracts/contracts/CoreCollection.sol::47 => require(!initialized, "CoreCollection: Already initialized"); core-contracts/contracts/CoreCollection.sol::146 => require(amount > 0, "CoreCollection: Amount should be greater than 0"); core-contracts/contracts/CoreCollection.sol::192 => "CoreCollection: Only Split Factory or owner can initialize vault." core-contracts/contracts/CoreCollection.sol::207 => "CoreCollection: Hashed Proof is set" core-contracts/contracts/CoreCollection.sol::223 => "CoreCollection: Starting index is already set" royalty-vault/contracts/RoyaltyVault.sol::36 => "Vault does not have enough royalty Asset to send" royalty-vault/contracts/RoyaltyVault.sol::45 => "Failed to transfer royalty Asset to splitter" royalty-vault/contracts/RoyaltyVault.sol::49 => "Failed to increment splitter window" royalty-vault/contracts/RoyaltyVault.sol::56 => "Failed to transfer royalty Asset to platform fee recipient" splits/contracts/Splitter.sol::123 => "NFT has already claimed the given window" ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Unspecific Compiler Version Pragma  Issue Information: [L003](https://github.com/byterocket/c4-common-issues/blob/main/2-Low-Risk.md#l003---unspecific-compiler-version-pragma)  All contracts use a floating pragma. Consider specifying a concrete solidity version for non-interface contracts.  #### Tools used [c4udit](https://github.com/byterocket/c4udit) 
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L156-L159   # Vulnerability details  ## Proof of Concept  ```solidity         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             "Unauthorised to increment window"         ); ```  The authorization check in `incrementWindow` can be easily passed. However, `incrementWindow` can change the value of `currentWindow` which is used for loop. It should be guard properly.  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L50   ```solidity for (uint256 i = 0; i < currentWindow; i++) { ```   ## Recommended Mitigation Steps  Consider using white list for this task.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57   # Vulnerability details   Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.  Recommendation: Consider using OpenZeppelinâ€™s SafeERC20  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55   # Vulnerability details  The below transferFrom command is called at two places in the core contracts, followed by an emit event ``` payableToken.transferFrom(msg.sender,recipient,_amount) emit ...(...); ``` The return value is not checked during the payableToken.transferFrom  ## Impact In the event of failure of payableToken.transferFrom(...), the emit event is still generated causing the downstream applications to capture wrong transaction / state of the protocol.  ## Proof of Concept 1. Contract CoreCollection.sol      function withdraw()  2. Contract ERC721Payable.sol    function _handlePayment   ## Recommended Mitigation Steps Add a require statement as being used in the RoyaltyVault.sol ``` require( payableToken.transferFrom(msg.sender,recipient,_amount) == true,             "Failed to transfer amount to recipient" ); ```  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175   # Vulnerability details   The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` ( who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.  Recommendation : replace `transferFrom` with `transfer`  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31   # Vulnerability details  ## Impact  Each CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.  ## Proof of Concept  Each RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.  ```     function sendToSplitter() external override {         ...         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         );         ...         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             "Failed to transfer royalty Asset to platform fee recipient"         );         ...     } ```  Considering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.  ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          ...          royaltyVault = _royaltyVault;          ...      }       function _handlePayment(uint256 _amount) internal {          address recipient = royaltyVaultInitialized()              ? royaltyVault              : address(this);          payableToken.transferFrom(msg.sender, recipient, _amount);          ...      } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  While assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`   ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          require(              payableToken == _royaltyVault.royaltyAsset(),              "CoreCollection : payableToken must be same as royaltyAsset."          );          ...          royaltyVault = _royaltyVault;          ...      } ```   
**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] Avoid unnecessary external call can save gas  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, avoiding unnecessary external call can save gas if possible.  For example:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVaultFactory.sol#L37-L50  ```solidity     function createVault(address _splitter, address _royaltyAsset)         external         returns (address vault)     {         splitterProxy = _splitter;         royaltyAsset = _royaltyAsset;          vault = address(             new ProxyVault{salt: keccak256(abi.encode(_splitter))}()         );          delete splitterProxy;         delete royaltyAsset;     } ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L16-L22  ```solidity     constructor() {         royaltyVault = IVaultFactory(msg.sender).royaltyVault();         splitterProxy = IVaultFactory(msg.sender).splitterProxy();         royaltyAsset = IVaultFactory(msg.sender).royaltyAsset();         platformFee = IVaultFactory(msg.sender).platformFee();         platformFeeRecipient = IVaultFactory(msg.sender).platformFeeRecipient();     } ```  Can be changed to:  ```solidity     constructor(address _royaltyVault, address _splitterProxy, address _royaltyAsset, uint256 _platformFee, address _platformFeeRecipient) {         royaltyVault = _royaltyVault;         splitterProxy = _splitterProxy;         royaltyAsset = _royaltyAsset;         platformFee = _platformFee;         platformFeeRecipient = _platformFeeRecipient;     } ```  ```solidity     function createVault(address _splitter, address _royaltyAsset)         external         returns (address vault)     {         splitterProxy = _splitter;         royaltyAsset = _royaltyAsset;          vault = address(             new ProxyVault{salt: keccak256(abi.encode(_splitter))}(royaltyVault, splitterProxy, royaltyAsset, platformFee, platformFeeRecipient)         );          delete splitterProxy;         delete royaltyAsset;     } ```  It can save 5 times of external calls.  ## [M] Setting `uint256` variables to `0` is redundant  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49-L49  ```solidity         uint256 amount = 0; ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  Other examples include:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279-L279  ## [S] Cache array length in for loops can save gas  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `CoreFactory.sol#createProject()`      https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79-L92  - `Splitter.sol#verifyProof()`      https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274-L288  ## [M] `++i` is more efficient than `i++`  Using `++i` is more gas efficient than `i++`, especially in for loops.  For example:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274-L274  ```solidity         for (uint256 i = 0; i < proof.length; i++) ```  Change to:  ```solidity         for (uint256 i = 0; i < proof.length; +i) ```  ## [M] Unused constant variable  Unused constant variables in contracts increase contract size and gas usage at deployment.   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14-L15  ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5;  ```  In the contract, the constant variable `PERCENTAGE_SCALE` is set once but has never been read, therefore it can be removed.  ## [M] Use short reason strings can save gas  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146-L146  ```solidity require(amount > 0, "CoreCollection: Amount should be greater than 0"); ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192  ```solidity         require(             msg.sender == splitFactory || msg.sender == owner(),             "CoreCollection: Only Split Factory or owner can initialize vault."         ); ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223  ```solidity         require(             startingIndex == 0,             "CoreCollection: Starting index is already set"         ); ```  ## [M] Unused events  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVaultFactory.sol#L19-L19  ```solidity     event VaultCreated(address vault); ```  `VaultCreated` is unused.  ## [M] Unused function parameters  Unused private function increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257  ```solidity     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}("");         return success;     } ```  `attemptETHTransfer()` is unused.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L224  ```solidity     function amountFromPercent(uint256 amount, uint32 percent)         private         pure         returns (uint256)     {         // Solidity 0.8.0 lets us do this without SafeMath.         return (amount * percent) / 100;     } ```  `amountFromPercent()` is unused.  ## [S] Use `immutable` instead of getter to save gas  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L8-L37  ```solidity contract CoreProxy is Ownable {     address private immutable _implement;      constructor(address _imp) {         _implement = _imp;     }      fallback() external {         address _impl = implement();         assembly {             let ptr := mload(0x40)             calldatacopy(ptr, 0, calldatasize())             let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)             let size := returndatasize()             returndatacopy(ptr, 0, size)              switch result             case 0 {                 revert(ptr, size)             }             default {                 return(ptr, size)             }         }     }      function implement() public view returns (address) {         return _implement;     } } ```  ### Recommendation  Change to:  ```solidity contract CoreProxy is Ownable {     address private immutable _implement;      constructor(address _imp) {         _implement = _imp;     }      fallback() external {         address _impl = _implement;         assembly {             let ptr := mload(0x40)             calldatacopy(ptr, 0, calldatasize())             let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)             let size := returndatasize()             returndatacopy(ptr, 0, size)              switch result             case 0 {                 revert(ptr, size)             }             default {                 return(ptr, size)             }         }     }      function implement() external view returns (address) {         return _implement;     } } ``` 
# QA Report  ## Low severity findings  ### token transfer in `CoreCollection:withdraw` will fail  In function `CoreCollection` mintfee is transfered to same address if vault is not initialized, these tokens can be withdrawn by owner using `withdraw` function, but transferFrom function will fail due to lack of allowance  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173  ``` function withdraw() external onlyOwner {     uint256 amount = payableToken.balanceOf(address(this));     payableToken.transferFrom(address(this), msg.sender, amount);      emit NewWithdrawal(msg.sender, amount); } ```  #### Mitigation  `transferFrom` can be replaced with `transfer`  ### Increment window and transfer funds  Function `Splitter:incrementWindow` is executed by `vault:sendToSplitter` transfered tokens is pushed into `balanceForWindow` array and window is incremented, but the function can be executed by any contract and more than allowed share of tokens can be transfered by whitelisted users  #### Proof of concept  ``` bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;  function incrementWindow(uint256 royaltyAmount) public returns (bool) {     uint256 wethBalance;      require(         IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),         "Royalty Vault not supported"     );     require(         IRoyaltyVault(msg.sender).getSplitter() == address(this),         "Unauthorised to increment window"     );      wethBalance = IERC20(splitAsset).balanceOf(address(this));     require(wethBalance >= royaltyAmount, "Insufficient funds");      require(royaltyAmount > 0, "No additional funds for window");     balanceForWindow.push(royaltyAmount);     currentWindow += 1;     emit WindowIncremented(currentWindow, royaltyAmount);     return true; } ``` The function can be executed by any contract with function `supportsInterface` and `getSplitter` that returns splitter address     royaltyAmount equivalent to current unclaimed balance can be added to window and the window can be incremented to add windows  `claimForAllWindows` can be executed by whitelisted user to transfer percent allocated tokens from each new window    #### Mitigation  A storage variable with tokens added to the window can be added, and `total-windowBalance` can be added to next window, and when token is transfered windowBalance can be decremented  ### `CoreCollection` can be re-initialized by owner  Function `CoreCollection:initialize` can be executed by owner after initialisation and state variables like mintFee, maxSupply can be changed to increase/decrease fee and supply, isForSale can be set to false to stop token sale  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L97  #### Mitigation   require statement can be added to revert if function is already initialized   ## Non-critical findings  ### Unused import  Imported file is not used in the contract and can be removed  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L6  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L6  #### Mitigation  import statement can be removed  ### Lack of input validation  #### Impact  Input validation is absent for address variables which may result in re-deployment if address is wrong in constructor or value transfer to wrong address, it is recommended to add validation statements in all address inputs especially in value transfers and immutable variable initialisation.  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L27   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L140  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L59-64  #### Mitigation  Add address validation statement    ### Lack of comments  #### Impact  Some functions in the code are not commented or missing parts of comments. Adding comments can improve readability of the code   #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128  missing return comment https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L33  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L41  missing param comment https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L57  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L230  #### Mitigation  Comments can be added to the functions  ### boolean comparison with constant  In function `RoyaltyVault:sentToSplitter` external function return value boolean is compared with boolean constant. The return value can be directly used in the require statement  #### Proof of concept   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51  #### Mitigation  The return value of the function can be directly used in the require statement  ### Code Layout  #### Impact   Code can be structed in order type declarations, state variables, events and functions which can improve readability Refer: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#order-of-layout  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol
1. There are a lack of input checks around the contracts: - [CoreCollection.sol#L88-L96](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L88-L96) - [CoreCollection.sol#L125-L126](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L125-L126) - [CoreCollection.sol#L193](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L193) and [CoreCollection.sol#L209](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L209) could be critical because only can be assigned once. - [CoreFactory.sol#L28-L29](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L28-L29)  2. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of approve methods. - [CoreCollection.sol#L175](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175) - [ERC721Payable.sol#L54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54)  
### `require()`/`revert()` strings longer than 32 bytes cost extra gas  1. File: core-contracts/contracts/ERC721Payable.sol (lines [21-24](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L21-L24)) ```solidity     require(       !royaltyVaultInitialized(),       'CoreCollection: Royalty Vault already initialized'     ); ``` 2. File: core-contracts/contracts/ERC721Payable.sol (lines [29-32](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L29-L32)) ```solidity     require(       royaltyVaultInitialized(),       'CoreCollection: Royalty Vault not initialized'     ); ``` 3. File: core-contracts/contracts/ERC721Claimable.sol (line [23](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L23)) ```solidity     require(!claimableSet(), 'ERC721Claimable: Claimable is already set'); ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [47](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L47)) ```solidity         require(!initialized, "CoreCollection: Already initialized"); ``` 5. File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55)) ```solidity         require(             _maxSupply > 0,             "CoreCollection: Max supply should be greater than 0"         ); ``` 6. File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146)) ```solidity         require(amount > 0, "CoreCollection: Amount should be greater than 0"); ``` 7. File: core-contracts/contracts/CoreCollection.sol (lines [189-192](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192)) ```solidity         require(             msg.sender == splitFactory || msg.sender == owner(),             "CoreCollection: Only Split Factory or owner can initialize vault."         ); ``` 8. File: core-contracts/contracts/CoreCollection.sol (lines [204-207](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L204-L207)) ```solidity         require(             bytes(HASHED_PROOF).length == 0,             "CoreCollection: Hashed Proof is set"         ); ``` 9. File: core-contracts/contracts/CoreCollection.sol (lines [220-223](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223)) ```solidity         require(             startingIndex == 0,             "CoreCollection: Starting index is already set"         ); ``` 10. File: core-contracts/contracts/CoreFactory.sol (lines [35-38](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L35-L38)) ```solidity     require(       projects[_projectId].creator == address(0),       'CoreFactory: Unavailable project id'     ); ``` 11. File: core-contracts/contracts/CoreFactory.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L43-L46)) ```solidity     require(       projects[_projectId].creator == msg.sender,       'CoreFactory: Not an owner of the project'     ); ``` 12. File: core-contracts/contracts/CoreFactory.sol (lines [51-54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L51-L54)) ```solidity     require(       collections[_collectionId] == address(0),       'CoreFactory: Unavailable collection id'     ); ``` 13. File: core-contracts/contracts/CoreFactory.sol (lines [74-77](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L74-L77)) ```solidity     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ``` 14. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37)) ```solidity         require(             balanceOfVault > 0,             "Vault does not have enough royalty Asset to send"         ); ``` 15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L46)) ```solidity         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         ); ``` 16. File: royalty-vault/contracts/RoyaltyVault.sol (lines [47-50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47-L50)) ```solidity         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             "Failed to increment splitter window"         ); ``` 17. File: royalty-vault/contracts/RoyaltyVault.sol (lines [51-57](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57)) ```solidity         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             "Failed to transfer royalty Asset to platform fee recipient"         ); ``` 18. File: splits/contracts/SplitFactory.sol (lines [48-51](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L48-L51)) ```solidity     require(       splits[_splitId] == address(0),       'SplitFactory : Split ID already in use'     ); ``` 19. File: splits/contracts/SplitFactory.sol (lines [81-84](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L81-L84)) ```solidity     require(       ICoreCollection(_collectionContract).owner() == msg.sender,       'Transaction sender is not collection owner'     ); ``` 20. File: splits/contracts/Splitter.sol (lines [118-121](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L118-L121)) ```solidity         require(             !isClaimed(msg.sender, window),             "NFT has already claimed the given window"         ); ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  1. File: royalty-vault/contracts/RoyaltyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 2. File: royalty-vault/contracts/ProxyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 3. File: splits/contracts/SplitFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 4. File: splits/contracts/SplitProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitProxy.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 5. File: splits/contracts/Splitter.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L2)) ```solidity pragma solidity ^0.8.4; ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  1. File: core-contracts/contracts/ERC721Payable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 2. File: core-contracts/contracts/CoreProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 3. File: core-contracts/contracts/ERC721Claimable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 5. File: core-contracts/contracts/CoreFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L2)) ```solidity pragma solidity ^0.8.0; ```  ### Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27  1. File: core-contracts/contracts/ERC721Payable.sol (line [8](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L8)) ```solidity   bool public isForSale; ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [20](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L20)) ```solidity     bool public initialized; ```  ### Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement  1. File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55)) ```solidity         require(             _maxSupply > 0,             "CoreCollection: Max supply should be greater than 0"         ); ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146)) ```solidity         require(amount > 0, "CoreCollection: Amount should be greater than 0"); ``` 3. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37)) ```solidity         require(             balanceOfVault > 0,             "Vault does not have enough royalty Asset to send"         ); ``` 4. File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164)) ```solidity         require(royaltyAmount > 0, "No additional funds for window"); ```  ### `<array>.length` should not be looked up in every loop of a `for`-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length  1. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 2. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### It costs more gas to initialize variables to zero than to let the default of zero be applied  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: splits/contracts/Splitter.sol (line [49](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49)) ```solidity         uint256 amount = 0; ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second access of a state variable within a function. Less obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.  1. File: core-contracts/contracts/CoreCollection.sol (line [231](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L231)) ```solidity         emit StartingIndexSet(startingIndex); ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [264](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L264)) ```solidity         tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1; ``` 3. File: splits/contracts/SplitFactory.sol (line [161](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L161)) ```solidity     delete merkleRoot; ``` 4. File: splits/contracts/SplitFactory.sol (line [171](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L171)) ```solidity     delete splitterProxy; ```  ### Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas  1. File: core-contracts/contracts/CoreCollection.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L79)) ```solidity         string memory _collectionName, ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L80)) ```solidity         string memory _collectionSymbol, ``` 3. File: core-contracts/contracts/CoreCollection.sol (line [81](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L81)) ```solidity         string memory _collectionURI, ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L122)) ```solidity         string memory _collectionName, ``` 5. File: core-contracts/contracts/CoreCollection.sol (line [123](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L123)) ```solidity         string memory _collectionSymbol ``` 6. File: core-contracts/contracts/CoreFactory.sol (line [71](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L71)) ```solidity     string memory _projectId, ``` 7. File: core-contracts/contracts/CoreFactory.sol (line [72](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L72)) ```solidity     Collection[] memory _collections ``` 8. File: core-contracts/contracts/CoreFactory.sol (line [109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L109)) ```solidity     string memory _projectId, ``` 9. File: core-contracts/contracts/CoreFactory.sol (line [110](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L110)) ```solidity     Collection memory _collection ``` 10. File: core-contracts/contracts/CoreFactory.sol (line [128](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128)) ```solidity   function getProject(string memory _projectId) ``` 11. File: splits/contracts/SplitFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L79)) ```solidity     string memory _splitId ``` 12. File: splits/contracts/SplitFactory.sol (line [105](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L105)) ```solidity     string memory _splitId ```  ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### `++i` costs less gas than `++i`, especially when it's used in `for`-loops (`--i`/`i--` too)  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  1. File: splits/contracts/Splitter.sol (line [217](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217)) ```solidity     function amountFromPercent(uint256 amount, uint32 percent) ```  ### Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code  1. File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14)) ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5; ``` 2. File: splits/contracts/Splitter.sol (line [15](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L15)) ```solidity     bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId; ```  ### Don't compare boolean expressions to boolean literals `if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`  1. File: royalty-vault/contracts/RoyaltyVault.sol (line [44](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L44)) ```solidity             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, ``` 2. File: royalty-vault/contracts/RoyaltyVault.sol (line [48](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L48)) ```solidity             ISplitter(splitterProxy).incrementWindow(splitterShare) == true, ``` 3. File: royalty-vault/contracts/RoyaltyVault.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L52-L55)) ```solidity             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true, ```  ### Remove unused variables  1. File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14)) ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5; ```  ### State variables only set in the constructor should be declared `immutable`  1. File: royalty-vault/contracts/ProxyVault.sol (line [9](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L9)) ```solidity     address internal royaltyVault; ```  ### `require()` or `revert()` statements that check input arguments should be at the top of the function  1. File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164)) ```solidity         require(royaltyAmount > 0, "No additional funds for window"); ```  ### `private` functions not called by the contract should be removed to save deployment gas  1. File: splits/contracts/Splitter.sol (lines [217-220](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L220)) ```solidity     function amountFromPercent(uint256 amount, uint32 percent)         private         pure         returns (uint256) ``` 2. File: splits/contracts/Splitter.sol (lines [248-250](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L250)) ```solidity     function attemptETHTransfer(address to, uint256 value)         private         returns (bool) ```  ### `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`. 1. File: royalty-vault/contracts/RoyaltyVault.sol (lines [95-100](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L95-L100)) ```solidity     function supportsInterface(bytes4 interfaceId)         public         view         virtual         override(IRoyaltyVault, ERC165)         returns (bool) ``` 2. File: royalty-vault/contracts/RoyaltyVault.sol (line [88](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L88)) ```solidity     function getSplitter() public view override returns (address) { ```  ### Use custom errors rather than `revert()`/`require()` strings to save deployment gas  1. File: royalty-vault/contracts/RoyaltyVault.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol)) 2. File: splits/contracts/SplitFactory.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol)) 3. File: splits/contracts/Splitter.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol))  ### Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  1. File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87)) ```solidity     function initialize(         string memory _collectionName,         string memory _collectionSymbol,         string memory _collectionURI,         uint256 _maxSupply,         uint256 _mintFee,         address _payableToken,         bool _isForSale,         address _splitFactory     ) external onlyOwner onlyValidSupply(_maxSupply) { ``` 2. File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87)) ```solidity     function initialize(         string memory _collectionName,         string memory _collectionSymbol,         string memory _collectionURI,         uint256 _maxSupply,         uint256 _mintFee,         address _payableToken,         bool _isForSale,         address _splitFactory     ) external onlyOwner onlyValidSupply(_maxSupply) { ``` 3. File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109)) ```solidity     function initializeClaims(bytes32 _root)         external         onlyOwner         onlyNotClaimableSet         onlyValidRoot(_root) ``` 4. File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109)) ```solidity     function initializeClaims(bytes32 _root)         external         onlyOwner         onlyNotClaimableSet         onlyValidRoot(_root) ``` 5. File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109)) ```solidity     function initializeClaims(bytes32 _root)         external         onlyOwner         onlyNotClaimableSet         onlyValidRoot(_root) ``` 6. File: core-contracts/contracts/CoreCollection.sol (lines [121-124](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L121-L124)) ```solidity     function setCollectionMeta(         string memory _collectionName,         string memory _collectionSymbol     ) external onlyOwner { ``` 7. File: core-contracts/contracts/CoreCollection.sol (lines [139-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L139-L145)) ```solidity     function mintToken(         address to,         bool isClaim,         uint256 claimableAmount,         uint256 amount,         bytes32[] calldata merkleProof     ) external onlyInitialized { ``` 8. File: core-contracts/contracts/CoreCollection.sol (line [173](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173)) ```solidity     function withdraw() external onlyOwner { ``` 9. File: core-contracts/contracts/CoreCollection.sol (lines [185-187](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L185-L187)) ```solidity     function setRoyaltyVault(address _royaltyVault)         external         onlyVaultUninitialized ``` 10. File: core-contracts/contracts/CoreCollection.sol (line [203](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L203)) ```solidity     function setHashedProof(string calldata _proof) external onlyOwner { ``` 11. File: core-contracts/contracts/CoreFactory.sol (lines [70-73](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L70-L73)) ```solidity   function createProject(     string memory _projectId,     Collection[] memory _collections   ) external onlyAvailableProject(_projectId) { ``` 12. File: core-contracts/contracts/CoreFactory.sol (lines [108-111](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108-L111)) ```solidity   function addCollection(     string memory _projectId,     Collection memory _collection   ) external onlyProjectOwner(_projectId) returns (address) { ``` 13. File: core-contracts/contracts/CoreFactory.sol (lines [142-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L142-L145)) ```solidity   function _createCollection(Collection memory _collection)     private     onlyAvailableCollection(_collection.id)     returns (address) ``` 14. File: royalty-vault/contracts/RoyaltyVault.sol (line [67](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L67)) ```solidity     function setPlatformFee(uint256 _platformFee) external override onlyOwner { ``` 15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [76-79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L79)) ```solidity     function setPlatformFeeRecipient(address _platformFeeRecipient)         external         override         onlyOwner ``` 16. File: splits/contracts/SplitFactory.sol (lines [75-80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L75-L80)) ```solidity   function createSplit(     bytes32 _merkleRoot,     address _splitAsset,     address _collectionContract,     string memory _splitId   ) external onlyAvailableSplit(_splitId) returns (address splitProxy) { ``` 17. File: splits/contracts/SplitFactory.sol (lines [102-106](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L102-L106)) ```solidity   function createSplit(     bytes32 _merkleRoot,     address _splitAsset,     string memory _splitId   ) external onlyAvailableSplit(_splitId) returns (address splitProxy) { ``` 18. File: splits/contracts/SplitFactory.sol (lines [120-122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L120-L122)) ```solidity   function setPlatformFee(address _vault, uint256 _platformFee)     external     onlyOwner ``` 19. File: splits/contracts/SplitFactory.sol (lines [132-135](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L132-L135)) ```solidity   function setPlatformFeeRecipient(     address _vault,     address _platformFeeRecipient   ) external onlyOwner { ```
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103   # Vulnerability details  ## Details & Impact  There is a `PERCENTAGE_SCALE = 10e5` defined, but the actual denominator used is `10000`. This is aggravated by the following factors:  1. Split contracts are created by collection owners, not the factory owner. Hence, there is a likelihood for someone to mistakenly use `PERCENTAGE_SCALE` instead of `10000`. 2. The merkle root for split distribution can only be set once, and a collectionâ€™s split and royalty vault canâ€™t be changed once created.  Thus, if an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.  ## Recommended Mitigation Steps  Remove `PERCENTAGE_SCALE` because it is unused, or replace its value with `10_000` and use that instead.   P.S: there is an issue with the example scaled percentage given for platform fees `(5% = 200)`. Should be `500` instead of `200`.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54   # Vulnerability details  ## Details  The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.  Some tokens like [EURS](https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and [BAT](https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will **not** revert if the transfer failed but return `false` instead. Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.  ## Impact  Users would be able to mint NFTs for free regardless of mint fee if tokens that donâ€™t revert on failed transfers were used.  ## Recommended Mitigation Steps  Check theÂ `success` boolean of allÂ `transferFrom()` calls. Alternatively, use OZâ€™s `SafeERC20`â€™s `safeTransferFrom()` function.  
# 1. Low - transfer return value is ignored  ## Impact  Some ERC20 tokens, such as USDT, don't revert when transfer/transferFrom fails. The transfer return value has to be checked (as there are some other tokens that returns false instead revert). safeTransfer should be used instead of transfer  ## Proof of Concept  safeTransferFrom should be used instead of transferFrom on this line https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use safeTransfer instead of transfer or check the return value of transfer. The return value of transfer is checked properly in these locations https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L44 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L52 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L237  # 2. Low - onlyUnInitialized modifier missing from initialize function  ## Impact  The CoreCollection initialize function is missing the onlyUnInitialized function. The onlyUnInitialized modifier is not used in the contract right now and this allows the initialize function to be called more than once.  ## Proof of Concept  The onlyUnInitialized modifier prevents functions from being run if the initialized is set to true https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46  This modifier is missing from the initialize function https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the onlyUnInitialized modifier to the initialize function
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50   # Vulnerability details  ## Impact  Certain ERC20 tokens may change user's balances over time (positively or negatively) or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by `RoyaltyVault.sol` or `Splitter.sol` and may result in tokens being stuck in `Splitter` or overstating the balance of a user   Thus, for FoT tokens if all users tried to claim from the Splitter there would be insufficient funds and the last user could not withdraw their tokens.  ## Proof of Concept  The function `RoyaltyVault.sendToSplitter()` will transfer `splitterShare` tokens to the `Splitter` and then call `incrementWindow(splitterShare)` which tells the contract to split `splitterShare` between each of the users.  ```         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         );         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             "Failed to increment splitter window"         ); ```  Since the `Splitter` may receive less than `splitterShare` tokens if there is a fee on transfer the `Splitter` will overstate the amount split and each user can claim more than their value (except the last user who claims nothing as the contract will have insufficient funds to transfer them the full amount).  Furthermore, if the token rebase their value of the tokens down while they are sitting in the `Splitter` the same issue will occur. If the tokens rebase their value up then this will not be accounted for in the protocol.  ## Recommended Mitigation Steps  It is recommend documenting clearly that rebasing token should not be used in the protocol.  Alternatively, if it is a requirement to handle rebasing tokens balance checks should be done before and after the transfer to ensure accurate accounting. Note: this makes the contract vulnerable to reentrancy and so a [reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) must be placed over the function `sendToSplitter()`.  ```         uint256 balanceBefore = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             "Failed to transfer royalty Asset to splitter"         );         uint256 balanceAfter = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             ISplitter(splitterProxy).incrementWindow(balanceAfter - balanceBefore) == true,             "Failed to increment splitter window"         ); ```  
### l01: Event emission is missing CoreCollection.initialize() (core-contracts/contracts/CoreCollection.sol#78-97) should emit an event for:           - maxSupply = _maxSupply (core-contracts/contracts/CoreCollection.sol#91)    ### l02: lack of zero checks CoreCollection.initialize()._splitFactory (core-contracts/contracts/CoreCollection.sol#86) lacks a zero-check on :                  - splitFactory = _splitFactory (core-contracts/contracts/CoreCollection.sol#95)  CoreCollection.setRoyaltyVault()._royaltyVault (core-contracts/contracts/CoreCollection.sol#185) lacks a zero-check on :                  - royaltyVault = _royaltyVault (core-contracts/contracts/CoreCollection.sol#193)   ### l03: use safe erc20 functions  ERC721Payable._handlePayment() (core-contracts/contracts/ERC721Payable.sol#50-56)  ignores return value by payableToken.transferFrom() (core-contracts/contracts/ERC721Payable.sol#54)  consider safeTransferFrom to prevent any locks or loss of funds 
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164   # Vulnerability details  ## Impact  When royaltyAsset is an ERC20 that doesn't allow zero amount transfers, the following griefing attack is possible, entirely disabling CoreCollection token transfer by precision degradation as both reward distribution and vault balance can be manipulated.  Suppose splitterProxy is set, all addresses and fees are configured correctly, system is in normal operating state.  POC:  Bob the attacker setup a bot which every time it observes positive royaltyVault balance:  1) runs `sendToSplitter()`, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so vault balance becomes zero  2) sends `1 wei` of royaltyAsset to the royaltyVault balance  3) each next CoreCollection token transfer will calculate `platformShare = (balanceOfVault * platformFee) / 10000`, which will be 0 as platformFee is supposed to be less than 100%, and then there will be an attempt to transfer it to `platformFeeRecipient`  If royaltyAsset reverts on zero amount transfers, the whole operation will fail as the success of `IERC20(royaltyAsset).transfer(platformFeeRecipient, platformShare)` is required for each CoreCollection token transfer, which invokes `sendToSplitter()` in `_beforeTokenTransfer()` as vault balance is positive in (3).  Notice, that Bob needn't to front run the transfer, it is enough to empty the balance in a lazy way, so cumulative gas cost of the attack can be kept moderate.  Setting severity to medium as on one hand, the attack is easy to setup and completely blocks token transfers, making the system inoperable, and it looks like system has to be redeployed on such type of attack with some manual management of user funds, which means additional operational costs and reputational damage. On the another, it is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.  That is, as an another corner case, if platformFee is set to 100%, `platformShare` will be `1 wei` and `splitterShare` be zero in (3), so this attack be valid for any royaltyAsset as it is required in Splitter's `incrementWindow` that `splitterShare` be positive.  ## Proof of Concept  As royaltyAsset can be an arbitrary ERC20 it can be reverting on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  `_beforeTokenTransfer` runs `IRoyaltyVault(royaltyVault).sendToSplitter()` whenever royaltyVault is set and have positive balance:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307  `sendToSplitter()` leaves vault balance as exactly zero as `splitterShare = balanceOfVault - platformShare`, i.e. no dust is left behind:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41  This way the balance opens up for the tiny amount manipulation.  One require that can fail the whole operation is `platformShare` transfer:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  Another is positive `royaltyAmount` = `splitterShare` requirement:  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164  ## Recommended Mitigation Steps  The issue is that token transfer, which is core system operation, require fee splitting to be done on the spot. More failsafe design is to try to send the fees and record the amounts not yet distributed, not requiring immediate success. The logic here is that transfer itself is more important than fee distribution, which is simple enough and can be performed in a variety of ways later.  Another issue is a combination of direct balance usage and the lack of access controls of the sendToSplitter function, but it only affects fee splitting and is somewhat harder to address.  As one approach consider trying, but not requiring `IRoyaltyVault(royaltyVault).sendToSplitter()` to run successfully as it can be executed later with the same result.  Another, a simpler one (the same is in `Griefing attack is possible making Splitter's claimForAllWindows inaccessible` issue), is to introduce action threshold, `MIN_ROYALTY_AMOUNT`, to `sendToSplitter()`, for example:  Now: ``` /**  * @dev Send accumulated royalty to splitter.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      require(         balanceOfVault > 0,         "Vault does not have enough royalty Asset to send"     );  ...      emit RoyaltySentToSplitter(...);     emit FeeSentToPlatform(...); } ```  To be: ``` /**  * @dev Send accumulated royalty to splitter if it's above MIN_ROYALTY_AMOUNT threshold.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      if (balanceOfVault > MIN_ROYALTY_AMOUNT) {   ...       emit RoyaltySentToSplitter(...);      emit FeeSentToPlatform(...);     } } ```  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L153-L155   # Vulnerability details  ## Impact  A `merkleRoot` may only be used once in `createSplit()` since it is used as `salt` to the deployment of a `SplitProxy`.   The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`.  The original transaction will revert and the user will not be able to send any more transaction with this `merkleRoot`.  The user would therefore have to generate a new merkle tree with different address, different allocations or a different order of leaves in the tree to create a new merkle root. However, the attack is repeateable and there is no guarantee this new merkle root will be successfully added to a split without the attacker front-running the transaction again.  ## Proof of Concept  The excerpt from `createSplitProxy()` shows the `merkleRoot()` being used as a `salt`.  ```   splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()   ); ```  ## Recommended Mitigation Steps  As seems to be the case here if the transaction address does NOT need to be known ahead of time consider removing the `salt` parameter from the contract deployment.  Otherwise, if the transaction address does need to be known ahead of time then consider concatenating `msg.sender` to the `merkleRoot`. e.g.  ``` splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(msg.sender, merkleRoot))}()   ) ```  
## Issue 1 (Low) - All function inputs should verify address != address(0)  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L193 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L60-L61 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76  There are several input addresses that should be verified != address(0). Most notably, the royaltyVault and platformFeeRecipient.  ## Issue 2 (Low) - platformFeeRecipient must be trusted  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  In the event that `royaltyAsset` gives control on transfer such as with an ERC777, a malicious `platformFeeRecipient` will have the power to stop all executions of `sendToSplitter()`  ## Issue 3 (Low) - Function definition doesn't match purpose  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L231-L240  The `transferSplitAsset()` function contains comments about sending ETH, and the event that is emitted is called `TransferETH` despite only ERC20 transfers.  ## Issue 4 (Non-critical) - Private attemptETHTransfer() never used  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248  Since `attemptETHTransfer()` is private and not used in the contract, it can safely be removed.  ## Issue 5 (non-critical) - Internal functions should start with underscore  Example: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/MultiSigWallet.sol#L284  Code style best practice.  ## Issue 6 (non-critical) - Unnecessary bool in TransferETH event  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L237-L239   The function reverts if transfer fails, so bool in event will always be true.    
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact  Collection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).  ## Proof of Concept  Consider a new `Collection` with a `RoyaltyVault` and `Splitter` set and a nonzero mint fee.  When calling `mintToken`, the `_handlePayment` function is called https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163  This will transfer the minting fee to the `RoyaltyVault` contract.  On each transfer of an NFT within the collection (for instance in the `_mint` call which occurs directly after calling `_handlePayment`), the `Collection` contract will call `sendToSplitter` on the `RoyaltyVault`: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307  This function will forward the collection owners' portion of the minting on to the `Splitter` contract but another important thing to note is that we call `Splitter.incrementWindow`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50  This results in the fees newly deposited into the `Splitter` contract being held in a separate "window" to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169  From this we can see that the `claim` function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142  Note that we can attempt to claim from multiple windows in a single transaction using `claimForAllWindow` but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with `claim`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62  We're then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to `claim` incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.  Compound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.  Medium risk as it's gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.  ## Recommended Mitigation Steps  It doesn't seem like the "window" mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77   # Vulnerability details  ## Impact  This is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that _collections.isForSale can be change by frontrunner)  ## Proof of Concept  1. Anyone can call `createProject`.  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77  ```solidity   function createProject(     string memory _projectId,     Collection[] memory _collections   ) external onlyAvailableProject(_projectId) {     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ```  ## Recommended Mitigation Steps  Two way to mitigate.  1. Consider use white list on project creation. 2. Ask user to sign their address and check the signature against `msg.sender`.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102  
# Report  ## Don't ignore ERC20 transfer return values  You're ignoring the return value of an ERC20 transfer twice:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54  Either use SafeERC20 or check the return value as you do in other places in the code base.  ## Add a max boundary for the platform fee  Fees should have a boundary of 100% (10000): https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L68  Otherwise the contract will try to transfer more than possible which will result in reverts: https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L40  It might also be helpful the have an fixed upper boundary that doesn't allow the platform to collect more than a set amount of fees, e.g. 10%.  ## No connection between a project & collection  When creating a project with collections, there is no ID linking the collections to that specific project. Both entities exist independent of each other. There seems to be no way of associating them with each other after the creation (besides the emitted event).  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L99
 Title: Does not validate the input fee parameter Severity: Low Risk   Some fee parameters of functions are not checked for invalid values. Validate the parameters:                           RoyaltyVaultFactory.setPlatformFeeRecipient (_platformFeeRecipient)         RoyaltyVaultFactory.setPlatformFee (_platformFee)         SplitFactory.setPlatformFeeRecipient (_platformFeeRecipient)         CoreCollection.initialize (_mintFee)         RoyaltyVault.setPlatformFeeRecipient (_platformFeeRecipient)         RoyaltyVault.setPlatformFee (_platformFee)         SplitFactory.setPlatformFee (_platformFee)    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           Splitter.sol: function attemptETHTransfer parameter value isn't used. (attemptETHTransfer is private)    Title: Not verified claimer Severity: Low Risk   If a functions gets as input a claimer param, then it should make sure the claimer address is not address(0). Otherwise it will cause to loss of the funds or access.           ERC721Claimable.sol._claim claimer    Title: Missing commenting Severity: Low Risk           The following functions are missing commenting as describe below:                  MultiSigWallet.sol, external_call (private), parameters destination, value, dataLength, data not commented         SplitProxy.sol, splitter (public), @return is missing         MultiSigWallet.sol, external_call (private), @return is missing    Title: Two Steps Verification before Transferring Ownership Severity: Low Risk  The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ICoreCollection.sol    Title: Not verified owner Severity: Low Risk           owner param should be validated to make sure the owner address is not address(0).         Otherwise if not given the right input all only owner accessible functions will be unaccessible.                           MultiSigWallet.sol.replaceOwner owner         MultiSigWallet.sol.removeOwner owner         MultiSigWallet.sol.addOwner owner         MultiSigWallet.sol.replaceOwner newOwner    Title: Duplicates in array Severity: Low Risk  You allow in some arrays to have duplicates. Sometimes you assumes there are no duplicates in the array.              MultiSigWallet.addOwner pushed (owner)    Title: Solidity compiler versions mismatch Severity: Low Risk   The project is compiled with different versions of solidity, which is not recommended because it can lead to undefined behaviors.                      Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       MockCollection.sol.setRoyaltyVault _royaltyVault         Splitter.sol.setClaimed who         CoreCollection.sol.setRoyaltyVault _royaltyVault         RoyaltyVault.sol.setPlatformFeeRecipient _platformFeeRecipient    Title: Require with empty message Severity: Low Risk  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: MultiSigWallet.sol, In line 99 with Empty Require message.         Solidity file: CoreMultiSig.sol, In line 21 with Empty Require message.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L83   # Vulnerability details  ## Impact  The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.  As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.  ## Proof of Concept  ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  ## Recommended Mitigation Steps  This issue may be mitigated by add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform).  Also consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.  Consider the following code. ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         require(_platformFee < MAX_FEE);         sendToSplitter(); // @audit this will need to be public rather than external         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257   # Vulnerability details  ## Impact  The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the `receive()` function. As a result the user would be unable to receive funds from this function.  ## Proof of Concept  ```     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}("");         return success;     } ```  ## Recommended Mitigation Steps  Consider removing the `gas` field to use the default amount and protect from reentrancy by using reentrancy guards and the [check-effects-interaction pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html). Note this pattern is already applied correctly.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50-L59   # Vulnerability details  ## Impact  When the value of `currentWindow` is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.  `currentWindow` can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.  Furthermore, an attacker can continually increment `currentWindow` by calling `incrementWindow()`. An attacker can impersonate a `IRoyaltyVault` and send 1 WEI worth of WETH to pass the required checks.  ## Proof of Concept  Excerpt from `Splitter.claimForAllWindows()` demonstrating the for loop over `currentWindow` that will grow indefinitely. ```         for (uint256 i = 0; i < currentWindow; i++) {             if (!isClaimed(msg.sender, i)) {                 setClaimed(msg.sender, i);                  amount += scaleAmountByPercentage(                     balanceForWindow[i],                     percentageAllocation                 );             }         } ```  `Splitter.incrementWindow()` may be called by an attacker increasing `currentWindow`. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             "Royalty Vault not supported"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             "Unauthorised to increment window"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, "Insufficient funds");          require(royaltyAmount > 0, "No additional funds for window");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ```  ## Recommended Mitigation Steps  Consider modifying the function `claimForAllWindows()` to instead claim for range of windows. Pass the function a `startWindow` and `endWindow` and only iterate through windows in that range. Ensure that `endWindow < currentWindow`.  
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L78-L97   # Vulnerability details  ## Impact  Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.  Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.  However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.  ## Proof of Concept  `initialize` doesn't control for repetitive runs:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Recommended Mitigation Steps  Add `onlyUnInitialized` modifier to the `initialize` function:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49   
# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact In general, the Splitter contract's incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             "Royalty Vault not supported"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             "Unauthorised to increment window"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, "Insufficient funds");          require(royaltyAmount > 0, "No additional funds for window");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169 ## Tools Used None ## Recommended Mitigation Steps Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.  
# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Version](#version)       - [Upgrade pragma to at least 0.8.4](#upgrade-pragma-to-at-least-084)     - [Contract size](#contract-size)       - [Contract is Ownable but owner capabilites are not used](#contract-is-ownable-but-owner-capabilites-are-not-used)     - [Storage](#storage)       - [Caching storage values in memory](#caching-storage-values-in-memory)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)     - [Comparisons](#comparisons)       - [Boolean comparisons](#boolean-comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Visibility](#visibility)       - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings  ### Version  #### Upgrade pragma to at least 0.8.4  Using newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.  The advantages here are:  - **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions). - **Optimizer improvements in packed structs** (>= 0.8.3) - **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  Consider upgrading pragma to at least 0.8.4:  ```jsx core-contracts/contracts/CoreCollection.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/CoreFactory.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/CoreProxy.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/ERC721Claimable.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/ERC721Payable.sol:2:pragma solidity ^0.8.0; ```  ### Contract size  #### Contract is Ownable but owner capabilites are not used  Reduce contract size by removing Ownable given that its functionalities are not used here:  ```solidity core-contracts/contracts/CoreProxy.sol:4:import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol"; core-contracts/contracts/CoreProxy.sol:8:contract CoreProxy is Ownable { royalty-vault/contracts/ProxyVault.sol:6:import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol"; royalty-vault/contracts/ProxyVault.sol:8:contract ProxyVault is VaultStorage, Ownable { ```  ### Storage  #### Caching storage values in memory  The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):  ```solidity core-contracts/contracts/CoreCollection.sol:   225          startingIndex =   226              (uint256(   227                  keccak256(abi.encodePacked("CoreCollection", block.number))   228              ) % maxSupply) +   229:             1; //@audit gas: this calculation should be cached and saved in memory before being saved in startingIndex, so that the cached value can be emitted Line L231   230          startingIndexBlock = uint256(block.number);   231:         emit StartingIndexSet(startingIndex); //@audit gas: should emit the suggested cached memory variable in comment L229 instead of making a storage read (SLOAD) here    304:             royaltyVault != address(0) && //@audit gas: royaltyVault should get cached in memory   305:             IRoyaltyVault(royaltyVault).getVaultBalance() > 0 //@audit gas: should use the suggested cached royaltyVault   306          ) {   307:             IRoyaltyVault(royaltyVault).sendToSplitter(); //@audit gas: should use the suggested cached royaltyVault  royalty-vault/contracts/RoyaltyVault.sol:   38:         require(splitterProxy != address(0), "Splitter is not set"); //@audit gas: splitterProxy should get cached in memory      44:             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, //@audit gas: should use the suggested cached splitterProxy //@audit gas: royaltyAsset should get cached in memory    45              "Failed to transfer royalty Asset to splitter"   46          );   47          require(   48:             ISplitter(splitterProxy).incrementWindow(splitterShare) == true, //@audit gas: should use the suggested cached splitterProxy   49              "Failed to increment splitter window"   50          );   51          require(   52:             IERC20(royaltyAsset).transfer( //@audit gas: should use the suggested cached royaltyAsset    53:                 platformFeeRecipient, //@audit gas: platformFeeRecipient should get cached in memory   54                  platformShare   55              ) == true,   56              "Failed to transfer royalty Asset to platform fee recipient"   57          );   58     59:         emit RoyaltySentToSplitter(splitterProxy, splitterShare); //@audit gas: should use the suggested cached splitterProxy   60:         emit FeeSentToPlatform(platformFeeRecipient, platformShare); //@audit gas: should use the suggested cached platformFeeRecipient ```  ### Variables  #### No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { splits/contracts/Splitter.sol:49:        uint256 amount = 0; splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  I suggest removing explicit initializations for default values.  ### Comparisons  #### Boolean comparisons  Comparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value. I suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here:  ```solidity royalty-vault/contracts/RoyaltyVault.sol:44:            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, royalty-vault/contracts/RoyaltyVault.sol:48:            ISplitter(splitterProxy).incrementWindow(splitterShare) == true, royalty-vault/contracts/RoyaltyVault.sol:55:            ) == true, ```  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity core-contracts/contracts/CoreCollection.sol:    52          require(    53:             _maxSupply > 0,    146:         require(amount > 0, "CoreCollection: Amount should be greater than 0");  core-contracts/contracts/CoreFactory.sol:   74      require(   75:       _collections.length > 0,  royalty-vault/contracts/RoyaltyVault.sol:   34          require(   35:             balanceOfVault > 0,  splits/contracts/Splitter.sol:   164:         require(royaltyAmount > 0, "No additional funds for window"); ```  Also, please enable the Optimizer.  ### For-Loops  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```solidity core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  #### `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:166:        currentWindow += 1; splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  The code would go from:      ```solidity for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ```solidity for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ### Arithmetics    #### Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity File: RoyaltyVault.sol 40:         uint256 platformShare = (balanceOfVault * platformFee) / 10000; 41:         uint256 splitterShare = balanceOfVault - platformShare; //@audit gas: should be unchecked (as L40: platformFee == 500 < 10000 so platformShare < balanceOfVault and I don't believe platformFee would ever be set to >= 10000) ```  ### Visibility  #### Consider making some constants as non-public to save gas  Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here:  ```solidity splits/contracts/Splitter.sol:14:    uint256 public constant PERCENTAGE_SCALE = 10e5; splits/contracts/Splitter.sol:15:    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId; ```  ### Errors  #### Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity core-contracts/contracts/CoreCollection.sol:47:        require(!initialized, "CoreCollection: Already initialized"); core-contracts/contracts/CoreCollection.sol:54:            "CoreCollection: Max supply should be greater than 0" core-contracts/contracts/CoreCollection.sol:146:        require(amount > 0, "CoreCollection: Amount should be greater than 0"); core-contracts/contracts/CoreCollection.sol:191:            "CoreCollection: Only Split Factory or owner can initialize vault." core-contracts/contracts/CoreCollection.sol:206:            "CoreCollection: Hashed Proof is set" core-contracts/contracts/CoreCollection.sol:222:            "CoreCollection: Starting index is already set" royalty-vault/contracts/RoyaltyVault.sol:36:            "Vault does not have enough royalty Asset to send" royalty-vault/contracts/RoyaltyVault.sol:45:            "Failed to transfer royalty Asset to splitter" royalty-vault/contracts/RoyaltyVault.sol:49:            "Failed to increment splitter window" royalty-vault/contracts/RoyaltyVault.sol:56:            "Failed to transfer royalty Asset to platform fee recipient" splits/contracts/Splitter.sol:120:            "NFT has already claimed the given window"  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```solidity core-contracts/contracts/CoreCollection.sol:42:        require(initialized, "CoreCollection: Not initialized"); core-contracts/contracts/CoreCollection.sol:47:        require(!initialized, "CoreCollection: Already initialized"); core-contracts/contracts/CoreCollection.sol:52:        require( core-contracts/contracts/CoreCollection.sol:60:        require(_exists(_tokenId), "CoreCollection: Invalid token id"); core-contracts/contracts/CoreCollection.sol:146:        require(amount > 0, "CoreCollection: Amount should be greater than 0"); core-contracts/contracts/CoreCollection.sol:147:        require( core-contracts/contracts/CoreCollection.sol:153:            require(claimableSet(), "CoreCollection: No claimable"); core-contracts/contracts/CoreCollection.sol:154:            require( core-contracts/contracts/CoreCollection.sol:160:            require(isForSale, "CoreCollection: Not for sale"); core-contracts/contracts/CoreCollection.sol:189:        require( core-contracts/contracts/CoreCollection.sol:204:        require( core-contracts/contracts/CoreCollection.sol:220:        require( core-contracts/contracts/CoreFactory.sol:35:    require( core-contracts/contracts/CoreFactory.sol:43:    require( core-contracts/contracts/CoreFactory.sol:51:    require( core-contracts/contracts/CoreFactory.sol:74:    require( core-contracts/contracts/ERC721Claimable.sol:13:    require(root != bytes32(0), 'ERC721Claimable: Not valid root'); core-contracts/contracts/ERC721Claimable.sol:18:    require(claimableSet(), 'ERC721Claimable: No claimable'); core-contracts/contracts/ERC721Claimable.sol:23:    require(!claimableSet(), 'ERC721Claimable: Claimable is already set'); core-contracts/contracts/ERC721Claimable.sol:63:    require( core-contracts/contracts/ERC721Payable.sol:21:    require( core-contracts/contracts/ERC721Payable.sol:29:    require( royalty-vault/contracts/RoyaltyVault.sol:34:        require( royalty-vault/contracts/RoyaltyVault.sol:38:        require(splitterProxy != address(0), "Splitter is not set"); royalty-vault/contracts/RoyaltyVault.sol:43:        require( royalty-vault/contracts/RoyaltyVault.sol:47:        require( royalty-vault/contracts/RoyaltyVault.sol:51:        require( splits/contracts/SplitFactory.sol:48:    require( splits/contracts/SplitFactory.sol:81:    require( splits/contracts/SplitFactory.sol:136:    require(_vault != address(0), 'Invalid vault'); splits/contracts/SplitFactory.sol:137:    require( splits/contracts/Splitter.sol:40:        require( splits/contracts/Splitter.sol:117:        require(currentWindow > window, "cannot claim for a future window"); splits/contracts/Splitter.sol:118:        require( splits/contracts/Splitter.sol:125:        require( splits/contracts/Splitter.sol:152:        require( splits/contracts/Splitter.sol:156:        require( splits/contracts/Splitter.sol:162:        require(wethBalance >= royaltyAmount, "Insufficient funds"); splits/contracts/Splitter.sol:164:        require(royaltyAmount > 0, "No additional funds for window"); splits/contracts/Splitter.sol:237:        require(didSucceed, "Failed to transfer ETH"); ```  I suggest replacing revert strings with custom errors. 
