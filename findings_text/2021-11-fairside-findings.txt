# Handle  leastwood   # Vulnerability details  ## Impact  The `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.  There are two main reasons as to why the beneficiary or an attacker would want to call this function: - To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration. - An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134  ## Tools Used  Manual code review. Discussions with dev.  ## Recommended Mitigation Steps  Ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.  
# Handle  ye0lde   # Vulnerability details  ## Impact  None/Code clarity  ## Proof of Concept  "is" to "in"   https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L347  "the" not needed https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/timelock/Timelock.sol#L16  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the typos.  
# Handle  hyh   # Vulnerability details  ## Impact  As funding pool should be filled with Hatch phase deposits, the phase advance should happen only after it is filled, but when this happen the minting in Beta phase would be frozen by 'fundingPool.balance < 2000 ether' condition. As mintBeta is the only logic for Beta phase the contract will be frozen until phase change.  If there is a setup when Hatch phase advances to Beta before funding pool is filled, mintBeta will work only while it has below 2000 ether, i.e. mintBeta behavior will not be controlled explicitly: anyone can end the Beta phase by sending enough ether directly to funding pool and the contract mint will be frozen until next phase advance.   ## Proof of Concept  'fundingPool.balance < 2000 ether' condition for minting in Beta phase can be blocking as funding pool transfers happen only in mintHatch function during Hatch phase, while subsequent phases do not have any funding pool related logic neither in code, nor in documentation. https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSD.sol#L204 https://fairside-network.gitbook.io/fairside-network/white-paper/augmented-bonding-curve  ## Recommended Mitigation Steps  Remove 'fundingPool.balance < 2000 ether' condition from mintBeta  
# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Finding ```  contracts/token/FSD.sol:174: require(bonded > 0, "FSD::mintHatch: Insufficient Deposit"); ``` On L170, we check whether `bonded` is bigger than 5 ETH. After multiplying with `HATCH_CURVE_RATIO`, it is still over 0. Therefore, it is a tautology and not needed.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  Manual analysis  
# Handle  cmichel   # Vulnerability details  The `FSD.claimGovernanceTribute` function first performs the expensive `getPriorConvictionScore` instead of the cheap `isGovernance[msg.sender]` check.  ```solidity function claimGovernanceTribute(uint256 num) external {     require(         governanceThreshold <=             getPriorConvictionScore(                 msg.sender,                 governanceTributes[num].blockNumber             ) &&             // @audit gas: rearrange this to be first for short circuiting             isGovernance[msg.sender],         "FSD::claimGovernanceTribute: Not a governance member"     );     _claimGovernanceTribute(num); } ```  Reordering the conditions to first do the cheap governance check would allow this function to short-circuit if the user is not a governor, which will save gas on average. The last assignment `membership[msg.sender] = user;` is not required.   
# Handle  cmichel   # Vulnerability details  In `ERC20ConvictionScore._writeCheckpoint`, when the checkpoint is overwritten (`checkpoint.fromBlock == blockNumber`), the new value is set to the `memory checkpoint` structure and never written to storage.  ```solidity // @audit this is MEMORY, setting new convictionScore doesn't write to storage Checkpoint memory checkpoint = checkpoints[user][nCheckpoints - 1];  if (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {     checkpoint.convictionScore = newCS; } ```  Users that have their conviction score updated several times in the same block will only have their first score persisted.  #### POC - User updates their conviction with `updateConvictionScore(user)` - **In the same block**, the user now redeems an NFT conviction using `acquireConviction(id)`. This calls `_increaseConvictionScore(user, amount)` which calls `_writeCheckpoint(..., prevConvictionScore + amount)`. The updated checkpoint is **not** written to storage, and the user lost their conviction NFT. (The conviction/governance totals might still be updated though, leading to a discrepancy.)  ## Impact Users that have their conviction score updated several times in the same block will only have their first score persisted.  This also applies to the total conviction scores `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` (see `_updateConvictionTotals`) which is a big issue as these are updated a lot of times each block.  It can also be used for inflating a user's conviction by first calling `updateConvictionScore` and then creating conviction tokens with `tokenizeConviction`. The `_resetConviction` will not actually reset the user's conviction.  ## Recommended Mitigation Steps Define the `checkpoint` variable as a `storage` pointer:  ```solidity Checkpoint storage checkpoint = checkpoints[user][nCheckpoints - 1]; ```  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, especially in for loops, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dependencies/TributeAccrual.sol#L77-L88  ```solidity=77     function totalAvailableTribute(uint256 offset)         external         view         override         returns (uint256 total)     {         for (uint256 i = offset; i < totalTributes; i++)             total = total.add(availableTribute(i));          for (uint256 i = offset; i < totalGovernanceTributes; i++)             total = total.add(availableGovernanceTribute(i));     } ```  `totalTributes` and `totalGovernanceTributes` can be cached.  
# Handle  WatchPug   # Vulnerability details  Based on the context, once the beneficiary claimed all their vesting tokens, they should get the `fairSideConviction` NFT.  However, in the current implementation, if the beneficiary has claimed any amounts before it's fully vested, then they will never be able to get the `fairSideConviction` NFT, because at L138, it requires the `tokenbClaim` to be equal to the initial vesting amount.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/FSDVesting.sol#L124-L142  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         "FSDVesting::claimVestedTokens: Zero claimable tokens"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == tokenClaim) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  ### Recommendation  Change to:  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         "FSDVesting::claimVestedTokens: Zero claimable tokens"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == totalClaimed) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L274-L291  ```solidity=274 if (user.creation == 0) {     user.creation = block.timestamp;     user.gracePeriod =         membership[msg.sender].creation +         MEMBERSHIP_DURATION +         60 days; } else {     uint256 elapsedDurationPercentage = ((block.timestamp -         user.creation) * 1 ether) / MEMBERSHIP_DURATION;     if (elapsedDurationPercentage < 1 ether) {         uint256 durationIncrease = (costShareBenefit.mul(1 ether) /             (totalCostShareBenefit - costShareBenefit)).mul(                 MEMBERSHIP_DURATION             ) / 1 ether;         user.creation += durationIncrease;         user.gracePeriod += durationIncrease;     } } ```  ### PoC  1. Alice calls `function purchaseMembership()` and adds 20 ether of `costShareBenefit` on day 1:  ``` alice.creation = day 1 timestamp; alice.gracePeriod = day 791 timestamp; ```  2. Alice calls `function purchaseMembership()` again and adds 20 ether of `costShareBenefit` on day 2:  ``` elapsedDurationPercentage = 1/720 durationIncrease = 730 day  alice.creation = day 731 timestamp; alice.gracePeriod = day 1521 timestamp; ```  Making Alice unable to use any membership features until two years later.  
# Handle  WatchPug   # Vulnerability details  The checks in the for loop can be changed to `else if` to save gas and make sure `msg.sender != sigAssessor`.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L616-L649  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             }             if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             "FSDNetwork::_isApprovedByAssessors: Not an Assessor"         );         require(             msg.sender != sigAssessor,             "FSDNetwork::_isApprovedByAssessors: Cannot be the single Assessor"         );          return true;     } ```   ### Recommendation  Change to:  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             } else if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             "FSDNetwork::_isApprovedByAssessors: Not an Assessor"         );          return true;     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L482-L495  ```solidity=482 function setAssessors(address[] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             "FSDNetwork::setAssessors: Insufficient Privileges"         );          uint256 assessorsLength = _assessors.length;         require(             assessorsLength == 3,             "FSDNetwork::setAssessors: Number of assessors must be three"         );          assessors = _assessors;     } ```  ### Recommendation  Change to:  ```solidity=482 function setAssessors(address[3] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             "FSDNetwork::setAssessors: Insufficient Privileges"         );          assessors = _assessors;     } ```  
# Handle  WatchPug   # Vulnerability details  The check if `_wallets.length <= 2` is redundant as the length of `_wallets` parameter must be 2.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L520-L533  ```solidity=520 function setMembershipWallets(address[2] calldata _wallets) external {     //todo internal     require(         membership[msg.sender].wallets[0] == address(0) &&             membership[msg.sender].wallets[1] == address(0),         "FSDNetwork::setMembershipWallets: Cannot have more than three wallets per membership"     );     require(         _wallets.length <= 2,         "FSDNetwork::setMembershipWallets: Too many wallets"     );     membership[msg.sender].wallets = _wallets; } ```  ### Recommendation  Remove the redundant check.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L310-L315  ```solidity=310 // 20% as staking rewards fsd.safeTransfer(address(fsd), stakingRewards); fsd.addRegistrationTribute(stakingRewards);  // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards); ```  The 2 transfers to the same address can be done in one external call to save gas  ### Recommendation  Change to:  ```solidity=310 // 20% as staking rewards // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards + stakingRewards); fsd.addRegistrationTribute(stakingRewards); ```  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/ABC.sol#L53 https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L521  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  
# Handle  rfa   # Vulnerability details  ## Impact When you are reading a value from a storage and using a storage pointer instead of memory, you write directly to the storage instead of the memory.  In the https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234 this line is reading membership[msg.sender] with a storage pointer,  this means any changes to the user variable, is updating directly to the membership[msg.sender],  therefore https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 this line update, makes it useless since the data already written to the membership[msg.sender]  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234-L294   ## Tools Used  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 membership[msg.sender] = user;  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Tracing the function calls, the `_start` parameter in `initiateVesting()` will always be `block.timestamp`. Hence, this input parameter can be removed from the function.  ## Recommended Mitigation Steps  ```jsx // TODO: Modify relevant function calls function initiateVesting(   address _beneficiary,   uint256 _amount ) external onlyFactory {  require(     start == 0,     "FSDVesting::initiateVesting: Vesting is already initialized"   );  beneficiary = _beneficiary;  start = block.timestamp;  amount = _amount; } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  1. The `_user` input in `updateVestedTokens()` is redundant because each user will have at most 1 vesting contract, and this function should be restricted to the FSD token contract only (kindly refer to related submitted issue), which stores and retrieves the mapping of users to vesting contracts. 2. The zero amount check is redundant because it is already checked in `FSD._createVesting()`.  ## Recommended Mitigation Steps  ```jsx /** * @dev Allows a vesting beneficiary to extend their vested token amount. */ function updateVestedTokens(uint256 _amount)   external   override  onlyFsd {   amount = amount.add(_amount); } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  `DURATION.sub(CLIFF)` is calculated in `calculateVestingClaim()`. Since both are constants, it would be better to define a new constant `LINEAR_VEST_AFTER_CLIFF` that refers to the vest duration after the cliff.  ## Recommended Mitigation Steps  `uint256 private constant LINEAR_VEST_AFTER_CLIFF = 18 * ONE_MONTH;`  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Since the defined constants are unneeded elsewhere, it can be defined to be `internal` or `private` to save gas.  ## Recommended Mitigation Steps  ```jsx // One month in seconds uint256 internal constant ONE_MONTH = 30 days; // Cliff period for a vest uint256 internal constant CLIFF = 12 * ONE_MONTH; // Duration of a vest uint256 internal constant DURATION = 30 * ONE_MONTH; ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The claiming of staking and governance tributes for the a beneficiary's vested tokens should be no different than other users / EOAs. However, the `claimTribute()` and `claimGovernanceTribute()` are missing the actual claiming calls to the corresponding functions of the FSD token contract. As a result, the accrued rewards are taken from the beneficiary's vested token while not claiming (replenishing) from the FSD token contract.  ## Recommended Mitigation Steps  In addition to what has been mentioned above, the internal accounting for claimedTribute states can be removed because they are already performed in the FSD token contract.  ```jsx // TODO: Remove _claimedTribute and _claimedGovernanceTribute mappings  /** * @dev Allows claiming of staking tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimTribute(uint256 num) external onlyBeneficiary {     uint256 tribute = fsd.availableTribute(num);     require(tribute != 0, "FSDVesting::claimTribute: No tribute to claim");   fsd.claimTribute(num);     fsd.safeTransfer(msg.sender, tribute);     emit TributeClaimed(msg.sender, tribute); }  /** * @dev Allows claiming of governance tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimGovernanceTribute(uint256 num) external onlyBeneficiary {   uint256 tribute = fsd.availableGovernanceTribute(num);   require(     tribute != 0,     "FSDVesting::claimGovernanceTribute: No governance tribute to claim"   );   fsd.claimGovernanceTribute(num);   fsd.safeTransfer(msg.sender, tribute);   emit GovernanceTributeClaimed(msg.sender, tribute); } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The comment for the `disableOffchainVoting()` function specifies that the feature can be reenabled in the future through a proposal. But, there seems to be no function to do that in the DAO contract.  ## Proof of Concept Function with the comment: https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dao/FairSideDAO.sol#L619  No way to reassign the value: `grep offchain`  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Either remove the comment if the feature is not intended or add a function to reassign the `offchain` and `guardian` state variable  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs  ## Proof of Concept  In a number of places a `keccak("string")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dao/FairSideDAO.sol#L43-L49  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: https://github.com/ethereum/solidity/issues/9232  ## Recommended Mitigation Steps  Change all `constant` hashes to be `immutable`  
# Handle  leastwood   # Vulnerability details  ## Impact  The `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.  There are two main reasons as to why the beneficiary or an attacker would want to call this function: - To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration. - An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134  ## Tools Used  Manual code review. Discussions with dev.  ## Recommended Mitigation Steps  Ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.  
# Handle  ye0lde   # Vulnerability details  ## Impact  None/Code clarity  ## Proof of Concept  "is" to "in"   https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L347  "the" not needed https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/timelock/Timelock.sol#L16  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the typos.  
# Handle  hyh   # Vulnerability details  ## Impact  As funding pool should be filled with Hatch phase deposits, the phase advance should happen only after it is filled, but when this happen the minting in Beta phase would be frozen by 'fundingPool.balance < 2000 ether' condition. As mintBeta is the only logic for Beta phase the contract will be frozen until phase change.  If there is a setup when Hatch phase advances to Beta before funding pool is filled, mintBeta will work only while it has below 2000 ether, i.e. mintBeta behavior will not be controlled explicitly: anyone can end the Beta phase by sending enough ether directly to funding pool and the contract mint will be frozen until next phase advance.   ## Proof of Concept  'fundingPool.balance < 2000 ether' condition for minting in Beta phase can be blocking as funding pool transfers happen only in mintHatch function during Hatch phase, while subsequent phases do not have any funding pool related logic neither in code, nor in documentation. https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSD.sol#L204 https://fairside-network.gitbook.io/fairside-network/white-paper/augmented-bonding-curve  ## Recommended Mitigation Steps  Remove 'fundingPool.balance < 2000 ether' condition from mintBeta  
# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Finding ```  contracts/token/FSD.sol:174: require(bonded > 0, "FSD::mintHatch: Insufficient Deposit"); ``` On L170, we check whether `bonded` is bigger than 5 ETH. After multiplying with `HATCH_CURVE_RATIO`, it is still over 0. Therefore, it is a tautology and not needed.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  Manual analysis  
# Handle  cmichel   # Vulnerability details  The `FSD.claimGovernanceTribute` function first performs the expensive `getPriorConvictionScore` instead of the cheap `isGovernance[msg.sender]` check.  ```solidity function claimGovernanceTribute(uint256 num) external {     require(         governanceThreshold <=             getPriorConvictionScore(                 msg.sender,                 governanceTributes[num].blockNumber             ) &&             // @audit gas: rearrange this to be first for short circuiting             isGovernance[msg.sender],         "FSD::claimGovernanceTribute: Not a governance member"     );     _claimGovernanceTribute(num); } ```  Reordering the conditions to first do the cheap governance check would allow this function to short-circuit if the user is not a governor, which will save gas on average. The last assignment `membership[msg.sender] = user;` is not required.   
# Handle  cmichel   # Vulnerability details  In `ERC20ConvictionScore._writeCheckpoint`, when the checkpoint is overwritten (`checkpoint.fromBlock == blockNumber`), the new value is set to the `memory checkpoint` structure and never written to storage.  ```solidity // @audit this is MEMORY, setting new convictionScore doesn't write to storage Checkpoint memory checkpoint = checkpoints[user][nCheckpoints - 1];  if (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {     checkpoint.convictionScore = newCS; } ```  Users that have their conviction score updated several times in the same block will only have their first score persisted.  #### POC - User updates their conviction with `updateConvictionScore(user)` - **In the same block**, the user now redeems an NFT conviction using `acquireConviction(id)`. This calls `_increaseConvictionScore(user, amount)` which calls `_writeCheckpoint(..., prevConvictionScore + amount)`. The updated checkpoint is **not** written to storage, and the user lost their conviction NFT. (The conviction/governance totals might still be updated though, leading to a discrepancy.)  ## Impact Users that have their conviction score updated several times in the same block will only have their first score persisted.  This also applies to the total conviction scores `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` (see `_updateConvictionTotals`) which is a big issue as these are updated a lot of times each block.  It can also be used for inflating a user's conviction by first calling `updateConvictionScore` and then creating conviction tokens with `tokenizeConviction`. The `_resetConviction` will not actually reset the user's conviction.  ## Recommended Mitigation Steps Define the `checkpoint` variable as a `storage` pointer:  ```solidity Checkpoint storage checkpoint = checkpoints[user][nCheckpoints - 1]; ```  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, especially in for loops, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dependencies/TributeAccrual.sol#L77-L88  ```solidity=77     function totalAvailableTribute(uint256 offset)         external         view         override         returns (uint256 total)     {         for (uint256 i = offset; i < totalTributes; i++)             total = total.add(availableTribute(i));          for (uint256 i = offset; i < totalGovernanceTributes; i++)             total = total.add(availableGovernanceTribute(i));     } ```  `totalTributes` and `totalGovernanceTributes` can be cached.  
# Handle  WatchPug   # Vulnerability details  Based on the context, once the beneficiary claimed all their vesting tokens, they should get the `fairSideConviction` NFT.  However, in the current implementation, if the beneficiary has claimed any amounts before it's fully vested, then they will never be able to get the `fairSideConviction` NFT, because at L138, it requires the `tokenbClaim` to be equal to the initial vesting amount.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/FSDVesting.sol#L124-L142  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         "FSDVesting::claimVestedTokens: Zero claimable tokens"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == tokenClaim) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  ### Recommendation  Change to:  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         "FSDVesting::claimVestedTokens: Zero claimable tokens"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == totalClaimed) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L274-L291  ```solidity=274 if (user.creation == 0) {     user.creation = block.timestamp;     user.gracePeriod =         membership[msg.sender].creation +         MEMBERSHIP_DURATION +         60 days; } else {     uint256 elapsedDurationPercentage = ((block.timestamp -         user.creation) * 1 ether) / MEMBERSHIP_DURATION;     if (elapsedDurationPercentage < 1 ether) {         uint256 durationIncrease = (costShareBenefit.mul(1 ether) /             (totalCostShareBenefit - costShareBenefit)).mul(                 MEMBERSHIP_DURATION             ) / 1 ether;         user.creation += durationIncrease;         user.gracePeriod += durationIncrease;     } } ```  ### PoC  1. Alice calls `function purchaseMembership()` and adds 20 ether of `costShareBenefit` on day 1:  ``` alice.creation = day 1 timestamp; alice.gracePeriod = day 791 timestamp; ```  2. Alice calls `function purchaseMembership()` again and adds 20 ether of `costShareBenefit` on day 2:  ``` elapsedDurationPercentage = 1/720 durationIncrease = 730 day  alice.creation = day 731 timestamp; alice.gracePeriod = day 1521 timestamp; ```  Making Alice unable to use any membership features until two years later.  
# Handle  WatchPug   # Vulnerability details  The checks in the for loop can be changed to `else if` to save gas and make sure `msg.sender != sigAssessor`.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L616-L649  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             }             if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             "FSDNetwork::_isApprovedByAssessors: Not an Assessor"         );         require(             msg.sender != sigAssessor,             "FSDNetwork::_isApprovedByAssessors: Cannot be the single Assessor"         );          return true;     } ```   ### Recommendation  Change to:  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             } else if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             "FSDNetwork::_isApprovedByAssessors: Not an Assessor"         );          return true;     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L482-L495  ```solidity=482 function setAssessors(address[] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             "FSDNetwork::setAssessors: Insufficient Privileges"         );          uint256 assessorsLength = _assessors.length;         require(             assessorsLength == 3,             "FSDNetwork::setAssessors: Number of assessors must be three"         );          assessors = _assessors;     } ```  ### Recommendation  Change to:  ```solidity=482 function setAssessors(address[3] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             "FSDNetwork::setAssessors: Insufficient Privileges"         );          assessors = _assessors;     } ```  
# Handle  WatchPug   # Vulnerability details  The check if `_wallets.length <= 2` is redundant as the length of `_wallets` parameter must be 2.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L520-L533  ```solidity=520 function setMembershipWallets(address[2] calldata _wallets) external {     //todo internal     require(         membership[msg.sender].wallets[0] == address(0) &&             membership[msg.sender].wallets[1] == address(0),         "FSDNetwork::setMembershipWallets: Cannot have more than three wallets per membership"     );     require(         _wallets.length <= 2,         "FSDNetwork::setMembershipWallets: Too many wallets"     );     membership[msg.sender].wallets = _wallets; } ```  ### Recommendation  Remove the redundant check.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L310-L315  ```solidity=310 // 20% as staking rewards fsd.safeTransfer(address(fsd), stakingRewards); fsd.addRegistrationTribute(stakingRewards);  // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards); ```  The 2 transfers to the same address can be done in one external call to save gas  ### Recommendation  Change to:  ```solidity=310 // 20% as staking rewards // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards + stakingRewards); fsd.addRegistrationTribute(stakingRewards); ```  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/ABC.sol#L53 https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L521  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  
# Handle  rfa   # Vulnerability details  ## Impact When you are reading a value from a storage and using a storage pointer instead of memory, you write directly to the storage instead of the memory.  In the https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234 this line is reading membership[msg.sender] with a storage pointer,  this means any changes to the user variable, is updating directly to the membership[msg.sender],  therefore https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 this line update, makes it useless since the data already written to the membership[msg.sender]  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234-L294   ## Tools Used  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 membership[msg.sender] = user;  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Tracing the function calls, the `_start` parameter in `initiateVesting()` will always be `block.timestamp`. Hence, this input parameter can be removed from the function.  ## Recommended Mitigation Steps  ```jsx // TODO: Modify relevant function calls function initiateVesting(   address _beneficiary,   uint256 _amount ) external onlyFactory {  require(     start == 0,     "FSDVesting::initiateVesting: Vesting is already initialized"   );  beneficiary = _beneficiary;  start = block.timestamp;  amount = _amount; } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  1. The `_user` input in `updateVestedTokens()` is redundant because each user will have at most 1 vesting contract, and this function should be restricted to the FSD token contract only (kindly refer to related submitted issue), which stores and retrieves the mapping of users to vesting contracts. 2. The zero amount check is redundant because it is already checked in `FSD._createVesting()`.  ## Recommended Mitigation Steps  ```jsx /** * @dev Allows a vesting beneficiary to extend their vested token amount. */ function updateVestedTokens(uint256 _amount)   external   override  onlyFsd {   amount = amount.add(_amount); } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  `DURATION.sub(CLIFF)` is calculated in `calculateVestingClaim()`. Since both are constants, it would be better to define a new constant `LINEAR_VEST_AFTER_CLIFF` that refers to the vest duration after the cliff.  ## Recommended Mitigation Steps  `uint256 private constant LINEAR_VEST_AFTER_CLIFF = 18 * ONE_MONTH;`  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Since the defined constants are unneeded elsewhere, it can be defined to be `internal` or `private` to save gas.  ## Recommended Mitigation Steps  ```jsx // One month in seconds uint256 internal constant ONE_MONTH = 30 days; // Cliff period for a vest uint256 internal constant CLIFF = 12 * ONE_MONTH; // Duration of a vest uint256 internal constant DURATION = 30 * ONE_MONTH; ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The claiming of staking and governance tributes for the a beneficiary's vested tokens should be no different than other users / EOAs. However, the `claimTribute()` and `claimGovernanceTribute()` are missing the actual claiming calls to the corresponding functions of the FSD token contract. As a result, the accrued rewards are taken from the beneficiary's vested token while not claiming (replenishing) from the FSD token contract.  ## Recommended Mitigation Steps  In addition to what has been mentioned above, the internal accounting for claimedTribute states can be removed because they are already performed in the FSD token contract.  ```jsx // TODO: Remove _claimedTribute and _claimedGovernanceTribute mappings  /** * @dev Allows claiming of staking tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimTribute(uint256 num) external onlyBeneficiary {     uint256 tribute = fsd.availableTribute(num);     require(tribute != 0, "FSDVesting::claimTribute: No tribute to claim");   fsd.claimTribute(num);     fsd.safeTransfer(msg.sender, tribute);     emit TributeClaimed(msg.sender, tribute); }  /** * @dev Allows claiming of governance tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimGovernanceTribute(uint256 num) external onlyBeneficiary {   uint256 tribute = fsd.availableGovernanceTribute(num);   require(     tribute != 0,     "FSDVesting::claimGovernanceTribute: No governance tribute to claim"   );   fsd.claimGovernanceTribute(num);   fsd.safeTransfer(msg.sender, tribute);   emit GovernanceTributeClaimed(msg.sender, tribute); } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The comment for the `disableOffchainVoting()` function specifies that the feature can be reenabled in the future through a proposal. But, there seems to be no function to do that in the DAO contract.  ## Proof of Concept Function with the comment: https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dao/FairSideDAO.sol#L619  No way to reassign the value: `grep offchain`  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Either remove the comment if the feature is not intended or add a function to reassign the `offchain` and `guardian` state variable  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs  ## Proof of Concept  In a number of places a `keccak("string")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dao/FairSideDAO.sol#L43-L49  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: https://github.com/ethereum/solidity/issues/9232  ## Recommended Mitigation Steps  Change all `constant` hashes to be `immutable`  
# Handle  leastwood   # Vulnerability details  ## Impact  The `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.  There are two main reasons as to why the beneficiary or an attacker would want to call this function: - To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration. - An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134  ## Tools Used  Manual code review. Discussions with dev.  ## Recommended Mitigation Steps  Ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.  
# Handle  ye0lde   # Vulnerability details  ## Impact  None/Code clarity  ## Proof of Concept  "is" to "in"   https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L347  "the" not needed https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/timelock/Timelock.sol#L16  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the typos.  
# Handle  hyh   # Vulnerability details  ## Impact  As funding pool should be filled with Hatch phase deposits, the phase advance should happen only after it is filled, but when this happen the minting in Beta phase would be frozen by 'fundingPool.balance < 2000 ether' condition. As mintBeta is the only logic for Beta phase the contract will be frozen until phase change.  If there is a setup when Hatch phase advances to Beta before funding pool is filled, mintBeta will work only while it has below 2000 ether, i.e. mintBeta behavior will not be controlled explicitly: anyone can end the Beta phase by sending enough ether directly to funding pool and the contract mint will be frozen until next phase advance.   ## Proof of Concept  'fundingPool.balance < 2000 ether' condition for minting in Beta phase can be blocking as funding pool transfers happen only in mintHatch function during Hatch phase, while subsequent phases do not have any funding pool related logic neither in code, nor in documentation. https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSD.sol#L204 https://fairside-network.gitbook.io/fairside-network/white-paper/augmented-bonding-curve  ## Recommended Mitigation Steps  Remove 'fundingPool.balance < 2000 ether' condition from mintBeta  
# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Finding ```  contracts/token/FSD.sol:174: require(bonded > 0, "FSD::mintHatch: Insufficient Deposit"); ``` On L170, we check whether `bonded` is bigger than 5 ETH. After multiplying with `HATCH_CURVE_RATIO`, it is still over 0. Therefore, it is a tautology and not needed.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  Manual analysis  
# Handle  cmichel   # Vulnerability details  The `FSD.claimGovernanceTribute` function first performs the expensive `getPriorConvictionScore` instead of the cheap `isGovernance[msg.sender]` check.  ```solidity function claimGovernanceTribute(uint256 num) external {     require(         governanceThreshold <=             getPriorConvictionScore(                 msg.sender,                 governanceTributes[num].blockNumber             ) &&             // @audit gas: rearrange this to be first for short circuiting             isGovernance[msg.sender],         "FSD::claimGovernanceTribute: Not a governance member"     );     _claimGovernanceTribute(num); } ```  Reordering the conditions to first do the cheap governance check would allow this function to short-circuit if the user is not a governor, which will save gas on average. The last assignment `membership[msg.sender] = user;` is not required.   
# Handle  cmichel   # Vulnerability details  In `ERC20ConvictionScore._writeCheckpoint`, when the checkpoint is overwritten (`checkpoint.fromBlock == blockNumber`), the new value is set to the `memory checkpoint` structure and never written to storage.  ```solidity // @audit this is MEMORY, setting new convictionScore doesn't write to storage Checkpoint memory checkpoint = checkpoints[user][nCheckpoints - 1];  if (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {     checkpoint.convictionScore = newCS; } ```  Users that have their conviction score updated several times in the same block will only have their first score persisted.  #### POC - User updates their conviction with `updateConvictionScore(user)` - **In the same block**, the user now redeems an NFT conviction using `acquireConviction(id)`. This calls `_increaseConvictionScore(user, amount)` which calls `_writeCheckpoint(..., prevConvictionScore + amount)`. The updated checkpoint is **not** written to storage, and the user lost their conviction NFT. (The conviction/governance totals might still be updated though, leading to a discrepancy.)  ## Impact Users that have their conviction score updated several times in the same block will only have their first score persisted.  This also applies to the total conviction scores `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` (see `_updateConvictionTotals`) which is a big issue as these are updated a lot of times each block.  It can also be used for inflating a user's conviction by first calling `updateConvictionScore` and then creating conviction tokens with `tokenizeConviction`. The `_resetConviction` will not actually reset the user's conviction.  ## Recommended Mitigation Steps Define the `checkpoint` variable as a `storage` pointer:  ```solidity Checkpoint storage checkpoint = checkpoints[user][nCheckpoints - 1]; ```  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, especially in for loops, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dependencies/TributeAccrual.sol#L77-L88  ```solidity=77     function totalAvailableTribute(uint256 offset)         external         view         override         returns (uint256 total)     {         for (uint256 i = offset; i < totalTributes; i++)             total = total.add(availableTribute(i));          for (uint256 i = offset; i < totalGovernanceTributes; i++)             total = total.add(availableGovernanceTribute(i));     } ```  `totalTributes` and `totalGovernanceTributes` can be cached.  
# Handle  WatchPug   # Vulnerability details  Based on the context, once the beneficiary claimed all their vesting tokens, they should get the `fairSideConviction` NFT.  However, in the current implementation, if the beneficiary has claimed any amounts before it's fully vested, then they will never be able to get the `fairSideConviction` NFT, because at L138, it requires the `tokenbClaim` to be equal to the initial vesting amount.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/FSDVesting.sol#L124-L142  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         "FSDVesting::claimVestedTokens: Zero claimable tokens"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == tokenClaim) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  ### Recommendation  Change to:  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         "FSDVesting::claimVestedTokens: Zero claimable tokens"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == totalClaimed) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L274-L291  ```solidity=274 if (user.creation == 0) {     user.creation = block.timestamp;     user.gracePeriod =         membership[msg.sender].creation +         MEMBERSHIP_DURATION +         60 days; } else {     uint256 elapsedDurationPercentage = ((block.timestamp -         user.creation) * 1 ether) / MEMBERSHIP_DURATION;     if (elapsedDurationPercentage < 1 ether) {         uint256 durationIncrease = (costShareBenefit.mul(1 ether) /             (totalCostShareBenefit - costShareBenefit)).mul(                 MEMBERSHIP_DURATION             ) / 1 ether;         user.creation += durationIncrease;         user.gracePeriod += durationIncrease;     } } ```  ### PoC  1. Alice calls `function purchaseMembership()` and adds 20 ether of `costShareBenefit` on day 1:  ``` alice.creation = day 1 timestamp; alice.gracePeriod = day 791 timestamp; ```  2. Alice calls `function purchaseMembership()` again and adds 20 ether of `costShareBenefit` on day 2:  ``` elapsedDurationPercentage = 1/720 durationIncrease = 730 day  alice.creation = day 731 timestamp; alice.gracePeriod = day 1521 timestamp; ```  Making Alice unable to use any membership features until two years later.  
# Handle  WatchPug   # Vulnerability details  The checks in the for loop can be changed to `else if` to save gas and make sure `msg.sender != sigAssessor`.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L616-L649  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             }             if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             "FSDNetwork::_isApprovedByAssessors: Not an Assessor"         );         require(             msg.sender != sigAssessor,             "FSDNetwork::_isApprovedByAssessors: Cannot be the single Assessor"         );          return true;     } ```   ### Recommendation  Change to:  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             } else if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             "FSDNetwork::_isApprovedByAssessors: Not an Assessor"         );          return true;     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L482-L495  ```solidity=482 function setAssessors(address[] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             "FSDNetwork::setAssessors: Insufficient Privileges"         );          uint256 assessorsLength = _assessors.length;         require(             assessorsLength == 3,             "FSDNetwork::setAssessors: Number of assessors must be three"         );          assessors = _assessors;     } ```  ### Recommendation  Change to:  ```solidity=482 function setAssessors(address[3] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             "FSDNetwork::setAssessors: Insufficient Privileges"         );          assessors = _assessors;     } ```  
# Handle  WatchPug   # Vulnerability details  The check if `_wallets.length <= 2` is redundant as the length of `_wallets` parameter must be 2.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L520-L533  ```solidity=520 function setMembershipWallets(address[2] calldata _wallets) external {     //todo internal     require(         membership[msg.sender].wallets[0] == address(0) &&             membership[msg.sender].wallets[1] == address(0),         "FSDNetwork::setMembershipWallets: Cannot have more than three wallets per membership"     );     require(         _wallets.length <= 2,         "FSDNetwork::setMembershipWallets: Too many wallets"     );     membership[msg.sender].wallets = _wallets; } ```  ### Recommendation  Remove the redundant check.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L310-L315  ```solidity=310 // 20% as staking rewards fsd.safeTransfer(address(fsd), stakingRewards); fsd.addRegistrationTribute(stakingRewards);  // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards); ```  The 2 transfers to the same address can be done in one external call to save gas  ### Recommendation  Change to:  ```solidity=310 // 20% as staking rewards // 7.5% towards governance fsd.safeTransfer(address(fsd), governancePoolRewards + stakingRewards); fsd.addRegistrationTribute(stakingRewards); ```  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/ABC.sol#L53 https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L521  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  
# Handle  rfa   # Vulnerability details  ## Impact When you are reading a value from a storage and using a storage pointer instead of memory, you write directly to the storage instead of the memory.  In the https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234 this line is reading membership[msg.sender] with a storage pointer,  this means any changes to the user variable, is updating directly to the membership[msg.sender],  therefore https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 this line update, makes it useless since the data already written to the membership[msg.sender]  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234-L294   ## Tools Used  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 membership[msg.sender] = user;  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Tracing the function calls, the `_start` parameter in `initiateVesting()` will always be `block.timestamp`. Hence, this input parameter can be removed from the function.  ## Recommended Mitigation Steps  ```jsx // TODO: Modify relevant function calls function initiateVesting(   address _beneficiary,   uint256 _amount ) external onlyFactory {  require(     start == 0,     "FSDVesting::initiateVesting: Vesting is already initialized"   );  beneficiary = _beneficiary;  start = block.timestamp;  amount = _amount; } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  1. The `_user` input in `updateVestedTokens()` is redundant because each user will have at most 1 vesting contract, and this function should be restricted to the FSD token contract only (kindly refer to related submitted issue), which stores and retrieves the mapping of users to vesting contracts. 2. The zero amount check is redundant because it is already checked in `FSD._createVesting()`.  ## Recommended Mitigation Steps  ```jsx /** * @dev Allows a vesting beneficiary to extend their vested token amount. */ function updateVestedTokens(uint256 _amount)   external   override  onlyFsd {   amount = amount.add(_amount); } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  `DURATION.sub(CLIFF)` is calculated in `calculateVestingClaim()`. Since both are constants, it would be better to define a new constant `LINEAR_VEST_AFTER_CLIFF` that refers to the vest duration after the cliff.  ## Recommended Mitigation Steps  `uint256 private constant LINEAR_VEST_AFTER_CLIFF = 18 * ONE_MONTH;`  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Since the defined constants are unneeded elsewhere, it can be defined to be `internal` or `private` to save gas.  ## Recommended Mitigation Steps  ```jsx // One month in seconds uint256 internal constant ONE_MONTH = 30 days; // Cliff period for a vest uint256 internal constant CLIFF = 12 * ONE_MONTH; // Duration of a vest uint256 internal constant DURATION = 30 * ONE_MONTH; ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The claiming of staking and governance tributes for the a beneficiary's vested tokens should be no different than other users / EOAs. However, the `claimTribute()` and `claimGovernanceTribute()` are missing the actual claiming calls to the corresponding functions of the FSD token contract. As a result, the accrued rewards are taken from the beneficiary's vested token while not claiming (replenishing) from the FSD token contract.  ## Recommended Mitigation Steps  In addition to what has been mentioned above, the internal accounting for claimedTribute states can be removed because they are already performed in the FSD token contract.  ```jsx // TODO: Remove _claimedTribute and _claimedGovernanceTribute mappings  /** * @dev Allows claiming of staking tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimTribute(uint256 num) external onlyBeneficiary {     uint256 tribute = fsd.availableTribute(num);     require(tribute != 0, "FSDVesting::claimTribute: No tribute to claim");   fsd.claimTribute(num);     fsd.safeTransfer(msg.sender, tribute);     emit TributeClaimed(msg.sender, tribute); }  /** * @dev Allows claiming of governance tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimGovernanceTribute(uint256 num) external onlyBeneficiary {   uint256 tribute = fsd.availableGovernanceTribute(num);   require(     tribute != 0,     "FSDVesting::claimGovernanceTribute: No governance tribute to claim"   );   fsd.claimGovernanceTribute(num);   fsd.safeTransfer(msg.sender, tribute);   emit GovernanceTributeClaimed(msg.sender, tribute); } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The comment for the `disableOffchainVoting()` function specifies that the feature can be reenabled in the future through a proposal. But, there seems to be no function to do that in the DAO contract.  ## Proof of Concept Function with the comment: https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dao/FairSideDAO.sol#L619  No way to reassign the value: `grep offchain`  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Either remove the comment if the feature is not intended or add a function to reassign the `offchain` and `guardian` state variable  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs  ## Proof of Concept  In a number of places a `keccak("string")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dao/FairSideDAO.sol#L43-L49  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: https://github.com/ethereum/solidity/issues/9232  ## Recommended Mitigation Steps  Change all `constant` hashes to be `immutable`  
