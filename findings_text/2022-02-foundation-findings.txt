# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L263-L292 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L125-L141   # Vulnerability details  ## Impact  The `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider invalidating the buy offer before account migration.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCreators.sol#L49-L251   # Vulnerability details  ## Impact  The `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a `try` statement, the revert is actually not handled and it will not fall through to the empty `catch` statement.  ## Proof of Concept  The end result is that valid and honest NFT contracts may revert if the call runs out of gas due to an unbounded `_recipients` array. `try` statements are only able to handle external calls.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L143-L150   # Vulnerability details  ## Impact  The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L255-L271 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L557 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L510-L515 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketFees.sol#L188-L189   # Vulnerability details  ## Impact  Once an auction has ended, the highest bidder now has sole rights to the underlying NFT. By finalizing the auction, fees are charged on the sale and the NFT is transferred to `auction.bidder`. However, if `auction.bidder` accepts an offer before finalization, fees will be charged on the `auction.bidder` sale before the original sale. As a result, it is possible to avoid paying the primary foundation fee as a creator if the NFT is sold by `auction.bidder` before finalization.  ## Proof of Concept  Consider the following scenario: - Alice creates an auction and is the NFT creator. - Bob bids on the auction and is the highest bidder. - The auction ends but Alice leaves it in an unfinalized state. - Carol makes an offer on the NFT which Bob accepts. - `_acceptOffer()` will distribute funds on the sale between Bob and Carol before distributing funds on the sale between Alice and Bob. - The first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true, meaning that future sales will only be charged the secondary foundation fee.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked. It might be useful to ensure the distribution of funds are in the order of when the trades occurred. For example, an unfinalized auction should always have its fees paid before other sales.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123-L174   # Vulnerability details  ## Impact Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call `#buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.   The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.   ## Proof of Concept  Consider the following example:  1. Joe the NFT owner sells a NFT to the malicious buyer Rachel via a private sale.  2. Rachel through this private sale obtains the EIP-712 signature and uses it to purchase a NFT. 3. Joe the NFT owner purchases back the NFT within two days of the original sale to Rachel. 4. Joe the NFT owner puts the NFT back on sale. 5. Rachel, who has the original EIP-712 signature, can re-purchase the NFT by calling `#buyFromPrivateSaleFor` again with the same parameters they provided in the original private sale purchase in step 1.  The `#buyFromPrivateSaleFor` [function](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123) runs several validation checks before transferring the NFT over to the buyer. The validations are as follows:  1. L#132 - The signature has expired. 2. L#135 - The deadline is beyond 48 hours from now. 3. L#143 - The amount argument is greater than msg.value. 4. L#149 - The msg.value is greater than the amount set. 5. L#171 - This checks that the EIP-712 signature comes from the NFT seller.  As you can see, there are no checks that the EIP-712 signature has been used before. If the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction.  ## Tools Used Pen and paper  ## Recommended Mitigation Steps Most contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87   # Vulnerability details     ## Impact  If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.  I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.  This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.  ## Proof of Concept  An attacker can make a tiny offer with `makeOffer`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189  Then call `acceptOffer`, which will lead to `_acceptOffer`.  Direct NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  `_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order: ``` function _transferFromEscrow( ... ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {    super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  If there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87  This will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.  ## Recommended Mitigation Steps  Consider adding additional checks to control who can obtain unallocated NFTs from the contract.  Protocol controlled entity can handle such cases manually by initial sender's request.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560   # Vulnerability details   ## Impact  An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.  This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.  ## Proof of Concept  When an auction has ended, there is a possibility to make the offers for an auctioned NFT as:  `makeOffer` checks `_isInActiveAuction`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200  `_isInActiveAuction` returns false when `auctionIdToAuction[auctionId].endTime < block.timestamp`, so `makeOffer` above can proceed:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669  Then, the auction winner can call `acceptOffer -> _acceptOffer` (or `setBuyPrice -> _autoAcceptOffer -> _acceptOffer`).  `_acceptOffer` will try to transfer directly, and then calls `_transferFromEscrow`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  If the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with `_transferFromEscrow` in the FNDNFTMarket defined order: ``` function _transferFromEscrow( address nftContract, uint256 tokenId, address recipient, address seller ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) { super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  NFTMarketOffer._transferFromEscrow will call super as `nftContractToIdToOffer` was already deleted:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302  NFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293  Finally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560  The `recipient` user who made the offer is not present in this logic, the NFT is being transferred to the `auction.bidder`, and the original `acceptOffer` will go through successfully.  ## Recommended Mitigation Steps  An attempt to set a buy price from auction winner will lead to auction finalisation, so `_buy` cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270  is the only user of   https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560   This way the fix is to update L556-L560 for the described case as:  Now: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, false);  // Finalize includes the transfer, so we are done here. return; ```  To be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, true); ```  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L433   # Vulnerability details  ## Impact The `FETH.withdrawFrom` function does not validate its `to` parameter. Funds can be lost if `to` is the zero address.  > Similar issues have been judged as medium recently, see [Sandclock M-15](https://code4rena.com/reports/2022-01-sandclock/) / [Github issue](https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171)  ## Recommended Mitigation Steps Check that `to != 0`.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99   # Vulnerability details  According to the `README.md` > All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21  Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.  ## Impact By updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.  ## Proof of Concept ```solidity           // 4th priority: getRoyalties override           if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {             try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (               address payable[] memory _recipients,               uint256[] memory recipientBasisPoints             ) {               if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {                 bool hasRecipient;                 for (uint256 i = 0; i < _recipients.length; ++i) {                   if (_recipients[i] != address(0)) {                     hasRecipient = true;                     if (_recipients[i] == seller) {                       return (_recipients, recipientBasisPoints, true); ``` https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154  When `true` is returned as the final return value above, the following code leaves `ownerRev` as zero because `isCreator` is `true` ```solidity       uint256 ownerRev     )   {     bool isCreator;     (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);      // Calculate the Foundation fee     uint256 fee;     if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {       fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;     } else {       fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;     }      foundationFee = (price * fee) / BASIS_POINTS;      if (creatorRecipients.length > 0) {       if (isCreator) {         // When sold by the creator, all revenue is split if applicable.         creatorRev = price - foundationFee;       } else {         // Rounding favors the owner first, then creator, and foundation last.         creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;         ownerRevTo = seller;         ownerRev = price - foundationFee - creatorRev;       }     } else {       // No royalty recipients found.       ownerRevTo = seller;       ownerRev = price - foundationFee;     }   } ```  In addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, then the seller is omitted from the calculation and gets zero (`_sendValueWithFallbackWithdraw()` doesn't complain when it sends zero) ```solidity         uint256 maxCreatorIndex = creatorRecipients.length - 1;         if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {           maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;         } ``` https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79  This issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in `_getCreatorPaymentInfo()` that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator - creators can be bribed with kickbacks.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always calculate owner/seller revenue separately from royalty revenue   
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L325-L349 https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L596-L599   # Vulnerability details  # Impact NFT owner can permanently lock funds of bidders.   # Proof of concept  Alice (the attacker) calls `createReserveAuction`, and creates one like normal. let this be auction id 1.  Alice calls `createReserveAuction` again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because `_transferToEscrow` doesn't revert if there's an existing auction. let this be Auction id 2.  Since `nftContractToTokenIdToAuctionId[nftContract][tokenId]` will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).  Alice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.  # Mitigation Prevent NFT owners from creating multiple auctions  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77   # Vulnerability details  ## Impact The NFTMarketFees contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.  ```   function _sendValueWithFallbackWithdraw(     address payable user,     uint256 amount,     uint256 gasLimit   ) internal {     if (amount == 0) {       return;     }     // Cap the gas to prevent consuming all available gas to block a tx from completing successfully     // solhint-disable-next-line avoid-low-level-calls     (bool success, ) = user.call{ value: amount, gas: gasLimit }("");     if (!success) {       // Record failed sends for a withdrawal later       // Transfers could fail if sent to a multisig with non-trivial receiver logic       unchecked {         pendingWithdrawals[user] += amount;       }       emit WithdrawPending(user, amount);     }   } ``` The user can then withdraw ether via the withdraw or withdrawFor functions. ```   function withdraw() external {     withdrawFor(payable(msg.sender));   }   function withdrawFor(address payable user) public nonReentrant {     uint256 amount = pendingWithdrawals[user];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[user] = 0;     user.sendValue(amount);     emit Withdrawal(user, amount);   } ``` However, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals. When the recipient is a contract that cannot receive ether, these ethers will be locked in the contract and cannot be withdrawn. ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77 ## Tools Used None ## Recommended Mitigation Steps Add the withdrawTo function as follows:  ```   function withdrawTo(address payable to) public nonReentrant {     uint256 amount = pendingWithdrawals[msg.sneder];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[msg.sneder] = 0;     to.sendValue(amount);     emit Withdrawal(msg.sneder, amount);   } ```  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150   # Vulnerability details  ## Impact In NFTMarketOffer.sol the adminCancelOffers() function has comments above it that mention   "tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`"  This means that both the tokensIds and nftContracts arrays must be the same length but this is not required in the code of the function itself which can lead to the function failing.   ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add to adminCancelOffers() function:   require(nftContracts.length == tokenIds.length, Arrays must be same length");  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L263-L292 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L125-L141   # Vulnerability details  ## Impact  The `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider invalidating the buy offer before account migration.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCreators.sol#L49-L251   # Vulnerability details  ## Impact  The `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a `try` statement, the revert is actually not handled and it will not fall through to the empty `catch` statement.  ## Proof of Concept  The end result is that valid and honest NFT contracts may revert if the call runs out of gas due to an unbounded `_recipients` array. `try` statements are only able to handle external calls.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L143-L150   # Vulnerability details  ## Impact  The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L255-L271 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L557 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L510-L515 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketFees.sol#L188-L189   # Vulnerability details  ## Impact  Once an auction has ended, the highest bidder now has sole rights to the underlying NFT. By finalizing the auction, fees are charged on the sale and the NFT is transferred to `auction.bidder`. However, if `auction.bidder` accepts an offer before finalization, fees will be charged on the `auction.bidder` sale before the original sale. As a result, it is possible to avoid paying the primary foundation fee as a creator if the NFT is sold by `auction.bidder` before finalization.  ## Proof of Concept  Consider the following scenario: - Alice creates an auction and is the NFT creator. - Bob bids on the auction and is the highest bidder. - The auction ends but Alice leaves it in an unfinalized state. - Carol makes an offer on the NFT which Bob accepts. - `_acceptOffer()` will distribute funds on the sale between Bob and Carol before distributing funds on the sale between Alice and Bob. - The first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true, meaning that future sales will only be charged the secondary foundation fee.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked. It might be useful to ensure the distribution of funds are in the order of when the trades occurred. For example, an unfinalized auction should always have its fees paid before other sales.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123-L174   # Vulnerability details  ## Impact Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call `#buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.   The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.   ## Proof of Concept  Consider the following example:  1. Joe the NFT owner sells a NFT to the malicious buyer Rachel via a private sale.  2. Rachel through this private sale obtains the EIP-712 signature and uses it to purchase a NFT. 3. Joe the NFT owner purchases back the NFT within two days of the original sale to Rachel. 4. Joe the NFT owner puts the NFT back on sale. 5. Rachel, who has the original EIP-712 signature, can re-purchase the NFT by calling `#buyFromPrivateSaleFor` again with the same parameters they provided in the original private sale purchase in step 1.  The `#buyFromPrivateSaleFor` [function](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123) runs several validation checks before transferring the NFT over to the buyer. The validations are as follows:  1. L#132 - The signature has expired. 2. L#135 - The deadline is beyond 48 hours from now. 3. L#143 - The amount argument is greater than msg.value. 4. L#149 - The msg.value is greater than the amount set. 5. L#171 - This checks that the EIP-712 signature comes from the NFT seller.  As you can see, there are no checks that the EIP-712 signature has been used before. If the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction.  ## Tools Used Pen and paper  ## Recommended Mitigation Steps Most contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87   # Vulnerability details     ## Impact  If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.  I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.  This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.  ## Proof of Concept  An attacker can make a tiny offer with `makeOffer`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189  Then call `acceptOffer`, which will lead to `_acceptOffer`.  Direct NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  `_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order: ``` function _transferFromEscrow( ... ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {    super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  If there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87  This will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.  ## Recommended Mitigation Steps  Consider adding additional checks to control who can obtain unallocated NFTs from the contract.  Protocol controlled entity can handle such cases manually by initial sender's request.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560   # Vulnerability details   ## Impact  An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.  This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.  ## Proof of Concept  When an auction has ended, there is a possibility to make the offers for an auctioned NFT as:  `makeOffer` checks `_isInActiveAuction`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200  `_isInActiveAuction` returns false when `auctionIdToAuction[auctionId].endTime < block.timestamp`, so `makeOffer` above can proceed:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669  Then, the auction winner can call `acceptOffer -> _acceptOffer` (or `setBuyPrice -> _autoAcceptOffer -> _acceptOffer`).  `_acceptOffer` will try to transfer directly, and then calls `_transferFromEscrow`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  If the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with `_transferFromEscrow` in the FNDNFTMarket defined order: ``` function _transferFromEscrow( address nftContract, uint256 tokenId, address recipient, address seller ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) { super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  NFTMarketOffer._transferFromEscrow will call super as `nftContractToIdToOffer` was already deleted:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302  NFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293  Finally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560  The `recipient` user who made the offer is not present in this logic, the NFT is being transferred to the `auction.bidder`, and the original `acceptOffer` will go through successfully.  ## Recommended Mitigation Steps  An attempt to set a buy price from auction winner will lead to auction finalisation, so `_buy` cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270  is the only user of   https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560   This way the fix is to update L556-L560 for the described case as:  Now: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, false);  // Finalize includes the transfer, so we are done here. return; ```  To be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, true); ```  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L433   # Vulnerability details  ## Impact The `FETH.withdrawFrom` function does not validate its `to` parameter. Funds can be lost if `to` is the zero address.  > Similar issues have been judged as medium recently, see [Sandclock M-15](https://code4rena.com/reports/2022-01-sandclock/) / [Github issue](https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171)  ## Recommended Mitigation Steps Check that `to != 0`.  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99   # Vulnerability details  According to the `README.md` > All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21  Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.  ## Impact By updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.  ## Proof of Concept ```solidity           // 4th priority: getRoyalties override           if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {             try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (               address payable[] memory _recipients,               uint256[] memory recipientBasisPoints             ) {               if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {                 bool hasRecipient;                 for (uint256 i = 0; i < _recipients.length; ++i) {                   if (_recipients[i] != address(0)) {                     hasRecipient = true;                     if (_recipients[i] == seller) {                       return (_recipients, recipientBasisPoints, true); ``` https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154  When `true` is returned as the final return value above, the following code leaves `ownerRev` as zero because `isCreator` is `true` ```solidity       uint256 ownerRev     )   {     bool isCreator;     (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);      // Calculate the Foundation fee     uint256 fee;     if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {       fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;     } else {       fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;     }      foundationFee = (price * fee) / BASIS_POINTS;      if (creatorRecipients.length > 0) {       if (isCreator) {         // When sold by the creator, all revenue is split if applicable.         creatorRev = price - foundationFee;       } else {         // Rounding favors the owner first, then creator, and foundation last.         creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;         ownerRevTo = seller;         ownerRev = price - foundationFee - creatorRev;       }     } else {       // No royalty recipients found.       ownerRevTo = seller;       ownerRev = price - foundationFee;     }   } ```  In addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, then the seller is omitted from the calculation and gets zero (`_sendValueWithFallbackWithdraw()` doesn't complain when it sends zero) ```solidity         uint256 maxCreatorIndex = creatorRecipients.length - 1;         if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {           maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;         } ``` https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79  This issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in `_getCreatorPaymentInfo()` that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator - creators can be bribed with kickbacks.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always calculate owner/seller revenue separately from royalty revenue   
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L325-L349 https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L596-L599   # Vulnerability details  # Impact NFT owner can permanently lock funds of bidders.   # Proof of concept  Alice (the attacker) calls `createReserveAuction`, and creates one like normal. let this be auction id 1.  Alice calls `createReserveAuction` again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because `_transferToEscrow` doesn't revert if there's an existing auction. let this be Auction id 2.  Since `nftContractToTokenIdToAuctionId[nftContract][tokenId]` will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).  Alice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.  # Mitigation Prevent NFT owners from creating multiple auctions  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77   # Vulnerability details  ## Impact The NFTMarketFees contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.  ```   function _sendValueWithFallbackWithdraw(     address payable user,     uint256 amount,     uint256 gasLimit   ) internal {     if (amount == 0) {       return;     }     // Cap the gas to prevent consuming all available gas to block a tx from completing successfully     // solhint-disable-next-line avoid-low-level-calls     (bool success, ) = user.call{ value: amount, gas: gasLimit }("");     if (!success) {       // Record failed sends for a withdrawal later       // Transfers could fail if sent to a multisig with non-trivial receiver logic       unchecked {         pendingWithdrawals[user] += amount;       }       emit WithdrawPending(user, amount);     }   } ``` The user can then withdraw ether via the withdraw or withdrawFor functions. ```   function withdraw() external {     withdrawFor(payable(msg.sender));   }   function withdrawFor(address payable user) public nonReentrant {     uint256 amount = pendingWithdrawals[user];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[user] = 0;     user.sendValue(amount);     emit Withdrawal(user, amount);   } ``` However, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals. When the recipient is a contract that cannot receive ether, these ethers will be locked in the contract and cannot be withdrawn. ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77 ## Tools Used None ## Recommended Mitigation Steps Add the withdrawTo function as follows:  ```   function withdrawTo(address payable to) public nonReentrant {     uint256 amount = pendingWithdrawals[msg.sneder];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[msg.sneder] = 0;     to.sendValue(amount);     emit Withdrawal(msg.sneder, amount);   } ```  
# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150   # Vulnerability details  ## Impact In NFTMarketOffer.sol the adminCancelOffers() function has comments above it that mention   "tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`"  This means that both the tokensIds and nftContracts arrays must be the same length but this is not required in the code of the function itself which can lead to the function failing.   ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add to adminCancelOffers() function:   require(nftContracts.length == tokenIds.length, Arrays must be same length");  
