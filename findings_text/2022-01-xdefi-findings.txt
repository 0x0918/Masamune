# Handle  0xsanson   # Vulnerability details  Not an issue.  I noticed that the `merge` function doesn't have an event associated with it. Depending on the kind of offchain analysis/tools you will end up using, an event here may turn up useful to know which NFTs got merged together into a new one.  ## Recommended Mitigation Steps Add an event which contains `uint256[] memory tokenIds_` and `tokenId_`.  
# Handle  Czar102   # Vulnerability details  ## Impact  Proper event declaration eases off-chain monitoring.  ## Proof of Concept  In the case of qualitative variables, it is recommended to use `indexed` keyword.  Despite the `uint duration` argument seems to be a quantitative one, it is limited to few values, which specify the "locking mode".  ## Recommended Mitigation Steps  `uint duration` variable should be considered qualitative and be marked `indexed` in the following events: ``` event LockPeriodSet(uint256 duration, uint8 bonusMultiplier); event LockPositionCreated(uint256 indexed tokenId, address indexed owner, uint256 amount, uint256 duration); ```   
# Handle  0xsanson   # Vulnerability details  ## Impact Throughout the code the safe functions `safeTransfer` and `safeTransferFrom` are used when dealing with XDEFI. Isn't this token a standard ERC20? I believe the normal ERC20 transfer functions can be used. The advantage is gaining some 100s gas otherwise spent in unneeded logic.  ## Proof of Concept grep safeT *.sol  ## Recommended Mitigation Steps Consider removing the SafeERC20 library.  
# Handle  Czar102   # Vulnerability details  ## Impact  An owner of the contract may, by ordering their or others' locking transactions, significantly increase or decrease `bonusMultiplier` for some set of transactions.  So, by mining a single block, an owner can lower other's bonus multipliers, execute locking transactions and then restore bonus multipliers.  A user might send a locking transaction in a similar time as an owner lowers the multipliers, resulting in lowering the revenue against data presented to the user.  An owner can also pass ownership to a contract that will change bonus multipliers and lock funds with a very high bonus multiplier, then restore previous multipliers' state not to let others do the same. This way, the owner can gain an unfair advantage over others.  ## Recommended Mitigation Steps  Use a timelock for `setLockPeriods(...)` function and require passing `bonusMultiplier` in locking functions, revert if they are different from the state variables.   
# Handle  defsec   # Vulnerability details  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L274 ```  ## Tools Used  None   ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  If a user locks funds in the contract, they can only withdraw funds by calling functions that in turn call the `_unlock()` function. The `_unlock()` function requires the position to have block.timestamp >= position.expiry. If there is a problem with the contract, with the XDEFI ERC20 token, or a user changes their mind and wants their funds back, they do not have this option. This can be more problematic with very long lock duration values.  ## Proof of Concept  There is a hard requirement that block.timestamp >= uint256(expiry) for any position before it can be unlocked and the funds released. All code paths that allow a use to withdraw their XDEFI rely on the `_unlock()` function:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L305  ## Recommended Mitigation Steps  Different options exist to assist users with this issue. One would be to keep lock duration values small, especially when the contract is first released to users. Another is to add an emergency withdrawal function that has the onlyOwner modifier, such as using OpenZeppelin's Pausable module: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol   
# Handle  sirhashalot   # Vulnerability details  ## Impact  There is a require statement that contains the comment "Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway." This comment is correct that the require statement is unnecessary and removing saves on gas during relock functions.  ## Proof of Concept  The unnecessary require statement is in the `relock()` and `relockBatch()` functions of XDEFIDistribution.sol: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L115 https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L170  ## Recommended Mitigation Steps  Remove the unnecessary require statement to save gas  
# Handle  Czar102   # Vulnerability details  ## Impact  Wrong revert messages might lead to confusion.  ## Proof of Concept  In line 52 of XDEFIDistribution, the reason for a fail of a reentrant call is `"LOCKED"`. In DeFi, it usually means that contract's functionality is temporarily limited. This is not true in this case.  ## Recommended Mitigation Steps  Consider changing the revert string to `"REENTRY_NOT_ALLOWED"`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151  ```solidity     _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached); ```  In the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.   A malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.  As a result, the contract can be malfunctioning and even freeze users' funds in edge cases.  ### PoC  Given:  - bonusMultiplierOf[30 days] = 100  1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`; 2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:  ```solidity     _pointsPerUnit += ((170141183460469 * 2**128) / 1); ```  3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows; 4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days; 5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:   ```solidity     _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1)); ```  6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.    ### Recomandation  Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.  The same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`    https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44  ```solidity constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721("Locked XDEFI", "lXDEFI") {         require((XDEFI = XDEFI_) != address(0), "INVALID_TOKEN");         owner = msg.sender;         baseURI = baseURI_;         _zeroDurationPointBase = zeroDurationPointBase_;          totalUnits = 100_000_000;     } ```  
# Handle  WatchPug   # Vulnerability details  Storage writes (`SSTORE`) to `distributableXDEFI` may not be needed when `previousDistributableXDEFI == currentDistributableXDEFI`, therefore the code can be reorganized to save gas from unnecessary storage writes.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L330-L336  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  ### Recommendation  Change to:  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      newFundsTokenBalance_ = _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);     if (newFundsTokenBalance_ != 0) {         distributableXDEFI = currentDistributableXDEFI;     } } ```  
# Handle  WatchPug   # Vulnerability details  `_zeroDurationPointBase` can be set at deploy time so that locks with 0 duration can get scores.  However, if the value of `_zeroDurationPointBase` is being set high enough. It can potentially be exploited by repeatedly lock(), and unlock() with 0 duration to get scores.  This can get amplified with flashloans.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L245-L247  ```solidity function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {     return amount_ * (duration_ + _zeroDurationPointBase); } ```  ## Recommendation  Consider changing `_zeroDurationPointBase` to a constant of value `1`.  
# Handle  Dravee   # Vulnerability details  ## Impact Code clarity / code style  ## Proof of Concept At the following places, the casts are implicit, whereas the project's style hints at explicit casts everywhere : https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L255 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L269 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L314  ## Tools Used VS Code  ## Recommended Mitigation Steps Use explicit casts everywhere for unsigned integers, as it's the practice everywhere else  
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check (XDEFIDistribution.sol line 255). using double require check can save more gas:   require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");  ## Tools Used  ## Recommended Mitigation Steps require(amount_ != uint256(0), "INVALID_AMOUNT" ); require(amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");  
# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L120-L125  ```solidity=120 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ```  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L175-L180  ```solidity=175 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ``` ### Recommendation  Change to:  ```solidity if (amountUnlocked_ > lockAmount_) {     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_ - lockAmount_); } ```  - Removed a local variable: `withdrawAmount`; - Only do the arithmetic when needed: `amountUnlocked_ - lockAmount_`.  
# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol lines 151, 338-344 Instead of multiplying by _pointsMultiplier, which is 2 ** 128, it is more efficient to shift by 128 (x * (2 ** 128) = x << 128), same for dividing (x / (2 ** 128) = x >> 128) ```sol // line 151 - old _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);  // line 151 - new _pointsPerUnit += ((newXDEFI << 128) / totalUnitsCached);   // lines 338-344 - old return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) / _pointsMultiplier ) + uint256(depositedXDEFI_);  // lines 338-344 - new return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) >> 128 ) + uint256(depositedXDEFI_); ```  
# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol line 332  The "currentDistributableXDEFI" variable is not used (can use distributableXDEFI instead). ```sol // function before: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); }  // function after: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(distributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  
# Handle  WatchPug   # Vulnerability details  In the current implementation, when `_unlockBatch()` is called with `tokenIds_.length == 1`, the transaction will be reverted with an error `USE_UNLOCK`.  Even though it's sub-optimal to use `relockBatch()` and `unlockBatch()` for only 1 tokenId, reverting and requiring the user to resend the transaction to another method still costs more gas than allowing it.  Therefore, we sugguest not to revert in `_unlockBatch()` when `tokenIds_.length == 1`.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L320-L328  ```solidity=320     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > uint256(1), "USE_UNLOCK");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  ### Recommendation  Change to:  ```solidity     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > 0, "NO_TOKEN_IDS");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  
# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  Instances include:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L82-L82  ```solidity require(duration <= uint256(18250 days), "INVALID_DURATION"); ```  Consider changing `uint256(18250 days)` to `MAX_DURATION` constant.   
# Handle  Fitraldys   # Vulnerability details  ## Impact expensive gas, because in the line https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistributionHelper.sol#L23,  the tokenids.length is save to a new variable to be used in the for loop, instead of call tokenids.length directly in the for loop  ## Proof of Concept ``` pragma solidity =0.8.7;  contract pikir {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {                  uint256 alltokens = tokenIds.length;         uint256 hasil;          for (uint256 i; i < alltokens; ++i){                          hasil += 1;          }         return hasil;      }  } //24714 gas  contract pikir2 {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {              uint256 hasil;          for (uint256 i; i < tokenIds.length; ++i){                          hasil += 1;          }         return hasil;      }  } //24710 gas ```  ## Tools Used remix   
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept  In contract `XDEFIDistribution`, the only use of `bonusMultiplier` is to calculate `units` in `_lock`.  In contract `XDEFIDistributionHelper`, `bonusMultiplier` is used for return value. However, `bonusMultiplier` can be calculated by `units * 100 / depositedXDEFI`.  
# Handle  defsec   # Vulnerability details  ## Impact  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint32 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint32 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L301 ```  2. Expiry value is just used for the comparison with the block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint32.  
# Handle  Tomio   # Vulnerability details  ## Impact in function setLockPeriods multiplier can be set to lower than 100 which will break the calculation when dividing the multiplier in function _lock https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268. If the amount times bonus multiplier below 100 the units value will be 0, therefore the totalUnits won't be added but the positionOf[tokenId_] bill be added.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L77 https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268  ## Tools Used  ## Recommended Mitigation Steps in function setLockPeriods need to be add  ```function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {            uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             require(multipliers >= 100); //added             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Extra gas costs from unnecessary casting.  ## Proof of Concept  `pointsCorrection` is stored as a int256 variable.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/interfaces/IXDEFIDistribution.sol#L15  However we can see that this variable is always negative (`_pointsPerUnit` and  `units` are both positive)  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L277  The only usage of `pointsCorrection` is in the `_withdrawableGiven` function as shown below.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L341-L342  ``` (   _toUint256Safe(       _toInt256Safe(_pointsPerUnit * uint256(units_)) +       pointsCorrection_   ) / _pointsMultiplier ) + uint256(depositedXDEFI_); ```  `pointsCorrection` is set to `_pointsPerUnit * uint256(units_)` when locking and `_pointsPerUnit` only increases so we can safely store `pointsCorrection as a positive uint256 (note this is an assumption of the original code as well) and simplify the above expression.  ``` // notice the sign change before `pointsCorrection_` (_pointsPerUnit * uint256(units_) - pointsCorrection_) / _pointsMultiplier + uint256(depositedXDEFI_); ```  We can then remove a significant amount of casting along with the associated costs.  ## Recommended Mitigation Steps  store `pointsCorrection` in a uint256 and subtract rather than add.  
# Handle  Dravee   # Vulnerability details  ## Impact Solidity defines a naming convention that should be followed.  ## Proof of Concept ``` Variable XDEFIDistribution.MAX_TOTAL_XDEFI_SUPPLY (contracts/XDEFIDistribution.sol#14) is not in mixedCase Constant XDEFIDistribution._pointsMultiplier (contracts/XDEFIDistribution.sol#17) is not in UPPER_CASE_WITH_UNDERSCORES Variable XDEFIDistribution._pointsPerUnit (contracts/XDEFIDistribution.sol#18) is not in mixedCase Variable XDEFIDistribution.XDEFI (contracts/XDEFIDistribution.sol#20) is not in mixedCase Variable XDEFIDistribution._zeroDurationPointBase (contracts/XDEFIDistribution.sol#30) is not in mixedCase Variable XDEFIDistribution._locked (contracts/XDEFIDistribution.sol#37) is not in mixedCase Function IXDEFIDistribution.XDEFI() (contracts/interfaces/IXDEFIDistribution.sol#37) is not in mixedCase ```  ## Tools Used Slither  ## Recommended Mitigation Steps Follow the Solidity naming convention: https://docs.soliditylang.org/en/v0.4.25/style-guide.html#naming-conventions  
# Handle  onewayfunction   # Vulnerability details  ## Impact The owner of the `XDEFIDistribution` contract can use flash loans to atomically steal XDEFI from the contract without taking on any capital risk.  ## Proof of Concept In my previous submission, "Anyone can steal XDEFI from the `XDEFIDistribution` contract and make the contract insolvent", I showed how any user can use the `onERC721Received` hook of the `_safeMint` function to steal XDEFI tokens from the contract and generally bork the contract's accounting. The attacker in that case took on some risk proportional to the minimum allowable `duration` and was limited in the amount they could steal based on their own capital available (how much XDEFI they had to use during the malicious lockup).  However, when a similar attack is performed by the `owner` of the `XDEFIDistribution` contract, it can be done (1) without the owner taking on any risk at all and (2) the owner can use flashloans to dramatically increase the amount of XDEFI they can steal.  In particular, the owner can perform all of the following in a single transaction (or in a single flashbots bundle):  First, the owner can call the [`setLockPeriods` function](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77) to allow `0` duration locks with a large `multiplier`.  Next, they can flash borrow as much XDEFI as possible from DEXs and loaning platforms. Call this amount of XDEFI `X`.  Then they do a (normal) `0` duration lock with `X/2` XDEFI. This could give them a large proportion of locked XDEFI.  Next, they do the "malicious lock" technique that I previously reported, using the remaining `X/2` XDEFI. This means that their first lock with be able to withdraw more than `X/2` XDEFI when they unlock.  Then, in the same transaction -- which is possible because they are using a `0` duration lock -- they can unlock both thier first "normal" lock, as well as their "malicious" lock, giving them more than `X` XDEFI in total.  They can repay the flash loan, and keep the difference.  Since the never have to hold a lock for any positive duration, and never even have to have any exposure to XDEFI, the attack is risk free for them. And since they can use flash loans, they'll likely have access to dramatically more capital than a non-owner (who can't use flash loans) could.   ## Recommended Mitigation Steps  In addition to the "use `_mint()` instead of `_safeMint()`" suggestion from the previous submission, I also recommend adding a `require(duration > 0, "INVALID_DURATION");` statement just above [L82](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L82).  Not only will disallowing `0` duration locks prevent most flashloan shenanigans by the owner, it would also help prevent sandwich attacks that steal incoming distributableX DEFI tokens by sandwiching such incoming txs with a `lock` and `unlock` transaction.  
# Handle  Dravee   # Vulnerability details  ## Impact   Waste of gas due to unnecessary underflow checks  ## Proof of Concept   On `XDEFIDistribution.sol:120` and `XDEFIDistribution.sol:175`, you can find the following substraction: `uint256 withdrawAmount = amountUnlocked_ - lockAmount_;`  However, as the Solidity version is 0.8.10, default overflow and underflow checks are made, which cost some gas.  You can save this gas with the `unchecked` keyword to bypass these checks as 5 lines above (L115 and L170), a `require` statement already checks that `lockAmount_ <= amountUnlocked_`.   Therefore, no underflow is possible.  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the "unchecked" keyword   
# Handle  PierrickGT   # Vulnerability details  ## Impact In [lockWithPermit](https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L99), we use the same code to transfer XDEFI and lock the position than in [lock](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L92-96). We can create an internal function to reuse this code and avoid duplication.  ## Proof of Concept Create an internal function called `_lockPosition` that will transfer XDEFI and lock the position. This function will be called in `lock` and `lockWithPermit`.  ## Recommended Mitigation Steps The following change is recommended.  ``` function _lockPosition(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Lock the XDEFI in the contract.     SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);      // Handle the lock position creation and get the tokenId of the locked position.     return _lock(amount_, duration_, destination_); }  function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {     return _lockPosition(amount_, duration_, destination_); }  function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {     // Approve this contract for the amount, using the provided signature.     IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);      return _lockPosition(amount_, duration_, destination_); } ```  
# Handle  cccz   # Vulnerability details  ## Impact  In the setLockPeriods function, there is no verification of the multipliers parameter, multipliers[i] may be 0, and the length of multipliers may not be equal to the length of durations_.  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77-L85  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { +      require(durations_.length == multipliers.length);         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i]; +         require(multipliers[i] != 0);             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```    
# Handle  agusduha   # Vulnerability details  ## Impact  MAX_TOTAL_XDEFI_SUPPLY has always the same value and is used only in one place, it should be constant to optimize gas  ## Proof of Concept  Variable declaration: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  Variable utilization: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the "constant" keyword to the storage variable declaration  
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from [https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory](https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory) :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   interfaces\IXDEFIDistribution.sol:55:    function baseURI() external view returns (string memory baseURI_); interfaces\IXDEFIDistribution.sol:74:    function setBaseURI(string memory baseURI_) external; interfaces\IXDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external; interfaces\IXDEFIDistribution.sol:106:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external returns (uint256 amountUnlocked_, uint256  newTokenId_); interfaces\IXDEFIDistribution.sol:109:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external returns (uint256 amountUnlocked_); interfaces\IXDEFIDistribution.sol:119:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_); interfaces\IXDEFIDistribution.sol:125:    function tokenURI(uint256 tokenId_) external view returns (string memory tokenURI_); XDEFIDistribution.sol:73:    function setBaseURI(string memory baseURI_) external onlyOwner { XDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { XDEFIDistribution.sol:165:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256  newTokenId_) { XDEFIDistribution.sol:186:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) { XDEFIDistribution.sol:205:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.  
# Handle  cccz   # Vulnerability details  ## Impact  There is a reentrancy vulnerability in the _safeMint function  ```     function _safeMint(         address to,         uint256 tokenId,         bytes memory _data     ) internal virtual {         _mint(to, tokenId);         require(             _checkOnERC721Received(address(0), to, tokenId, _data),             "ERC721: transfer to non ERC721Receiver implementer"         );     }     ...     function _checkOnERC721Received(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) private returns (bool) {         if (to.isContract()) {             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {                 return retval == IERC721Receiver.onERC721Received.selector; ```  The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function  ```     function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {         // Lock the XDEFI in the contract.         SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);          // Handle the lock position creation and get the tokenId of the locked position.         return _lock(amount_, duration_, destination_);     }     ...         function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {         // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.         require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");          // Get bonus multiplier and check that it is not zero (which validates the duration).         uint8 bonusMultiplier = bonusMultiplierOf[duration_];         require(bonusMultiplier != uint8(0), "INVALID_DURATION");          // Mint a locked staked position NFT to the destination.         _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));          // Track deposits.         totalDepositedXDEFI += amount_;  ``` Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.   ```      function updateDistribution() external {         uint256 totalUnitsCached = totalUnits;          require(totalUnitsCached> uint256(0), "NO_UNIT_SUPPLY");          uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());          if (newXDEFI == uint256(0)) return;          _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);          emit DistributionUpdated(msg.sender, newXDEFI);     }     ...     function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {         uint256 previousDistributableXDEFI = distributableXDEFI;         uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;          return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);     }   ``` If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user   ```      function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {         // Handle the unlock and get the amount of XDEFI eligible to withdraw.         amountUnlocked_ = _unlock(msg.sender, tokenId_);          // Send the the unlocked XDEFI to the destination.         SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);          // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.         _updateXDEFIBalance();     } ...      function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {         // Check that the account is the position NFT owner.         require(ownerOf(tokenId_) == account_, "NOT_OWNER");          // Fetch position.         Position storage position = positionOf[tokenId_];         uint96 units = position.units;         uint88 depositedXDEFI = position.depositedXDEFI;         uint32 expiry = position.expiry;          // Check that enough time has elapsed in order to unlock.         require(expiry != uint32(0), "NO_LOCKED_POSITION");         require(block.timestamp >= uint256(expiry), "CANNOT_UNLOCK");          // Get the withdrawable amount of XDEFI for the position.         amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);          // Track deposits.         totalDepositedXDEFI -= uint256(depositedXDEFI);          // Burn FDT Position.         totalUnits -= units;         delete positionOf[tokenId_];          emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);     }     ...      function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {         return             (                 _toUint256Safe(                     _toInt256Safe(_pointsPerUnit * uint256(units_)) +                     pointsCorrection_                 ) / _pointsMultiplier             ) + uint256(depositedXDEFI_);     }  ``` ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ``` -    function updateDistribution() external  { +    function updateDistribution() external  noReenter { ```  
# Handle  Dravee   # Vulnerability details  ## Impact   Custom errors from Solidity 0.8.4 are cheaper than revert strings.    ## Proof of Concept   Source: https://blog.soliditylang.org/2021/04/21/custom-errors/:  Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```   XDEFIDistribution.sol:40:        require((XDEFI = XDEFI_) != address(0), "INVALID_TOKEN"); XDEFIDistribution.sol:47:        require(owner == msg.sender, "NOT_OWNER"); XDEFIDistribution.sol:52:        require(_locked == 0, "LOCKED"); XDEFIDistribution.sol:63:        require(pendingOwner == msg.sender, "NOT_PENDING_OWNER"); XDEFIDistribution.sol:82:            require(duration <= uint256(18250 days), "INVALID_DURATION"); XDEFIDistribution.sol:115:        require(lockAmount_ <= amountUnlocked_, "INSUFFICIENT_AMOUNT_UNLOCKED"); XDEFIDistribution.sol:145:        require(totalUnitsCached > uint256(0), "NO_UNIT_SUPPLY"); XDEFIDistribution.sol:170:        require(lockAmount_ <= amountUnlocked_, "INSUFFICIENT_AMOUNT_UNLOCKED"); XDEFIDistribution.sol:207:        require(count > uint256(1), "MIN_2_TO_MERGE"); XDEFIDistribution.sol:214:            require(ownerOf(tokenId) == msg.sender, "NOT_OWNER"); XDEFIDistribution.sol:215:            require(positionOf[tokenId].expiry == uint32(0), "POSITION_NOT_UNLOCKED");  XDEFIDistribution.sol:227:        require(_exists(tokenId_), "NO_TOKEN"); XDEFIDistribution.sol:232:        require(_exists(tokenId_), "NO_TOKEN"); XDEFIDistribution.sol:255:        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT"); XDEFIDistribution.sol:259:        require(bonusMultiplier != uint8(0), "INVALID_DURATION"); XDEFIDistribution.sol:295:        require(ownerOf(tokenId_) == account_, "NOT_OWNER"); XDEFIDistribution.sol:304:        require(expiry != uint32(0), "NO_LOCKED_POSITION"); XDEFIDistribution.sol:305:        require(block.timestamp >= uint256(expiry), "CANNOT_UNLOCK"); XDEFIDistribution.sol:322:        require(count > uint256(1), "USE_UNLOCK"); ```      ## Tools Used   VS Code    ## Recommended Mitigation Steps   Replace revert strings with custom errors.   
# Handle  leastwood   # Vulnerability details  ## Impact  NFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.  When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.  This edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.  ## Proof of Concept  ``` function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.     require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");      // Get bonus multiplier and check that it is not zero (which validates the duration).     uint8 bonusMultiplier = bonusMultiplierOf[duration_];     require(bonusMultiplier != uint8(0), "INVALID_DURATION");      // Mint a locked staked position NFT to the destination.     _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));      // Track deposits.     totalDepositedXDEFI += amount_;      // Create Position.     uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));     totalUnits += units;     positionOf[tokenId_] =         Position({             units: units,             depositedXDEFI: uint88(amount_),             expiry: uint32(block.timestamp + duration_),             created: uint32(block.timestamp),             bonusMultiplier: bonusMultiplier,             pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)         });      emit LockPositionCreated(tokenId_, destination_, amount_, duration_); } ```  ``` function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {     // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.     return (points_ << uint256(128)) + uint128(totalSupply() + 1); } ```  ``` function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {     uint256 count = tokenIds_.length;     require(count > uint256(1), "MIN_2_TO_MERGE");      uint256 points;      // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.     for (uint256 i; i < count; ++i) {         uint256 tokenId = tokenIds_[i];         require(ownerOf(tokenId) == msg.sender, "NOT_OWNER");         require(positionOf[tokenId].expiry == uint32(0), "POSITION_NOT_UNLOCKED");          _burn(tokenId);          points += _getPointsFromTokenId(tokenId);     }      // Mine a new NFT to the destinations, based on the accumulated points.     _safeMint(destination_, tokenId_ = _generateNewTokenId(points)); } ```  ## Tools Used  Manual code review. Discussions with Michael.  ## Recommended Mitigation Steps  Consider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In Contract **XDEFIDistribution** the function **setBaseURI** is missing an event for this admin functionality.  ## Impact Users can't monitor admin changes done to the contract to reflect it in their clients.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps create event for base URI changes and emit it.  
# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          XDEFIDistribution.sol : reachable assert in line 284         XDEFIDistribution.sol : reachable assert in line 288  
# Handle  robee   # Vulnerability details   The following requires has a non comprehensive messages.  This is very important to add a comprehensive message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: XDEFIDistribution.sol, In line 227 with Require message: NO_TOKEN         Solidity file: XDEFIDistribution.sol, In line 232 with Require message: NO_TOKEN    
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: XDEFIDistribution.sol, i, 80         just change to unchecked: XDEFIDistribution.sol, i, 212         just change to unchecked: XDEFIDistribution.sol, i, 325         just change to unchecked: XDEFIDistributionHelper.sol, i, 15         just change to unchecked: XDEFIDistributionHelper.sol, i, 29         just change to unchecked: XDEFIDistributionHelper.sol, i, 42   
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           XDEFIDistributionHelper.sol, variable name: tokenIds times: 3 at: getAllLockedPositionsForAccount   
# Handle  robee   # Vulnerability details   The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function withdrawableOf in XDEFIDistribution.sol could be set external         The function tokenURI in XDEFIDistribution.sol could be set external         The function getAllTokensForAccount in XDEFIDistributionHelper.sol could be set external         The function getAllLockedPositionsForAccount in XDEFIDistributionHelper.sol could be set external    
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs of all locking operations.  ## Proof of Concept  XDEFIDistribution.sol stores the total supply of the XDEFI token:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  This is so that the amount being locked can be checked to be less than this on each call  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  This is unnecessary as the XDEFI token has no external mint function and so has a fixed supply. It's then impossible for any user to supply more than 240M XDEFI in order to fail this check.  https://etherscan.io/address/0x72b886d09c117654ab7da13a14d603001de0b777#code  ## Recommended Mitigation Steps  Remove the unnecessary check on the total supply.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduced readability  ## Proof of Concept  In a number of placed we seem to be inlining an assignment with the usage of that variable:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L40  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L70  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L83  This is quite atypical in my experience and reduces readability: lines which contain require statements and event emission now modify contract storage.  ## Recommended Mitigation Steps  Consider whether any small benefits to gas/compactness are worth the reduced clarity.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduction of potential gas refunds.  ## Proof of Concept  The reentrancy guard variable is initially set to zero, set to a nonzero value and then reset to zero:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  We then have to the higher cost for writing to clean storage rather than dirty storage (which is then refunded). This is not recommended as it can cause the size of the gas refunded to users to be capped. For more info see the OZ implementation:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  ## Recommended Mitigation Steps  Change from 0->1->0 to 1->2->1  
# Handle  0xsanson   # Vulnerability details  Not an issue.  I noticed that the `merge` function doesn't have an event associated with it. Depending on the kind of offchain analysis/tools you will end up using, an event here may turn up useful to know which NFTs got merged together into a new one.  ## Recommended Mitigation Steps Add an event which contains `uint256[] memory tokenIds_` and `tokenId_`.  
# Handle  Czar102   # Vulnerability details  ## Impact  Proper event declaration eases off-chain monitoring.  ## Proof of Concept  In the case of qualitative variables, it is recommended to use `indexed` keyword.  Despite the `uint duration` argument seems to be a quantitative one, it is limited to few values, which specify the "locking mode".  ## Recommended Mitigation Steps  `uint duration` variable should be considered qualitative and be marked `indexed` in the following events: ``` event LockPeriodSet(uint256 duration, uint8 bonusMultiplier); event LockPositionCreated(uint256 indexed tokenId, address indexed owner, uint256 amount, uint256 duration); ```   
# Handle  0xsanson   # Vulnerability details  ## Impact Throughout the code the safe functions `safeTransfer` and `safeTransferFrom` are used when dealing with XDEFI. Isn't this token a standard ERC20? I believe the normal ERC20 transfer functions can be used. The advantage is gaining some 100s gas otherwise spent in unneeded logic.  ## Proof of Concept grep safeT *.sol  ## Recommended Mitigation Steps Consider removing the SafeERC20 library.  
# Handle  Czar102   # Vulnerability details  ## Impact  An owner of the contract may, by ordering their or others' locking transactions, significantly increase or decrease `bonusMultiplier` for some set of transactions.  So, by mining a single block, an owner can lower other's bonus multipliers, execute locking transactions and then restore bonus multipliers.  A user might send a locking transaction in a similar time as an owner lowers the multipliers, resulting in lowering the revenue against data presented to the user.  An owner can also pass ownership to a contract that will change bonus multipliers and lock funds with a very high bonus multiplier, then restore previous multipliers' state not to let others do the same. This way, the owner can gain an unfair advantage over others.  ## Recommended Mitigation Steps  Use a timelock for `setLockPeriods(...)` function and require passing `bonusMultiplier` in locking functions, revert if they are different from the state variables.   
# Handle  defsec   # Vulnerability details  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L274 ```  ## Tools Used  None   ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  If a user locks funds in the contract, they can only withdraw funds by calling functions that in turn call the `_unlock()` function. The `_unlock()` function requires the position to have block.timestamp >= position.expiry. If there is a problem with the contract, with the XDEFI ERC20 token, or a user changes their mind and wants their funds back, they do not have this option. This can be more problematic with very long lock duration values.  ## Proof of Concept  There is a hard requirement that block.timestamp >= uint256(expiry) for any position before it can be unlocked and the funds released. All code paths that allow a use to withdraw their XDEFI rely on the `_unlock()` function:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L305  ## Recommended Mitigation Steps  Different options exist to assist users with this issue. One would be to keep lock duration values small, especially when the contract is first released to users. Another is to add an emergency withdrawal function that has the onlyOwner modifier, such as using OpenZeppelin's Pausable module: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol   
# Handle  sirhashalot   # Vulnerability details  ## Impact  There is a require statement that contains the comment "Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway." This comment is correct that the require statement is unnecessary and removing saves on gas during relock functions.  ## Proof of Concept  The unnecessary require statement is in the `relock()` and `relockBatch()` functions of XDEFIDistribution.sol: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L115 https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L170  ## Recommended Mitigation Steps  Remove the unnecessary require statement to save gas  
# Handle  Czar102   # Vulnerability details  ## Impact  Wrong revert messages might lead to confusion.  ## Proof of Concept  In line 52 of XDEFIDistribution, the reason for a fail of a reentrant call is `"LOCKED"`. In DeFi, it usually means that contract's functionality is temporarily limited. This is not true in this case.  ## Recommended Mitigation Steps  Consider changing the revert string to `"REENTRY_NOT_ALLOWED"`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151  ```solidity     _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached); ```  In the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.   A malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.  As a result, the contract can be malfunctioning and even freeze users' funds in edge cases.  ### PoC  Given:  - bonusMultiplierOf[30 days] = 100  1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`; 2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:  ```solidity     _pointsPerUnit += ((170141183460469 * 2**128) / 1); ```  3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows; 4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days; 5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:   ```solidity     _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1)); ```  6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.    ### Recomandation  Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.  The same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`    https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44  ```solidity constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721("Locked XDEFI", "lXDEFI") {         require((XDEFI = XDEFI_) != address(0), "INVALID_TOKEN");         owner = msg.sender;         baseURI = baseURI_;         _zeroDurationPointBase = zeroDurationPointBase_;          totalUnits = 100_000_000;     } ```  
# Handle  WatchPug   # Vulnerability details  Storage writes (`SSTORE`) to `distributableXDEFI` may not be needed when `previousDistributableXDEFI == currentDistributableXDEFI`, therefore the code can be reorganized to save gas from unnecessary storage writes.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L330-L336  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  ### Recommendation  Change to:  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      newFundsTokenBalance_ = _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);     if (newFundsTokenBalance_ != 0) {         distributableXDEFI = currentDistributableXDEFI;     } } ```  
# Handle  WatchPug   # Vulnerability details  `_zeroDurationPointBase` can be set at deploy time so that locks with 0 duration can get scores.  However, if the value of `_zeroDurationPointBase` is being set high enough. It can potentially be exploited by repeatedly lock(), and unlock() with 0 duration to get scores.  This can get amplified with flashloans.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L245-L247  ```solidity function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {     return amount_ * (duration_ + _zeroDurationPointBase); } ```  ## Recommendation  Consider changing `_zeroDurationPointBase` to a constant of value `1`.  
# Handle  Dravee   # Vulnerability details  ## Impact Code clarity / code style  ## Proof of Concept At the following places, the casts are implicit, whereas the project's style hints at explicit casts everywhere : https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L255 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L269 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L314  ## Tools Used VS Code  ## Recommended Mitigation Steps Use explicit casts everywhere for unsigned integers, as it's the practice everywhere else  
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check (XDEFIDistribution.sol line 255). using double require check can save more gas:   require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");  ## Tools Used  ## Recommended Mitigation Steps require(amount_ != uint256(0), "INVALID_AMOUNT" ); require(amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");  
# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L120-L125  ```solidity=120 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ```  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L175-L180  ```solidity=175 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ``` ### Recommendation  Change to:  ```solidity if (amountUnlocked_ > lockAmount_) {     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_ - lockAmount_); } ```  - Removed a local variable: `withdrawAmount`; - Only do the arithmetic when needed: `amountUnlocked_ - lockAmount_`.  
# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol lines 151, 338-344 Instead of multiplying by _pointsMultiplier, which is 2 ** 128, it is more efficient to shift by 128 (x * (2 ** 128) = x << 128), same for dividing (x / (2 ** 128) = x >> 128) ```sol // line 151 - old _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);  // line 151 - new _pointsPerUnit += ((newXDEFI << 128) / totalUnitsCached);   // lines 338-344 - old return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) / _pointsMultiplier ) + uint256(depositedXDEFI_);  // lines 338-344 - new return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) >> 128 ) + uint256(depositedXDEFI_); ```  
# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol line 332  The "currentDistributableXDEFI" variable is not used (can use distributableXDEFI instead). ```sol // function before: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); }  // function after: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(distributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  
# Handle  WatchPug   # Vulnerability details  In the current implementation, when `_unlockBatch()` is called with `tokenIds_.length == 1`, the transaction will be reverted with an error `USE_UNLOCK`.  Even though it's sub-optimal to use `relockBatch()` and `unlockBatch()` for only 1 tokenId, reverting and requiring the user to resend the transaction to another method still costs more gas than allowing it.  Therefore, we sugguest not to revert in `_unlockBatch()` when `tokenIds_.length == 1`.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L320-L328  ```solidity=320     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > uint256(1), "USE_UNLOCK");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  ### Recommendation  Change to:  ```solidity     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > 0, "NO_TOKEN_IDS");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  
# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  Instances include:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L82-L82  ```solidity require(duration <= uint256(18250 days), "INVALID_DURATION"); ```  Consider changing `uint256(18250 days)` to `MAX_DURATION` constant.   
# Handle  Fitraldys   # Vulnerability details  ## Impact expensive gas, because in the line https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistributionHelper.sol#L23,  the tokenids.length is save to a new variable to be used in the for loop, instead of call tokenids.length directly in the for loop  ## Proof of Concept ``` pragma solidity =0.8.7;  contract pikir {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {                  uint256 alltokens = tokenIds.length;         uint256 hasil;          for (uint256 i; i < alltokens; ++i){                          hasil += 1;          }         return hasil;      }  } //24714 gas  contract pikir2 {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {              uint256 hasil;          for (uint256 i; i < tokenIds.length; ++i){                          hasil += 1;          }         return hasil;      }  } //24710 gas ```  ## Tools Used remix   
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept  In contract `XDEFIDistribution`, the only use of `bonusMultiplier` is to calculate `units` in `_lock`.  In contract `XDEFIDistributionHelper`, `bonusMultiplier` is used for return value. However, `bonusMultiplier` can be calculated by `units * 100 / depositedXDEFI`.  
# Handle  defsec   # Vulnerability details  ## Impact  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint32 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint32 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L301 ```  2. Expiry value is just used for the comparison with the block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint32.  
# Handle  Tomio   # Vulnerability details  ## Impact in function setLockPeriods multiplier can be set to lower than 100 which will break the calculation when dividing the multiplier in function _lock https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268. If the amount times bonus multiplier below 100 the units value will be 0, therefore the totalUnits won't be added but the positionOf[tokenId_] bill be added.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L77 https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268  ## Tools Used  ## Recommended Mitigation Steps in function setLockPeriods need to be add  ```function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {            uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             require(multipliers >= 100); //added             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Extra gas costs from unnecessary casting.  ## Proof of Concept  `pointsCorrection` is stored as a int256 variable.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/interfaces/IXDEFIDistribution.sol#L15  However we can see that this variable is always negative (`_pointsPerUnit` and  `units` are both positive)  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L277  The only usage of `pointsCorrection` is in the `_withdrawableGiven` function as shown below.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L341-L342  ``` (   _toUint256Safe(       _toInt256Safe(_pointsPerUnit * uint256(units_)) +       pointsCorrection_   ) / _pointsMultiplier ) + uint256(depositedXDEFI_); ```  `pointsCorrection` is set to `_pointsPerUnit * uint256(units_)` when locking and `_pointsPerUnit` only increases so we can safely store `pointsCorrection as a positive uint256 (note this is an assumption of the original code as well) and simplify the above expression.  ``` // notice the sign change before `pointsCorrection_` (_pointsPerUnit * uint256(units_) - pointsCorrection_) / _pointsMultiplier + uint256(depositedXDEFI_); ```  We can then remove a significant amount of casting along with the associated costs.  ## Recommended Mitigation Steps  store `pointsCorrection` in a uint256 and subtract rather than add.  
# Handle  Dravee   # Vulnerability details  ## Impact Solidity defines a naming convention that should be followed.  ## Proof of Concept ``` Variable XDEFIDistribution.MAX_TOTAL_XDEFI_SUPPLY (contracts/XDEFIDistribution.sol#14) is not in mixedCase Constant XDEFIDistribution._pointsMultiplier (contracts/XDEFIDistribution.sol#17) is not in UPPER_CASE_WITH_UNDERSCORES Variable XDEFIDistribution._pointsPerUnit (contracts/XDEFIDistribution.sol#18) is not in mixedCase Variable XDEFIDistribution.XDEFI (contracts/XDEFIDistribution.sol#20) is not in mixedCase Variable XDEFIDistribution._zeroDurationPointBase (contracts/XDEFIDistribution.sol#30) is not in mixedCase Variable XDEFIDistribution._locked (contracts/XDEFIDistribution.sol#37) is not in mixedCase Function IXDEFIDistribution.XDEFI() (contracts/interfaces/IXDEFIDistribution.sol#37) is not in mixedCase ```  ## Tools Used Slither  ## Recommended Mitigation Steps Follow the Solidity naming convention: https://docs.soliditylang.org/en/v0.4.25/style-guide.html#naming-conventions  
# Handle  onewayfunction   # Vulnerability details  ## Impact The owner of the `XDEFIDistribution` contract can use flash loans to atomically steal XDEFI from the contract without taking on any capital risk.  ## Proof of Concept In my previous submission, "Anyone can steal XDEFI from the `XDEFIDistribution` contract and make the contract insolvent", I showed how any user can use the `onERC721Received` hook of the `_safeMint` function to steal XDEFI tokens from the contract and generally bork the contract's accounting. The attacker in that case took on some risk proportional to the minimum allowable `duration` and was limited in the amount they could steal based on their own capital available (how much XDEFI they had to use during the malicious lockup).  However, when a similar attack is performed by the `owner` of the `XDEFIDistribution` contract, it can be done (1) without the owner taking on any risk at all and (2) the owner can use flashloans to dramatically increase the amount of XDEFI they can steal.  In particular, the owner can perform all of the following in a single transaction (or in a single flashbots bundle):  First, the owner can call the [`setLockPeriods` function](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77) to allow `0` duration locks with a large `multiplier`.  Next, they can flash borrow as much XDEFI as possible from DEXs and loaning platforms. Call this amount of XDEFI `X`.  Then they do a (normal) `0` duration lock with `X/2` XDEFI. This could give them a large proportion of locked XDEFI.  Next, they do the "malicious lock" technique that I previously reported, using the remaining `X/2` XDEFI. This means that their first lock with be able to withdraw more than `X/2` XDEFI when they unlock.  Then, in the same transaction -- which is possible because they are using a `0` duration lock -- they can unlock both thier first "normal" lock, as well as their "malicious" lock, giving them more than `X` XDEFI in total.  They can repay the flash loan, and keep the difference.  Since the never have to hold a lock for any positive duration, and never even have to have any exposure to XDEFI, the attack is risk free for them. And since they can use flash loans, they'll likely have access to dramatically more capital than a non-owner (who can't use flash loans) could.   ## Recommended Mitigation Steps  In addition to the "use `_mint()` instead of `_safeMint()`" suggestion from the previous submission, I also recommend adding a `require(duration > 0, "INVALID_DURATION");` statement just above [L82](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L82).  Not only will disallowing `0` duration locks prevent most flashloan shenanigans by the owner, it would also help prevent sandwich attacks that steal incoming distributableX DEFI tokens by sandwiching such incoming txs with a `lock` and `unlock` transaction.  
# Handle  Dravee   # Vulnerability details  ## Impact   Waste of gas due to unnecessary underflow checks  ## Proof of Concept   On `XDEFIDistribution.sol:120` and `XDEFIDistribution.sol:175`, you can find the following substraction: `uint256 withdrawAmount = amountUnlocked_ - lockAmount_;`  However, as the Solidity version is 0.8.10, default overflow and underflow checks are made, which cost some gas.  You can save this gas with the `unchecked` keyword to bypass these checks as 5 lines above (L115 and L170), a `require` statement already checks that `lockAmount_ <= amountUnlocked_`.   Therefore, no underflow is possible.  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the "unchecked" keyword   
# Handle  PierrickGT   # Vulnerability details  ## Impact In [lockWithPermit](https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L99), we use the same code to transfer XDEFI and lock the position than in [lock](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L92-96). We can create an internal function to reuse this code and avoid duplication.  ## Proof of Concept Create an internal function called `_lockPosition` that will transfer XDEFI and lock the position. This function will be called in `lock` and `lockWithPermit`.  ## Recommended Mitigation Steps The following change is recommended.  ``` function _lockPosition(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Lock the XDEFI in the contract.     SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);      // Handle the lock position creation and get the tokenId of the locked position.     return _lock(amount_, duration_, destination_); }  function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {     return _lockPosition(amount_, duration_, destination_); }  function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {     // Approve this contract for the amount, using the provided signature.     IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);      return _lockPosition(amount_, duration_, destination_); } ```  
# Handle  cccz   # Vulnerability details  ## Impact  In the setLockPeriods function, there is no verification of the multipliers parameter, multipliers[i] may be 0, and the length of multipliers may not be equal to the length of durations_.  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77-L85  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { +      require(durations_.length == multipliers.length);         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i]; +         require(multipliers[i] != 0);             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```    
# Handle  agusduha   # Vulnerability details  ## Impact  MAX_TOTAL_XDEFI_SUPPLY has always the same value and is used only in one place, it should be constant to optimize gas  ## Proof of Concept  Variable declaration: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  Variable utilization: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the "constant" keyword to the storage variable declaration  
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from [https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory](https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory) :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   interfaces\IXDEFIDistribution.sol:55:    function baseURI() external view returns (string memory baseURI_); interfaces\IXDEFIDistribution.sol:74:    function setBaseURI(string memory baseURI_) external; interfaces\IXDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external; interfaces\IXDEFIDistribution.sol:106:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external returns (uint256 amountUnlocked_, uint256  newTokenId_); interfaces\IXDEFIDistribution.sol:109:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external returns (uint256 amountUnlocked_); interfaces\IXDEFIDistribution.sol:119:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_); interfaces\IXDEFIDistribution.sol:125:    function tokenURI(uint256 tokenId_) external view returns (string memory tokenURI_); XDEFIDistribution.sol:73:    function setBaseURI(string memory baseURI_) external onlyOwner { XDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { XDEFIDistribution.sol:165:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256  newTokenId_) { XDEFIDistribution.sol:186:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) { XDEFIDistribution.sol:205:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.  
# Handle  cccz   # Vulnerability details  ## Impact  There is a reentrancy vulnerability in the _safeMint function  ```     function _safeMint(         address to,         uint256 tokenId,         bytes memory _data     ) internal virtual {         _mint(to, tokenId);         require(             _checkOnERC721Received(address(0), to, tokenId, _data),             "ERC721: transfer to non ERC721Receiver implementer"         );     }     ...     function _checkOnERC721Received(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) private returns (bool) {         if (to.isContract()) {             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {                 return retval == IERC721Receiver.onERC721Received.selector; ```  The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function  ```     function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {         // Lock the XDEFI in the contract.         SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);          // Handle the lock position creation and get the tokenId of the locked position.         return _lock(amount_, duration_, destination_);     }     ...         function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {         // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.         require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");          // Get bonus multiplier and check that it is not zero (which validates the duration).         uint8 bonusMultiplier = bonusMultiplierOf[duration_];         require(bonusMultiplier != uint8(0), "INVALID_DURATION");          // Mint a locked staked position NFT to the destination.         _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));          // Track deposits.         totalDepositedXDEFI += amount_;  ``` Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.   ```      function updateDistribution() external {         uint256 totalUnitsCached = totalUnits;          require(totalUnitsCached> uint256(0), "NO_UNIT_SUPPLY");          uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());          if (newXDEFI == uint256(0)) return;          _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);          emit DistributionUpdated(msg.sender, newXDEFI);     }     ...     function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {         uint256 previousDistributableXDEFI = distributableXDEFI;         uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;          return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);     }   ``` If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user   ```      function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {         // Handle the unlock and get the amount of XDEFI eligible to withdraw.         amountUnlocked_ = _unlock(msg.sender, tokenId_);          // Send the the unlocked XDEFI to the destination.         SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);          // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.         _updateXDEFIBalance();     } ...      function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {         // Check that the account is the position NFT owner.         require(ownerOf(tokenId_) == account_, "NOT_OWNER");          // Fetch position.         Position storage position = positionOf[tokenId_];         uint96 units = position.units;         uint88 depositedXDEFI = position.depositedXDEFI;         uint32 expiry = position.expiry;          // Check that enough time has elapsed in order to unlock.         require(expiry != uint32(0), "NO_LOCKED_POSITION");         require(block.timestamp >= uint256(expiry), "CANNOT_UNLOCK");          // Get the withdrawable amount of XDEFI for the position.         amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);          // Track deposits.         totalDepositedXDEFI -= uint256(depositedXDEFI);          // Burn FDT Position.         totalUnits -= units;         delete positionOf[tokenId_];          emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);     }     ...      function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {         return             (                 _toUint256Safe(                     _toInt256Safe(_pointsPerUnit * uint256(units_)) +                     pointsCorrection_                 ) / _pointsMultiplier             ) + uint256(depositedXDEFI_);     }  ``` ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ``` -    function updateDistribution() external  { +    function updateDistribution() external  noReenter { ```  
# Handle  Dravee   # Vulnerability details  ## Impact   Custom errors from Solidity 0.8.4 are cheaper than revert strings.    ## Proof of Concept   Source: https://blog.soliditylang.org/2021/04/21/custom-errors/:  Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```   XDEFIDistribution.sol:40:        require((XDEFI = XDEFI_) != address(0), "INVALID_TOKEN"); XDEFIDistribution.sol:47:        require(owner == msg.sender, "NOT_OWNER"); XDEFIDistribution.sol:52:        require(_locked == 0, "LOCKED"); XDEFIDistribution.sol:63:        require(pendingOwner == msg.sender, "NOT_PENDING_OWNER"); XDEFIDistribution.sol:82:            require(duration <= uint256(18250 days), "INVALID_DURATION"); XDEFIDistribution.sol:115:        require(lockAmount_ <= amountUnlocked_, "INSUFFICIENT_AMOUNT_UNLOCKED"); XDEFIDistribution.sol:145:        require(totalUnitsCached > uint256(0), "NO_UNIT_SUPPLY"); XDEFIDistribution.sol:170:        require(lockAmount_ <= amountUnlocked_, "INSUFFICIENT_AMOUNT_UNLOCKED"); XDEFIDistribution.sol:207:        require(count > uint256(1), "MIN_2_TO_MERGE"); XDEFIDistribution.sol:214:            require(ownerOf(tokenId) == msg.sender, "NOT_OWNER"); XDEFIDistribution.sol:215:            require(positionOf[tokenId].expiry == uint32(0), "POSITION_NOT_UNLOCKED");  XDEFIDistribution.sol:227:        require(_exists(tokenId_), "NO_TOKEN"); XDEFIDistribution.sol:232:        require(_exists(tokenId_), "NO_TOKEN"); XDEFIDistribution.sol:255:        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT"); XDEFIDistribution.sol:259:        require(bonusMultiplier != uint8(0), "INVALID_DURATION"); XDEFIDistribution.sol:295:        require(ownerOf(tokenId_) == account_, "NOT_OWNER"); XDEFIDistribution.sol:304:        require(expiry != uint32(0), "NO_LOCKED_POSITION"); XDEFIDistribution.sol:305:        require(block.timestamp >= uint256(expiry), "CANNOT_UNLOCK"); XDEFIDistribution.sol:322:        require(count > uint256(1), "USE_UNLOCK"); ```      ## Tools Used   VS Code    ## Recommended Mitigation Steps   Replace revert strings with custom errors.   
# Handle  leastwood   # Vulnerability details  ## Impact  NFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.  When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.  This edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.  ## Proof of Concept  ``` function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.     require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");      // Get bonus multiplier and check that it is not zero (which validates the duration).     uint8 bonusMultiplier = bonusMultiplierOf[duration_];     require(bonusMultiplier != uint8(0), "INVALID_DURATION");      // Mint a locked staked position NFT to the destination.     _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));      // Track deposits.     totalDepositedXDEFI += amount_;      // Create Position.     uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));     totalUnits += units;     positionOf[tokenId_] =         Position({             units: units,             depositedXDEFI: uint88(amount_),             expiry: uint32(block.timestamp + duration_),             created: uint32(block.timestamp),             bonusMultiplier: bonusMultiplier,             pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)         });      emit LockPositionCreated(tokenId_, destination_, amount_, duration_); } ```  ``` function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {     // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.     return (points_ << uint256(128)) + uint128(totalSupply() + 1); } ```  ``` function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {     uint256 count = tokenIds_.length;     require(count > uint256(1), "MIN_2_TO_MERGE");      uint256 points;      // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.     for (uint256 i; i < count; ++i) {         uint256 tokenId = tokenIds_[i];         require(ownerOf(tokenId) == msg.sender, "NOT_OWNER");         require(positionOf[tokenId].expiry == uint32(0), "POSITION_NOT_UNLOCKED");          _burn(tokenId);          points += _getPointsFromTokenId(tokenId);     }      // Mine a new NFT to the destinations, based on the accumulated points.     _safeMint(destination_, tokenId_ = _generateNewTokenId(points)); } ```  ## Tools Used  Manual code review. Discussions with Michael.  ## Recommended Mitigation Steps  Consider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In Contract **XDEFIDistribution** the function **setBaseURI** is missing an event for this admin functionality.  ## Impact Users can't monitor admin changes done to the contract to reflect it in their clients.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps create event for base URI changes and emit it.  
# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          XDEFIDistribution.sol : reachable assert in line 284         XDEFIDistribution.sol : reachable assert in line 288  
# Handle  robee   # Vulnerability details   The following requires has a non comprehensive messages.  This is very important to add a comprehensive message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: XDEFIDistribution.sol, In line 227 with Require message: NO_TOKEN         Solidity file: XDEFIDistribution.sol, In line 232 with Require message: NO_TOKEN    
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: XDEFIDistribution.sol, i, 80         just change to unchecked: XDEFIDistribution.sol, i, 212         just change to unchecked: XDEFIDistribution.sol, i, 325         just change to unchecked: XDEFIDistributionHelper.sol, i, 15         just change to unchecked: XDEFIDistributionHelper.sol, i, 29         just change to unchecked: XDEFIDistributionHelper.sol, i, 42   
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           XDEFIDistributionHelper.sol, variable name: tokenIds times: 3 at: getAllLockedPositionsForAccount   
# Handle  robee   # Vulnerability details   The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function withdrawableOf in XDEFIDistribution.sol could be set external         The function tokenURI in XDEFIDistribution.sol could be set external         The function getAllTokensForAccount in XDEFIDistributionHelper.sol could be set external         The function getAllLockedPositionsForAccount in XDEFIDistributionHelper.sol could be set external    
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs of all locking operations.  ## Proof of Concept  XDEFIDistribution.sol stores the total supply of the XDEFI token:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  This is so that the amount being locked can be checked to be less than this on each call  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  This is unnecessary as the XDEFI token has no external mint function and so has a fixed supply. It's then impossible for any user to supply more than 240M XDEFI in order to fail this check.  https://etherscan.io/address/0x72b886d09c117654ab7da13a14d603001de0b777#code  ## Recommended Mitigation Steps  Remove the unnecessary check on the total supply.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduced readability  ## Proof of Concept  In a number of placed we seem to be inlining an assignment with the usage of that variable:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L40  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L70  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L83  This is quite atypical in my experience and reduces readability: lines which contain require statements and event emission now modify contract storage.  ## Recommended Mitigation Steps  Consider whether any small benefits to gas/compactness are worth the reduced clarity.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduction of potential gas refunds.  ## Proof of Concept  The reentrancy guard variable is initially set to zero, set to a nonzero value and then reset to zero:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  We then have to the higher cost for writing to clean storage rather than dirty storage (which is then refunded). This is not recommended as it can cause the size of the gas refunded to users to be capped. For more info see the OZ implementation:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  ## Recommended Mitigation Steps  Change from 0->1->0 to 1->2->1  
# Handle  0xsanson   # Vulnerability details  Not an issue.  I noticed that the `merge` function doesn't have an event associated with it. Depending on the kind of offchain analysis/tools you will end up using, an event here may turn up useful to know which NFTs got merged together into a new one.  ## Recommended Mitigation Steps Add an event which contains `uint256[] memory tokenIds_` and `tokenId_`.  
# Handle  Czar102   # Vulnerability details  ## Impact  Proper event declaration eases off-chain monitoring.  ## Proof of Concept  In the case of qualitative variables, it is recommended to use `indexed` keyword.  Despite the `uint duration` argument seems to be a quantitative one, it is limited to few values, which specify the "locking mode".  ## Recommended Mitigation Steps  `uint duration` variable should be considered qualitative and be marked `indexed` in the following events: ``` event LockPeriodSet(uint256 duration, uint8 bonusMultiplier); event LockPositionCreated(uint256 indexed tokenId, address indexed owner, uint256 amount, uint256 duration); ```   
# Handle  0xsanson   # Vulnerability details  ## Impact Throughout the code the safe functions `safeTransfer` and `safeTransferFrom` are used when dealing with XDEFI. Isn't this token a standard ERC20? I believe the normal ERC20 transfer functions can be used. The advantage is gaining some 100s gas otherwise spent in unneeded logic.  ## Proof of Concept grep safeT *.sol  ## Recommended Mitigation Steps Consider removing the SafeERC20 library.  
# Handle  Czar102   # Vulnerability details  ## Impact  An owner of the contract may, by ordering their or others' locking transactions, significantly increase or decrease `bonusMultiplier` for some set of transactions.  So, by mining a single block, an owner can lower other's bonus multipliers, execute locking transactions and then restore bonus multipliers.  A user might send a locking transaction in a similar time as an owner lowers the multipliers, resulting in lowering the revenue against data presented to the user.  An owner can also pass ownership to a contract that will change bonus multipliers and lock funds with a very high bonus multiplier, then restore previous multipliers' state not to let others do the same. This way, the owner can gain an unfair advantage over others.  ## Recommended Mitigation Steps  Use a timelock for `setLockPeriods(...)` function and require passing `bonusMultiplier` in locking functions, revert if they are different from the state variables.   
# Handle  defsec   # Vulnerability details  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L274 ```  ## Tools Used  None   ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  If a user locks funds in the contract, they can only withdraw funds by calling functions that in turn call the `_unlock()` function. The `_unlock()` function requires the position to have block.timestamp >= position.expiry. If there is a problem with the contract, with the XDEFI ERC20 token, or a user changes their mind and wants their funds back, they do not have this option. This can be more problematic with very long lock duration values.  ## Proof of Concept  There is a hard requirement that block.timestamp >= uint256(expiry) for any position before it can be unlocked and the funds released. All code paths that allow a use to withdraw their XDEFI rely on the `_unlock()` function:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L305  ## Recommended Mitigation Steps  Different options exist to assist users with this issue. One would be to keep lock duration values small, especially when the contract is first released to users. Another is to add an emergency withdrawal function that has the onlyOwner modifier, such as using OpenZeppelin's Pausable module: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol   
# Handle  sirhashalot   # Vulnerability details  ## Impact  There is a require statement that contains the comment "Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway." This comment is correct that the require statement is unnecessary and removing saves on gas during relock functions.  ## Proof of Concept  The unnecessary require statement is in the `relock()` and `relockBatch()` functions of XDEFIDistribution.sol: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L115 https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L170  ## Recommended Mitigation Steps  Remove the unnecessary require statement to save gas  
# Handle  Czar102   # Vulnerability details  ## Impact  Wrong revert messages might lead to confusion.  ## Proof of Concept  In line 52 of XDEFIDistribution, the reason for a fail of a reentrant call is `"LOCKED"`. In DeFi, it usually means that contract's functionality is temporarily limited. This is not true in this case.  ## Recommended Mitigation Steps  Consider changing the revert string to `"REENTRY_NOT_ALLOWED"`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151  ```solidity     _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached); ```  In the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.   A malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.  As a result, the contract can be malfunctioning and even freeze users' funds in edge cases.  ### PoC  Given:  - bonusMultiplierOf[30 days] = 100  1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`; 2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:  ```solidity     _pointsPerUnit += ((170141183460469 * 2**128) / 1); ```  3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows; 4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days; 5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:   ```solidity     _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1)); ```  6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.    ### Recomandation  Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.  The same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`    https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44  ```solidity constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721("Locked XDEFI", "lXDEFI") {         require((XDEFI = XDEFI_) != address(0), "INVALID_TOKEN");         owner = msg.sender;         baseURI = baseURI_;         _zeroDurationPointBase = zeroDurationPointBase_;          totalUnits = 100_000_000;     } ```  
# Handle  WatchPug   # Vulnerability details  Storage writes (`SSTORE`) to `distributableXDEFI` may not be needed when `previousDistributableXDEFI == currentDistributableXDEFI`, therefore the code can be reorganized to save gas from unnecessary storage writes.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L330-L336  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  ### Recommendation  Change to:  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      newFundsTokenBalance_ = _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);     if (newFundsTokenBalance_ != 0) {         distributableXDEFI = currentDistributableXDEFI;     } } ```  
# Handle  WatchPug   # Vulnerability details  `_zeroDurationPointBase` can be set at deploy time so that locks with 0 duration can get scores.  However, if the value of `_zeroDurationPointBase` is being set high enough. It can potentially be exploited by repeatedly lock(), and unlock() with 0 duration to get scores.  This can get amplified with flashloans.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L245-L247  ```solidity function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {     return amount_ * (duration_ + _zeroDurationPointBase); } ```  ## Recommendation  Consider changing `_zeroDurationPointBase` to a constant of value `1`.  
# Handle  Dravee   # Vulnerability details  ## Impact Code clarity / code style  ## Proof of Concept At the following places, the casts are implicit, whereas the project's style hints at explicit casts everywhere : https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L255 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L269 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L314  ## Tools Used VS Code  ## Recommended Mitigation Steps Use explicit casts everywhere for unsigned integers, as it's the practice everywhere else  
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check (XDEFIDistribution.sol line 255). using double require check can save more gas:   require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");  ## Tools Used  ## Recommended Mitigation Steps require(amount_ != uint256(0), "INVALID_AMOUNT" ); require(amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");  
# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L120-L125  ```solidity=120 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ```  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L175-L180  ```solidity=175 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ``` ### Recommendation  Change to:  ```solidity if (amountUnlocked_ > lockAmount_) {     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_ - lockAmount_); } ```  - Removed a local variable: `withdrawAmount`; - Only do the arithmetic when needed: `amountUnlocked_ - lockAmount_`.  
# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol lines 151, 338-344 Instead of multiplying by _pointsMultiplier, which is 2 ** 128, it is more efficient to shift by 128 (x * (2 ** 128) = x << 128), same for dividing (x / (2 ** 128) = x >> 128) ```sol // line 151 - old _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);  // line 151 - new _pointsPerUnit += ((newXDEFI << 128) / totalUnitsCached);   // lines 338-344 - old return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) / _pointsMultiplier ) + uint256(depositedXDEFI_);  // lines 338-344 - new return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) >> 128 ) + uint256(depositedXDEFI_); ```  
# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol line 332  The "currentDistributableXDEFI" variable is not used (can use distributableXDEFI instead). ```sol // function before: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); }  // function after: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(distributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  
# Handle  WatchPug   # Vulnerability details  In the current implementation, when `_unlockBatch()` is called with `tokenIds_.length == 1`, the transaction will be reverted with an error `USE_UNLOCK`.  Even though it's sub-optimal to use `relockBatch()` and `unlockBatch()` for only 1 tokenId, reverting and requiring the user to resend the transaction to another method still costs more gas than allowing it.  Therefore, we sugguest not to revert in `_unlockBatch()` when `tokenIds_.length == 1`.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L320-L328  ```solidity=320     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > uint256(1), "USE_UNLOCK");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  ### Recommendation  Change to:  ```solidity     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > 0, "NO_TOKEN_IDS");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  
# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  Instances include:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L82-L82  ```solidity require(duration <= uint256(18250 days), "INVALID_DURATION"); ```  Consider changing `uint256(18250 days)` to `MAX_DURATION` constant.   
# Handle  Fitraldys   # Vulnerability details  ## Impact expensive gas, because in the line https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistributionHelper.sol#L23,  the tokenids.length is save to a new variable to be used in the for loop, instead of call tokenids.length directly in the for loop  ## Proof of Concept ``` pragma solidity =0.8.7;  contract pikir {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {                  uint256 alltokens = tokenIds.length;         uint256 hasil;          for (uint256 i; i < alltokens; ++i){                          hasil += 1;          }         return hasil;      }  } //24714 gas  contract pikir2 {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {              uint256 hasil;          for (uint256 i; i < tokenIds.length; ++i){                          hasil += 1;          }         return hasil;      }  } //24710 gas ```  ## Tools Used remix   
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept  In contract `XDEFIDistribution`, the only use of `bonusMultiplier` is to calculate `units` in `_lock`.  In contract `XDEFIDistributionHelper`, `bonusMultiplier` is used for return value. However, `bonusMultiplier` can be calculated by `units * 100 / depositedXDEFI`.  
# Handle  defsec   # Vulnerability details  ## Impact  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint32 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint32 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L301 ```  2. Expiry value is just used for the comparison with the block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint32.  
# Handle  Tomio   # Vulnerability details  ## Impact in function setLockPeriods multiplier can be set to lower than 100 which will break the calculation when dividing the multiplier in function _lock https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268. If the amount times bonus multiplier below 100 the units value will be 0, therefore the totalUnits won't be added but the positionOf[tokenId_] bill be added.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L77 https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268  ## Tools Used  ## Recommended Mitigation Steps in function setLockPeriods need to be add  ```function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {            uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             require(multipliers >= 100); //added             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Extra gas costs from unnecessary casting.  ## Proof of Concept  `pointsCorrection` is stored as a int256 variable.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/interfaces/IXDEFIDistribution.sol#L15  However we can see that this variable is always negative (`_pointsPerUnit` and  `units` are both positive)  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L277  The only usage of `pointsCorrection` is in the `_withdrawableGiven` function as shown below.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L341-L342  ``` (   _toUint256Safe(       _toInt256Safe(_pointsPerUnit * uint256(units_)) +       pointsCorrection_   ) / _pointsMultiplier ) + uint256(depositedXDEFI_); ```  `pointsCorrection` is set to `_pointsPerUnit * uint256(units_)` when locking and `_pointsPerUnit` only increases so we can safely store `pointsCorrection as a positive uint256 (note this is an assumption of the original code as well) and simplify the above expression.  ``` // notice the sign change before `pointsCorrection_` (_pointsPerUnit * uint256(units_) - pointsCorrection_) / _pointsMultiplier + uint256(depositedXDEFI_); ```  We can then remove a significant amount of casting along with the associated costs.  ## Recommended Mitigation Steps  store `pointsCorrection` in a uint256 and subtract rather than add.  
# Handle  Dravee   # Vulnerability details  ## Impact Solidity defines a naming convention that should be followed.  ## Proof of Concept ``` Variable XDEFIDistribution.MAX_TOTAL_XDEFI_SUPPLY (contracts/XDEFIDistribution.sol#14) is not in mixedCase Constant XDEFIDistribution._pointsMultiplier (contracts/XDEFIDistribution.sol#17) is not in UPPER_CASE_WITH_UNDERSCORES Variable XDEFIDistribution._pointsPerUnit (contracts/XDEFIDistribution.sol#18) is not in mixedCase Variable XDEFIDistribution.XDEFI (contracts/XDEFIDistribution.sol#20) is not in mixedCase Variable XDEFIDistribution._zeroDurationPointBase (contracts/XDEFIDistribution.sol#30) is not in mixedCase Variable XDEFIDistribution._locked (contracts/XDEFIDistribution.sol#37) is not in mixedCase Function IXDEFIDistribution.XDEFI() (contracts/interfaces/IXDEFIDistribution.sol#37) is not in mixedCase ```  ## Tools Used Slither  ## Recommended Mitigation Steps Follow the Solidity naming convention: https://docs.soliditylang.org/en/v0.4.25/style-guide.html#naming-conventions  
# Handle  onewayfunction   # Vulnerability details  ## Impact The owner of the `XDEFIDistribution` contract can use flash loans to atomically steal XDEFI from the contract without taking on any capital risk.  ## Proof of Concept In my previous submission, "Anyone can steal XDEFI from the `XDEFIDistribution` contract and make the contract insolvent", I showed how any user can use the `onERC721Received` hook of the `_safeMint` function to steal XDEFI tokens from the contract and generally bork the contract's accounting. The attacker in that case took on some risk proportional to the minimum allowable `duration` and was limited in the amount they could steal based on their own capital available (how much XDEFI they had to use during the malicious lockup).  However, when a similar attack is performed by the `owner` of the `XDEFIDistribution` contract, it can be done (1) without the owner taking on any risk at all and (2) the owner can use flashloans to dramatically increase the amount of XDEFI they can steal.  In particular, the owner can perform all of the following in a single transaction (or in a single flashbots bundle):  First, the owner can call the [`setLockPeriods` function](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77) to allow `0` duration locks with a large `multiplier`.  Next, they can flash borrow as much XDEFI as possible from DEXs and loaning platforms. Call this amount of XDEFI `X`.  Then they do a (normal) `0` duration lock with `X/2` XDEFI. This could give them a large proportion of locked XDEFI.  Next, they do the "malicious lock" technique that I previously reported, using the remaining `X/2` XDEFI. This means that their first lock with be able to withdraw more than `X/2` XDEFI when they unlock.  Then, in the same transaction -- which is possible because they are using a `0` duration lock -- they can unlock both thier first "normal" lock, as well as their "malicious" lock, giving them more than `X` XDEFI in total.  They can repay the flash loan, and keep the difference.  Since the never have to hold a lock for any positive duration, and never even have to have any exposure to XDEFI, the attack is risk free for them. And since they can use flash loans, they'll likely have access to dramatically more capital than a non-owner (who can't use flash loans) could.   ## Recommended Mitigation Steps  In addition to the "use `_mint()` instead of `_safeMint()`" suggestion from the previous submission, I also recommend adding a `require(duration > 0, "INVALID_DURATION");` statement just above [L82](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L82).  Not only will disallowing `0` duration locks prevent most flashloan shenanigans by the owner, it would also help prevent sandwich attacks that steal incoming distributableX DEFI tokens by sandwiching such incoming txs with a `lock` and `unlock` transaction.  
# Handle  Dravee   # Vulnerability details  ## Impact   Waste of gas due to unnecessary underflow checks  ## Proof of Concept   On `XDEFIDistribution.sol:120` and `XDEFIDistribution.sol:175`, you can find the following substraction: `uint256 withdrawAmount = amountUnlocked_ - lockAmount_;`  However, as the Solidity version is 0.8.10, default overflow and underflow checks are made, which cost some gas.  You can save this gas with the `unchecked` keyword to bypass these checks as 5 lines above (L115 and L170), a `require` statement already checks that `lockAmount_ <= amountUnlocked_`.   Therefore, no underflow is possible.  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the "unchecked" keyword   
# Handle  PierrickGT   # Vulnerability details  ## Impact In [lockWithPermit](https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L99), we use the same code to transfer XDEFI and lock the position than in [lock](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L92-96). We can create an internal function to reuse this code and avoid duplication.  ## Proof of Concept Create an internal function called `_lockPosition` that will transfer XDEFI and lock the position. This function will be called in `lock` and `lockWithPermit`.  ## Recommended Mitigation Steps The following change is recommended.  ``` function _lockPosition(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Lock the XDEFI in the contract.     SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);      // Handle the lock position creation and get the tokenId of the locked position.     return _lock(amount_, duration_, destination_); }  function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {     return _lockPosition(amount_, duration_, destination_); }  function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {     // Approve this contract for the amount, using the provided signature.     IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);      return _lockPosition(amount_, duration_, destination_); } ```  
# Handle  cccz   # Vulnerability details  ## Impact  In the setLockPeriods function, there is no verification of the multipliers parameter, multipliers[i] may be 0, and the length of multipliers may not be equal to the length of durations_.  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77-L85  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { +      require(durations_.length == multipliers.length);         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i]; +         require(multipliers[i] != 0);             require(duration <= uint256(18250 days), "INVALID_DURATION");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```    
# Handle  agusduha   # Vulnerability details  ## Impact  MAX_TOTAL_XDEFI_SUPPLY has always the same value and is used only in one place, it should be constant to optimize gas  ## Proof of Concept  Variable declaration: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  Variable utilization: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the "constant" keyword to the storage variable declaration  
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from [https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory](https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory) :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   interfaces\IXDEFIDistribution.sol:55:    function baseURI() external view returns (string memory baseURI_); interfaces\IXDEFIDistribution.sol:74:    function setBaseURI(string memory baseURI_) external; interfaces\IXDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external; interfaces\IXDEFIDistribution.sol:106:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external returns (uint256 amountUnlocked_, uint256  newTokenId_); interfaces\IXDEFIDistribution.sol:109:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external returns (uint256 amountUnlocked_); interfaces\IXDEFIDistribution.sol:119:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_); interfaces\IXDEFIDistribution.sol:125:    function tokenURI(uint256 tokenId_) external view returns (string memory tokenURI_); XDEFIDistribution.sol:73:    function setBaseURI(string memory baseURI_) external onlyOwner { XDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { XDEFIDistribution.sol:165:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256  newTokenId_) { XDEFIDistribution.sol:186:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) { XDEFIDistribution.sol:205:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.  
# Handle  cccz   # Vulnerability details  ## Impact  There is a reentrancy vulnerability in the _safeMint function  ```     function _safeMint(         address to,         uint256 tokenId,         bytes memory _data     ) internal virtual {         _mint(to, tokenId);         require(             _checkOnERC721Received(address(0), to, tokenId, _data),             "ERC721: transfer to non ERC721Receiver implementer"         );     }     ...     function _checkOnERC721Received(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) private returns (bool) {         if (to.isContract()) {             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {                 return retval == IERC721Receiver.onERC721Received.selector; ```  The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function  ```     function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {         // Lock the XDEFI in the contract.         SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);          // Handle the lock position creation and get the tokenId of the locked position.         return _lock(amount_, duration_, destination_);     }     ...         function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {         // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.         require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");          // Get bonus multiplier and check that it is not zero (which validates the duration).         uint8 bonusMultiplier = bonusMultiplierOf[duration_];         require(bonusMultiplier != uint8(0), "INVALID_DURATION");          // Mint a locked staked position NFT to the destination.         _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));          // Track deposits.         totalDepositedXDEFI += amount_;  ``` Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.   ```      function updateDistribution() external {         uint256 totalUnitsCached = totalUnits;          require(totalUnitsCached> uint256(0), "NO_UNIT_SUPPLY");          uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());          if (newXDEFI == uint256(0)) return;          _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);          emit DistributionUpdated(msg.sender, newXDEFI);     }     ...     function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {         uint256 previousDistributableXDEFI = distributableXDEFI;         uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;          return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);     }   ``` If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user   ```      function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {         // Handle the unlock and get the amount of XDEFI eligible to withdraw.         amountUnlocked_ = _unlock(msg.sender, tokenId_);          // Send the the unlocked XDEFI to the destination.         SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);          // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.         _updateXDEFIBalance();     } ...      function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {         // Check that the account is the position NFT owner.         require(ownerOf(tokenId_) == account_, "NOT_OWNER");          // Fetch position.         Position storage position = positionOf[tokenId_];         uint96 units = position.units;         uint88 depositedXDEFI = position.depositedXDEFI;         uint32 expiry = position.expiry;          // Check that enough time has elapsed in order to unlock.         require(expiry != uint32(0), "NO_LOCKED_POSITION");         require(block.timestamp >= uint256(expiry), "CANNOT_UNLOCK");          // Get the withdrawable amount of XDEFI for the position.         amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);          // Track deposits.         totalDepositedXDEFI -= uint256(depositedXDEFI);          // Burn FDT Position.         totalUnits -= units;         delete positionOf[tokenId_];          emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);     }     ...      function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {         return             (                 _toUint256Safe(                     _toInt256Safe(_pointsPerUnit * uint256(units_)) +                     pointsCorrection_                 ) / _pointsMultiplier             ) + uint256(depositedXDEFI_);     }  ``` ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ``` -    function updateDistribution() external  { +    function updateDistribution() external  noReenter { ```  
# Handle  Dravee   # Vulnerability details  ## Impact   Custom errors from Solidity 0.8.4 are cheaper than revert strings.    ## Proof of Concept   Source: https://blog.soliditylang.org/2021/04/21/custom-errors/:  Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```   XDEFIDistribution.sol:40:        require((XDEFI = XDEFI_) != address(0), "INVALID_TOKEN"); XDEFIDistribution.sol:47:        require(owner == msg.sender, "NOT_OWNER"); XDEFIDistribution.sol:52:        require(_locked == 0, "LOCKED"); XDEFIDistribution.sol:63:        require(pendingOwner == msg.sender, "NOT_PENDING_OWNER"); XDEFIDistribution.sol:82:            require(duration <= uint256(18250 days), "INVALID_DURATION"); XDEFIDistribution.sol:115:        require(lockAmount_ <= amountUnlocked_, "INSUFFICIENT_AMOUNT_UNLOCKED"); XDEFIDistribution.sol:145:        require(totalUnitsCached > uint256(0), "NO_UNIT_SUPPLY"); XDEFIDistribution.sol:170:        require(lockAmount_ <= amountUnlocked_, "INSUFFICIENT_AMOUNT_UNLOCKED"); XDEFIDistribution.sol:207:        require(count > uint256(1), "MIN_2_TO_MERGE"); XDEFIDistribution.sol:214:            require(ownerOf(tokenId) == msg.sender, "NOT_OWNER"); XDEFIDistribution.sol:215:            require(positionOf[tokenId].expiry == uint32(0), "POSITION_NOT_UNLOCKED");  XDEFIDistribution.sol:227:        require(_exists(tokenId_), "NO_TOKEN"); XDEFIDistribution.sol:232:        require(_exists(tokenId_), "NO_TOKEN"); XDEFIDistribution.sol:255:        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT"); XDEFIDistribution.sol:259:        require(bonusMultiplier != uint8(0), "INVALID_DURATION"); XDEFIDistribution.sol:295:        require(ownerOf(tokenId_) == account_, "NOT_OWNER"); XDEFIDistribution.sol:304:        require(expiry != uint32(0), "NO_LOCKED_POSITION"); XDEFIDistribution.sol:305:        require(block.timestamp >= uint256(expiry), "CANNOT_UNLOCK"); XDEFIDistribution.sol:322:        require(count > uint256(1), "USE_UNLOCK"); ```      ## Tools Used   VS Code    ## Recommended Mitigation Steps   Replace revert strings with custom errors.   
# Handle  leastwood   # Vulnerability details  ## Impact  NFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.  When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.  This edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.  ## Proof of Concept  ``` function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.     require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, "INVALID_AMOUNT");      // Get bonus multiplier and check that it is not zero (which validates the duration).     uint8 bonusMultiplier = bonusMultiplierOf[duration_];     require(bonusMultiplier != uint8(0), "INVALID_DURATION");      // Mint a locked staked position NFT to the destination.     _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));      // Track deposits.     totalDepositedXDEFI += amount_;      // Create Position.     uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));     totalUnits += units;     positionOf[tokenId_] =         Position({             units: units,             depositedXDEFI: uint88(amount_),             expiry: uint32(block.timestamp + duration_),             created: uint32(block.timestamp),             bonusMultiplier: bonusMultiplier,             pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)         });      emit LockPositionCreated(tokenId_, destination_, amount_, duration_); } ```  ``` function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {     // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.     return (points_ << uint256(128)) + uint128(totalSupply() + 1); } ```  ``` function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {     uint256 count = tokenIds_.length;     require(count > uint256(1), "MIN_2_TO_MERGE");      uint256 points;      // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.     for (uint256 i; i < count; ++i) {         uint256 tokenId = tokenIds_[i];         require(ownerOf(tokenId) == msg.sender, "NOT_OWNER");         require(positionOf[tokenId].expiry == uint32(0), "POSITION_NOT_UNLOCKED");          _burn(tokenId);          points += _getPointsFromTokenId(tokenId);     }      // Mine a new NFT to the destinations, based on the accumulated points.     _safeMint(destination_, tokenId_ = _generateNewTokenId(points)); } ```  ## Tools Used  Manual code review. Discussions with Michael.  ## Recommended Mitigation Steps  Consider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In Contract **XDEFIDistribution** the function **setBaseURI** is missing an event for this admin functionality.  ## Impact Users can't monitor admin changes done to the contract to reflect it in their clients.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps create event for base URI changes and emit it.  
# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          XDEFIDistribution.sol : reachable assert in line 284         XDEFIDistribution.sol : reachable assert in line 288  
# Handle  robee   # Vulnerability details   The following requires has a non comprehensive messages.  This is very important to add a comprehensive message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: XDEFIDistribution.sol, In line 227 with Require message: NO_TOKEN         Solidity file: XDEFIDistribution.sol, In line 232 with Require message: NO_TOKEN    
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: XDEFIDistribution.sol, i, 80         just change to unchecked: XDEFIDistribution.sol, i, 212         just change to unchecked: XDEFIDistribution.sol, i, 325         just change to unchecked: XDEFIDistributionHelper.sol, i, 15         just change to unchecked: XDEFIDistributionHelper.sol, i, 29         just change to unchecked: XDEFIDistributionHelper.sol, i, 42   
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           XDEFIDistributionHelper.sol, variable name: tokenIds times: 3 at: getAllLockedPositionsForAccount   
# Handle  robee   # Vulnerability details   The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function withdrawableOf in XDEFIDistribution.sol could be set external         The function tokenURI in XDEFIDistribution.sol could be set external         The function getAllTokensForAccount in XDEFIDistributionHelper.sol could be set external         The function getAllLockedPositionsForAccount in XDEFIDistributionHelper.sol could be set external    
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs of all locking operations.  ## Proof of Concept  XDEFIDistribution.sol stores the total supply of the XDEFI token:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  This is so that the amount being locked can be checked to be less than this on each call  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  This is unnecessary as the XDEFI token has no external mint function and so has a fixed supply. It's then impossible for any user to supply more than 240M XDEFI in order to fail this check.  https://etherscan.io/address/0x72b886d09c117654ab7da13a14d603001de0b777#code  ## Recommended Mitigation Steps  Remove the unnecessary check on the total supply.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduced readability  ## Proof of Concept  In a number of placed we seem to be inlining an assignment with the usage of that variable:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L40  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L70  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L83  This is quite atypical in my experience and reduces readability: lines which contain require statements and event emission now modify contract storage.  ## Recommended Mitigation Steps  Consider whether any small benefits to gas/compactness are worth the reduced clarity.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduction of potential gas refunds.  ## Proof of Concept  The reentrancy guard variable is initially set to zero, set to a nonzero value and then reset to zero:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  We then have to the higher cost for writing to clean storage rather than dirty storage (which is then refunded). This is not recommended as it can cause the size of the gas refunded to users to be capped. For more info see the OZ implementation:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  ## Recommended Mitigation Steps  Change from 0->1->0 to 1->2->1  
