## Low ### Use a 2 step procedure to update feeManager Use a 2 step procedure to update feeManager to reduce risk of burning the admin key https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L53-L57  ```solidity     function setFeeManager(address _feeManager) external {         require(msg.sender == feeManager, "!auth");         feeManager = _feeManager;         emit FeeManagerUpdated(_feeManager);     } ```  ## Non Critical ### Outdated Solidity Consider upgrade to latest 0.8.14
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576   # Vulnerability details  ## Proof-of-Concept  The `Booster.setFeeInfo` function is responsible for setting the allocation of gauge fees between lockers and $VE3D stakers.  `lockFeesIncentive` and `stakerLockFeesIncentive` should add up to `10000` , which is equivalent to `100%`.  However, there is no validation check to ensure that that `_lockFeesIncentive` and `_stakerLockFeesIncentive` add up to `10000`. Thus, it entirely depends on the developer to get these two values right.  As such, it is possible to set `lockFeesIncentive + takerLockFeesIncentive` to be less than `100%`. This might happen due to human error. For instance, a typo (forget a few zero) or newly joined developer might not be aware of the fee denomination and called `setFeeInfo(40, 60)` instead of `setFeeInfo(4000, 6000)`.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193)  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, "!auth");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  Assume that `setFeeInfo(40, 60)` is called instead of of `setFeeInfo(4000, 6000)`, only `1%` of the fee collected will be transferred to the users and the remaining `99%` of the fee collected will be stuck in the `Booster` contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576)  ```solidity function earmarkFees() external returns (bool) {     //claim fee rewards     IStaker(staker).claimFees(feeDistro, feeToken);     //send fee rewards to reward contract     uint256 _balance = IERC20(feeToken).balanceOf(address(this));      uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);     uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(         FEE_DENOMINATOR     );     if (_lockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);         IRewards(lockFees).queueNewRewards(_lockFeesIncentive);     }     if (_stakerLockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);         IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);     }     return true; } ```  ### Can we retrieve or "save" the tokens stuck in `Booster` contract?  Any veAsset (e.g. CRV, ANGLE) sitting on the `Booster` contract is claimable. However, in this case, the `feeToken` is likely not a veAsset, thus the remaining gauge fee will be stuck in the `Booster` contract perpetually. For instance, in Curve, the gauge fee is paid out in 3CRV, the LP token for the TriPool. ([Source](https://resources.curve.fi/crv-token/understanding-crv#staking-trading-fees))  ## Impact  Users will lost their gauge fee if this happens.  ## Recommended Mitigation Steps  Implement validation check to ensure that `lockFeesIncentive` and `takerLockFeesIncentive` add up to 100% to eliminate any risk of misconfiguration.  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, "!auth");     require(_lockFeesIncentive + _stakerLockFeesIncentive == FEE_DENOMINATOR, "Invalid fees");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495   # Vulnerability details  > Note: This report aims to discuss the issue encountered when `ExtraRewardStashV3` is used within Angle Deployment. There is also another issue when `ExtraRewardStashV2` is used within Angle Deployment, but I will raise it in a separate report since `ExtraRewardStashV2` and `ExtraRewardStashV3` operate differently, and the proof-of-concept and mitigation are different too.  ## Proof-of-Concept  In this example, assume the following Angle's gauge setup  > Name = Angle sanDAI_EUR Gauge > > Symbol = SsanDAI_EUR > > reward_count = 2 > > reward_tokens(0) = ANGLE > > reward_tokens(1) = DAI > > Gauge Contract: [LiquidityGaugeV4.vy](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy) > > Stash Contract: [ExtraRewardStashV3](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol)  To collect the gauge rewards, users would trigger the `Booster._earmarkRewards` function to claim veAsset and extra rewards from a gauge.   Per the code logic, the function will attempt to execute the following two key operations:  1) First Operation -  Claim the veAsset by calling `VoterProxy.claimVeAsset`. Call Flow as follow: `VoterProxy.claimVeAsset() > IGauge(_gauge).claim_rewards()`. 2) Second Operation - Claim extra rewards by calling `ExtraRewardStashV3.claimRewards`. Call flow as follows: `ExtraRewardStashV3.claimRewards > Booster.claimRewards > VoterProxy.claimRewards > IGauge(_gauge).claim_rewards()` .   Note that`IGauge(_gauge).claim_rewards()` will claim all available reward tokens from the Angle's gauge.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495)  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {     PoolInfo storage pool = poolInfo[_pid];     require(pool.shutdown == false, "pool is closed");      address gauge = pool.gauge;      //claim veAsset     IStaker(staker).claimVeAsset(gauge);      //check if there are extra rewards     address stash = pool.stash;     if (stash != address(0)) {         //claim extra rewards         IStash(stash).claimRewards();         //process extra rewards         IStash(stash).processStash();     }  ..SNIP.. } ```  ### First Operation -  Claim the veAsset  Since this is a Angle Deployment, when the `VoterProxy.claimVeAsset` is triggered,  it will go through the if-else logic (`escrowModle == IVoteEscrow.EscrowModle.ANGLE`) and execute ` IGauge(_gauge).claim_rewards()`, and all rewards tokens will be sent to `VoterProxy` contract. Assume that `100 ANGLE` and `100 DAI` were received.  Note that in this example, we have two reward tokens (ANGLE and DAI). Additionally, gauge redirection was not configured on the gauge at this point, thus the gauge rewards will be sent to the caller, which is the `VoterProxy` contract.  Subsequently, the code `IERC20(veAsset).safeTransfer(operator, _balance);` will be executed, and veAsset (`100 ANGLE`) reward tokens will be transferred to the `Booster` contract for distribution. However, the `100 DAI` reward tokens will remain stuck in the `VoterProxy` contract. As such, users will not be able to get any reward tokens (e.g. DAI, WETH) except veAsset (ANGLE) tokens from the gauges.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224)  ```solidity function claimVeAsset(address _gauge) external returns (uint256) {     require(msg.sender == operator, "!auth");      uint256 _balance = 0;      if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {         try IGauge(_gauge).getReward() {} catch {             return _balance;         }     } else if (         escrowModle == IVoteEscrow.EscrowModle.CURVE ||         escrowModle == IVoteEscrow.EscrowModle.RIBBON     ) {         try ITokenMinter(minter).mint(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {         try ITokenMinter(minter).distribute(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {         try IGauge(_gauge).claim_rewards() {} catch {             return _balance;         }     }      _balance = IERC20(veAsset).balanceOf(address(this));     IERC20(veAsset).safeTransfer(operator, _balance);      return _balance; } ```  Following is Angle's Gauge Contract for reference:  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344)  (Mainnet Deployed Address: https://etherscan.io/address/0x8E2c0CbDa6bA7B65dbcA333798A3949B07638026)   > Note: Angle Protocol is observed to use LiquidityGaugeV4 contract for all of their gauges. Thus, ExtraRewardStashV3 is utilised during pool creation.  ```python @external @nonreentrant('lock') def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):     """     @notice Claim available reward tokens for `_addr`     @param _addr Address to claim for     @param _receiver Address to transfer rewards to - if set to                      ZERO_ADDRESS, uses the default reward receiver                      for the caller     """     if _receiver != ZERO_ADDRESS:         assert _addr == msg.sender  # dev: cannot redirect when claiming for another user     self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver) ```  ### Second Operation - Claim extra rewards  After the `IStaker(staker).claimVeAsset(gauge);` code within the `Booster._earmarkRewards` function is executed, `IStash(stash).claimRewards();`  and `IStash(stash).processStash();` functions will be executed next. `stash` == `ExtraRewardStashV3`.  The `ExtraRewardStashV3.claimRewards` will call the `Booster.setGaugeRedirect` first so that all the gauge rewards will be redirected to `ExtraRewardStashV3` stash contract. Subsequently, `ExtraRewardStashV3.claimRewards` will trigger `Booster.claimRewards` to claim the gauge rewards from the Angle's gauge.   Note that this is the second time the contract attempts to claim gauge rewards from the gauge. Thus, no gauge rewards will be received since we already claimed them earlier. Next, `ExtraRewardStashV3` will attempt to process all the tokens stored in its contract and send them to the respective reward contracts for distribution to the users. However, the contract does not have any tokens stored in it because the earlier attempt to claim gauge rewards return nothing.  As we can see, the DAI reward tokens are still stuck in the `VoterProxy` contract at this point.  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332)  ```python def set_rewards_receiver(_receiver: address):     """     @notice Set the default reward receiver for the caller.     @dev When set to ZERO_ADDRESS, rewards are sent to the caller     @param _receiver Receiver address for any rewards claimed via `claim_rewards`     """     self.rewards_receiver[msg.sender] = _receiver ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61)  ```solidity //try claiming if there are reward tokens registered function claimRewards() external returns (bool) {     require(msg.sender == operator, "!authorized");      //this is updateable from v2 gauges now so must check each time.     checkForNewRewardTokens();      //make sure we're redirected     if (!hasRedirected) {         IDeposit(operator).setGaugeRedirect(pid);         hasRedirected = true;     }      uint256 length = tokenCount;     if (length > 0) {         //claim rewards on gauge for staker         //using reward_receiver so all rewards will be moved to this stash         IDeposit(operator).claimRewards(pid, gauge);     }     return true; } ```  ## Impact  User's gauge rewards are frozen/stuck in `VoterProxy` contract. Additionally, there is no method to sweep/collect the reward tokens stuck in the `VoterProxy` contract.  ## Recommended Mitigation Steps  > Note: I do not see `Booster.setGaugeRedirect` being called in the deployment and testing scripts. Thus, it is fair to assume that the team is not aware of the need to trigger `Booster.setGaugeRedirect` during deployment. If the gauge redirection has been set to the stash contract `ExtraRewardStashV3` right from the start before anyone triggered the `earmarkRewards` function, this issue should not occur.  Consider triggering `Booster.setGaugeRedirect` during the deployment to set gauge redirection to stash contract (`ExtraRewardStashV3`) so that the Angle's gauge rewards will not be redirected to `VoterProxy` contract and get stuck there.  Alternatively, update the `Booster._earmarkRewards` to as follows:  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {  PoolInfo storage pool = poolInfo[_pid];  require(pool.shutdown == false, "pool is closed");   address stash = pool.stash;  if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {   //claims gauges rewards   IStash(stash).claimRewards();   //process gauges rewards   IStash(stash).processStash();  } else {   //claim veAsset         IStaker(staker).claimVeAsset(gauge);          //check if there are extra rewards         address stash = pool.stash;         if (stash != address(0)) {             //claim extra rewards             IStash(stash).claimRewards();             //process extra rewards             IStash(stash).processStash();         }  }   //veAsset balance     uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));  ..SNIP.. } ```  There is no need to specifically call `VoterProxy.claimVeAsset` to fetch ANGLE for Angle Protocol because calling `IStash(stash).claimRewards()` will fetch both ANGLE and other reward tokens from the gauge anyway. When the stash contract receives the ANGLE tokens, it will automatically transfer all of them back to `Booster` contract when `IStash(stash).processStash()` is executed. The `IStash(stash).claimRewards()` function also performs a sanity check to ensure that the gauge redirection is pointing to itself before claiming the gauge rewards, and automatically configure them if it is not, so it will not cause the reward tokens to get stuck in `VoterProxy` contract.  - Curve uses an older version of LiquidityGauge contract. Thus, two calls are needed (`Minter.mint` to claim CRV and `LiquidityGauge.claim_rewards` to claim other rewards).   - Angle uses newer version of LiquidityGauge (V4) contract that just need one function call (`LiquidityGauge.claim_rewards` ) to fetch both veAsset and other rewards. - IDLE uses LiquidityGauge (V3) contract. veAsset (IDLE) is minted by calling `DistributorProxy.distribute` and gauge rewards are claimed by calling `LiquidityGauge.claim_rewards`.  Due to the discrepancies between different protocols in the reward claiming process, additional care must be taken to ensure that the flow of veAsset and gauge rewards are transferred to the appropriate contracts during integration. Otherwise, rewards will be stuck.  Lastly, I only see test cases written for claiming veAsset from the gauge. For completeness, it is recommended to also write test cases for claiming extra rewards from the gauge apart from veAsset.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48   # Vulnerability details  ## Vulernability Details  It was observed that users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws $VE3D token from the `VeTokenMinter` contract.  ## Proof-of-Concept  Based on the deployment script, it was understood that at the start of the project deployment, 30 million $VE3D tokens will be pre-minted for the `VeTokenMinter` contract. Thus, the `veToken.balanceOf(VeTokenMinter.address)` will be 30 million $VE3D tokens after the deployment.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18)  ```javascript // vetoken minter await deployer.deploy(VeTokenMinter, veTokenAddress); let vetokenMinter = await VeTokenMinter.deployed(); addContract("system", "vetokenMinter", vetokenMinter.address); global.created = true; //mint vetoke to minter contract const vetoken = await VeToken.at(veTokenAddress); await vetoken.mint(vetokenMinter.address, web3.utils.toWei("30000000"), { from: vetokenOperator }); addContract("system", "vetoken", veTokenAddress); ```  In the `VeTokenMinter ` contract, there is a function called `VeTokenMinter.withdraw` that allows the admin to withdraw $VE3D tokens from the contract. Noted that this withdraw function only perform the transfer, but did not update any of the state variables (e.g. totalSupply, maxSupply) in the contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77)  ```solidity function withdraw(address _destination, uint256 _amount) external onlyOwner {     veToken.safeTransfer(_destination, _amount);      emit Withdraw(_destination, _amount); } ```  Assuming that an admin withdrawed 29 million $VE3D tokens from the `VoteProxy` with the appropriate approval from the DAO or community for some valid purposes. The `veToken.balanceOf(VeTokenMinter.address)` will be 1 million $VE3D tokens after the withdrawal.  At this point, notice that `veToken.balanceOf(VeTokenMinter.address)` is 1 million, while the `VeTokenMinter.maxSupply` constant is 30 million. Therefore, there exists a discrepency between the actual amount of $VE3D tokens (1 million) stored in the contact versus the max supply (30 million).  This discrepency will cause an issue in the `VeTokenMinter.mint` function because the calculation of the amount of $VE3D tokens to be transferred is based on the fact that 30 million $VE3D tokens is always sitting in the `VeTokenMinter` contract, and thus there is always sufficient $VE3D tokens available in the `VeTokenMinter` contract to send to its users.  The `uint256 amtTillMax = maxSupply.sub(supply);` code shows that the calculation is based on `maxSupply` constant, which is 30 million.  Assume that `mint(0x001, 10 million)` is called, and the value of the state variables when stepping through this function are as follows:  - `maxSupply` constant = 30 million - `veToken.balanceOf(VeTokenMinter.address)` = 1 million - `supply` & `totalSupply` = 20 million - `totalCliffs` = 1000 - `reductionPerCliff ` = 30,000 (maxSupply / totalCliffs) - `cliff` = 666 (supply/reductionPerCliff) - `reduction` = 1000 - 666 = 334 - `_amount` = 10 million * (334/1000) = 3.340 million - `amtTillMax` = 10 million (maxSupply - supply) (Over here the contract assume that it still has 10 million VE3D tokens more to reach the max supply) - `(_amount > amtTillMax)` = `False` (since "3.340 million > 10 million" = false ) - `veToken.safeTransfer(0x001, 3.340 million)` (This will revert. Insufficent balance)  The `veToken.safeTransfer(0x001, 3.340 million` will fail and revert because `VeTokenMinter` contract does not hold sufficent amount of $VE3D tokens to transfer out.`veToken.balanceOf(VeTokenMinter.address)` = 1 million, while the contract was attempting to send out 3.340 million.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48)  ```solidity function mint(address _to, uint256 _amount) external {     require(operators.contains(_msgSender()), "not an operator");      uint256 supply = totalSupply;      //use current supply to gauge cliff     //this will cause a bit of overflow into the next cliff range     //but should be within reasonable levels.     //requires a max supply check though     uint256 cliff = supply.div(reductionPerCliff);     //mint if below total cliffs     if (cliff < totalCliffs) {         //for reduction% take inverse of current cliff         uint256 reduction = totalCliffs.sub(cliff);         //reduce         _amount = _amount.mul(reduction).div(totalCliffs);          //supply cap check         uint256 amtTillMax = maxSupply.sub(supply);         if (_amount > amtTillMax) {             _amount = amtTillMax;         }          //mint         veToken.safeTransfer(_to, _amount);         totalSupply += _amount;     } } ```  The failure/revert of `VeTokenMinter.mint` function will cascade up to `Booster.rewardClaimed`, and futher cascade up to `BaseRewardPool.getReward`. Thus, `BaseRewardPool.getReward` will stop working. As a result, the users will not be able to get any rewards from the reward contracts.   This issue will affect all projects (Curve, Pickle, Ribbon, Idle, Angle, Balancer) because `VeTokenMinter ` contract is deployed once, and referenced by all the projects. Thus, the impact could be quite widespread if this occurs, and many users would be affected.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598)  ```solidity function rewardClaimed(     uint256 _pid,     address _address,     uint256 _amount ) external returns (bool) {     address rewardContract = poolInfo[_pid].veAssetRewards;     require(msg.sender == rewardContract || msg.sender == lockRewards, "!auth");     ITokenMinter veTokenMinter = ITokenMinter(minter);     //calc the amount of veAssetEarned     uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(         veTokenMinter.totalWeight()     );     //mint reward tokens     ITokenMinter(minter).mint(_address, _veAssetEarned);      return true; } ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267)  ```solidity function getReward(address _account, bool _claimExtras)     public     updateReward(_account)     returns (bool) {     uint256 reward = earned(_account);     if (reward > 0) {         rewards[_account] = 0;         rewardToken.safeTransfer(_account, reward);         IDeposit(operator).rewardClaimed(pid, _account, reward);         emit RewardPaid(_account, reward);     }      //also get rewards from linked rewards     if (_claimExtras) {         for (uint256 i = 0; i < extraRewards.length; i++) {             IRewards(extraRewards[i]).getReward(_account);         }     }     return true; } ```  ## Recommended Mitigation Steps  Remove the `VeTokenMinter.withdraw` function if possible. Otherwise, update the internal accounting of `VeTokenMinter` contract during withdrawal so that the actual balance of the $VE3D tokens is taken into consideration within the `VeTokenMinter.mint`, and the contract will not attempt to transfer more tokens than what it has.  On a side note, [Convex's Minter contract](https://github.com/convex-eth/platform/blob/main/contracts/contracts/Cvx.sol), will mint the `CRX` gov tokens to the users on the fly. See https://github.com/convex-eth/platform/blob/1f11027d429e454dacc4c959502687eaeffdb74a/contracts/contracts/Cvx.sol#L76. Thus, there will not be a case where there is not sufficient `CRV` tokens in the contract to send to it users.  However, in VeToken Protocol, it attempts to transfer the portion of pre-minted $VE3D tokens (30 millions) to the users. See https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L72. Thus, it is possible that there is not enough $VE3D tokens to send to its users if the admin withdraw the pre-minted $VE3D tokens.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46   # Vulnerability details  ## Impact The admin may fat-finger a change, or be malicious, and have the weights be extreme - ranging from zero to `type(uint256).max`, which would cause the booster to pay out unexpected amounts  ## Proof of Concept No bounds checks in the update function: ```solidity File: contracts/VeTokenMinter.sol   #1  41       function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner { 42           require(operators.contains(veAssetOperator), "not an veAsset operator"); 43           totalWeight -= veAssetWeights[veAssetOperator]; 44           veAssetWeights[veAssetOperator] = newWeight; 45           totalWeight += newWeight; 46       } ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46  The value is used by the reward contract to determine how much to mint: ```solidity File: contracts/Booster.sol   #2  598       function rewardClaimed( 599           uint256 _pid, 600           address _address, 601           uint256 _amount 602       ) external returns (bool) { 603           address rewardContract = poolInfo[_pid].veAssetRewards; 604           require(msg.sender == rewardContract || msg.sender == lockRewards, "!auth"); 605           ITokenMinter veTokenMinter = ITokenMinter(minter); 606           //calc the amount of veAssetEarned 607           uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div( 608               veTokenMinter.totalWeight() 609           ); 610           //mint reward tokens 611           ITokenMinter(minter).mint(_address, _veAssetEarned); ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598-L611  Wrong values will lead to excessive inflation/deflation  ## Tools Used Code inspection  ## Recommended Mitigation Steps Have sane upper/lower limits on the values   
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L356 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L337   # Vulnerability details  As arbitrary ERC20 tokens can be passed, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. Also, it's a good practice for the future of the solution.  Affected code:  - File: Booster.sol  ```solidity 345:     function deposit( 346:         uint256 _pid, 347:         uint256 _amount, 348:         bool _stake 349:     ) public returns (bool) { ... 356:         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); //@audit medium: not compatible with Fee On Transfer Tokens ... 372:             ITokenMinter(token).mint(address(this), _amount); ... 374:             IERC20(token).safeApprove(rewardContract, _amount); 375:             IRewards(rewardContract).stakeFor(msg.sender, _amount); ... 378:             ITokenMinter(token).mint(msg.sender, _amount); ... 381:         emit Deposited(msg.sender, _pid, _amount); ... ```  - File: VE3DRewardPool.sol  ```solidity 336:     function donate(address _rewardToken, uint256 _amount) external { 337:         IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount); //@audit medium: not compatible with Fee On Transfer Tokens 338:         rewardTokenInfo[_rewardToken].queuedRewards += _amount; 339:     } ```  ## Recommended Mitigation Steps  Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299 https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152   # Vulnerability details  Project veToken is supposed to be a generalized version of Convex for non-Curve token. There is only one contract for all rewards token in the platform.  All ve3Token rewards are bundled together inside `ve3DLocker` and `ve3DRewardPool` in a loop. Instead of having its own unique contract like `VeAssetDepositer` or `VoterProxy` for each token.  ## Impact  If one token has pausable transfer, user cannot claim rewards or withdraw if they have multiple rewards include that pause token.  Right now the project intends to support only 6 tokens, including Ribbon token which has [pausable transfer](https://etherscan.io/address/0x6123b0049f904d730db3c36a31167d9d4121fa6b#code#L810) controlled by Ribbon DAO.  Normally, this would not be an issue in Convex where only a few pools would be affected by single coin. Since, veAsset are bundled together into single reward pool, it becomes a major problem.  ## Proof of concept  - Token like Ribbon pause token transfer by DAO due to an unfortunate event. - `VE3DRewardPool` try call `getReward()`, `VeAssetDepositor` [try deposit token from earned rewards](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299) does not work anymore because `IERC20.transfer` [is blocked](https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152). This effectively reverts current function if user have this token reward > 0.  ## Recommended mitigation step  It would be a better practice if we had a second `getReward()` function that accepts an array of token that we would like to interact with. It saves gas and only requires some extra work on frontend website. Instead of current implementation, withdraw all token bundles together.   
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L305-L329 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L349-L373 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L376-L396 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L399-L415   # Vulnerability details  ```solidity function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {     uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(         rewardsDuration     );     uint256 cutoffEpoch = epochStart.sub(lockDuration);      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) <= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; } ````  In `VE3DLocker.sol`, there are multiple instances in which an inversely traverse for loop is used "to make more current queries more gas efficient".  For example:  - `totalSupplyAtEpoch()` - `balanceAtEpochOf()` - `pendingLockAtEpochOf()` - `totalSupply()`  The implementation of the inversely traverse for loop is inherited from Convex's original version: https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol#L333-L334  However, Convex's locker contract is using Solidity 0.6.12, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `VE3DLocker.sol` is `0.8.7`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.7/080-breaking-changes.html#silent-changes-of-the-semantics  Which makes the current implementation of inversely traverse for loops always reverts.  More specifically:  1. `for (uint i = locks.length - 1; i + 1 != 0; i--) {` will revert when `locks.length == 0` at `locks.length - 1` due to underflow; 2. `for (uint256 i = _epoch; i + 1 != 0; i--) {` will loop until `i == 0` and reverts at `i--` due to underflow.  As a result, all these functions will be malfunctioning and all the internal and external usage of these function will always revert.  ### Recommendation  Change `VE3DLocker.sol#L315` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);     //lock epoch must be less or equal to the epoch we're basing from.     if (lockEpoch <= epochTime) {         if (lockEpoch > cutoffEpoch) {             amount = amount.add(locks[i - 1].amount); ```  Change `VE3DLocker.sol#L360` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);      //return the next epoch balance     if (lockEpoch == nextEpoch) {         return locks[i - 1].amount;     } else if (lockEpoch < nextEpoch) {         //no need to check anymore         break;     } ```  Change `VE3DLocker.sol#L387` to:  ```solidity for (uint256 i = epochindex; i > 0; i--) {     Epoch storage e = epochs[i - 1]; ```  Change `VE3DLocker.sol#L406` to:  ```solidity for (uint256 i = _epoch + 1; i > 0; i--) {     Epoch storage e = epochs[i - 1];     if (uint256(e.date) <= cutoffEpoch) {         break;     }     supply = supply.add(e.supply); } ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L129   # Vulnerability details  ## Impact Once Fee Manager has been set initially by owner, then owner has no power to change it. Owner should be allowed to change fees manager in case if he feels current fee manager is behaving maliciously  ## Proof of Concept 1. Observe the setFeeManager function and see that only feeManager is allowed to change it once set initially  ``` function setFeeManager(address _feeM) external {         require(msg.sender == feeManager, "!auth");         feeManager = _feeM;         emit FeeManagerUpdated(_feeM);     } ```  ## Recommended Mitigation Steps Change the setFeeManager function like below. Same can be done with other important functionality involving setArbitrator and setVoteDelegate  ``` require(msg.sender == owner, "!auth"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 ttps://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156   # Vulnerability details  ## Impact Similar to a reported I submitted for BaseRewardPool.sol (https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126)  When adding `extraRewards` to the extra reward pool in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 , there's no check for already existing address. Assume a particular address takes up 2 slots out of 3, and a user withdraws staked extra rewards, the user will receive double the amount requested in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258  ## Proof of Concept 1.  Assume `rewardManager` had mistakenly added the same address twice in `addExtraReward()` 2. A user calls `stake()` , linked rewards is staked twice to the same address (unexpected behaviour I guess but not severe issue) 3. Now, user calls `withdraw()` to withdraw linked rewards (this is already 2x in step 2) 4. User will receive double the linked rewards due to the iteration in `https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258`  ## Tools Used Manual review  ## Recommended Mitigation Steps Guess a check for an already existing extraRewards can be added before Line 138  ##Similar issue **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156 - not so sure of the severity for this. **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126  - reported in a seperate report    
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L68 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L80   # Vulnerability details  ## Impact The address of G-Uni tokens in the deployment scripts are not up to date.   ## Proof of concept For example for agEUR/USDC it is 0xedecb43233549c51cc3268b5de840239787ad56c and not 0x2bD9F7974Bc0E4Cb19B8813F8Be6034F3E772add  ## Mitigation steps For safety why not fetching directly the LP token from the staking contract ?   
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VoterProxy.sol   # Vulnerability details  ## Impact  For some veAsset project (for example Angle’s [gauges](https://github.com/AngleProtocol/angle-core/blob/main/contracts/staking/LiquidityGaugeV4UpgradedToken.vy), gauge contracts are upgradable, so interfaces and underlying LP tokens are subject to change, blocking and freezing the system. Note that this is not hypothetic as it happened a few weeks ago: see this [snapshot vote]( https://snapshot.org/#/anglegovernance.eth/proposal/0x1adb0a958220b3dcb54d2cb426ca19110486a598a41a75b3b37c51bfbd299513). Therefore, the system should be robust to a change in the pair gauge / token.   Note that is doable in the current setup for the veToken team to rescue the funds in such case, hence it is only a medium issue. You’d have to do as follow: a painful shutdown of the `Booster` (which would lead to an horrible situation where you’d have to preserve backwards compatibility for LPs to save their funds in the new Booster), an operator change in `VoterProxy` to be able to call `execute`.  ## Mitigation steps To deal with upgradeable contracts, either the `VoterProxy` needs to be upgradable to deal with any situation that may arise, either you need to add upgradeable “intermediate” contracts between the `staker` and the gauge that could be changed to preserve the logic.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203   # Vulnerability details  There is no check for the reward token amount to be transferred out in stashRewards(). As reward token list is external (controlled with `IGauge(gauge).reward_tokens`), and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable.  I.e. stashRewards() can be blocked for even an extended period of time, so all other extra rewards gathering will not be possible. This cannot be controlled by the system as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality of the system and its availability is affected.  ## Proof of Concept  stashRewards() attempts to send the `amount` to rewardArbitrator() without checking:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203  ```solidity     if (activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  If `IStaker(staker).withdraw()` produced no new tokens for any reason, the `amount = amount.sub(before)` above can be zero:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L188-L189  ```solidity     uint256 before = IERC20(token).balanceOf(address(this));     IStaker(staker).withdraw(token); ```  As reward `token` can be arbitrary, it can also be reverting on an attempt to transfer zero amounts:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  If this be the case then the whole stashRewards() call will be failing until `IStaker(staker).withdraw()` manage to withdraw some `tokens` or such `token` be removed from gauge's reward token list. Both events aren’t directly controllable by the system.  ## Recommended Mitigation Steps  Consider running the transfer only when amount is positive:  ```solidity -   if (activeCount > 1) { +   if (amount > 0 && activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120   # Vulnerability details  ## Impact   In [VeAssetDepositor.sol#L117-L120](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120), the condition to mint the additional rewards tokens to the user is `if (incentiveVeAsset > 0)`. However, the `incentiveVeAsset` variable is only updated to zero after an external call to the `ITokenMinter` contract. This lacks the Checks Effects and Interactions safety pattern. In the event that the **wrong** minter contract has been initialised, an attacker could potentially drain all the additional reward tokens via a reentrancy attack.  ## Proof of Concept  - <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>  ## Recommended Mitigation Steps  Be sure to follow the [Checks Effects and Interactions safety pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and update the `incentiveVeAsset = 0` before minting the token for the user. Alternatively, the developers can also add the `nonReentrant()` [modifier](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard) from OpenZeppelin to prevent any sort of potential reentrancy attacks.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L256   # Vulnerability details  ## Impact It was observed that addPool function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with deposits.  In case of duplicate lpToken, the first pool calling depositAll will take away all lpToken and deposit them under there own pid. This leaves no balance for 2nd pool  ## Proof of Concept  1. PoolManager call addPool function and uses lpToken as A 2. PoolManager again call addPool function and mistakenly provides lpToken as A 3. Now 2 pools will be created with lpToken as A 4. depositAll function is called passing first pool.  5. This takes all balance of lpToken A and depsoit it under first pool pid 6. This mean no balance is left for second pool now  ## Recommended Mitigation Steps Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken addPool function should fail.  
## Low ### Use a 2 step procedure to update feeManager Use a 2 step procedure to update feeManager to reduce risk of burning the admin key https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L53-L57  ```solidity     function setFeeManager(address _feeManager) external {         require(msg.sender == feeManager, "!auth");         feeManager = _feeManager;         emit FeeManagerUpdated(_feeManager);     } ```  ## Non Critical ### Outdated Solidity Consider upgrade to latest 0.8.14
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576   # Vulnerability details  ## Proof-of-Concept  The `Booster.setFeeInfo` function is responsible for setting the allocation of gauge fees between lockers and $VE3D stakers.  `lockFeesIncentive` and `stakerLockFeesIncentive` should add up to `10000` , which is equivalent to `100%`.  However, there is no validation check to ensure that that `_lockFeesIncentive` and `_stakerLockFeesIncentive` add up to `10000`. Thus, it entirely depends on the developer to get these two values right.  As such, it is possible to set `lockFeesIncentive + takerLockFeesIncentive` to be less than `100%`. This might happen due to human error. For instance, a typo (forget a few zero) or newly joined developer might not be aware of the fee denomination and called `setFeeInfo(40, 60)` instead of `setFeeInfo(4000, 6000)`.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193)  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, "!auth");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  Assume that `setFeeInfo(40, 60)` is called instead of of `setFeeInfo(4000, 6000)`, only `1%` of the fee collected will be transferred to the users and the remaining `99%` of the fee collected will be stuck in the `Booster` contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576)  ```solidity function earmarkFees() external returns (bool) {     //claim fee rewards     IStaker(staker).claimFees(feeDistro, feeToken);     //send fee rewards to reward contract     uint256 _balance = IERC20(feeToken).balanceOf(address(this));      uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);     uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(         FEE_DENOMINATOR     );     if (_lockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);         IRewards(lockFees).queueNewRewards(_lockFeesIncentive);     }     if (_stakerLockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);         IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);     }     return true; } ```  ### Can we retrieve or "save" the tokens stuck in `Booster` contract?  Any veAsset (e.g. CRV, ANGLE) sitting on the `Booster` contract is claimable. However, in this case, the `feeToken` is likely not a veAsset, thus the remaining gauge fee will be stuck in the `Booster` contract perpetually. For instance, in Curve, the gauge fee is paid out in 3CRV, the LP token for the TriPool. ([Source](https://resources.curve.fi/crv-token/understanding-crv#staking-trading-fees))  ## Impact  Users will lost their gauge fee if this happens.  ## Recommended Mitigation Steps  Implement validation check to ensure that `lockFeesIncentive` and `takerLockFeesIncentive` add up to 100% to eliminate any risk of misconfiguration.  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, "!auth");     require(_lockFeesIncentive + _stakerLockFeesIncentive == FEE_DENOMINATOR, "Invalid fees");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495   # Vulnerability details  > Note: This report aims to discuss the issue encountered when `ExtraRewardStashV3` is used within Angle Deployment. There is also another issue when `ExtraRewardStashV2` is used within Angle Deployment, but I will raise it in a separate report since `ExtraRewardStashV2` and `ExtraRewardStashV3` operate differently, and the proof-of-concept and mitigation are different too.  ## Proof-of-Concept  In this example, assume the following Angle's gauge setup  > Name = Angle sanDAI_EUR Gauge > > Symbol = SsanDAI_EUR > > reward_count = 2 > > reward_tokens(0) = ANGLE > > reward_tokens(1) = DAI > > Gauge Contract: [LiquidityGaugeV4.vy](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy) > > Stash Contract: [ExtraRewardStashV3](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol)  To collect the gauge rewards, users would trigger the `Booster._earmarkRewards` function to claim veAsset and extra rewards from a gauge.   Per the code logic, the function will attempt to execute the following two key operations:  1) First Operation -  Claim the veAsset by calling `VoterProxy.claimVeAsset`. Call Flow as follow: `VoterProxy.claimVeAsset() > IGauge(_gauge).claim_rewards()`. 2) Second Operation - Claim extra rewards by calling `ExtraRewardStashV3.claimRewards`. Call flow as follows: `ExtraRewardStashV3.claimRewards > Booster.claimRewards > VoterProxy.claimRewards > IGauge(_gauge).claim_rewards()` .   Note that`IGauge(_gauge).claim_rewards()` will claim all available reward tokens from the Angle's gauge.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495)  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {     PoolInfo storage pool = poolInfo[_pid];     require(pool.shutdown == false, "pool is closed");      address gauge = pool.gauge;      //claim veAsset     IStaker(staker).claimVeAsset(gauge);      //check if there are extra rewards     address stash = pool.stash;     if (stash != address(0)) {         //claim extra rewards         IStash(stash).claimRewards();         //process extra rewards         IStash(stash).processStash();     }  ..SNIP.. } ```  ### First Operation -  Claim the veAsset  Since this is a Angle Deployment, when the `VoterProxy.claimVeAsset` is triggered,  it will go through the if-else logic (`escrowModle == IVoteEscrow.EscrowModle.ANGLE`) and execute ` IGauge(_gauge).claim_rewards()`, and all rewards tokens will be sent to `VoterProxy` contract. Assume that `100 ANGLE` and `100 DAI` were received.  Note that in this example, we have two reward tokens (ANGLE and DAI). Additionally, gauge redirection was not configured on the gauge at this point, thus the gauge rewards will be sent to the caller, which is the `VoterProxy` contract.  Subsequently, the code `IERC20(veAsset).safeTransfer(operator, _balance);` will be executed, and veAsset (`100 ANGLE`) reward tokens will be transferred to the `Booster` contract for distribution. However, the `100 DAI` reward tokens will remain stuck in the `VoterProxy` contract. As such, users will not be able to get any reward tokens (e.g. DAI, WETH) except veAsset (ANGLE) tokens from the gauges.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224)  ```solidity function claimVeAsset(address _gauge) external returns (uint256) {     require(msg.sender == operator, "!auth");      uint256 _balance = 0;      if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {         try IGauge(_gauge).getReward() {} catch {             return _balance;         }     } else if (         escrowModle == IVoteEscrow.EscrowModle.CURVE ||         escrowModle == IVoteEscrow.EscrowModle.RIBBON     ) {         try ITokenMinter(minter).mint(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {         try ITokenMinter(minter).distribute(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {         try IGauge(_gauge).claim_rewards() {} catch {             return _balance;         }     }      _balance = IERC20(veAsset).balanceOf(address(this));     IERC20(veAsset).safeTransfer(operator, _balance);      return _balance; } ```  Following is Angle's Gauge Contract for reference:  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344)  (Mainnet Deployed Address: https://etherscan.io/address/0x8E2c0CbDa6bA7B65dbcA333798A3949B07638026)   > Note: Angle Protocol is observed to use LiquidityGaugeV4 contract for all of their gauges. Thus, ExtraRewardStashV3 is utilised during pool creation.  ```python @external @nonreentrant('lock') def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):     """     @notice Claim available reward tokens for `_addr`     @param _addr Address to claim for     @param _receiver Address to transfer rewards to - if set to                      ZERO_ADDRESS, uses the default reward receiver                      for the caller     """     if _receiver != ZERO_ADDRESS:         assert _addr == msg.sender  # dev: cannot redirect when claiming for another user     self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver) ```  ### Second Operation - Claim extra rewards  After the `IStaker(staker).claimVeAsset(gauge);` code within the `Booster._earmarkRewards` function is executed, `IStash(stash).claimRewards();`  and `IStash(stash).processStash();` functions will be executed next. `stash` == `ExtraRewardStashV3`.  The `ExtraRewardStashV3.claimRewards` will call the `Booster.setGaugeRedirect` first so that all the gauge rewards will be redirected to `ExtraRewardStashV3` stash contract. Subsequently, `ExtraRewardStashV3.claimRewards` will trigger `Booster.claimRewards` to claim the gauge rewards from the Angle's gauge.   Note that this is the second time the contract attempts to claim gauge rewards from the gauge. Thus, no gauge rewards will be received since we already claimed them earlier. Next, `ExtraRewardStashV3` will attempt to process all the tokens stored in its contract and send them to the respective reward contracts for distribution to the users. However, the contract does not have any tokens stored in it because the earlier attempt to claim gauge rewards return nothing.  As we can see, the DAI reward tokens are still stuck in the `VoterProxy` contract at this point.  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332)  ```python def set_rewards_receiver(_receiver: address):     """     @notice Set the default reward receiver for the caller.     @dev When set to ZERO_ADDRESS, rewards are sent to the caller     @param _receiver Receiver address for any rewards claimed via `claim_rewards`     """     self.rewards_receiver[msg.sender] = _receiver ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61)  ```solidity //try claiming if there are reward tokens registered function claimRewards() external returns (bool) {     require(msg.sender == operator, "!authorized");      //this is updateable from v2 gauges now so must check each time.     checkForNewRewardTokens();      //make sure we're redirected     if (!hasRedirected) {         IDeposit(operator).setGaugeRedirect(pid);         hasRedirected = true;     }      uint256 length = tokenCount;     if (length > 0) {         //claim rewards on gauge for staker         //using reward_receiver so all rewards will be moved to this stash         IDeposit(operator).claimRewards(pid, gauge);     }     return true; } ```  ## Impact  User's gauge rewards are frozen/stuck in `VoterProxy` contract. Additionally, there is no method to sweep/collect the reward tokens stuck in the `VoterProxy` contract.  ## Recommended Mitigation Steps  > Note: I do not see `Booster.setGaugeRedirect` being called in the deployment and testing scripts. Thus, it is fair to assume that the team is not aware of the need to trigger `Booster.setGaugeRedirect` during deployment. If the gauge redirection has been set to the stash contract `ExtraRewardStashV3` right from the start before anyone triggered the `earmarkRewards` function, this issue should not occur.  Consider triggering `Booster.setGaugeRedirect` during the deployment to set gauge redirection to stash contract (`ExtraRewardStashV3`) so that the Angle's gauge rewards will not be redirected to `VoterProxy` contract and get stuck there.  Alternatively, update the `Booster._earmarkRewards` to as follows:  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {  PoolInfo storage pool = poolInfo[_pid];  require(pool.shutdown == false, "pool is closed");   address stash = pool.stash;  if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {   //claims gauges rewards   IStash(stash).claimRewards();   //process gauges rewards   IStash(stash).processStash();  } else {   //claim veAsset         IStaker(staker).claimVeAsset(gauge);          //check if there are extra rewards         address stash = pool.stash;         if (stash != address(0)) {             //claim extra rewards             IStash(stash).claimRewards();             //process extra rewards             IStash(stash).processStash();         }  }   //veAsset balance     uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));  ..SNIP.. } ```  There is no need to specifically call `VoterProxy.claimVeAsset` to fetch ANGLE for Angle Protocol because calling `IStash(stash).claimRewards()` will fetch both ANGLE and other reward tokens from the gauge anyway. When the stash contract receives the ANGLE tokens, it will automatically transfer all of them back to `Booster` contract when `IStash(stash).processStash()` is executed. The `IStash(stash).claimRewards()` function also performs a sanity check to ensure that the gauge redirection is pointing to itself before claiming the gauge rewards, and automatically configure them if it is not, so it will not cause the reward tokens to get stuck in `VoterProxy` contract.  - Curve uses an older version of LiquidityGauge contract. Thus, two calls are needed (`Minter.mint` to claim CRV and `LiquidityGauge.claim_rewards` to claim other rewards).   - Angle uses newer version of LiquidityGauge (V4) contract that just need one function call (`LiquidityGauge.claim_rewards` ) to fetch both veAsset and other rewards. - IDLE uses LiquidityGauge (V3) contract. veAsset (IDLE) is minted by calling `DistributorProxy.distribute` and gauge rewards are claimed by calling `LiquidityGauge.claim_rewards`.  Due to the discrepancies between different protocols in the reward claiming process, additional care must be taken to ensure that the flow of veAsset and gauge rewards are transferred to the appropriate contracts during integration. Otherwise, rewards will be stuck.  Lastly, I only see test cases written for claiming veAsset from the gauge. For completeness, it is recommended to also write test cases for claiming extra rewards from the gauge apart from veAsset.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48   # Vulnerability details  ## Vulernability Details  It was observed that users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws $VE3D token from the `VeTokenMinter` contract.  ## Proof-of-Concept  Based on the deployment script, it was understood that at the start of the project deployment, 30 million $VE3D tokens will be pre-minted for the `VeTokenMinter` contract. Thus, the `veToken.balanceOf(VeTokenMinter.address)` will be 30 million $VE3D tokens after the deployment.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18)  ```javascript // vetoken minter await deployer.deploy(VeTokenMinter, veTokenAddress); let vetokenMinter = await VeTokenMinter.deployed(); addContract("system", "vetokenMinter", vetokenMinter.address); global.created = true; //mint vetoke to minter contract const vetoken = await VeToken.at(veTokenAddress); await vetoken.mint(vetokenMinter.address, web3.utils.toWei("30000000"), { from: vetokenOperator }); addContract("system", "vetoken", veTokenAddress); ```  In the `VeTokenMinter ` contract, there is a function called `VeTokenMinter.withdraw` that allows the admin to withdraw $VE3D tokens from the contract. Noted that this withdraw function only perform the transfer, but did not update any of the state variables (e.g. totalSupply, maxSupply) in the contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77)  ```solidity function withdraw(address _destination, uint256 _amount) external onlyOwner {     veToken.safeTransfer(_destination, _amount);      emit Withdraw(_destination, _amount); } ```  Assuming that an admin withdrawed 29 million $VE3D tokens from the `VoteProxy` with the appropriate approval from the DAO or community for some valid purposes. The `veToken.balanceOf(VeTokenMinter.address)` will be 1 million $VE3D tokens after the withdrawal.  At this point, notice that `veToken.balanceOf(VeTokenMinter.address)` is 1 million, while the `VeTokenMinter.maxSupply` constant is 30 million. Therefore, there exists a discrepency between the actual amount of $VE3D tokens (1 million) stored in the contact versus the max supply (30 million).  This discrepency will cause an issue in the `VeTokenMinter.mint` function because the calculation of the amount of $VE3D tokens to be transferred is based on the fact that 30 million $VE3D tokens is always sitting in the `VeTokenMinter` contract, and thus there is always sufficient $VE3D tokens available in the `VeTokenMinter` contract to send to its users.  The `uint256 amtTillMax = maxSupply.sub(supply);` code shows that the calculation is based on `maxSupply` constant, which is 30 million.  Assume that `mint(0x001, 10 million)` is called, and the value of the state variables when stepping through this function are as follows:  - `maxSupply` constant = 30 million - `veToken.balanceOf(VeTokenMinter.address)` = 1 million - `supply` & `totalSupply` = 20 million - `totalCliffs` = 1000 - `reductionPerCliff ` = 30,000 (maxSupply / totalCliffs) - `cliff` = 666 (supply/reductionPerCliff) - `reduction` = 1000 - 666 = 334 - `_amount` = 10 million * (334/1000) = 3.340 million - `amtTillMax` = 10 million (maxSupply - supply) (Over here the contract assume that it still has 10 million VE3D tokens more to reach the max supply) - `(_amount > amtTillMax)` = `False` (since "3.340 million > 10 million" = false ) - `veToken.safeTransfer(0x001, 3.340 million)` (This will revert. Insufficent balance)  The `veToken.safeTransfer(0x001, 3.340 million` will fail and revert because `VeTokenMinter` contract does not hold sufficent amount of $VE3D tokens to transfer out.`veToken.balanceOf(VeTokenMinter.address)` = 1 million, while the contract was attempting to send out 3.340 million.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48)  ```solidity function mint(address _to, uint256 _amount) external {     require(operators.contains(_msgSender()), "not an operator");      uint256 supply = totalSupply;      //use current supply to gauge cliff     //this will cause a bit of overflow into the next cliff range     //but should be within reasonable levels.     //requires a max supply check though     uint256 cliff = supply.div(reductionPerCliff);     //mint if below total cliffs     if (cliff < totalCliffs) {         //for reduction% take inverse of current cliff         uint256 reduction = totalCliffs.sub(cliff);         //reduce         _amount = _amount.mul(reduction).div(totalCliffs);          //supply cap check         uint256 amtTillMax = maxSupply.sub(supply);         if (_amount > amtTillMax) {             _amount = amtTillMax;         }          //mint         veToken.safeTransfer(_to, _amount);         totalSupply += _amount;     } } ```  The failure/revert of `VeTokenMinter.mint` function will cascade up to `Booster.rewardClaimed`, and futher cascade up to `BaseRewardPool.getReward`. Thus, `BaseRewardPool.getReward` will stop working. As a result, the users will not be able to get any rewards from the reward contracts.   This issue will affect all projects (Curve, Pickle, Ribbon, Idle, Angle, Balancer) because `VeTokenMinter ` contract is deployed once, and referenced by all the projects. Thus, the impact could be quite widespread if this occurs, and many users would be affected.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598)  ```solidity function rewardClaimed(     uint256 _pid,     address _address,     uint256 _amount ) external returns (bool) {     address rewardContract = poolInfo[_pid].veAssetRewards;     require(msg.sender == rewardContract || msg.sender == lockRewards, "!auth");     ITokenMinter veTokenMinter = ITokenMinter(minter);     //calc the amount of veAssetEarned     uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(         veTokenMinter.totalWeight()     );     //mint reward tokens     ITokenMinter(minter).mint(_address, _veAssetEarned);      return true; } ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267)  ```solidity function getReward(address _account, bool _claimExtras)     public     updateReward(_account)     returns (bool) {     uint256 reward = earned(_account);     if (reward > 0) {         rewards[_account] = 0;         rewardToken.safeTransfer(_account, reward);         IDeposit(operator).rewardClaimed(pid, _account, reward);         emit RewardPaid(_account, reward);     }      //also get rewards from linked rewards     if (_claimExtras) {         for (uint256 i = 0; i < extraRewards.length; i++) {             IRewards(extraRewards[i]).getReward(_account);         }     }     return true; } ```  ## Recommended Mitigation Steps  Remove the `VeTokenMinter.withdraw` function if possible. Otherwise, update the internal accounting of `VeTokenMinter` contract during withdrawal so that the actual balance of the $VE3D tokens is taken into consideration within the `VeTokenMinter.mint`, and the contract will not attempt to transfer more tokens than what it has.  On a side note, [Convex's Minter contract](https://github.com/convex-eth/platform/blob/main/contracts/contracts/Cvx.sol), will mint the `CRX` gov tokens to the users on the fly. See https://github.com/convex-eth/platform/blob/1f11027d429e454dacc4c959502687eaeffdb74a/contracts/contracts/Cvx.sol#L76. Thus, there will not be a case where there is not sufficient `CRV` tokens in the contract to send to it users.  However, in VeToken Protocol, it attempts to transfer the portion of pre-minted $VE3D tokens (30 millions) to the users. See https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L72. Thus, it is possible that there is not enough $VE3D tokens to send to its users if the admin withdraw the pre-minted $VE3D tokens.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46   # Vulnerability details  ## Impact The admin may fat-finger a change, or be malicious, and have the weights be extreme - ranging from zero to `type(uint256).max`, which would cause the booster to pay out unexpected amounts  ## Proof of Concept No bounds checks in the update function: ```solidity File: contracts/VeTokenMinter.sol   #1  41       function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner { 42           require(operators.contains(veAssetOperator), "not an veAsset operator"); 43           totalWeight -= veAssetWeights[veAssetOperator]; 44           veAssetWeights[veAssetOperator] = newWeight; 45           totalWeight += newWeight; 46       } ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46  The value is used by the reward contract to determine how much to mint: ```solidity File: contracts/Booster.sol   #2  598       function rewardClaimed( 599           uint256 _pid, 600           address _address, 601           uint256 _amount 602       ) external returns (bool) { 603           address rewardContract = poolInfo[_pid].veAssetRewards; 604           require(msg.sender == rewardContract || msg.sender == lockRewards, "!auth"); 605           ITokenMinter veTokenMinter = ITokenMinter(minter); 606           //calc the amount of veAssetEarned 607           uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div( 608               veTokenMinter.totalWeight() 609           ); 610           //mint reward tokens 611           ITokenMinter(minter).mint(_address, _veAssetEarned); ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598-L611  Wrong values will lead to excessive inflation/deflation  ## Tools Used Code inspection  ## Recommended Mitigation Steps Have sane upper/lower limits on the values   
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L356 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L337   # Vulnerability details  As arbitrary ERC20 tokens can be passed, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. Also, it's a good practice for the future of the solution.  Affected code:  - File: Booster.sol  ```solidity 345:     function deposit( 346:         uint256 _pid, 347:         uint256 _amount, 348:         bool _stake 349:     ) public returns (bool) { ... 356:         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); //@audit medium: not compatible with Fee On Transfer Tokens ... 372:             ITokenMinter(token).mint(address(this), _amount); ... 374:             IERC20(token).safeApprove(rewardContract, _amount); 375:             IRewards(rewardContract).stakeFor(msg.sender, _amount); ... 378:             ITokenMinter(token).mint(msg.sender, _amount); ... 381:         emit Deposited(msg.sender, _pid, _amount); ... ```  - File: VE3DRewardPool.sol  ```solidity 336:     function donate(address _rewardToken, uint256 _amount) external { 337:         IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount); //@audit medium: not compatible with Fee On Transfer Tokens 338:         rewardTokenInfo[_rewardToken].queuedRewards += _amount; 339:     } ```  ## Recommended Mitigation Steps  Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299 https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152   # Vulnerability details  Project veToken is supposed to be a generalized version of Convex for non-Curve token. There is only one contract for all rewards token in the platform.  All ve3Token rewards are bundled together inside `ve3DLocker` and `ve3DRewardPool` in a loop. Instead of having its own unique contract like `VeAssetDepositer` or `VoterProxy` for each token.  ## Impact  If one token has pausable transfer, user cannot claim rewards or withdraw if they have multiple rewards include that pause token.  Right now the project intends to support only 6 tokens, including Ribbon token which has [pausable transfer](https://etherscan.io/address/0x6123b0049f904d730db3c36a31167d9d4121fa6b#code#L810) controlled by Ribbon DAO.  Normally, this would not be an issue in Convex where only a few pools would be affected by single coin. Since, veAsset are bundled together into single reward pool, it becomes a major problem.  ## Proof of concept  - Token like Ribbon pause token transfer by DAO due to an unfortunate event. - `VE3DRewardPool` try call `getReward()`, `VeAssetDepositor` [try deposit token from earned rewards](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299) does not work anymore because `IERC20.transfer` [is blocked](https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152). This effectively reverts current function if user have this token reward > 0.  ## Recommended mitigation step  It would be a better practice if we had a second `getReward()` function that accepts an array of token that we would like to interact with. It saves gas and only requires some extra work on frontend website. Instead of current implementation, withdraw all token bundles together.   
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L305-L329 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L349-L373 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L376-L396 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L399-L415   # Vulnerability details  ```solidity function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {     uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(         rewardsDuration     );     uint256 cutoffEpoch = epochStart.sub(lockDuration);      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) <= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; } ````  In `VE3DLocker.sol`, there are multiple instances in which an inversely traverse for loop is used "to make more current queries more gas efficient".  For example:  - `totalSupplyAtEpoch()` - `balanceAtEpochOf()` - `pendingLockAtEpochOf()` - `totalSupply()`  The implementation of the inversely traverse for loop is inherited from Convex's original version: https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol#L333-L334  However, Convex's locker contract is using Solidity 0.6.12, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `VE3DLocker.sol` is `0.8.7`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.7/080-breaking-changes.html#silent-changes-of-the-semantics  Which makes the current implementation of inversely traverse for loops always reverts.  More specifically:  1. `for (uint i = locks.length - 1; i + 1 != 0; i--) {` will revert when `locks.length == 0` at `locks.length - 1` due to underflow; 2. `for (uint256 i = _epoch; i + 1 != 0; i--) {` will loop until `i == 0` and reverts at `i--` due to underflow.  As a result, all these functions will be malfunctioning and all the internal and external usage of these function will always revert.  ### Recommendation  Change `VE3DLocker.sol#L315` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);     //lock epoch must be less or equal to the epoch we're basing from.     if (lockEpoch <= epochTime) {         if (lockEpoch > cutoffEpoch) {             amount = amount.add(locks[i - 1].amount); ```  Change `VE3DLocker.sol#L360` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);      //return the next epoch balance     if (lockEpoch == nextEpoch) {         return locks[i - 1].amount;     } else if (lockEpoch < nextEpoch) {         //no need to check anymore         break;     } ```  Change `VE3DLocker.sol#L387` to:  ```solidity for (uint256 i = epochindex; i > 0; i--) {     Epoch storage e = epochs[i - 1]; ```  Change `VE3DLocker.sol#L406` to:  ```solidity for (uint256 i = _epoch + 1; i > 0; i--) {     Epoch storage e = epochs[i - 1];     if (uint256(e.date) <= cutoffEpoch) {         break;     }     supply = supply.add(e.supply); } ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L129   # Vulnerability details  ## Impact Once Fee Manager has been set initially by owner, then owner has no power to change it. Owner should be allowed to change fees manager in case if he feels current fee manager is behaving maliciously  ## Proof of Concept 1. Observe the setFeeManager function and see that only feeManager is allowed to change it once set initially  ``` function setFeeManager(address _feeM) external {         require(msg.sender == feeManager, "!auth");         feeManager = _feeM;         emit FeeManagerUpdated(_feeM);     } ```  ## Recommended Mitigation Steps Change the setFeeManager function like below. Same can be done with other important functionality involving setArbitrator and setVoteDelegate  ``` require(msg.sender == owner, "!auth"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 ttps://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156   # Vulnerability details  ## Impact Similar to a reported I submitted for BaseRewardPool.sol (https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126)  When adding `extraRewards` to the extra reward pool in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 , there's no check for already existing address. Assume a particular address takes up 2 slots out of 3, and a user withdraws staked extra rewards, the user will receive double the amount requested in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258  ## Proof of Concept 1.  Assume `rewardManager` had mistakenly added the same address twice in `addExtraReward()` 2. A user calls `stake()` , linked rewards is staked twice to the same address (unexpected behaviour I guess but not severe issue) 3. Now, user calls `withdraw()` to withdraw linked rewards (this is already 2x in step 2) 4. User will receive double the linked rewards due to the iteration in `https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258`  ## Tools Used Manual review  ## Recommended Mitigation Steps Guess a check for an already existing extraRewards can be added before Line 138  ##Similar issue **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156 - not so sure of the severity for this. **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126  - reported in a seperate report    
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L68 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L80   # Vulnerability details  ## Impact The address of G-Uni tokens in the deployment scripts are not up to date.   ## Proof of concept For example for agEUR/USDC it is 0xedecb43233549c51cc3268b5de840239787ad56c and not 0x2bD9F7974Bc0E4Cb19B8813F8Be6034F3E772add  ## Mitigation steps For safety why not fetching directly the LP token from the staking contract ?   
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VoterProxy.sol   # Vulnerability details  ## Impact  For some veAsset project (for example Angle’s [gauges](https://github.com/AngleProtocol/angle-core/blob/main/contracts/staking/LiquidityGaugeV4UpgradedToken.vy), gauge contracts are upgradable, so interfaces and underlying LP tokens are subject to change, blocking and freezing the system. Note that this is not hypothetic as it happened a few weeks ago: see this [snapshot vote]( https://snapshot.org/#/anglegovernance.eth/proposal/0x1adb0a958220b3dcb54d2cb426ca19110486a598a41a75b3b37c51bfbd299513). Therefore, the system should be robust to a change in the pair gauge / token.   Note that is doable in the current setup for the veToken team to rescue the funds in such case, hence it is only a medium issue. You’d have to do as follow: a painful shutdown of the `Booster` (which would lead to an horrible situation where you’d have to preserve backwards compatibility for LPs to save their funds in the new Booster), an operator change in `VoterProxy` to be able to call `execute`.  ## Mitigation steps To deal with upgradeable contracts, either the `VoterProxy` needs to be upgradable to deal with any situation that may arise, either you need to add upgradeable “intermediate” contracts between the `staker` and the gauge that could be changed to preserve the logic.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203   # Vulnerability details  There is no check for the reward token amount to be transferred out in stashRewards(). As reward token list is external (controlled with `IGauge(gauge).reward_tokens`), and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable.  I.e. stashRewards() can be blocked for even an extended period of time, so all other extra rewards gathering will not be possible. This cannot be controlled by the system as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality of the system and its availability is affected.  ## Proof of Concept  stashRewards() attempts to send the `amount` to rewardArbitrator() without checking:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203  ```solidity     if (activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  If `IStaker(staker).withdraw()` produced no new tokens for any reason, the `amount = amount.sub(before)` above can be zero:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L188-L189  ```solidity     uint256 before = IERC20(token).balanceOf(address(this));     IStaker(staker).withdraw(token); ```  As reward `token` can be arbitrary, it can also be reverting on an attempt to transfer zero amounts:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  If this be the case then the whole stashRewards() call will be failing until `IStaker(staker).withdraw()` manage to withdraw some `tokens` or such `token` be removed from gauge's reward token list. Both events aren’t directly controllable by the system.  ## Recommended Mitigation Steps  Consider running the transfer only when amount is positive:  ```solidity -   if (activeCount > 1) { +   if (amount > 0 && activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120   # Vulnerability details  ## Impact   In [VeAssetDepositor.sol#L117-L120](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120), the condition to mint the additional rewards tokens to the user is `if (incentiveVeAsset > 0)`. However, the `incentiveVeAsset` variable is only updated to zero after an external call to the `ITokenMinter` contract. This lacks the Checks Effects and Interactions safety pattern. In the event that the **wrong** minter contract has been initialised, an attacker could potentially drain all the additional reward tokens via a reentrancy attack.  ## Proof of Concept  - <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>  ## Recommended Mitigation Steps  Be sure to follow the [Checks Effects and Interactions safety pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and update the `incentiveVeAsset = 0` before minting the token for the user. Alternatively, the developers can also add the `nonReentrant()` [modifier](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard) from OpenZeppelin to prevent any sort of potential reentrancy attacks.  
# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L256   # Vulnerability details  ## Impact It was observed that addPool function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with deposits.  In case of duplicate lpToken, the first pool calling depositAll will take away all lpToken and deposit them under there own pid. This leaves no balance for 2nd pool  ## Proof of Concept  1. PoolManager call addPool function and uses lpToken as A 2. PoolManager again call addPool function and mistakenly provides lpToken as A 3. Now 2 pools will be created with lpToken as A 4. depositAll function is called passing first pool.  5. This takes all balance of lpToken A and depsoit it under first pool pid 6. This mean no balance is left for second pool now  ## Recommended Mitigation Steps Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken addPool function should fail.  
