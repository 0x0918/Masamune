# Handle  gzeon   # Vulnerability details  ## Impact `stopLiquidation` does not pull fund from `Liquidator` while setting `_liquidator` to address(0). Since the `DebtLocker` own `Liquidator` and there are no way to set `_liquidator` to existing address, fund still in `Liquidator` would be stuck unless `DebtLocker` is upgraded to support such behavior.  Also, when `stopLiquidation` is called, remaining fund in Liquidator can still be liquidated by keepers.  ## Proof of Concept https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L112 ```     function stopLiquidation() external override {         require(msg.sender == _getPoolDelegate(), "DL:SL:NOT_PD");          _liquidator = address(0);          emit LiquidationStopped();     } ```  ## Recommended Mitigation Steps Pull remaining fund in `stopLiquidation`    
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L205-L215  ```solidity function _handleClaimOfRepossessed() internal returns (uint256[7] memory details_) {     ...     details_[0] = recoveredFunds + fundsCaptured;     details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : 0;     details_[2] = fundsCaptured;     details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;     details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : 0;      _fundsToCapture = uint256(0);     _repossessed    = false;      require(ERC20Helper.transfer(fundsAsset, _pool, recoveredFunds + fundsCaptured), "DL:HCOR:TRANSFER"); } ```  `recoveredFunds + fundsCaptured` at L215 is calculated before at L205, since it's a checked arithmetic operation with two memory variables, resue the result instead of doing the arithmetic operation again can save gas.  ### Recommendation  Change to:  `require(ERC20Helper.transfer(fundsAsset, _pool, details_[0]), "DL:HCOR:TRANSFER");`  
# Handle  WatchPug   # Vulnerability details  In `MapleLoanInternals.sol#_getCollateralRequiredFor`, when `principal_ <= drawableFunds_`, `0 / principalRequested_` can be avoid.  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L359-L359  ```solidity=359 return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_; ```  ### Recommendation  Change to:  ```solidity if (principal_ <= drawableFunds_) {     return uint256(0); }  return (collateralRequired_ * (principal_ - drawableFunds_)) / principalRequested_; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/Liquidator.sol#L45-L62  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(!_locked, "LIQ:LP:LOCKED");      _locked = true;     ...     _locked = false; } ```  `SSTORE` from false (0) to true (1) (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  ### Recommendation  Change to:  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(_locked = 1, "LIQ:LP:LOCKED");      _locked = 2;     ...     _locked = 1; } ```  
# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  Instances include:  `IERC20Like(collateralAsset).decimals()` in `DebtLocker.sol#getExpectedAmount()` can be cached to avoid an extra external call.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L237-L253  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** IERC20Like(collateralAsset).decimals()                      // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** IERC20Like(collateralAsset).decimals();      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  ### Recommendation  Change to:  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** collateralAssetDecimals                                     // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** collateralAssetDecimals;      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L86-L93  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:MP:TRANSFER_FROM_FAILED");          ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  The current implementation allows anyone to call `makePayment()` and repay the loan with `_drawableFunds`.  This makes it possible for a malicious `lender` to call `makePayment()` multiple times right after `fundLoan()` and retrieve most of the funds back immediately, while then `borrower` must continue to make payments or lose the `collateral`.  ### PoC   Given:  - `_collateralRequired` = 1 BTC - `_principalRequested` = 12,000 USDC - `_paymentInterval` = 30 day - `_paymentsRemaining` = 12 - `_gracePeriod` = 1 day - `interestRate_` = 2e17  1. The borrower calls `postCollateral()` and added `1 BTC` as `_collateralAsset`; 2. The lender calls `fundLoan()` and added `12,000 USDC` as  `_fundsAsset`; 3. The lender calls `makePayment()` 11 times, then: - `_drawableFunds` = 96 - `_claimableFunds` = 11903 - `_principal` = 1553  4. The lender calls `_claimFunds()` get 11,903 USDC of `_fundsAsset` back;  Now, for the borrower `1,579 USDC` is due, but only `96 USDC` can be used. The borrower is now forced to pay the interests for the funds that never be used or lose the collateral.  ### Recommendation  Change to:  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:MP:TRANSFER_FROM_FAILED");          require(msg.sender == _borrower, "ML:DF:NOT_BORROWER");              ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  
# Handle  gzeon   # Vulnerability details  ## Impact Use type(uint).max instead of block.timestamp to save gas  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L71 https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L71  
# Handle  WatchPug   # Vulnerability details  There are a few functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273  ```solidity=257     uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.     uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Drawable funds is the amount funded, minus any fees.     _drawableFunds = fundsLent_ - treasuryFee - delegateFee;      require(         treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),         "MLI:FL:T_TRANSFER_FAILED"     );      require(         delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),         "MLI:FL:PD_TRANSFER_FAILED"         ); ```  In the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.  This allows the attacker to set very high fees, making `_drawableFunds` near 0.  Since `mapleTreasury` and `poolDelegate` are also read from `lender_`, `treasuryFee` and `investorFee` can be retrieved back to the attacker.  As a result, the borrower won't get any `_drawableFunds` while also being unable to remove collateral.  ### PoC  Given:  - `_collateralRequired` = 10 BTC - `_principalRequested` = 1,000,000 USDC - `_paymentInterval` = 1 day - `_paymentsRemaining` = 10 - `_gracePeriod` = 1 day  1. Alice (borrower) calls `postCollateral()` and added `10 BTC` as `_collateralAsset`; 2. The attacker calls `fundLoan()` by taking `1,000,000 USDC` of flashloan and using a fake `lender`contract; 3. Alice calls `drawdownFunds()` with any amount > 0 will fail; 4. Alice calls `removeCollateral()` with any amount > 0 will get "MLI:DF:INSUFFICIENT_COLLATERAL" error; 5. Unless Alice make payment (which is meaningless), after 2 day, the attacker can call `repossess()` and get `10 BTC`.  ### Recommendation  Consider reading `treasuryFee`, `investorFee`, `mapleTreasury`, `poolDelegate` from an authoritative source instead.  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L56-L63  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:CL:TRANSFER_FROM_FAILED");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  Based on the context, we believe that the `closeLoan()` should only be called by the `borrower`. However, the current implementation allows anyone to call `closeLoan()` anytime after `fundLoan()`.  If there is no `earlyFee`, this enables a griefing attack, causing the `borrower` and `lender` to abandon this contract and redo everything which costs more gas.  If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in `fundLoan()`.  ### Recommendation  Change to:  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:CL:TRANSFER_FROM_FAILED");          require(msg.sender == _borrower, "ML:DF:NOT_BORROWER");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L85-L89  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), "DL:SAS:NOT_PD");          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  Considering that `_allowedSlippage` is a crucial settings for `getExpectedAmount()`, it's necessary to add `require(_allowedSlippage <  10000, "...")` to validate the input.  If `_allowedSlippage` is misconfigured to a value > `10000`, `getExpectedAmount()` will always revert.  ### Recommendation  Change to:  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), "DL:SAS:NOT_PD");         require(_allowedSlippage <  10000, "!slippage")          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  
# Handle  cmichel   # Vulnerability details  The liquidations strategies (`code-423n4/evm-league/56-maple/repo/liquidations-1.0.0-beta.1/contracts/SushiswapStrategy.sol/UniswapStrategy.sol`) check that the current contract balance in the `swap` callback exactly equals the `swapAmount_` parameter from `flashBorrowLiquidation`. (The `swap` is called as a callback from `flashBorrowLiquidation`'s `liquidatePortion`).  ```solidity function swap(     uint256 swapAmount_,     uint256 minReturnAmount_,     address collateralAsset_,     address middleAsset_,     address fundsAsset_,     address profitDestination_ )     external override {     // @audit grifer can send 1 wei. should >=     require(IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_, "SushiswapStrategy:WRONG_COLLATERAL_AMT"); } ```  There's a griefing attacker where a keeper tries to liquidate and calls `flashBorrowLiquidation`  but an attacker frontruns this transaction and sends the smallest unit of the `collateralAsset_` to the contract, making this `require` call fail.  ## Impact The important automated liquidation strategies that Keepers might use do not work anymore, no liquidations are done in time, and bad debt can occur.  I'd rate this as high severity as the impact is big and it's also very easy to break this contract entirely with a single transfer: - there's only one strategy contract for many liquidation contracts which means it's important that it's reliable - it's enough to send a few tokens of collateral assets to the contract _once_ to break the `flashBorrowLiquidation/swap` functionality. Because when calling `flashBorrowLiquidation(swapAmount)`, the liquidation contract will always send exactly this `swapAmount` to the strategy, meaning the `IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_` comparison will always fail if there already were tokens in the contract.  ## Recommended Mitigation Steps Use a `IERC20Like(collateralAsset_).balanceOf(address(this)) >= swapAmount_` comparison instead.   
# Handle  cmichel   # Vulnerability details  It's possible to overwrite the `_versionOf[implementationAddress_]` field through the `proxy-factory-1.0.0-beta.1/contracts/ProxyFactory._registerImplementation` function and register the implementation as several distinct versions.  ```solidity function _registerImplementation(uint256 version_, address implementationAddress_) internal virtual returns (bool success_) {     // Cannot already be registered and cannot be empty implementation.     if (_implementationOf[version_] != address(0) || !_isContract(implementationAddress_)) return false;     _versionOf[implementationAddress_] = version_;     _implementationOf[version_]        = implementationAddress_;      return true; } ```  #### POC - call `_registerImplementation(1, impl)` - call `_registerImplementation(2, impl)`. This does not check that the versions has not already been registered by checking `_versionOf[impl] == 0`. Then the old `_versionOf[impl] = 1` is overwritten with `2`.  ## Recommended Mitigation Steps Check if being able to set a new version for the same contract is desired. If not, add a `_versionOf[impl] == 0` check.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity or possibly gas savings if all the other named returns are in error.  ## Proof of Concept  Function `poolDelegate` does not have a named return even though its interface definition does. The named return isn't used so the fact that it's missing doesn't matter.  Function `pool` and tens of other functions do have a named return. Most of these named returns are not used and could be deleted. I'm assuming this is a project convention and may be used in off-chain reporting, etc.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L279-L285  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a named return to function `poolDelegate' for consistency/reporting.  Or if all those other named returns are in error, remove the unused named returns and kick this ticket over to gas optimization.    
# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings   ## Proof of Concept  "> 0" is used in the following location(s):  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L312  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Change "> 0" to "!=0" for small gas savings.    
# Handle  saian   # Vulnerability details  ## Impact  Contracts should be deployed with the same version of compilers with which it was tested,  Using a unlocked pragma might result in contract being deployed with a version it was not tested with, and might result in bugs and unwanted behaviour.   ## Proof of Concept  Contracts in below repositories :     maple-labs/debt-locker     maple-labs/erc20-helper     maple-labs/loan     maple-labs/maple-proxy-factory     maple-labs/proxy-factory   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Lock the pragma version, it is advised not to use unlocked pragma in production.  
# Handle  wuwe1   # Vulnerability details  liquidations-1.0.0-beta.1/contracts/interfaces/ILiquidator.sol:79:17    * @dev   3. Perfroms a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user.  `Perfroms` should be `Performs`   maple-proxy-factory-1.0.0-beta.1/contracts/interfaces/IMapleProxied.sol:11:42  *  @param toVersion_ The new version ot the loan.  `ot` should be `of`  
# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:                approve without approving 0 first SushiswapStrategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first SushiswapStrategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);          approve without approving 0 first UniswapV2Strategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first UniswapV2Strategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);   
# Handle  robee   # Vulnerability details  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:          Open TODO in DebtLocker.sol line 77 :     // TODO: Discuss pros/cons of pause on this function  
# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:  There are some variables that I was not sure if are assigned actually twice in real use. I added them anyway.          DebtLockerStorage.sol, _repossessed         DebtLockerStorage.sol, _loan         DebtLockerStorage.sol, _liquidator         DebtLockerStorage.sol, _pool         DebtLockerStorage.sol, _allowedSlippage         DebtLockerStorage.sol, _amountRecovered         DebtLockerStorage.sol, _fundsToCapture         DebtLockerStorage.sol, _minRatio         DebtLockerStorage.sol, _principalRemainingAtLastClaim         Liquidator.sol, collateralAsset         Liquidator.sol, destination         Liquidator.sol, fundsAsset         Liquidator.sol, owner         MapleLoanFactory.sol, isLoan         MapleLoanInternals.sol, _borrower         MapleLoanInternals.sol, _lender         MapleLoanInternals.sol, _pendingBorrower         MapleLoanInternals.sol, _pendingLender         MapleLoanInternals.sol, _collateralAsset         MapleLoanInternals.sol, _fundsAsset         MapleLoanInternals.sol, _collateralRequired         MapleLoanInternals.sol, _principalRequested         MapleProxyFactory.sol, mapleGlobals         MapleProxyFactory.sol, defaultVersion         MapleProxyFactory.sol, upgradeEnabledForPath         MapleProxyFactory.t.sol, governor         MapleProxyFactory.t.sol, notGovernor         MapleProxyFactory.t.sol, globals         MapleProxyFactory.t.sol, factory         MapleProxyFactory.t.sol, implementation1         MapleProxyFactory.t.sol, implementation2         MapleProxyFactory.t.sol, initializerV1         MapleProxyFactory.t.sol, initializerV2         MapleProxyFactory.t.sol, user     
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           Liquidator.sol Variable _locked is read 2 times in the function:  liquidatePortion         MapleLoanInternals.sol Variable _drawableFunds is read 2 times in the function:  _closeLoan         MapleLoanInternals.sol Variable _refinanceCommitment is read 2 times in the function:  _acceptNewTerms         MapleLoanInternals.sol Variable _fundsAsset is read 3 times in the function:  _fundLoan         MapleProxyFactory.t.sol Variable governor is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable globals is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable initializerV1 is read 2 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable factory is read 3 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable factory is read 5 times in the function:  test_enableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_disableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation2 is read 2 times in the function:  test_upgradeInstance   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: SushiswapStrategy.sol, In line 53, Require message length to shorten: 38         Solidity file: SushiswapStrategy.sol, In line 74, Require message length to shorten: 33         Solidity file: UniswapV2Strategy.sol, In line 53, Require message length to shorten: 38         Solidity file: UniswapV2Strategy.sol, In line 74, Require message length to shorten: 33         Solidity file: MapleProxyFactory.sol, In line 33, Require message length to shorten: 36         Solidity file: MapleProxyFactory.sol, In line 42, Require message length to shorten: 36  
# Handle  gzeon   # Vulnerability details  ## Impact `stopLiquidation` does not pull fund from `Liquidator` while setting `_liquidator` to address(0). Since the `DebtLocker` own `Liquidator` and there are no way to set `_liquidator` to existing address, fund still in `Liquidator` would be stuck unless `DebtLocker` is upgraded to support such behavior.  Also, when `stopLiquidation` is called, remaining fund in Liquidator can still be liquidated by keepers.  ## Proof of Concept https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L112 ```     function stopLiquidation() external override {         require(msg.sender == _getPoolDelegate(), "DL:SL:NOT_PD");          _liquidator = address(0);          emit LiquidationStopped();     } ```  ## Recommended Mitigation Steps Pull remaining fund in `stopLiquidation`    
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L205-L215  ```solidity function _handleClaimOfRepossessed() internal returns (uint256[7] memory details_) {     ...     details_[0] = recoveredFunds + fundsCaptured;     details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : 0;     details_[2] = fundsCaptured;     details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;     details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : 0;      _fundsToCapture = uint256(0);     _repossessed    = false;      require(ERC20Helper.transfer(fundsAsset, _pool, recoveredFunds + fundsCaptured), "DL:HCOR:TRANSFER"); } ```  `recoveredFunds + fundsCaptured` at L215 is calculated before at L205, since it's a checked arithmetic operation with two memory variables, resue the result instead of doing the arithmetic operation again can save gas.  ### Recommendation  Change to:  `require(ERC20Helper.transfer(fundsAsset, _pool, details_[0]), "DL:HCOR:TRANSFER");`  
# Handle  WatchPug   # Vulnerability details  In `MapleLoanInternals.sol#_getCollateralRequiredFor`, when `principal_ <= drawableFunds_`, `0 / principalRequested_` can be avoid.  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L359-L359  ```solidity=359 return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_; ```  ### Recommendation  Change to:  ```solidity if (principal_ <= drawableFunds_) {     return uint256(0); }  return (collateralRequired_ * (principal_ - drawableFunds_)) / principalRequested_; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/Liquidator.sol#L45-L62  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(!_locked, "LIQ:LP:LOCKED");      _locked = true;     ...     _locked = false; } ```  `SSTORE` from false (0) to true (1) (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  ### Recommendation  Change to:  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(_locked = 1, "LIQ:LP:LOCKED");      _locked = 2;     ...     _locked = 1; } ```  
# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  Instances include:  `IERC20Like(collateralAsset).decimals()` in `DebtLocker.sol#getExpectedAmount()` can be cached to avoid an extra external call.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L237-L253  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** IERC20Like(collateralAsset).decimals()                      // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** IERC20Like(collateralAsset).decimals();      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  ### Recommendation  Change to:  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** collateralAssetDecimals                                     // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** collateralAssetDecimals;      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L86-L93  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:MP:TRANSFER_FROM_FAILED");          ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  The current implementation allows anyone to call `makePayment()` and repay the loan with `_drawableFunds`.  This makes it possible for a malicious `lender` to call `makePayment()` multiple times right after `fundLoan()` and retrieve most of the funds back immediately, while then `borrower` must continue to make payments or lose the `collateral`.  ### PoC   Given:  - `_collateralRequired` = 1 BTC - `_principalRequested` = 12,000 USDC - `_paymentInterval` = 30 day - `_paymentsRemaining` = 12 - `_gracePeriod` = 1 day - `interestRate_` = 2e17  1. The borrower calls `postCollateral()` and added `1 BTC` as `_collateralAsset`; 2. The lender calls `fundLoan()` and added `12,000 USDC` as  `_fundsAsset`; 3. The lender calls `makePayment()` 11 times, then: - `_drawableFunds` = 96 - `_claimableFunds` = 11903 - `_principal` = 1553  4. The lender calls `_claimFunds()` get 11,903 USDC of `_fundsAsset` back;  Now, for the borrower `1,579 USDC` is due, but only `96 USDC` can be used. The borrower is now forced to pay the interests for the funds that never be used or lose the collateral.  ### Recommendation  Change to:  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:MP:TRANSFER_FROM_FAILED");          require(msg.sender == _borrower, "ML:DF:NOT_BORROWER");              ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  
# Handle  gzeon   # Vulnerability details  ## Impact Use type(uint).max instead of block.timestamp to save gas  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L71 https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L71  
# Handle  WatchPug   # Vulnerability details  There are a few functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273  ```solidity=257     uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.     uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Drawable funds is the amount funded, minus any fees.     _drawableFunds = fundsLent_ - treasuryFee - delegateFee;      require(         treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),         "MLI:FL:T_TRANSFER_FAILED"     );      require(         delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),         "MLI:FL:PD_TRANSFER_FAILED"         ); ```  In the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.  This allows the attacker to set very high fees, making `_drawableFunds` near 0.  Since `mapleTreasury` and `poolDelegate` are also read from `lender_`, `treasuryFee` and `investorFee` can be retrieved back to the attacker.  As a result, the borrower won't get any `_drawableFunds` while also being unable to remove collateral.  ### PoC  Given:  - `_collateralRequired` = 10 BTC - `_principalRequested` = 1,000,000 USDC - `_paymentInterval` = 1 day - `_paymentsRemaining` = 10 - `_gracePeriod` = 1 day  1. Alice (borrower) calls `postCollateral()` and added `10 BTC` as `_collateralAsset`; 2. The attacker calls `fundLoan()` by taking `1,000,000 USDC` of flashloan and using a fake `lender`contract; 3. Alice calls `drawdownFunds()` with any amount > 0 will fail; 4. Alice calls `removeCollateral()` with any amount > 0 will get "MLI:DF:INSUFFICIENT_COLLATERAL" error; 5. Unless Alice make payment (which is meaningless), after 2 day, the attacker can call `repossess()` and get `10 BTC`.  ### Recommendation  Consider reading `treasuryFee`, `investorFee`, `mapleTreasury`, `poolDelegate` from an authoritative source instead.  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L56-L63  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:CL:TRANSFER_FROM_FAILED");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  Based on the context, we believe that the `closeLoan()` should only be called by the `borrower`. However, the current implementation allows anyone to call `closeLoan()` anytime after `fundLoan()`.  If there is no `earlyFee`, this enables a griefing attack, causing the `borrower` and `lender` to abandon this contract and redo everything which costs more gas.  If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in `fundLoan()`.  ### Recommendation  Change to:  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:CL:TRANSFER_FROM_FAILED");          require(msg.sender == _borrower, "ML:DF:NOT_BORROWER");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L85-L89  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), "DL:SAS:NOT_PD");          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  Considering that `_allowedSlippage` is a crucial settings for `getExpectedAmount()`, it's necessary to add `require(_allowedSlippage <  10000, "...")` to validate the input.  If `_allowedSlippage` is misconfigured to a value > `10000`, `getExpectedAmount()` will always revert.  ### Recommendation  Change to:  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), "DL:SAS:NOT_PD");         require(_allowedSlippage <  10000, "!slippage")          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  
# Handle  cmichel   # Vulnerability details  The liquidations strategies (`code-423n4/evm-league/56-maple/repo/liquidations-1.0.0-beta.1/contracts/SushiswapStrategy.sol/UniswapStrategy.sol`) check that the current contract balance in the `swap` callback exactly equals the `swapAmount_` parameter from `flashBorrowLiquidation`. (The `swap` is called as a callback from `flashBorrowLiquidation`'s `liquidatePortion`).  ```solidity function swap(     uint256 swapAmount_,     uint256 minReturnAmount_,     address collateralAsset_,     address middleAsset_,     address fundsAsset_,     address profitDestination_ )     external override {     // @audit grifer can send 1 wei. should >=     require(IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_, "SushiswapStrategy:WRONG_COLLATERAL_AMT"); } ```  There's a griefing attacker where a keeper tries to liquidate and calls `flashBorrowLiquidation`  but an attacker frontruns this transaction and sends the smallest unit of the `collateralAsset_` to the contract, making this `require` call fail.  ## Impact The important automated liquidation strategies that Keepers might use do not work anymore, no liquidations are done in time, and bad debt can occur.  I'd rate this as high severity as the impact is big and it's also very easy to break this contract entirely with a single transfer: - there's only one strategy contract for many liquidation contracts which means it's important that it's reliable - it's enough to send a few tokens of collateral assets to the contract _once_ to break the `flashBorrowLiquidation/swap` functionality. Because when calling `flashBorrowLiquidation(swapAmount)`, the liquidation contract will always send exactly this `swapAmount` to the strategy, meaning the `IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_` comparison will always fail if there already were tokens in the contract.  ## Recommended Mitigation Steps Use a `IERC20Like(collateralAsset_).balanceOf(address(this)) >= swapAmount_` comparison instead.   
# Handle  cmichel   # Vulnerability details  It's possible to overwrite the `_versionOf[implementationAddress_]` field through the `proxy-factory-1.0.0-beta.1/contracts/ProxyFactory._registerImplementation` function and register the implementation as several distinct versions.  ```solidity function _registerImplementation(uint256 version_, address implementationAddress_) internal virtual returns (bool success_) {     // Cannot already be registered and cannot be empty implementation.     if (_implementationOf[version_] != address(0) || !_isContract(implementationAddress_)) return false;     _versionOf[implementationAddress_] = version_;     _implementationOf[version_]        = implementationAddress_;      return true; } ```  #### POC - call `_registerImplementation(1, impl)` - call `_registerImplementation(2, impl)`. This does not check that the versions has not already been registered by checking `_versionOf[impl] == 0`. Then the old `_versionOf[impl] = 1` is overwritten with `2`.  ## Recommended Mitigation Steps Check if being able to set a new version for the same contract is desired. If not, add a `_versionOf[impl] == 0` check.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity or possibly gas savings if all the other named returns are in error.  ## Proof of Concept  Function `poolDelegate` does not have a named return even though its interface definition does. The named return isn't used so the fact that it's missing doesn't matter.  Function `pool` and tens of other functions do have a named return. Most of these named returns are not used and could be deleted. I'm assuming this is a project convention and may be used in off-chain reporting, etc.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L279-L285  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a named return to function `poolDelegate' for consistency/reporting.  Or if all those other named returns are in error, remove the unused named returns and kick this ticket over to gas optimization.    
# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings   ## Proof of Concept  "> 0" is used in the following location(s):  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L312  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Change "> 0" to "!=0" for small gas savings.    
# Handle  saian   # Vulnerability details  ## Impact  Contracts should be deployed with the same version of compilers with which it was tested,  Using a unlocked pragma might result in contract being deployed with a version it was not tested with, and might result in bugs and unwanted behaviour.   ## Proof of Concept  Contracts in below repositories :     maple-labs/debt-locker     maple-labs/erc20-helper     maple-labs/loan     maple-labs/maple-proxy-factory     maple-labs/proxy-factory   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Lock the pragma version, it is advised not to use unlocked pragma in production.  
# Handle  wuwe1   # Vulnerability details  liquidations-1.0.0-beta.1/contracts/interfaces/ILiquidator.sol:79:17    * @dev   3. Perfroms a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user.  `Perfroms` should be `Performs`   maple-proxy-factory-1.0.0-beta.1/contracts/interfaces/IMapleProxied.sol:11:42  *  @param toVersion_ The new version ot the loan.  `ot` should be `of`  
# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:                approve without approving 0 first SushiswapStrategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first SushiswapStrategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);          approve without approving 0 first UniswapV2Strategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first UniswapV2Strategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);   
# Handle  robee   # Vulnerability details  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:          Open TODO in DebtLocker.sol line 77 :     // TODO: Discuss pros/cons of pause on this function  
# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:  There are some variables that I was not sure if are assigned actually twice in real use. I added them anyway.          DebtLockerStorage.sol, _repossessed         DebtLockerStorage.sol, _loan         DebtLockerStorage.sol, _liquidator         DebtLockerStorage.sol, _pool         DebtLockerStorage.sol, _allowedSlippage         DebtLockerStorage.sol, _amountRecovered         DebtLockerStorage.sol, _fundsToCapture         DebtLockerStorage.sol, _minRatio         DebtLockerStorage.sol, _principalRemainingAtLastClaim         Liquidator.sol, collateralAsset         Liquidator.sol, destination         Liquidator.sol, fundsAsset         Liquidator.sol, owner         MapleLoanFactory.sol, isLoan         MapleLoanInternals.sol, _borrower         MapleLoanInternals.sol, _lender         MapleLoanInternals.sol, _pendingBorrower         MapleLoanInternals.sol, _pendingLender         MapleLoanInternals.sol, _collateralAsset         MapleLoanInternals.sol, _fundsAsset         MapleLoanInternals.sol, _collateralRequired         MapleLoanInternals.sol, _principalRequested         MapleProxyFactory.sol, mapleGlobals         MapleProxyFactory.sol, defaultVersion         MapleProxyFactory.sol, upgradeEnabledForPath         MapleProxyFactory.t.sol, governor         MapleProxyFactory.t.sol, notGovernor         MapleProxyFactory.t.sol, globals         MapleProxyFactory.t.sol, factory         MapleProxyFactory.t.sol, implementation1         MapleProxyFactory.t.sol, implementation2         MapleProxyFactory.t.sol, initializerV1         MapleProxyFactory.t.sol, initializerV2         MapleProxyFactory.t.sol, user     
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           Liquidator.sol Variable _locked is read 2 times in the function:  liquidatePortion         MapleLoanInternals.sol Variable _drawableFunds is read 2 times in the function:  _closeLoan         MapleLoanInternals.sol Variable _refinanceCommitment is read 2 times in the function:  _acceptNewTerms         MapleLoanInternals.sol Variable _fundsAsset is read 3 times in the function:  _fundLoan         MapleProxyFactory.t.sol Variable governor is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable globals is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable initializerV1 is read 2 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable factory is read 3 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable factory is read 5 times in the function:  test_enableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_disableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation2 is read 2 times in the function:  test_upgradeInstance   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: SushiswapStrategy.sol, In line 53, Require message length to shorten: 38         Solidity file: SushiswapStrategy.sol, In line 74, Require message length to shorten: 33         Solidity file: UniswapV2Strategy.sol, In line 53, Require message length to shorten: 38         Solidity file: UniswapV2Strategy.sol, In line 74, Require message length to shorten: 33         Solidity file: MapleProxyFactory.sol, In line 33, Require message length to shorten: 36         Solidity file: MapleProxyFactory.sol, In line 42, Require message length to shorten: 36  
# Handle  gzeon   # Vulnerability details  ## Impact `stopLiquidation` does not pull fund from `Liquidator` while setting `_liquidator` to address(0). Since the `DebtLocker` own `Liquidator` and there are no way to set `_liquidator` to existing address, fund still in `Liquidator` would be stuck unless `DebtLocker` is upgraded to support such behavior.  Also, when `stopLiquidation` is called, remaining fund in Liquidator can still be liquidated by keepers.  ## Proof of Concept https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L112 ```     function stopLiquidation() external override {         require(msg.sender == _getPoolDelegate(), "DL:SL:NOT_PD");          _liquidator = address(0);          emit LiquidationStopped();     } ```  ## Recommended Mitigation Steps Pull remaining fund in `stopLiquidation`    
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L205-L215  ```solidity function _handleClaimOfRepossessed() internal returns (uint256[7] memory details_) {     ...     details_[0] = recoveredFunds + fundsCaptured;     details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : 0;     details_[2] = fundsCaptured;     details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;     details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : 0;      _fundsToCapture = uint256(0);     _repossessed    = false;      require(ERC20Helper.transfer(fundsAsset, _pool, recoveredFunds + fundsCaptured), "DL:HCOR:TRANSFER"); } ```  `recoveredFunds + fundsCaptured` at L215 is calculated before at L205, since it's a checked arithmetic operation with two memory variables, resue the result instead of doing the arithmetic operation again can save gas.  ### Recommendation  Change to:  `require(ERC20Helper.transfer(fundsAsset, _pool, details_[0]), "DL:HCOR:TRANSFER");`  
# Handle  WatchPug   # Vulnerability details  In `MapleLoanInternals.sol#_getCollateralRequiredFor`, when `principal_ <= drawableFunds_`, `0 / principalRequested_` can be avoid.  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L359-L359  ```solidity=359 return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_; ```  ### Recommendation  Change to:  ```solidity if (principal_ <= drawableFunds_) {     return uint256(0); }  return (collateralRequired_ * (principal_ - drawableFunds_)) / principalRequested_; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/Liquidator.sol#L45-L62  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(!_locked, "LIQ:LP:LOCKED");      _locked = true;     ...     _locked = false; } ```  `SSTORE` from false (0) to true (1) (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  ### Recommendation  Change to:  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(_locked = 1, "LIQ:LP:LOCKED");      _locked = 2;     ...     _locked = 1; } ```  
# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  Instances include:  `IERC20Like(collateralAsset).decimals()` in `DebtLocker.sol#getExpectedAmount()` can be cached to avoid an extra external call.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L237-L253  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** IERC20Like(collateralAsset).decimals()                      // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** IERC20Like(collateralAsset).decimals();      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  ### Recommendation  Change to:  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** collateralAssetDecimals                                     // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** collateralAssetDecimals;      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L86-L93  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:MP:TRANSFER_FROM_FAILED");          ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  The current implementation allows anyone to call `makePayment()` and repay the loan with `_drawableFunds`.  This makes it possible for a malicious `lender` to call `makePayment()` multiple times right after `fundLoan()` and retrieve most of the funds back immediately, while then `borrower` must continue to make payments or lose the `collateral`.  ### PoC   Given:  - `_collateralRequired` = 1 BTC - `_principalRequested` = 12,000 USDC - `_paymentInterval` = 30 day - `_paymentsRemaining` = 12 - `_gracePeriod` = 1 day - `interestRate_` = 2e17  1. The borrower calls `postCollateral()` and added `1 BTC` as `_collateralAsset`; 2. The lender calls `fundLoan()` and added `12,000 USDC` as  `_fundsAsset`; 3. The lender calls `makePayment()` 11 times, then: - `_drawableFunds` = 96 - `_claimableFunds` = 11903 - `_principal` = 1553  4. The lender calls `_claimFunds()` get 11,903 USDC of `_fundsAsset` back;  Now, for the borrower `1,579 USDC` is due, but only `96 USDC` can be used. The borrower is now forced to pay the interests for the funds that never be used or lose the collateral.  ### Recommendation  Change to:  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:MP:TRANSFER_FROM_FAILED");          require(msg.sender == _borrower, "ML:DF:NOT_BORROWER");              ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  
# Handle  gzeon   # Vulnerability details  ## Impact Use type(uint).max instead of block.timestamp to save gas  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L71 https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L71  
# Handle  WatchPug   # Vulnerability details  There are a few functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L55-L55 ```solidity=55 ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_); ```  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273  ```solidity=257     uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.     uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Drawable funds is the amount funded, minus any fees.     _drawableFunds = fundsLent_ - treasuryFee - delegateFee;      require(         treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),         "MLI:FL:T_TRANSFER_FAILED"     );      require(         delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),         "MLI:FL:PD_TRANSFER_FAILED"         ); ```  In the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.  This allows the attacker to set very high fees, making `_drawableFunds` near 0.  Since `mapleTreasury` and `poolDelegate` are also read from `lender_`, `treasuryFee` and `investorFee` can be retrieved back to the attacker.  As a result, the borrower won't get any `_drawableFunds` while also being unable to remove collateral.  ### PoC  Given:  - `_collateralRequired` = 10 BTC - `_principalRequested` = 1,000,000 USDC - `_paymentInterval` = 1 day - `_paymentsRemaining` = 10 - `_gracePeriod` = 1 day  1. Alice (borrower) calls `postCollateral()` and added `10 BTC` as `_collateralAsset`; 2. The attacker calls `fundLoan()` by taking `1,000,000 USDC` of flashloan and using a fake `lender`contract; 3. Alice calls `drawdownFunds()` with any amount > 0 will fail; 4. Alice calls `removeCollateral()` with any amount > 0 will get "MLI:DF:INSUFFICIENT_COLLATERAL" error; 5. Unless Alice make payment (which is meaningless), after 2 day, the attacker can call `repossess()` and get `10 BTC`.  ### Recommendation  Consider reading `treasuryFee`, `investorFee`, `mapleTreasury`, `poolDelegate` from an authoritative source instead.  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L56-L63  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:CL:TRANSFER_FROM_FAILED");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  Based on the context, we believe that the `closeLoan()` should only be called by the `borrower`. However, the current implementation allows anyone to call `closeLoan()` anytime after `fundLoan()`.  If there is no `earlyFee`, this enables a griefing attack, causing the `borrower` and `lender` to abandon this contract and redo everything which costs more gas.  If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in `fundLoan()`.  ### Recommendation  Change to:  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), "ML:CL:TRANSFER_FROM_FAILED");          require(msg.sender == _borrower, "ML:DF:NOT_BORROWER");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L85-L89  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), "DL:SAS:NOT_PD");          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  Considering that `_allowedSlippage` is a crucial settings for `getExpectedAmount()`, it's necessary to add `require(_allowedSlippage <  10000, "...")` to validate the input.  If `_allowedSlippage` is misconfigured to a value > `10000`, `getExpectedAmount()` will always revert.  ### Recommendation  Change to:  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), "DL:SAS:NOT_PD");         require(_allowedSlippage <  10000, "!slippage")          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  
# Handle  cmichel   # Vulnerability details  The liquidations strategies (`code-423n4/evm-league/56-maple/repo/liquidations-1.0.0-beta.1/contracts/SushiswapStrategy.sol/UniswapStrategy.sol`) check that the current contract balance in the `swap` callback exactly equals the `swapAmount_` parameter from `flashBorrowLiquidation`. (The `swap` is called as a callback from `flashBorrowLiquidation`'s `liquidatePortion`).  ```solidity function swap(     uint256 swapAmount_,     uint256 minReturnAmount_,     address collateralAsset_,     address middleAsset_,     address fundsAsset_,     address profitDestination_ )     external override {     // @audit grifer can send 1 wei. should >=     require(IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_, "SushiswapStrategy:WRONG_COLLATERAL_AMT"); } ```  There's a griefing attacker where a keeper tries to liquidate and calls `flashBorrowLiquidation`  but an attacker frontruns this transaction and sends the smallest unit of the `collateralAsset_` to the contract, making this `require` call fail.  ## Impact The important automated liquidation strategies that Keepers might use do not work anymore, no liquidations are done in time, and bad debt can occur.  I'd rate this as high severity as the impact is big and it's also very easy to break this contract entirely with a single transfer: - there's only one strategy contract for many liquidation contracts which means it's important that it's reliable - it's enough to send a few tokens of collateral assets to the contract _once_ to break the `flashBorrowLiquidation/swap` functionality. Because when calling `flashBorrowLiquidation(swapAmount)`, the liquidation contract will always send exactly this `swapAmount` to the strategy, meaning the `IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_` comparison will always fail if there already were tokens in the contract.  ## Recommended Mitigation Steps Use a `IERC20Like(collateralAsset_).balanceOf(address(this)) >= swapAmount_` comparison instead.   
# Handle  cmichel   # Vulnerability details  It's possible to overwrite the `_versionOf[implementationAddress_]` field through the `proxy-factory-1.0.0-beta.1/contracts/ProxyFactory._registerImplementation` function and register the implementation as several distinct versions.  ```solidity function _registerImplementation(uint256 version_, address implementationAddress_) internal virtual returns (bool success_) {     // Cannot already be registered and cannot be empty implementation.     if (_implementationOf[version_] != address(0) || !_isContract(implementationAddress_)) return false;     _versionOf[implementationAddress_] = version_;     _implementationOf[version_]        = implementationAddress_;      return true; } ```  #### POC - call `_registerImplementation(1, impl)` - call `_registerImplementation(2, impl)`. This does not check that the versions has not already been registered by checking `_versionOf[impl] == 0`. Then the old `_versionOf[impl] = 1` is overwritten with `2`.  ## Recommended Mitigation Steps Check if being able to set a new version for the same contract is desired. If not, add a `_versionOf[impl] == 0` check.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity or possibly gas savings if all the other named returns are in error.  ## Proof of Concept  Function `poolDelegate` does not have a named return even though its interface definition does. The named return isn't used so the fact that it's missing doesn't matter.  Function `pool` and tens of other functions do have a named return. Most of these named returns are not used and could be deleted. I'm assuming this is a project convention and may be used in off-chain reporting, etc.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L279-L285  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a named return to function `poolDelegate' for consistency/reporting.  Or if all those other named returns are in error, remove the unused named returns and kick this ticket over to gas optimization.    
# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings   ## Proof of Concept  "> 0" is used in the following location(s):  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L312  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Change "> 0" to "!=0" for small gas savings.    
# Handle  saian   # Vulnerability details  ## Impact  Contracts should be deployed with the same version of compilers with which it was tested,  Using a unlocked pragma might result in contract being deployed with a version it was not tested with, and might result in bugs and unwanted behaviour.   ## Proof of Concept  Contracts in below repositories :     maple-labs/debt-locker     maple-labs/erc20-helper     maple-labs/loan     maple-labs/maple-proxy-factory     maple-labs/proxy-factory   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Lock the pragma version, it is advised not to use unlocked pragma in production.  
# Handle  wuwe1   # Vulnerability details  liquidations-1.0.0-beta.1/contracts/interfaces/ILiquidator.sol:79:17    * @dev   3. Perfroms a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user.  `Perfroms` should be `Performs`   maple-proxy-factory-1.0.0-beta.1/contracts/interfaces/IMapleProxied.sol:11:42  *  @param toVersion_ The new version ot the loan.  `ot` should be `of`  
# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:                approve without approving 0 first SushiswapStrategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first SushiswapStrategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);          approve without approving 0 first UniswapV2Strategy.sol, 25,         ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);          approve without approving 0 first UniswapV2Strategy.sol, 54,         ERC20Helper.approve(collateralAsset_, ROUTER, swapAmount_);   
# Handle  robee   # Vulnerability details  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:          Open TODO in DebtLocker.sol line 77 :     // TODO: Discuss pros/cons of pause on this function  
# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:  There are some variables that I was not sure if are assigned actually twice in real use. I added them anyway.          DebtLockerStorage.sol, _repossessed         DebtLockerStorage.sol, _loan         DebtLockerStorage.sol, _liquidator         DebtLockerStorage.sol, _pool         DebtLockerStorage.sol, _allowedSlippage         DebtLockerStorage.sol, _amountRecovered         DebtLockerStorage.sol, _fundsToCapture         DebtLockerStorage.sol, _minRatio         DebtLockerStorage.sol, _principalRemainingAtLastClaim         Liquidator.sol, collateralAsset         Liquidator.sol, destination         Liquidator.sol, fundsAsset         Liquidator.sol, owner         MapleLoanFactory.sol, isLoan         MapleLoanInternals.sol, _borrower         MapleLoanInternals.sol, _lender         MapleLoanInternals.sol, _pendingBorrower         MapleLoanInternals.sol, _pendingLender         MapleLoanInternals.sol, _collateralAsset         MapleLoanInternals.sol, _fundsAsset         MapleLoanInternals.sol, _collateralRequired         MapleLoanInternals.sol, _principalRequested         MapleProxyFactory.sol, mapleGlobals         MapleProxyFactory.sol, defaultVersion         MapleProxyFactory.sol, upgradeEnabledForPath         MapleProxyFactory.t.sol, governor         MapleProxyFactory.t.sol, notGovernor         MapleProxyFactory.t.sol, globals         MapleProxyFactory.t.sol, factory         MapleProxyFactory.t.sol, implementation1         MapleProxyFactory.t.sol, implementation2         MapleProxyFactory.t.sol, initializerV1         MapleProxyFactory.t.sol, initializerV2         MapleProxyFactory.t.sol, user     
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           Liquidator.sol Variable _locked is read 2 times in the function:  liquidatePortion         MapleLoanInternals.sol Variable _drawableFunds is read 2 times in the function:  _closeLoan         MapleLoanInternals.sol Variable _refinanceCommitment is read 2 times in the function:  _acceptNewTerms         MapleLoanInternals.sol Variable _fundsAsset is read 3 times in the function:  _fundLoan         MapleProxyFactory.t.sol Variable governor is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable globals is read 2 times in the function:  setUp         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable initializerV1 is read 2 times in the function:  test_registerImplementation         MapleProxyFactory.t.sol Variable factory is read 3 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_setDefaultVersion         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable implementation1 is read 3 times in the function:  test_createInstance         MapleProxyFactory.t.sol Variable factory is read 5 times in the function:  test_enableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_disableUpgradePath         MapleProxyFactory.t.sol Variable factory is read 4 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation1 is read 2 times in the function:  test_upgradeInstance         MapleProxyFactory.t.sol Variable implementation2 is read 2 times in the function:  test_upgradeInstance   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: SushiswapStrategy.sol, In line 53, Require message length to shorten: 38         Solidity file: SushiswapStrategy.sol, In line 74, Require message length to shorten: 33         Solidity file: UniswapV2Strategy.sol, In line 53, Require message length to shorten: 38         Solidity file: UniswapV2Strategy.sol, In line 74, Require message length to shorten: 33         Solidity file: MapleProxyFactory.sol, In line 33, Require message length to shorten: 36         Solidity file: MapleProxyFactory.sol, In line 42, Require message length to shorten: 36  
