# Handle  jmak   # Vulnerability details  ## Impact Detailed description of the impact of this finding.The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The SubmitBadSignatureEvidence handler is omitted from module/x/gravity/handler.go  ## Tools Used Visual inspection  ## Recommended Mitigation Steps Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go.   
# Handle  shw   # Vulnerability details  ## Impact  The `sendToCosmos` function of `Gravity` transfers `_amount` of `_tokenContract` from the sender using the function `transferFrom`. If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than `_amount`. However, since `_amount` is passed as a parameter of the `SendToCosmosEvent` event, the Cosmos side will think more tokens are locked on the Ethereum side.  ## Proof of Concept  Referenced code: [Gravity.sol#L535](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L535) [Gravity.sol#L541](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L541)  ## Recommended Mitigation Steps  Consider getting the received amount by calculating the difference of token balance (using `balanceOf`) before and after the `transferFrom`.  
# Handle  shw   # Vulnerability details  ## Impact  The `verifySig` function of `Gravity` calls the Solidity `ecrecover` function directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks.  Although a replay attack seems not possible here since the nonce is increased each time, ensuring the signatures are not malleable is considered a best practice (and so is checking `_signer != address(0)`, where `address(0)` means an invalid signature).  ## Proof of Concept  Referenced code: [Gravity.sol#L153](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L153)  [SWC-117: Signature Malleability](https://swcregistry.io/docs/SWC-117) [SWC-121: Missing Protection against Signature Replay Attacks](https://swcregistry.io/docs/SWC-121)  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification.  
# Handle  shw   # Vulnerability details  ## Impact  SafeMath library functions are not always used in the `Gravity` contract's arithmetic operations, which could cause integer underflow/overflows. Using SafeMath is considered a best practice that could completely prevent underflow/overflows and increase code consistency.  ## Proof of Concept  Referenced code: [Gravity.sol#L202](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L202) [Gravity.sol#L586](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L586)  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that on the cosmos side Coin amount has not been checked on the token definition. That can use misfunctionality on the bridge.  Although zero amount definition fee will be calculated. That can cause lose of user funds.   ## Proof of Concept  1. Navigate to "https://github.com/althea-net/cosmos-gravity-bridge/blob/main/module/x/gravity/types/ethereum.go" Line #69. 2. On the following code, ValidateBasic function does not validate amount.  ``` // ValidateBasic permforms stateless validation func (e *ERC20Token) ValidateBasic() error {  if err := ValidateEthAddress(e.Contract); err != nil {   return sdkerrors.Wrap(err, "ethereum address")  }  // TODO: Validate all the things  return nil } ```  ## Tools Used  ## Recommended Mitigation Steps  Add the following validation steps on the ValidationBasic function.  ```  if !m.Amount.IsValid() {   return cosmos.ErrInvalidCoins("coins must be valid")  }   if !m.Amount.IsAllPositive() {   return cosmos.ErrInvalidCoins("coins must be positive")  } ```    
# Handle  hrkrshnn   # Vulnerability details  ##  `updateValset` does not have enough sanity checks  In [updateValset](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L224) function, the current set of validators adds a new set.  It is missing the check that the combined power of all new validators is above the `state_powerThreshold`. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this.  It is also worth adding a that the size of the new validator check is less than a certain number.  Here is a rough calculation explaining how 10000 validators (an extreme example) is too much:  1.  Let us say that the new set of validators have the property that at     least, say, `N` validators are needed to get the total threshold     above `state_powerThreshold`. 2.  Since each validating signature requires a call to `ecrecover`,     costing at least `3000` gas, the minimum gas needed for getting a     proposal over `state_powerThreshold` would be `N * 3000` 3.  `N * 3000` cannot be more than the `block.gaslimit` Currently, this     puts `N` to be less than `10000`  Another approach to solve the above potential problems is to do the updating as a two step process:  1.  The current set of validators proposes a pending set of validators. 2.  And the pending set of validators need to do the transition to     become the new set of validators. Going through the same threshold     checks.  This guarantees that the new set of validators has enough power to pass threshold and doesn't have gas limit issues in doing so.   
# Handle  hrkrshnn   # Vulnerability details  ## State Variables that can be changed to `immutable`  [Solidity 0.6.5](https://blog.soliditylang.org/2020/04/06/solidity-0.6.5-release-announcement/) introduced `immutable` as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public owner = msg.sender; } ```  In the above example, each call to the function `owner()` reads from storage, using a `sload`. After [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public immutable owner = msg.sender; } ```  In the above example, each storage read of the `owner` state variable is replaced by the instruction `push32 value`, where `value` is set during contract construction time. Unlike the last example, this costs only 3 gas.  ### Examples  1.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L59> 2.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L60>    
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  https://swcregistry.io/docs/SWC-103  ## Proof of Concept https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L1  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  pauliax   # Vulnerability details  ## Impact I am concerned why invalidationId, invalidationNonce or valsetNonce are only required to be greater than the previous value. Why did you choose this approach instead of just simply asking for an incremented value? While this may not be a problem if the validators are honest, but otherwise, they may submit a nonce of MAX UINT and thus block the whole system as it would be no longer possible to submit a greater value. Again, just wanted you to be aware of this issue, not sure how likely this to happen is in practice, it depends on the honesty of validators so you better know.  ## Recommended Mitigation Steps I didn't receive an answer on Discord so decided to submit this FYI to decide if that's a hazard or no.  
# Handle  pauliax   # Vulnerability details  ## Impact There are a few validations that could be added to the system: the constructor could check that _gravityId is not empty. state_powerThreshold should always be greater than 0, otherwise, anyone will be available to execute actions.  ## Recommended Mitigation Steps Consider implementing suggested validations.  
# Handle  nascent   # Vulnerability details  **Severity: Medium** **Likelihood: High**  In `eth_oracle_main_loop`, `get_last_checked_block` is called. Followed by: ```rust= let logic_call_executed_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![LOGIC_CALL_EVENT_SIG],             )             .await; ``` and may hit the code path: ```rust=         for event in logic_call_executed_events {             match LogicCallExecutedEvent::from_log(&event) {                 Ok(call) => {                     trace!(                         "{} LogicCall event nonce {} last event nonce",                         call.event_nonce,                         last_event_nonce                     );                     if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()                     {                         return event.block_number.unwrap();                     }                 }                 Err(e) => error!("Got ERC20Deployed event that we can't parse {}", e),             }         } ```  But will panic at `from_log` here: ```rust= impl LogicCallExecutedEvent {     pub fn from_log(_input: &Log) -> Result<LogicCallExecutedEvent, GravityError> {         unimplemented!()     }     // snip... } ``` It can/will also be triggered here in `check_for_events`:  ```rust= let logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?; ```  Attestations will be frozen until patched.  ## Recommendation Implement the method.  ## Recommended Mitigation Steps  
# Handle  nascent   # Vulnerability details  "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayer" can affect just the relayers & not affect the oracle in certain circumstances. This could result in valid attestations, but prevent any of the other relayers from being able to participate in the execution. While the other relayers are down from the other attack, the attacker can win all batch, logic, and valset rewards as their node is the only relayer running. This is possible because `find_latest_valset` is run in the main relayer loop and everytime tries for 5000 blocks of logs.  
# Handle  nascent   # Vulnerability details  In a similar vein to "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms", a sufficiently large validator set or sufficiently rapid validator update could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors. In `find_latest_valset`, [we call](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/relayer/src/find_latest_valset.rs#L33-L40): ```rust= let mut all_valset_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![VALSET_UPDATED_EVENT_SIG],             )             .await?; ```  Which if the validator set is sufficiently large, or sufficiently rapidly updated, which continuous return an error if the logs in a 5000 (see: `const BLOCKS_TO_SEARCH: u128 = 5_000u128;`) block range are in excess of 10mb. Cosmos hub says they will be pushing the number of validators up to 300 (currently 125). At 300, each log would produce 19328 bytes of data (4\*32+64\*300). Given this, there must be below 517 updates per 5000 block range otherwise the node will fall out of sync.   This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  
# Handle  nascent   # Vulnerability details  Ethereum Oracles watch for events on the `Gravity.sol` contract on the Ethereum blockchain. This is performed in the [`check_for_events`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L23) function, ran in the [`eth_oracle_main_loop`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/main_loop.rs#L94).   In this function, there is [the following code snippet](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L66-L73): ```rust=     let erc20_deployed = web3         .check_for_events(             starting_block.clone(),             Some(latest_block.clone()),             vec![gravity_contract_address],             vec![ERC20_DEPLOYED_EVENT_SIG],         )         .await; ``` This snippet leverages the `web30` library to check for events from the `starting_block` to the `latest_block`. Inside the `web30` library this nets out to calling: ```rust=     pub async fn eth_get_logs(&self, new_filter: NewFilter) -> Result<Vec<Log>, Web3Error> {         self.jsonrpc_client             .request_method(                 "eth_getLogs",                 vec![new_filter],                 self.timeout,                 Some(10_000_000),             )             .await     } ```  The `10_000_000` specifies the maximum size of the return in bytes and returns an error if the return is larger: ```rust=         let res: Response<R> = match res.json().limit(limit).await {             Ok(val) => val,             Err(e) => return Err(Web3Error::BadResponse(format!("Web3 Error {}", e))),         }; ```  This can be triggered at will and keep the loop in a perpetual state of returning the `GravityError::EthereumRestError(Web3Error::BadResponse(             "Failed to get logs!".to_string()))` error. To force the node into this state, you just have to deploy ERC20s generated by the [public function in `Gravity.sol`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546-L565): ```solidity=  function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  And specify a large string as the denom, name, or symbol. If an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, and valset updates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due to `get_last_checked_block`.  This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  Additionally, you could require that validators sign ERC20 creation requests.  
# Handle  nascent   # Vulnerability details  Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.  # Proof of Concept Note the `c0` in the last argument of the call data (invalid UTF8).  It can be triggered with: ```solidity= data memory bytes = hex"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000"; gravity.call(data); ``` The log output is as follows: ``` ERC20DeployedEvent("atom", "name", ❮utf8 decode failed❯: 0x73796d626fc0, 18, 2) ```  Which hits [this code path](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/gravity_utils/src/types/ethereum_events.rs#L431-L438): ```rust=             let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());             trace!("Symbol {:?}", symbol);             if symbol.is_err() {                 return Err(GravityError::InvalidEventLogError(format!(                     "{:?} is not valid utf8, probably incorrect parsing",                     symbol                 )));             } ```  And would cause an early return [here](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L99): ```rust= let erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?; ```  Never updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.  ## Recommendation This is a hard one. Resyncing is permanently borked because on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce `N` from the orchestrator, but they can never parse the event `N`. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new `Gravity.sol` is deployed.  One potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.   
# Handle  ElliotFriedman   # Vulnerability details  ## Impact Currently, submitBatch, updateValset, deployERC20 and submitLogicCall all have arguments that are in memory. This causes calls to these functions to be more expensive than they need to be. By moving to external functions and upgrading the compiler version, there will be gas savings. The larger the amount of data being submitted to the contracts, the greater the savings as the cost of memory in the EVM goes up quadratically with the amount of data stored.  ## Tools Used Hardhat  ## Recommended Mitigation Steps Make all functions that you can external instead of public, especially the ones mentioned above that will see large transaction volumes, and change the data types from memory to external. This may involve changing compiler versions to 0.8.0 or greater to support using structs as external types.  
# Handle  jmak   # Vulnerability details  ## Impact Detailed description of the impact of this finding. The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The SubmitBadSignatureEvidence handler is omitted from module/x/gravity/handler.go  ## Tools Used Visual inspection  ## Recommended Mitigation Steps Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go.   
# Handle  shw   # Vulnerability details  ## Impact  The `sendToCosmos` function of `Gravity` transfers `_amount` of `_tokenContract` from the sender using the function `transferFrom`. If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than `_amount`. However, since `_amount` is passed as a parameter of the `SendToCosmosEvent` event, the Cosmos side will think more tokens are locked on the Ethereum side.  ## Proof of Concept  Referenced code: [Gravity.sol#L535](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L535) [Gravity.sol#L541](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L541)  ## Recommended Mitigation Steps  Consider getting the received amount by calculating the difference of token balance (using `balanceOf`) before and after the `transferFrom`.  
# Handle  shw   # Vulnerability details  ## Impact  The `verifySig` function of `Gravity` calls the Solidity `ecrecover` function directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks.  Although a replay attack seems not possible here since the nonce is increased each time, ensuring the signatures are not malleable is considered a best practice (and so is checking `_signer != address(0)`, where `address(0)` means an invalid signature).  ## Proof of Concept  Referenced code: [Gravity.sol#L153](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L153)  [SWC-117: Signature Malleability](https://swcregistry.io/docs/SWC-117) [SWC-121: Missing Protection against Signature Replay Attacks](https://swcregistry.io/docs/SWC-121)  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification.  
# Handle  shw   # Vulnerability details  ## Impact  SafeMath library functions are not always used in the `Gravity` contract's arithmetic operations, which could cause integer underflow/overflows. Using SafeMath is considered a best practice that could completely prevent underflow/overflows and increase code consistency.  ## Proof of Concept  Referenced code: [Gravity.sol#L202](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L202) [Gravity.sol#L586](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L586)  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that on the cosmos side Coin amount has not been checked on the token definition. That can use misfunctionality on the bridge.  Although zero amount definition fee will be calculated. That can cause lose of user funds.   ## Proof of Concept  1. Navigate to "https://github.com/althea-net/cosmos-gravity-bridge/blob/main/module/x/gravity/types/ethereum.go" Line #69. 2. On the following code, ValidateBasic function does not validate amount.  ``` // ValidateBasic permforms stateless validation func (e *ERC20Token) ValidateBasic() error {  if err := ValidateEthAddress(e.Contract); err != nil {   return sdkerrors.Wrap(err, "ethereum address")  }  // TODO: Validate all the things  return nil } ```  ## Tools Used  ## Recommended Mitigation Steps  Add the following validation steps on the ValidationBasic function.  ```  if !m.Amount.IsValid() {   return cosmos.ErrInvalidCoins("coins must be valid")  }   if !m.Amount.IsAllPositive() {   return cosmos.ErrInvalidCoins("coins must be positive")  } ```    
# Handle  hrkrshnn   # Vulnerability details  ##  `updateValset` does not have enough sanity checks  In [updateValset](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L224) function, the current set of validators adds a new set.  It is missing the check that the combined power of all new validators is above the `state_powerThreshold`. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this.  It is also worth adding a that the size of the new validator check is less than a certain number.  Here is a rough calculation explaining how 10000 validators (an extreme example) is too much:  1.  Let us say that the new set of validators have the property that at     least, say, `N` validators are needed to get the total threshold     above `state_powerThreshold`. 2.  Since each validating signature requires a call to `ecrecover`,     costing at least `3000` gas, the minimum gas needed for getting a     proposal over `state_powerThreshold` would be `N * 3000` 3.  `N * 3000` cannot be more than the `block.gaslimit` Currently, this     puts `N` to be less than `10000`  Another approach to solve the above potential problems is to do the updating as a two step process:  1.  The current set of validators proposes a pending set of validators. 2.  And the pending set of validators need to do the transition to     become the new set of validators. Going through the same threshold     checks.  This guarantees that the new set of validators has enough power to pass threshold and doesn't have gas limit issues in doing so.   
# Handle  hrkrshnn   # Vulnerability details  ## State Variables that can be changed to `immutable`  [Solidity 0.6.5](https://blog.soliditylang.org/2020/04/06/solidity-0.6.5-release-announcement/) introduced `immutable` as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public owner = msg.sender; } ```  In the above example, each call to the function `owner()` reads from storage, using a `sload`. After [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public immutable owner = msg.sender; } ```  In the above example, each storage read of the `owner` state variable is replaced by the instruction `push32 value`, where `value` is set during contract construction time. Unlike the last example, this costs only 3 gas.  ### Examples  1.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L59> 2.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L60>    
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  https://swcregistry.io/docs/SWC-103  ## Proof of Concept https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L1  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  pauliax   # Vulnerability details  ## Impact I am concerned why invalidationId, invalidationNonce or valsetNonce are only required to be greater than the previous value. Why did you choose this approach instead of just simply asking for an incremented value? While this may not be a problem if the validators are honest, but otherwise, they may submit a nonce of MAX UINT and thus block the whole system as it would be no longer possible to submit a greater value. Again, just wanted you to be aware of this issue, not sure how likely this to happen is in practice, it depends on the honesty of validators so you better know.  ## Recommended Mitigation Steps I didn't receive an answer on Discord so decided to submit this FYI to decide if that's a hazard or no.  
# Handle  pauliax   # Vulnerability details  ## Impact There are a few validations that could be added to the system: the constructor could check that _gravityId is not empty. state_powerThreshold should always be greater than 0, otherwise, anyone will be available to execute actions.  ## Recommended Mitigation Steps Consider implementing suggested validations.  
# Handle  nascent   # Vulnerability details  **Severity: Medium** **Likelihood: High**  In `eth_oracle_main_loop`, `get_last_checked_block` is called. Followed by: ```rust= let logic_call_executed_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![LOGIC_CALL_EVENT_SIG],             )             .await; ``` and may hit the code path: ```rust=         for event in logic_call_executed_events {             match LogicCallExecutedEvent::from_log(&event) {                 Ok(call) => {                     trace!(                         "{} LogicCall event nonce {} last event nonce",                         call.event_nonce,                         last_event_nonce                     );                     if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()                     {                         return event.block_number.unwrap();                     }                 }                 Err(e) => error!("Got ERC20Deployed event that we can't parse {}", e),             }         } ```  But will panic at `from_log` here: ```rust= impl LogicCallExecutedEvent {     pub fn from_log(_input: &Log) -> Result<LogicCallExecutedEvent, GravityError> {         unimplemented!()     }     // snip... } ``` It can/will also be triggered here in `check_for_events`:  ```rust= let logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?; ```  Attestations will be frozen until patched.  ## Recommendation Implement the method.  ## Recommended Mitigation Steps  
# Handle  nascent   # Vulnerability details  "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayer" can affect just the relayers & not affect the oracle in certain circumstances. This could result in valid attestations, but prevent any of the other relayers from being able to participate in the execution. While the other relayers are down from the other attack, the attacker can win all batch, logic, and valset rewards as their node is the only relayer running. This is possible because `find_latest_valset` is run in the main relayer loop and everytime tries for 5000 blocks of logs.  
# Handle  nascent   # Vulnerability details  In a similar vein to "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms", a sufficiently large validator set or sufficiently rapid validator update could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors. In `find_latest_valset`, [we call](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/relayer/src/find_latest_valset.rs#L33-L40): ```rust= let mut all_valset_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![VALSET_UPDATED_EVENT_SIG],             )             .await?; ```  Which if the validator set is sufficiently large, or sufficiently rapidly updated, which continuous return an error if the logs in a 5000 (see: `const BLOCKS_TO_SEARCH: u128 = 5_000u128;`) block range are in excess of 10mb. Cosmos hub says they will be pushing the number of validators up to 300 (currently 125). At 300, each log would produce 19328 bytes of data (4\*32+64\*300). Given this, there must be below 517 updates per 5000 block range otherwise the node will fall out of sync.   This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  
# Handle  nascent   # Vulnerability details  Ethereum Oracles watch for events on the `Gravity.sol` contract on the Ethereum blockchain. This is performed in the [`check_for_events`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L23) function, ran in the [`eth_oracle_main_loop`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/main_loop.rs#L94).   In this function, there is [the following code snippet](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L66-L73): ```rust=     let erc20_deployed = web3         .check_for_events(             starting_block.clone(),             Some(latest_block.clone()),             vec![gravity_contract_address],             vec![ERC20_DEPLOYED_EVENT_SIG],         )         .await; ``` This snippet leverages the `web30` library to check for events from the `starting_block` to the `latest_block`. Inside the `web30` library this nets out to calling: ```rust=     pub async fn eth_get_logs(&self, new_filter: NewFilter) -> Result<Vec<Log>, Web3Error> {         self.jsonrpc_client             .request_method(                 "eth_getLogs",                 vec![new_filter],                 self.timeout,                 Some(10_000_000),             )             .await     } ```  The `10_000_000` specifies the maximum size of the return in bytes and returns an error if the return is larger: ```rust=         let res: Response<R> = match res.json().limit(limit).await {             Ok(val) => val,             Err(e) => return Err(Web3Error::BadResponse(format!("Web3 Error {}", e))),         }; ```  This can be triggered at will and keep the loop in a perpetual state of returning the `GravityError::EthereumRestError(Web3Error::BadResponse(             "Failed to get logs!".to_string()))` error. To force the node into this state, you just have to deploy ERC20s generated by the [public function in `Gravity.sol`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546-L565): ```solidity=  function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  And specify a large string as the denom, name, or symbol. If an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, and valset updates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due to `get_last_checked_block`.  This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  Additionally, you could require that validators sign ERC20 creation requests.  
# Handle  nascent   # Vulnerability details  Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.  # Proof of Concept Note the `c0` in the last argument of the call data (invalid UTF8).  It can be triggered with: ```solidity= data memory bytes = hex"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000"; gravity.call(data); ``` The log output is as follows: ``` ERC20DeployedEvent("atom", "name", ❮utf8 decode failed❯: 0x73796d626fc0, 18, 2) ```  Which hits [this code path](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/gravity_utils/src/types/ethereum_events.rs#L431-L438): ```rust=             let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());             trace!("Symbol {:?}", symbol);             if symbol.is_err() {                 return Err(GravityError::InvalidEventLogError(format!(                     "{:?} is not valid utf8, probably incorrect parsing",                     symbol                 )));             } ```  And would cause an early return [here](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L99): ```rust= let erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?; ```  Never updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.  ## Recommendation This is a hard one. Resyncing is permanently borked because on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce `N` from the orchestrator, but they can never parse the event `N`. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new `Gravity.sol` is deployed.  One potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.   
# Handle  ElliotFriedman   # Vulnerability details  ## Impact Currently, submitBatch, updateValset, deployERC20 and submitLogicCall all have arguments that are in memory. This causes calls to these functions to be more expensive than they need to be. By moving to external functions and upgrading the compiler version, there will be gas savings. The larger the amount of data being submitted to the contracts, the greater the savings as the cost of memory in the EVM goes up quadratically with the amount of data stored.  ## Tools Used Hardhat  ## Recommended Mitigation Steps Make all functions that you can external instead of public, especially the ones mentioned above that will see large transaction volumes, and change the data types from memory to external. This may involve changing compiler versions to 0.8.0 or greater to support using structs as external types.  
# Handle  jmak   # Vulnerability details  ## Impact Detailed description of the impact of this finding. The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The SubmitBadSignatureEvidence handler is omitted from module/x/gravity/handler.go  ## Tools Used Visual inspection  ## Recommended Mitigation Steps Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go.   
# Handle  shw   # Vulnerability details  ## Impact  The `sendToCosmos` function of `Gravity` transfers `_amount` of `_tokenContract` from the sender using the function `transferFrom`. If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than `_amount`. However, since `_amount` is passed as a parameter of the `SendToCosmosEvent` event, the Cosmos side will think more tokens are locked on the Ethereum side.  ## Proof of Concept  Referenced code: [Gravity.sol#L535](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L535) [Gravity.sol#L541](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L541)  ## Recommended Mitigation Steps  Consider getting the received amount by calculating the difference of token balance (using `balanceOf`) before and after the `transferFrom`.  
# Handle  shw   # Vulnerability details  ## Impact  The `verifySig` function of `Gravity` calls the Solidity `ecrecover` function directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks.  Although a replay attack seems not possible here since the nonce is increased each time, ensuring the signatures are not malleable is considered a best practice (and so is checking `_signer != address(0)`, where `address(0)` means an invalid signature).  ## Proof of Concept  Referenced code: [Gravity.sol#L153](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L153)  [SWC-117: Signature Malleability](https://swcregistry.io/docs/SWC-117) [SWC-121: Missing Protection against Signature Replay Attacks](https://swcregistry.io/docs/SWC-121)  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification.  
# Handle  shw   # Vulnerability details  ## Impact  SafeMath library functions are not always used in the `Gravity` contract's arithmetic operations, which could cause integer underflow/overflows. Using SafeMath is considered a best practice that could completely prevent underflow/overflows and increase code consistency.  ## Proof of Concept  Referenced code: [Gravity.sol#L202](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L202) [Gravity.sol#L586](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L586)  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that on the cosmos side Coin amount has not been checked on the token definition. That can use misfunctionality on the bridge.  Although zero amount definition fee will be calculated. That can cause lose of user funds.   ## Proof of Concept  1. Navigate to "https://github.com/althea-net/cosmos-gravity-bridge/blob/main/module/x/gravity/types/ethereum.go" Line #69. 2. On the following code, ValidateBasic function does not validate amount.  ``` // ValidateBasic permforms stateless validation func (e *ERC20Token) ValidateBasic() error {  if err := ValidateEthAddress(e.Contract); err != nil {   return sdkerrors.Wrap(err, "ethereum address")  }  // TODO: Validate all the things  return nil } ```  ## Tools Used  ## Recommended Mitigation Steps  Add the following validation steps on the ValidationBasic function.  ```  if !m.Amount.IsValid() {   return cosmos.ErrInvalidCoins("coins must be valid")  }   if !m.Amount.IsAllPositive() {   return cosmos.ErrInvalidCoins("coins must be positive")  } ```    
# Handle  hrkrshnn   # Vulnerability details  ##  `updateValset` does not have enough sanity checks  In [updateValset](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L224) function, the current set of validators adds a new set.  It is missing the check that the combined power of all new validators is above the `state_powerThreshold`. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this.  It is also worth adding a that the size of the new validator check is less than a certain number.  Here is a rough calculation explaining how 10000 validators (an extreme example) is too much:  1.  Let us say that the new set of validators have the property that at     least, say, `N` validators are needed to get the total threshold     above `state_powerThreshold`. 2.  Since each validating signature requires a call to `ecrecover`,     costing at least `3000` gas, the minimum gas needed for getting a     proposal over `state_powerThreshold` would be `N * 3000` 3.  `N * 3000` cannot be more than the `block.gaslimit` Currently, this     puts `N` to be less than `10000`  Another approach to solve the above potential problems is to do the updating as a two step process:  1.  The current set of validators proposes a pending set of validators. 2.  And the pending set of validators need to do the transition to     become the new set of validators. Going through the same threshold     checks.  This guarantees that the new set of validators has enough power to pass threshold and doesn't have gas limit issues in doing so.   
# Handle  hrkrshnn   # Vulnerability details  ## State Variables that can be changed to `immutable`  [Solidity 0.6.5](https://blog.soliditylang.org/2020/04/06/solidity-0.6.5-release-announcement/) introduced `immutable` as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public owner = msg.sender; } ```  In the above example, each call to the function `owner()` reads from storage, using a `sload`. After [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public immutable owner = msg.sender; } ```  In the above example, each storage read of the `owner` state variable is replaced by the instruction `push32 value`, where `value` is set during contract construction time. Unlike the last example, this costs only 3 gas.  ### Examples  1.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L59> 2.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L60>    
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  https://swcregistry.io/docs/SWC-103  ## Proof of Concept https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L1  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  pauliax   # Vulnerability details  ## Impact I am concerned why invalidationId, invalidationNonce or valsetNonce are only required to be greater than the previous value. Why did you choose this approach instead of just simply asking for an incremented value? While this may not be a problem if the validators are honest, but otherwise, they may submit a nonce of MAX UINT and thus block the whole system as it would be no longer possible to submit a greater value. Again, just wanted you to be aware of this issue, not sure how likely this to happen is in practice, it depends on the honesty of validators so you better know.  ## Recommended Mitigation Steps I didn't receive an answer on Discord so decided to submit this FYI to decide if that's a hazard or no.  
# Handle  pauliax   # Vulnerability details  ## Impact There are a few validations that could be added to the system: the constructor could check that _gravityId is not empty. state_powerThreshold should always be greater than 0, otherwise, anyone will be available to execute actions.  ## Recommended Mitigation Steps Consider implementing suggested validations.  
# Handle  nascent   # Vulnerability details  **Severity: Medium** **Likelihood: High**  In `eth_oracle_main_loop`, `get_last_checked_block` is called. Followed by: ```rust= let logic_call_executed_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![LOGIC_CALL_EVENT_SIG],             )             .await; ``` and may hit the code path: ```rust=         for event in logic_call_executed_events {             match LogicCallExecutedEvent::from_log(&event) {                 Ok(call) => {                     trace!(                         "{} LogicCall event nonce {} last event nonce",                         call.event_nonce,                         last_event_nonce                     );                     if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()                     {                         return event.block_number.unwrap();                     }                 }                 Err(e) => error!("Got ERC20Deployed event that we can't parse {}", e),             }         } ```  But will panic at `from_log` here: ```rust= impl LogicCallExecutedEvent {     pub fn from_log(_input: &Log) -> Result<LogicCallExecutedEvent, GravityError> {         unimplemented!()     }     // snip... } ``` It can/will also be triggered here in `check_for_events`:  ```rust= let logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?; ```  Attestations will be frozen until patched.  ## Recommendation Implement the method.  ## Recommended Mitigation Steps  
# Handle  nascent   # Vulnerability details  "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayer" can affect just the relayers & not affect the oracle in certain circumstances. This could result in valid attestations, but prevent any of the other relayers from being able to participate in the execution. While the other relayers are down from the other attack, the attacker can win all batch, logic, and valset rewards as their node is the only relayer running. This is possible because `find_latest_valset` is run in the main relayer loop and everytime tries for 5000 blocks of logs.  
# Handle  nascent   # Vulnerability details  In a similar vein to "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms", a sufficiently large validator set or sufficiently rapid validator update could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors. In `find_latest_valset`, [we call](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/relayer/src/find_latest_valset.rs#L33-L40): ```rust= let mut all_valset_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![VALSET_UPDATED_EVENT_SIG],             )             .await?; ```  Which if the validator set is sufficiently large, or sufficiently rapidly updated, which continuous return an error if the logs in a 5000 (see: `const BLOCKS_TO_SEARCH: u128 = 5_000u128;`) block range are in excess of 10mb. Cosmos hub says they will be pushing the number of validators up to 300 (currently 125). At 300, each log would produce 19328 bytes of data (4\*32+64\*300). Given this, there must be below 517 updates per 5000 block range otherwise the node will fall out of sync.   This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  
# Handle  nascent   # Vulnerability details  Ethereum Oracles watch for events on the `Gravity.sol` contract on the Ethereum blockchain. This is performed in the [`check_for_events`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L23) function, ran in the [`eth_oracle_main_loop`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/main_loop.rs#L94).   In this function, there is [the following code snippet](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L66-L73): ```rust=     let erc20_deployed = web3         .check_for_events(             starting_block.clone(),             Some(latest_block.clone()),             vec![gravity_contract_address],             vec![ERC20_DEPLOYED_EVENT_SIG],         )         .await; ``` This snippet leverages the `web30` library to check for events from the `starting_block` to the `latest_block`. Inside the `web30` library this nets out to calling: ```rust=     pub async fn eth_get_logs(&self, new_filter: NewFilter) -> Result<Vec<Log>, Web3Error> {         self.jsonrpc_client             .request_method(                 "eth_getLogs",                 vec![new_filter],                 self.timeout,                 Some(10_000_000),             )             .await     } ```  The `10_000_000` specifies the maximum size of the return in bytes and returns an error if the return is larger: ```rust=         let res: Response<R> = match res.json().limit(limit).await {             Ok(val) => val,             Err(e) => return Err(Web3Error::BadResponse(format!("Web3 Error {}", e))),         }; ```  This can be triggered at will and keep the loop in a perpetual state of returning the `GravityError::EthereumRestError(Web3Error::BadResponse(             "Failed to get logs!".to_string()))` error. To force the node into this state, you just have to deploy ERC20s generated by the [public function in `Gravity.sol`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546-L565): ```solidity=  function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  And specify a large string as the denom, name, or symbol. If an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, and valset updates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due to `get_last_checked_block`.  This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  Additionally, you could require that validators sign ERC20 creation requests.  
# Handle  nascent   # Vulnerability details  Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.  # Proof of Concept Note the `c0` in the last argument of the call data (invalid UTF8).  It can be triggered with: ```solidity= data memory bytes = hex"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000"; gravity.call(data); ``` The log output is as follows: ``` ERC20DeployedEvent("atom", "name", ❮utf8 decode failed❯: 0x73796d626fc0, 18, 2) ```  Which hits [this code path](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/gravity_utils/src/types/ethereum_events.rs#L431-L438): ```rust=             let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());             trace!("Symbol {:?}", symbol);             if symbol.is_err() {                 return Err(GravityError::InvalidEventLogError(format!(                     "{:?} is not valid utf8, probably incorrect parsing",                     symbol                 )));             } ```  And would cause an early return [here](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L99): ```rust= let erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?; ```  Never updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.  ## Recommendation This is a hard one. Resyncing is permanently borked because on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce `N` from the orchestrator, but they can never parse the event `N`. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new `Gravity.sol` is deployed.  One potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.   
# Handle  ElliotFriedman   # Vulnerability details  ## Impact Currently, submitBatch, updateValset, deployERC20 and submitLogicCall all have arguments that are in memory. This causes calls to these functions to be more expensive than they need to be. By moving to external functions and upgrading the compiler version, there will be gas savings. The larger the amount of data being submitted to the contracts, the greater the savings as the cost of memory in the EVM goes up quadratically with the amount of data stored.  ## Tools Used Hardhat  ## Recommended Mitigation Steps Make all functions that you can external instead of public, especially the ones mentioned above that will see large transaction volumes, and change the data types from memory to external. This may involve changing compiler versions to 0.8.0 or greater to support using structs as external types.  
