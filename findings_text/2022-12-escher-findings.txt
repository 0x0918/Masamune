# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher.sol#L11 https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/65420cb9c943c32eb7e8c9da60183a413d90067a/contracts/access/AccessControlUpgradeable.sol#L150 https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher721Factory.sol#L32   # Vulnerability details  ## Impact (     creator = has a CREATOR_ROLE in Escher.sol     non-creator = doesn't have a CREATOR_ROLE in Escher.sol )  Currently creating an ERC721 edition via the ```Escher721Factory.sol``` contract requires a user to have the ``` CREATOR_ROLE ``` in the main ``` Escher.sol ``` contract. This requirement would mean that only users with the aforementioned role can be admins of editions. This requirement can be bypassed by having a 'malicious' creator create an edition for someone who doesn't have the  ``` CREATOR_ROLE ``` set by creating the edition and granting the ```DEFAULT_ADMIN_ROLE``` to the non-creator via AccessControl.sol's ```grantRole()``` function. This way the non-creator can revoke the original creator's roles in this edition and gain full ownership. Now this non-creator admin can create sales and operate as if he/she was a creator.   This defeats the point of having a role for creators and makes this function of the protocol not as described == faulty.   ## Proof of Concept A creator can benefit from his role by taking in payments for creating ERC721 editions for other people. This would make sense so that his risk can be covered.   1. A creator gets onboarded to Escher.  2. For some time he stays good but then people start offering payments for edition ownership 3. The more creators there are in Escher the less of a chance to get caught but then again the more inclusive Escher gets the more people will pay to get their own edition,     which makes this pretty dangerous 3. This creator creates an edition with the payer's inputs and grants the payer the DEFAULT_ADMIN_ROLE 4. Payer revokes all of the creator's roles and becomes the new admin   You can edit the Escher721.t.sol file to look like this and then run the test normally, everything should go through without errors:  ```  // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import "forge-std/Test.sol"; import {EscherTest} from "./utils/EscherTest.sol";  contract Escher721Test is EscherTest {     function setUp() public override {         super.setUp();     }     function test_grantRoles() public {         address _this = address(this);         // Malicious creator grants someone else the rights for this edition         edition.grantRole(bytes32(0x0), address(9));         vm.prank(address(9));         // Now this user can grant/revoke roles         edition.grantRole(edition.MINTER_ROLE(), address(9));         assertEq(edition.hasRole(bytes32(0x0), address(9)), true);         // clean out the partner         edition.revokeRole(bytes32(0x0), _this);         assertEq(edition.hasRole(bytes32(0x0), _this), false);     } } ```  This kind of attack/abuse is currently hard to track. There is no centralized database of created editions and their admins at the time of creations (i.e. a mapping). This makes it hard to track down malicious creators who create editions for other people. Looping through the emitted events and comparing current admins to the emitted admins is a hassle especially if this protocol gains a lot of traction in the future which I assume is the end goal here.   ## Tools Used Manual review, visual studio code, forge  ## Recommended Mitigation Steps  In ```EscherERC721.sol``` implementation contract, it is recommended to override the ```grantRole()``` function of ```AccessControlUpgradeable.sol``` with something like: ``` function grantRole(bytes32 role, address account) internal override {     revert("Admins can't be chagned"); } ```  This will disable the granting of roles after initialization. The initialization function already has the required granting of roles done and they cannot be changed after this fix.  Overall it would be recommended to store the created editions in a mapping for example to prevent problems like these. 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L58-L89   # Vulnerability details  ## Impact  The `buy` function on the `LPDA.sol` contract is not validating if the auction is still running, allowing a purchase to be made after the stipulated time. The `endtime` variable used to store the end date of the auction is not used at any point to validate whether the purchase is being made within the deadline.  ## Proof of Concept  ``` // SPDX-License-Identifier: MIT   pragma solidity ^0.8.17;   import "forge-std/Test.sol";  import {EscherTest} from "./utils/EscherTest.sol";  import {LPDAFactory, LPDA} from "src/minters/LPDAFactory.sol";   contract LPDABase is EscherTest {   LPDAFactory public lpdaSales;   LPDA.Sale public lpdaSale;     function setUp() public virtual override {    super.setUp();    lpdaSales = new LPDAFactory();   // set up a LPDA Sale    lpdaSale = LPDA.Sale({     currentId: uint48(0),     finalId: uint48(10),     edition: address(edition),     startPrice: uint80(uint256(1 ether)),     finalPrice: uint80(uint256(0.1 ether)),     dropPerSecond: uint80(uint256(0.1 ether) / 1 days),     startTime: uint96(block.timestamp),     saleReceiver: payable(address(69)),     endTime: uint96(block.timestamp + 1 days)    });  }  }   contract LPDATest is LPDABase {   LPDA public sale;     event End(LPDA.Sale _saleInfo);   function test_Buy() public {    sale = LPDA(lpdaSales.createLPDASale(lpdaSale));    // authorize the lpda sale to mint tokens   edition.grantRole(edition.MINTER_ROLE(), address(sale));   vm.warp(block.timestamp + 3 days);    sale.buy{value: 1 ether}(1);    assertEq(address(sale).balance, 1 ether);   }  } ```  The code above shows that even after two days after the `endTime` it was still possible to make the purchase.  ## Recommended Mitigation Steps  Our recommendation would be to introduce a require to validate the  if the purchase is being made within the `endTime`.   ``` require(block.timestamp > sale.endTime, "TOO LATE"); ```  The above could must be placed at the beginning of the `buy` function.
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L75   # Vulnerability details  The `OpenEdition` type of sale has a start time and an end time. The creator (or owner of the contract) can cancel a sale using the `cancel` function only if it hasn't started yet (i.e. start time is after current block timestamp).  However, the NFT creator can still revoke the minting permissions to the sale contract if he wishes to pull out of the sale. This will prevent anyone from calling the `buy` and prevent any further sale from the collection.  ## Impact  The owner of the sale contract can still virtually cancel a sale after it has started by simply revoking the minting permissions to the sale contract.  This will cause the `buy` function to fail because the call to `mint` will revert, effectively making it impossible to further purchase NFTs and causing the effect of canceling the sale.  ## PoC  In the following test, the creator of the sale decides to pull from it in the middle of the elapsed duraction. After that, he only needs to wait until the end time passes to call `finalize` and end the sale.  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import "forge-std/Test.sol"; import {FixedPriceFactory} from "src/minters/FixedPriceFactory.sol"; import {FixedPrice} from "src/minters/FixedPrice.sol"; import {OpenEditionFactory} from "src/minters/OpenEditionFactory.sol"; import {OpenEdition} from "src/minters/OpenEdition.sol"; import {LPDAFactory} from "src/minters/LPDAFactory.sol"; import {LPDA} from "src/minters/LPDA.sol"; import {Escher721} from "src/Escher721.sol";  contract AuditTest is Test {     address deployer;     address creator;     address buyer;      FixedPriceFactory fixedPriceFactory;     OpenEditionFactory openEditionFactory;     LPDAFactory lpdaFactory;      function setUp() public {         deployer = makeAddr("deployer");         creator = makeAddr("creator");         buyer = makeAddr("buyer");          vm.deal(buyer, 1e18);          vm.startPrank(deployer);          fixedPriceFactory = new FixedPriceFactory();         openEditionFactory = new OpenEditionFactory();         lpdaFactory = new LPDAFactory();          vm.stopPrank();     }          function test_OpenEdition_buy_CancelSaleByRevokingRole() public {         // Setup NFT and create sale         vm.startPrank(creator);          Escher721 nft = new Escher721();         nft.initialize(creator, address(0), "Test NFT", "TNFT");          uint24 startId = 0;         uint72 price = 1e6;         uint96 startTime = uint96(block.timestamp);         uint96 endTime = uint96(block.timestamp + 1 hours);          OpenEdition.Sale memory sale = OpenEdition.Sale(             price, // uint72 price;             startId, // uint24 currentId;             address(nft), // address edition;             startTime, // uint96 startTime;             payable(creator), // address payable saleReceiver;             endTime // uint96 endTime;         );         OpenEdition openSale = OpenEdition(openEditionFactory.createOpenEdition(sale));          nft.grantRole(nft.MINTER_ROLE(), address(openSale));          vm.stopPrank();          // simulate we are in the middle of the sale duration         vm.warp(startTime + 0.5 hours);          // Now creator decides to pull out of the sale. Since he can't cancel the sale because it already started and he can't end the sale now because it hasn't finished, he revokes the minter role. This will cause the buy transaction to fail.         vm.startPrank(creator);          nft.revokeRole(nft.MINTER_ROLE(), address(openSale));          vm.stopPrank();          vm.startPrank(buyer);          // Buyer can't call buy because sale contract can't mint tokens, the buy transaction reverts.         uint256 amount = 1;         vm.expectRevert();         openSale.buy{value: price * amount}(amount);          vm.stopPrank();          // Now creator just needs to wait until sale ends         vm.warp(endTime);          vm.prank(creator);         openSale.finalize();     } } ```  ## Recommendation  One possibilty is to acknowledge the fact the creator has still control over the minting process and can arbitrarily decide when to cancel the sale. If this route is taken, then the recommendation would be to make the `cancel` function unrestricted.  Preminting the NFTs is not a solution because of high gas costs and the fact that the amount of tokens to be sold is not known beforehand, it's determined by the actual amount sold during the sale.  A more elaborated solution that would require additional architecture changes is to prevent the revocation of the minting permissions if some conditions (defined by target sale contract) are met. 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117-L124   # Vulnerability details  The dutch auction in the `LPDA` contract is implemented by configuring a start price and price drop per second.  A bad set of settings can cause an issue where the elapsed duration of the sale multiplied by the drop per second gets bigger than the start price and underflows the current price calculation.  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117  ```solidity function getPrice() public view returns (uint256) {     Sale memory temp = sale;     (uint256 start, uint256 end) = (temp.startTime, temp.endTime);     if (block.timestamp < start) return type(uint256).max;     if (temp.currentId == temp.finalId) return temp.finalPrice;      uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;     return temp.startPrice - (temp.dropPerSecond * timeElapsed); } ```  This means that if `temp.dropPerSecond * timeElapsed > temp.startPrice` then the unsigned integer result will become negative and underflow, leading to potentially bricking the contract and an eventual loss of funds.  ## Impact  Due to Solidity 0.8 default checked math, the subtraction of the start price and the drop will cause a negative value that will generate an underflow in the unsigned integer type and lead to a transaction revert.  Calls to `getPrice` will revert, and since this function is used in the `buy` to calculate the current NFT price it will also cause the buy process to fail. The price drop will continue to increase as time passes, making it impossible to recover from this situation and effectively bricking the contract.  This will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale (i.e. buy everything up to the `sale.finalId`) which will be impossible if the `buy` function is bricked.  ## PoC  In the following test, the start price is 1500 and the duration is 1 hour (3600 seconds) with a drop of 1 per second. At about ~40% of the elapsed time the price drop will start underflowing the price, reverting the calls to both `getPrice` and `buy`.  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import "forge-std/Test.sol"; import {FixedPriceFactory} from "src/minters/FixedPriceFactory.sol"; import {FixedPrice} from "src/minters/FixedPrice.sol"; import {OpenEditionFactory} from "src/minters/OpenEditionFactory.sol"; import {OpenEdition} from "src/minters/OpenEdition.sol"; import {LPDAFactory} from "src/minters/LPDAFactory.sol"; import {LPDA} from "src/minters/LPDA.sol"; import {Escher721} from "src/Escher721.sol";  contract AuditTest is Test {     address deployer;     address creator;     address buyer;      FixedPriceFactory fixedPriceFactory;     OpenEditionFactory openEditionFactory;     LPDAFactory lpdaFactory;      function setUp() public {         deployer = makeAddr("deployer");         creator = makeAddr("creator");         buyer = makeAddr("buyer");          vm.deal(buyer, 1e18);          vm.startPrank(deployer);          fixedPriceFactory = new FixedPriceFactory();         openEditionFactory = new OpenEditionFactory();         lpdaFactory = new LPDAFactory();          vm.stopPrank();     }          function test_LPDA_getPrice_NegativePrice() public {         // Setup NFT and create sale         vm.startPrank(creator);          Escher721 nft = new Escher721();         nft.initialize(creator, address(0), "Test NFT", "TNFT");          // Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed duration         uint48 startId = 0;         uint48 finalId = 1;         uint80 startPrice = 1500;         uint80 dropPerSecond = 1;         uint96 startTime = uint96(block.timestamp);         uint96 endTime = uint96(block.timestamp + 1 hours);          LPDA.Sale memory sale = LPDA.Sale(             startId, // uint48 currentId;             finalId, // uint48 finalId;             address(nft), // address edition;             startPrice, // uint80 startPrice;             0, // uint80 finalPrice;             dropPerSecond, // uint80 dropPerSecond;             endTime, // uint96 endTime;             payable(creator), // address payable saleReceiver;             startTime // uint96 startTime;         );         LPDA lpdaSale = LPDA(lpdaFactory.createLPDASale(sale));          nft.grantRole(nft.MINTER_ROLE(), address(lpdaSale));          vm.stopPrank();          // simulate we are in the middle of the sale duration         vm.warp(startTime + 0.5 hours);          vm.startPrank(buyer);          // getPrice will revert due to the overflow caused by the price becoming negative         vm.expectRevert();         lpdaSale.getPrice();          // This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amount         uint256 amount = 1;         uint256 price = 1234;         vm.expectRevert();         lpdaSale.buy{value: price * amount}(amount);          vm.stopPrank();     } } ```  ## Recommendation  Add a validation in the `LPDAFactory.createLPDASale` function to ensure that the given duration and drop per second settings can't underflow the price.  ```solidity require((sale.endTime - sale.startTime) * sale.dropPerSecond <= sale.startPrice, "MAX DROP IS GREATER THAN START PRICE"); ``` 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L71 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L82 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L101 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L62   # Vulnerability details  ## Impact  Unsafe downcasting operation transcate user's input.  ## Proof of Concept  There are a few unsafe downcasting operation that transcate user's input. The impact can be severe or minial.  In FixedPrice.sol,  ```solidity /// @notice buy from a fixed price sale after the sale starts /// @param _amount the amount of editions to buy function buy(uint256 _amount) external payable {  Sale memory sale_ = sale;  IEscher721 nft = IEscher721(sale_.edition);  require(block.timestamp >= sale_.startTime, "TOO SOON");  require(_amount * sale_.price == msg.value, "WRONG PRICE");  uint48 newId = uint48(_amount) + sale_.currentId;  require(newId <= sale_.finalId, "TOO MANY");   for (uint48 x = sale_.currentId + 1; x <= newId; x++) {   nft.mint(msg.sender, x);  }   sale.currentId = newId;   emit Buy(msg.sender, _amount, msg.value, sale);   if (newId == sale_.finalId) _end(sale); } ```   the amount is unsafely downcasted from uint256 to uint48, note the code:    ```solidity require(_amount * sale_.price == msg.value, "WRONG PRICE"); uint48 newId = uint48(_amount) + sale_.currentId; ```  the upper limit for uint48 is 281474976710655,  if user wants to buy more than 281474976710655 amount of nft and pay the 281474976710655 * sale price amount, the user can only receive 281474976710655 amount of nft because of the downcasting.  In LPDA.sol, we are unsafely downcasting the price in the buy function  ```solidity receipts[msg.sender].amount += amount; receipts[msg.sender].balance += uint80(msg.value);  for (uint256 x = temp.currentId + 1; x <= newId; x++) {  nft.mint(msg.sender, x); }  sale.currentId = newId;  emit Buy(msg.sender, amount, msg.value, temp);  if (newId == temp.finalId) {  sale.finalPrice = uint80(price);  uint256 totalSale = price * amountSold;  uint256 fee = totalSale / 20;  ISaleFactory(factory).feeReceiver().transfer(fee);  temp.saleReceiver.transfer(totalSale - fee);  _end(); } ```  note the line:  uint80(msg.value) and uint80(price)  In LPDA.sol, same issue exists in the refund function:  ```solidity /// @notice allow a buyer to get a refund on the current price difference function refund() public {  Receipt memory r = receipts[msg.sender];  uint80 price = uint80(getPrice()) * r.amount;  uint80 owed = r.balance - price;  require(owed > 0, "NOTHING TO REFUND");  receipts[msg.sender].balance = price;  payable(msg.sender).transfer(owed); } ```  note the downcasting: uint80(getPrice())  this means if the price goes above uint80, it will be wrongly trancated to uint80 for price.  The Downcasting in LPDA.sol is damaging because it tracunated user's fund.  Below is the POC:  add test in LPDA.t.sol  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/test/LPDA.t.sol#L167  ```solidity     function test_LPDA_downcasting_POC() public {          // make the lpda sales contract         sale = LPDA(lpdaSales.createLPDASale(lpdaSale));         // authorize the lpda sale to mint tokens         edition.grantRole(edition.MINTER_ROLE(), address(sale));         //lets buy an NFT          uint256 val = uint256(type(uint80).max) + 10 ether;         console.log('msg.value');         console.log(val);         sale.buy{value: val}(1);          } ```  and import "forge-std/console.sol" in LPDA.sol  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L3  ```solidity import "forge-std/console.sol"; ```  and add console.log in LPDA.sol buy function.  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L69  ```solidity receipts[msg.sender].amount += amount; receipts[msg.sender].balance += uint80(msg.value);  console.log("truncated value"); console.log(receipts[msg.sender].balance); ```  We run our test:  ```solidity forge test -vv --match test_LPDA_downcasting_POC ```  the output is:  ```solidity Running 1 test for test/LPDA.t.sol:LPDATest [PASS] test_LPDA_downcasting_POC() (gas: 385619) Logs:   msg.value   1208935819614629174706175   truncated value   9999999999999999999  Test result: ok. 1 passed; 0 failed; finished in 3.61ms ```  as we can see, user uses 1208935819614629174706175 to buy in LPDA.sol but the balance is truncated to 9999999999999999999, later user is not able to get the refund they are entitled to because the msg.value is unsafely downcasted.  Also note the downcasting for getPrice in LPDA.sol is also a issue:  the getPrice in LPDA.sol returns a uint256  ```solidity /// @notice the price of the sale function getPrice() public view returns (uint256) {  Sale memory temp = sale;  (uint256 start, uint256 end) = (temp.startTime, temp.endTime);  if (block.timestamp < start) return type(uint256).max;  if (temp.currentId == temp.finalId) return temp.finalPrice;   uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;  return temp.startPrice - (temp.dropPerSecond * timeElapsed); } ```  but this is downcasted into uint80 in function buy and refund.  ```solidity uint80 price = uint80(getPrice()) * r.amount; ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project handle downcasting and use safe casting library to make sure the downcast does not unexpected truncate value.  https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L68   # Vulnerability details  ## Impact A buyer could plan on buying early at higher prices to make sure he would secure a portion (say 50%) of NFTs he desired. When the number of NFTs still available got smaller and that `sale.endTime` were yet to hit, he would then watch the mempool and repeatedly attempt to thwart the final group of buyers from successfully completing their respective transactions amidst the efforts to prolong the Dutch auction till `sale.endTime` was reached.   ## Proof of Concept Assuming this particular edition pertained to a 100 NFT collection that would at most last for 60 minutes, and Bob planned on minting 10 of them. At the beginning of the dutch auction, he would first mint 5 NFTs at higher prices no doubt. At 50th minute, `sale.currentId == 95`. Alice, upon seeing this, made up her mind and proceeded to buying the remaining NFTs. Bob, seeing this transaction queuing in the mempool, invoked `buy()` to mint 1 NFT by sending in higher amount of gas to front run Alice. Needless to say, Alice's transaction was going to revert on line 68 because `newId == 101`:  [File: LPDA.sol#L68](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L68)  ``` 68:        require(newId <= temp.finalId, "TOO MANY"); ``` Noticing the number of NFTs still available had become 4, Alice attempted to mint the remaining 4 NFTs this time. Bob, upon seeing the similar queue in the mempool again, front ran Alice with another mint of 1 NFT.   These steps were repeatedly carried out until Bob managed to get all NFTs he wanted where the last one was minted right after `sale.endTime` hit. At this point, every successful buyers was happy to get the biggest refund possible ensuring that each NFT was only paid for the lowest price. This intended goal, on the contrary, was achieved at the expense of the seller getting the lowest amount of revenue and that the front run buyers minting nothing.   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Considering refactoring the affected code line as follows:  ``` - require(newId <= temp.finalId, "TOO MANY"); + if(newId > temp.finalId) { +      uint256 diff = newId - temp.finalId;  +      newId = temp.finalId; +      amountSold -= diff; +      amount -= diff; + } ```
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEdition.sol#L63   # Vulnerability details  ## Impact `OpenEdition.buy()` might revert due to uint overflow when it should work.  ## Proof of Concept `OpenEdition.buy()` validates the total funds like below.  ```solidity     function buy(uint256 _amount) external payable {         uint24 amount = uint24(_amount);         Sale memory temp = sale;         IEscher721 nft = IEscher721(temp.edition);         require(block.timestamp >= temp.startTime, "TOO SOON");         require(block.timestamp < temp.endTime, "TOO LATE");         require(amount * sale.price == msg.value, "WRONG PRICE"); //@audit overflow ```  Here, `amount` was declared as `uint24` and `sale.price` is `uint72`.  And it will revert when `amount * sale.price >= type(uint72).max` and such cases would be likely to happen e.g. `amount = 64(so 2^6), sale.price = 73 * 10^18(so 2^66)`.  As a result, `buy()` might revert when it should work properly.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should modify like below.  ```solidity     require(uint256(amount) * sale.price == msg.value, "WRONG PRICE"); ```
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L85-L86 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92   # Vulnerability details  ## Impact The protocol uses Solidity’s `transfer()` when transferring ETH to the recipients. This has some notable shortcomings when the recipient is a smart contract, which can render ETH impossible to transfer. Specifically, the transfer will inevitably fail when the smart contract:  - does not implement a payable fallback function, or - implements a payable fallback function which would incur more than 2300 gas units, or - implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.  ## Proof of Concept [File: LPDA.sol](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol)  ``` 85:            ISaleFactory(factory).feeReceiver().transfer(fee); 86:            temp.saleReceiver.transfer(totalSale - fee);  105:        payable(msg.sender).transfer(owed); ``` [File: FixedPrice.sol#L109](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109)  ``` 109:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20); ``` [File: OpenEdition.sol#L92](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92)  ``` 92:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20); ``` Issues pertaining to the use of `transfer()` in the code blocks above may be referenced further via:  - [CONSENSYS Diligence's article](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) - [OpenZeppelin news & events](https://blog.openzeppelin.com/reentrancy-after-istanbul/)   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Using `call` with its returned boolean checked in combination with re-entrancy guard is highly recommended after December 2019.  For instance, [line 105](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105) in `LPDA.sol` may be refactored as follows:  ``` - payable(msg.sender).transfer(owed); + (bool success, ) = payable(msg.sender).call{ value: owed }(''); + require(success, " Transfer of ETH Failed"); ``` Alternatively, `Address.sendValue()` available in [OpenZeppelin Contract’s Address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L44-L65) can be used to transfer the Ether without being limited to 2300 gas units.   And again, in either of the above measures adopted, the risks of re-entrancy stemming from the use of this function can be mitigated by tightly following the “Check-effects-interactions” pattern and/or using [OpenZeppelin Contract’s ReentrancyGuard contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol#L43-L54).
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher.sol#L11 https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/65420cb9c943c32eb7e8c9da60183a413d90067a/contracts/access/AccessControlUpgradeable.sol#L150 https://github.com/code-423n4/2022-12-escher/blob/main/src/Escher721Factory.sol#L32   # Vulnerability details  ## Impact (     creator = has a CREATOR_ROLE in Escher.sol     non-creator = doesn't have a CREATOR_ROLE in Escher.sol )  Currently creating an ERC721 edition via the ```Escher721Factory.sol``` contract requires a user to have the ``` CREATOR_ROLE ``` in the main ``` Escher.sol ``` contract. This requirement would mean that only users with the aforementioned role can be admins of editions. This requirement can be bypassed by having a 'malicious' creator create an edition for someone who doesn't have the  ``` CREATOR_ROLE ``` set by creating the edition and granting the ```DEFAULT_ADMIN_ROLE``` to the non-creator via AccessControl.sol's ```grantRole()``` function. This way the non-creator can revoke the original creator's roles in this edition and gain full ownership. Now this non-creator admin can create sales and operate as if he/she was a creator.   This defeats the point of having a role for creators and makes this function of the protocol not as described == faulty.   ## Proof of Concept A creator can benefit from his role by taking in payments for creating ERC721 editions for other people. This would make sense so that his risk can be covered.   1. A creator gets onboarded to Escher.  2. For some time he stays good but then people start offering payments for edition ownership 3. The more creators there are in Escher the less of a chance to get caught but then again the more inclusive Escher gets the more people will pay to get their own edition,     which makes this pretty dangerous 3. This creator creates an edition with the payer's inputs and grants the payer the DEFAULT_ADMIN_ROLE 4. Payer revokes all of the creator's roles and becomes the new admin   You can edit the Escher721.t.sol file to look like this and then run the test normally, everything should go through without errors:  ```  // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import "forge-std/Test.sol"; import {EscherTest} from "./utils/EscherTest.sol";  contract Escher721Test is EscherTest {     function setUp() public override {         super.setUp();     }     function test_grantRoles() public {         address _this = address(this);         // Malicious creator grants someone else the rights for this edition         edition.grantRole(bytes32(0x0), address(9));         vm.prank(address(9));         // Now this user can grant/revoke roles         edition.grantRole(edition.MINTER_ROLE(), address(9));         assertEq(edition.hasRole(bytes32(0x0), address(9)), true);         // clean out the partner         edition.revokeRole(bytes32(0x0), _this);         assertEq(edition.hasRole(bytes32(0x0), _this), false);     } } ```  This kind of attack/abuse is currently hard to track. There is no centralized database of created editions and their admins at the time of creations (i.e. a mapping). This makes it hard to track down malicious creators who create editions for other people. Looping through the emitted events and comparing current admins to the emitted admins is a hassle especially if this protocol gains a lot of traction in the future which I assume is the end goal here.   ## Tools Used Manual review, visual studio code, forge  ## Recommended Mitigation Steps  In ```EscherERC721.sol``` implementation contract, it is recommended to override the ```grantRole()``` function of ```AccessControlUpgradeable.sol``` with something like: ``` function grantRole(bytes32 role, address account) internal override {     revert("Admins can't be chagned"); } ```  This will disable the granting of roles after initialization. The initialization function already has the required granting of roles done and they cannot be changed after this fix.  Overall it would be recommended to store the created editions in a mapping for example to prevent problems like these. 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L58-L89   # Vulnerability details  ## Impact  The `buy` function on the `LPDA.sol` contract is not validating if the auction is still running, allowing a purchase to be made after the stipulated time. The `endtime` variable used to store the end date of the auction is not used at any point to validate whether the purchase is being made within the deadline.  ## Proof of Concept  ``` // SPDX-License-Identifier: MIT   pragma solidity ^0.8.17;   import "forge-std/Test.sol";  import {EscherTest} from "./utils/EscherTest.sol";  import {LPDAFactory, LPDA} from "src/minters/LPDAFactory.sol";   contract LPDABase is EscherTest {   LPDAFactory public lpdaSales;   LPDA.Sale public lpdaSale;     function setUp() public virtual override {    super.setUp();    lpdaSales = new LPDAFactory();   // set up a LPDA Sale    lpdaSale = LPDA.Sale({     currentId: uint48(0),     finalId: uint48(10),     edition: address(edition),     startPrice: uint80(uint256(1 ether)),     finalPrice: uint80(uint256(0.1 ether)),     dropPerSecond: uint80(uint256(0.1 ether) / 1 days),     startTime: uint96(block.timestamp),     saleReceiver: payable(address(69)),     endTime: uint96(block.timestamp + 1 days)    });  }  }   contract LPDATest is LPDABase {   LPDA public sale;     event End(LPDA.Sale _saleInfo);   function test_Buy() public {    sale = LPDA(lpdaSales.createLPDASale(lpdaSale));    // authorize the lpda sale to mint tokens   edition.grantRole(edition.MINTER_ROLE(), address(sale));   vm.warp(block.timestamp + 3 days);    sale.buy{value: 1 ether}(1);    assertEq(address(sale).balance, 1 ether);   }  } ```  The code above shows that even after two days after the `endTime` it was still possible to make the purchase.  ## Recommended Mitigation Steps  Our recommendation would be to introduce a require to validate the  if the purchase is being made within the `endTime`.   ``` require(block.timestamp > sale.endTime, "TOO LATE"); ```  The above could must be placed at the beginning of the `buy` function.
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L75   # Vulnerability details  The `OpenEdition` type of sale has a start time and an end time. The creator (or owner of the contract) can cancel a sale using the `cancel` function only if it hasn't started yet (i.e. start time is after current block timestamp).  However, the NFT creator can still revoke the minting permissions to the sale contract if he wishes to pull out of the sale. This will prevent anyone from calling the `buy` and prevent any further sale from the collection.  ## Impact  The owner of the sale contract can still virtually cancel a sale after it has started by simply revoking the minting permissions to the sale contract.  This will cause the `buy` function to fail because the call to `mint` will revert, effectively making it impossible to further purchase NFTs and causing the effect of canceling the sale.  ## PoC  In the following test, the creator of the sale decides to pull from it in the middle of the elapsed duraction. After that, he only needs to wait until the end time passes to call `finalize` and end the sale.  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import "forge-std/Test.sol"; import {FixedPriceFactory} from "src/minters/FixedPriceFactory.sol"; import {FixedPrice} from "src/minters/FixedPrice.sol"; import {OpenEditionFactory} from "src/minters/OpenEditionFactory.sol"; import {OpenEdition} from "src/minters/OpenEdition.sol"; import {LPDAFactory} from "src/minters/LPDAFactory.sol"; import {LPDA} from "src/minters/LPDA.sol"; import {Escher721} from "src/Escher721.sol";  contract AuditTest is Test {     address deployer;     address creator;     address buyer;      FixedPriceFactory fixedPriceFactory;     OpenEditionFactory openEditionFactory;     LPDAFactory lpdaFactory;      function setUp() public {         deployer = makeAddr("deployer");         creator = makeAddr("creator");         buyer = makeAddr("buyer");          vm.deal(buyer, 1e18);          vm.startPrank(deployer);          fixedPriceFactory = new FixedPriceFactory();         openEditionFactory = new OpenEditionFactory();         lpdaFactory = new LPDAFactory();          vm.stopPrank();     }          function test_OpenEdition_buy_CancelSaleByRevokingRole() public {         // Setup NFT and create sale         vm.startPrank(creator);          Escher721 nft = new Escher721();         nft.initialize(creator, address(0), "Test NFT", "TNFT");          uint24 startId = 0;         uint72 price = 1e6;         uint96 startTime = uint96(block.timestamp);         uint96 endTime = uint96(block.timestamp + 1 hours);          OpenEdition.Sale memory sale = OpenEdition.Sale(             price, // uint72 price;             startId, // uint24 currentId;             address(nft), // address edition;             startTime, // uint96 startTime;             payable(creator), // address payable saleReceiver;             endTime // uint96 endTime;         );         OpenEdition openSale = OpenEdition(openEditionFactory.createOpenEdition(sale));          nft.grantRole(nft.MINTER_ROLE(), address(openSale));          vm.stopPrank();          // simulate we are in the middle of the sale duration         vm.warp(startTime + 0.5 hours);          // Now creator decides to pull out of the sale. Since he can't cancel the sale because it already started and he can't end the sale now because it hasn't finished, he revokes the minter role. This will cause the buy transaction to fail.         vm.startPrank(creator);          nft.revokeRole(nft.MINTER_ROLE(), address(openSale));          vm.stopPrank();          vm.startPrank(buyer);          // Buyer can't call buy because sale contract can't mint tokens, the buy transaction reverts.         uint256 amount = 1;         vm.expectRevert();         openSale.buy{value: price * amount}(amount);          vm.stopPrank();          // Now creator just needs to wait until sale ends         vm.warp(endTime);          vm.prank(creator);         openSale.finalize();     } } ```  ## Recommendation  One possibilty is to acknowledge the fact the creator has still control over the minting process and can arbitrarily decide when to cancel the sale. If this route is taken, then the recommendation would be to make the `cancel` function unrestricted.  Preminting the NFTs is not a solution because of high gas costs and the fact that the amount of tokens to be sold is not known beforehand, it's determined by the actual amount sold during the sale.  A more elaborated solution that would require additional architecture changes is to prevent the revocation of the minting permissions if some conditions (defined by target sale contract) are met. 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117-L124   # Vulnerability details  The dutch auction in the `LPDA` contract is implemented by configuring a start price and price drop per second.  A bad set of settings can cause an issue where the elapsed duration of the sale multiplied by the drop per second gets bigger than the start price and underflows the current price calculation.  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117  ```solidity function getPrice() public view returns (uint256) {     Sale memory temp = sale;     (uint256 start, uint256 end) = (temp.startTime, temp.endTime);     if (block.timestamp < start) return type(uint256).max;     if (temp.currentId == temp.finalId) return temp.finalPrice;      uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;     return temp.startPrice - (temp.dropPerSecond * timeElapsed); } ```  This means that if `temp.dropPerSecond * timeElapsed > temp.startPrice` then the unsigned integer result will become negative and underflow, leading to potentially bricking the contract and an eventual loss of funds.  ## Impact  Due to Solidity 0.8 default checked math, the subtraction of the start price and the drop will cause a negative value that will generate an underflow in the unsigned integer type and lead to a transaction revert.  Calls to `getPrice` will revert, and since this function is used in the `buy` to calculate the current NFT price it will also cause the buy process to fail. The price drop will continue to increase as time passes, making it impossible to recover from this situation and effectively bricking the contract.  This will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale (i.e. buy everything up to the `sale.finalId`) which will be impossible if the `buy` function is bricked.  ## PoC  In the following test, the start price is 1500 and the duration is 1 hour (3600 seconds) with a drop of 1 per second. At about ~40% of the elapsed time the price drop will start underflowing the price, reverting the calls to both `getPrice` and `buy`.  ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17;  import "forge-std/Test.sol"; import {FixedPriceFactory} from "src/minters/FixedPriceFactory.sol"; import {FixedPrice} from "src/minters/FixedPrice.sol"; import {OpenEditionFactory} from "src/minters/OpenEditionFactory.sol"; import {OpenEdition} from "src/minters/OpenEdition.sol"; import {LPDAFactory} from "src/minters/LPDAFactory.sol"; import {LPDA} from "src/minters/LPDA.sol"; import {Escher721} from "src/Escher721.sol";  contract AuditTest is Test {     address deployer;     address creator;     address buyer;      FixedPriceFactory fixedPriceFactory;     OpenEditionFactory openEditionFactory;     LPDAFactory lpdaFactory;      function setUp() public {         deployer = makeAddr("deployer");         creator = makeAddr("creator");         buyer = makeAddr("buyer");          vm.deal(buyer, 1e18);          vm.startPrank(deployer);          fixedPriceFactory = new FixedPriceFactory();         openEditionFactory = new OpenEditionFactory();         lpdaFactory = new LPDAFactory();          vm.stopPrank();     }          function test_LPDA_getPrice_NegativePrice() public {         // Setup NFT and create sale         vm.startPrank(creator);          Escher721 nft = new Escher721();         nft.initialize(creator, address(0), "Test NFT", "TNFT");          // Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed duration         uint48 startId = 0;         uint48 finalId = 1;         uint80 startPrice = 1500;         uint80 dropPerSecond = 1;         uint96 startTime = uint96(block.timestamp);         uint96 endTime = uint96(block.timestamp + 1 hours);          LPDA.Sale memory sale = LPDA.Sale(             startId, // uint48 currentId;             finalId, // uint48 finalId;             address(nft), // address edition;             startPrice, // uint80 startPrice;             0, // uint80 finalPrice;             dropPerSecond, // uint80 dropPerSecond;             endTime, // uint96 endTime;             payable(creator), // address payable saleReceiver;             startTime // uint96 startTime;         );         LPDA lpdaSale = LPDA(lpdaFactory.createLPDASale(sale));          nft.grantRole(nft.MINTER_ROLE(), address(lpdaSale));          vm.stopPrank();          // simulate we are in the middle of the sale duration         vm.warp(startTime + 0.5 hours);          vm.startPrank(buyer);          // getPrice will revert due to the overflow caused by the price becoming negative         vm.expectRevert();         lpdaSale.getPrice();          // This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amount         uint256 amount = 1;         uint256 price = 1234;         vm.expectRevert();         lpdaSale.buy{value: price * amount}(amount);          vm.stopPrank();     } } ```  ## Recommendation  Add a validation in the `LPDAFactory.createLPDASale` function to ensure that the given duration and drop per second settings can't underflow the price.  ```solidity require((sale.endTime - sale.startTime) * sale.dropPerSecond <= sale.startPrice, "MAX DROP IS GREATER THAN START PRICE"); ``` 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L71 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L82 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L101 https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L62   # Vulnerability details  ## Impact  Unsafe downcasting operation transcate user's input.  ## Proof of Concept  There are a few unsafe downcasting operation that transcate user's input. The impact can be severe or minial.  In FixedPrice.sol,  ```solidity /// @notice buy from a fixed price sale after the sale starts /// @param _amount the amount of editions to buy function buy(uint256 _amount) external payable {  Sale memory sale_ = sale;  IEscher721 nft = IEscher721(sale_.edition);  require(block.timestamp >= sale_.startTime, "TOO SOON");  require(_amount * sale_.price == msg.value, "WRONG PRICE");  uint48 newId = uint48(_amount) + sale_.currentId;  require(newId <= sale_.finalId, "TOO MANY");   for (uint48 x = sale_.currentId + 1; x <= newId; x++) {   nft.mint(msg.sender, x);  }   sale.currentId = newId;   emit Buy(msg.sender, _amount, msg.value, sale);   if (newId == sale_.finalId) _end(sale); } ```   the amount is unsafely downcasted from uint256 to uint48, note the code:    ```solidity require(_amount * sale_.price == msg.value, "WRONG PRICE"); uint48 newId = uint48(_amount) + sale_.currentId; ```  the upper limit for uint48 is 281474976710655,  if user wants to buy more than 281474976710655 amount of nft and pay the 281474976710655 * sale price amount, the user can only receive 281474976710655 amount of nft because of the downcasting.  In LPDA.sol, we are unsafely downcasting the price in the buy function  ```solidity receipts[msg.sender].amount += amount; receipts[msg.sender].balance += uint80(msg.value);  for (uint256 x = temp.currentId + 1; x <= newId; x++) {  nft.mint(msg.sender, x); }  sale.currentId = newId;  emit Buy(msg.sender, amount, msg.value, temp);  if (newId == temp.finalId) {  sale.finalPrice = uint80(price);  uint256 totalSale = price * amountSold;  uint256 fee = totalSale / 20;  ISaleFactory(factory).feeReceiver().transfer(fee);  temp.saleReceiver.transfer(totalSale - fee);  _end(); } ```  note the line:  uint80(msg.value) and uint80(price)  In LPDA.sol, same issue exists in the refund function:  ```solidity /// @notice allow a buyer to get a refund on the current price difference function refund() public {  Receipt memory r = receipts[msg.sender];  uint80 price = uint80(getPrice()) * r.amount;  uint80 owed = r.balance - price;  require(owed > 0, "NOTHING TO REFUND");  receipts[msg.sender].balance = price;  payable(msg.sender).transfer(owed); } ```  note the downcasting: uint80(getPrice())  this means if the price goes above uint80, it will be wrongly trancated to uint80 for price.  The Downcasting in LPDA.sol is damaging because it tracunated user's fund.  Below is the POC:  add test in LPDA.t.sol  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/test/LPDA.t.sol#L167  ```solidity     function test_LPDA_downcasting_POC() public {          // make the lpda sales contract         sale = LPDA(lpdaSales.createLPDASale(lpdaSale));         // authorize the lpda sale to mint tokens         edition.grantRole(edition.MINTER_ROLE(), address(sale));         //lets buy an NFT          uint256 val = uint256(type(uint80).max) + 10 ether;         console.log('msg.value');         console.log(val);         sale.buy{value: val}(1);          } ```  and import "forge-std/console.sol" in LPDA.sol  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L3  ```solidity import "forge-std/console.sol"; ```  and add console.log in LPDA.sol buy function.  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDA.sol#L69  ```solidity receipts[msg.sender].amount += amount; receipts[msg.sender].balance += uint80(msg.value);  console.log("truncated value"); console.log(receipts[msg.sender].balance); ```  We run our test:  ```solidity forge test -vv --match test_LPDA_downcasting_POC ```  the output is:  ```solidity Running 1 test for test/LPDA.t.sol:LPDATest [PASS] test_LPDA_downcasting_POC() (gas: 385619) Logs:   msg.value   1208935819614629174706175   truncated value   9999999999999999999  Test result: ok. 1 passed; 0 failed; finished in 3.61ms ```  as we can see, user uses 1208935819614629174706175 to buy in LPDA.sol but the balance is truncated to 9999999999999999999, later user is not able to get the refund they are entitled to because the msg.value is unsafely downcasted.  Also note the downcasting for getPrice in LPDA.sol is also a issue:  the getPrice in LPDA.sol returns a uint256  ```solidity /// @notice the price of the sale function getPrice() public view returns (uint256) {  Sale memory temp = sale;  (uint256 start, uint256 end) = (temp.startTime, temp.endTime);  if (block.timestamp < start) return type(uint256).max;  if (temp.currentId == temp.finalId) return temp.finalPrice;   uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;  return temp.startPrice - (temp.dropPerSecond * timeElapsed); } ```  but this is downcasted into uint80 in function buy and refund.  ```solidity uint80 price = uint80(getPrice()) * r.amount; ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project handle downcasting and use safe casting library to make sure the downcast does not unexpected truncate value.  https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast 
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L68   # Vulnerability details  ## Impact A buyer could plan on buying early at higher prices to make sure he would secure a portion (say 50%) of NFTs he desired. When the number of NFTs still available got smaller and that `sale.endTime` were yet to hit, he would then watch the mempool and repeatedly attempt to thwart the final group of buyers from successfully completing their respective transactions amidst the efforts to prolong the Dutch auction till `sale.endTime` was reached.   ## Proof of Concept Assuming this particular edition pertained to a 100 NFT collection that would at most last for 60 minutes, and Bob planned on minting 10 of them. At the beginning of the dutch auction, he would first mint 5 NFTs at higher prices no doubt. At 50th minute, `sale.currentId == 95`. Alice, upon seeing this, made up her mind and proceeded to buying the remaining NFTs. Bob, seeing this transaction queuing in the mempool, invoked `buy()` to mint 1 NFT by sending in higher amount of gas to front run Alice. Needless to say, Alice's transaction was going to revert on line 68 because `newId == 101`:  [File: LPDA.sol#L68](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L68)  ``` 68:        require(newId <= temp.finalId, "TOO MANY"); ``` Noticing the number of NFTs still available had become 4, Alice attempted to mint the remaining 4 NFTs this time. Bob, upon seeing the similar queue in the mempool again, front ran Alice with another mint of 1 NFT.   These steps were repeatedly carried out until Bob managed to get all NFTs he wanted where the last one was minted right after `sale.endTime` hit. At this point, every successful buyers was happy to get the biggest refund possible ensuring that each NFT was only paid for the lowest price. This intended goal, on the contrary, was achieved at the expense of the seller getting the lowest amount of revenue and that the front run buyers minting nothing.   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Considering refactoring the affected code line as follows:  ``` - require(newId <= temp.finalId, "TOO MANY"); + if(newId > temp.finalId) { +      uint256 diff = newId - temp.finalId;  +      newId = temp.finalId; +      amountSold -= diff; +      amount -= diff; + } ```
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEdition.sol#L63   # Vulnerability details  ## Impact `OpenEdition.buy()` might revert due to uint overflow when it should work.  ## Proof of Concept `OpenEdition.buy()` validates the total funds like below.  ```solidity     function buy(uint256 _amount) external payable {         uint24 amount = uint24(_amount);         Sale memory temp = sale;         IEscher721 nft = IEscher721(temp.edition);         require(block.timestamp >= temp.startTime, "TOO SOON");         require(block.timestamp < temp.endTime, "TOO LATE");         require(amount * sale.price == msg.value, "WRONG PRICE"); //@audit overflow ```  Here, `amount` was declared as `uint24` and `sale.price` is `uint72`.  And it will revert when `amount * sale.price >= type(uint72).max` and such cases would be likely to happen e.g. `amount = 64(so 2^6), sale.price = 73 * 10^18(so 2^66)`.  As a result, `buy()` might revert when it should work properly.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should modify like below.  ```solidity     require(uint256(amount) * sale.price == msg.value, "WRONG PRICE"); ```
# Lines of code  https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L85-L86 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109 https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92   # Vulnerability details  ## Impact The protocol uses Solidity’s `transfer()` when transferring ETH to the recipients. This has some notable shortcomings when the recipient is a smart contract, which can render ETH impossible to transfer. Specifically, the transfer will inevitably fail when the smart contract:  - does not implement a payable fallback function, or - implements a payable fallback function which would incur more than 2300 gas units, or - implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.  ## Proof of Concept [File: LPDA.sol](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol)  ``` 85:            ISaleFactory(factory).feeReceiver().transfer(fee); 86:            temp.saleReceiver.transfer(totalSale - fee);  105:        payable(msg.sender).transfer(owed); ``` [File: FixedPrice.sol#L109](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109)  ``` 109:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20); ``` [File: OpenEdition.sol#L92](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92)  ``` 92:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20); ``` Issues pertaining to the use of `transfer()` in the code blocks above may be referenced further via:  - [CONSENSYS Diligence's article](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) - [OpenZeppelin news & events](https://blog.openzeppelin.com/reentrancy-after-istanbul/)   ## Tools Used Manual inspection  ## Recommended Mitigation Steps Using `call` with its returned boolean checked in combination with re-entrancy guard is highly recommended after December 2019.  For instance, [line 105](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105) in `LPDA.sol` may be refactored as follows:  ``` - payable(msg.sender).transfer(owed); + (bool success, ) = payable(msg.sender).call{ value: owed }(''); + require(success, " Transfer of ETH Failed"); ``` Alternatively, `Address.sendValue()` available in [OpenZeppelin Contract’s Address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L44-L65) can be used to transfer the Ether without being limited to 2300 gas units.   And again, in either of the above measures adopted, the risks of re-entrancy stemming from the use of this function can be mitigated by tightly following the “Check-effects-interactions” pattern and/or using [OpenZeppelin Contract’s ReentrancyGuard contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol#L43-L54).
