# Handle  shw   # Vulnerability details  ## Impact  A logic error in the `burnFlashGovernanceAsset` function that resets a user's `pendingFlashDecision` allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.  ## Proof of Concept  1. An attacker Alice executes a malicious flash governance decision, and her assets are locked in the `FlashGovernanceArbiter` contract. 2. The community disagrees with Alice's flash governance decision and calls `burnFlashGovernanceAsset` to burn her locked assets. However, the `burnFlashGovernanceAsset` function resets Alice's `pendingFlashDecision` to the default config (see line 134). 3. A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.  4. Now, Alice calls `withdrawGovernanceAsset` to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's `pendingFlashDecision` is reset to the default, the `unlockTime < block.timestamp` condition is fulfilled, and the withdrawal succeeds.  Referenced code: [DAO/FlashGovernanceArbiter.sol#L134](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L134) [DAO/FlashGovernanceArbiter.sol#L146](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  ## Recommended Mitigation Steps  Change line 134 to `delete pendingFlashDecision[targetContract][user]` instead of setting the `pendingFlashDecision` to the default.  
# Handle  shw   # Vulnerability details  ## Impact  The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more `fate` than he is supposed to with a relatively low cost.  With the large portion of `fate` he gets, he has more voting power to influence the system's decisions, or even he can convert his `fate` to Flan tokens for a direct profit.  ## Proof of Concept  Below is an example of how the attack works:  1. Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool's total supply is 1000, and the attacker has 100 LP tokens. 2. If the attacker burns his LP tokens, he earns `1000 * 100/1000 * 20 = 2000` amount of `fate`. 3. Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to `x * y = k`, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens. 4. After the manipulation, he burns his LP tokens and gets `2000 * 100/1000 * 20 = 4000` amount of `fate`. 5. Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE. 6. Compared to Step 2, the attacker earns a double amount of `fate` by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more `fate` he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.  The `setEYEBasedAssetStake` function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the [Cheese Bank attack](https://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7) and the [Warp Finance attack](https://peckshield.medium.com/warpfinance-incident-root-cause-analysis-581a4869ee00).  Referenced code: [DAO/LimboDAO.sol#L356](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L356) [DAO/LimboDAO.sol#L392](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L392)  ## Recommended Mitigation Steps  Use a fair pricing formula for the LP tokens, for example, the one proposed by [Alpha Finance](https://blog.alphafinance.io/fair-lp-token-pricing/).  
# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: Limbo.sol ```solidity   FlanLike Flan; ``` TokenProxyLike.sol ```solidity   address internal baseToken; ``` ProposalFactory.sol ```solidity   string public description;   LimboDAOLike DAO; ``` Please review all the state variables and apply immutable where possible.  
# Handle  hyh   # Vulnerability details  ## Impact  No events in Limbo, LimboDAO and FlashGovernanceArbiter contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  Contract's events don't have indices:  Limbo:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L253-260  FlashGovernanceArbiter:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L22  LimboDAO:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L56-61  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all to the addresses of the tokens and accounts broadcasted   
# Handle  Dravee   # Vulnerability details  ## Impact Wrong fateBalance bookkeeping for a user. Wrong fateCreated value emitted.  ## Proof of Concept Taking into account the FOT is done almost everywhere important in the solution already. That's a known practice in the solution.  However, it's missing here (see @audit-info tags): ``` File: LimboDAO.sol 383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate { 384:     require(assetApproved[asset], "LimboDAO: illegal asset"); 385:     address sender = _msgSender(); 386:     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed"); //@audit-info FOT not taken into account 387:     uint256 fateCreated = fateState[_msgSender()].fateBalance; 388:     if (asset == domainConfig.eye) { 389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation 390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation 391:     } else { 392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset); 393:       require(actualEyeBalance > 0, "LimboDAO: No EYE"); 394:       uint256 totalSupply = IERC20(asset).totalSupply(); 395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply; 396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation 397:       fateCreated = impliedEye * 20; 398:     } 399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;   400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted 401:   } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check the balance before and after the transfer to take into account the Fees-On-Transfer  
# Handle  csanuragjain   # Vulnerability details  ## Impact unlockTime is set incorrectly  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol  2. Observe the assertGovernanceApproved function  ``` function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public { ... pendingFlashDecision[target][sender].unlockTime += block.timestamp; ... } ```  3. Assume assertGovernanceApproved is called with sender x and target y and pendingFlashDecision[target][sender].unlockTime is 100 and block.timestamp is 10000 then  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100 ```  4. Again assertGovernanceApproved is called with same argument after timestamp 10100. This time unlockTime is set to very high value  (assume block.timestamp is 10500). This is incorrect  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600 ```  ## Recommended Mitigation Steps unlock time should be calculated like below  ``` constant public CONSTANT_UNLOCK_TIME = 1 days; // example pendingFlashDecision[target][sender].unlockTime = CONSTANT_UNLOCK_TIME +  block.timestamp; ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact Gas savings  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol  2. Observe that in burnAsset function, fateCreated can be initialized with 0 instead of fateState[_msgSender()].fateBalance which takes more gas. Actual value of fateCreated is decided by if-else condition  3. Observe that in vote function isLive modifier should be before incrementFate as if contract is not live then there is no meaning of incrementFate  4. Observe that in vote function below nested condition can be placed beforehand as if this happens further execution is not required  ``` if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) ```  5. Observe that previousProposalState is never used and can be removed  
# Handle  csanuragjain   # Vulnerability details  ## Impact   ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol  2. Observe the configure function which has below require condition  ``` require(priceBoostOvershoot < 100, "Set overshoot to number between 1 and 100."); ```  3. This means priceBoostOvershoot can be set to 0 which contradicts the require statement message mentioning "Set overshoot to number between 1 and 100." ## Tools Used  ## Recommended Mitigation Steps Change the require condition to   ``` require(priceBoostOvershoot < 100 && priceBoostOvershoot > 0, "Set overshoot to number between 1 and 100."); ```  
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  > Consequences: each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )    ## Proof of Concept   ``` UniswapHelper.sol:56:  uint256 constant year = (1 days * 365); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Replace with: ``` UniswapHelper.sol:56:  uint256 constant year = 365 days; ```    
# Handle  sirhashalot   # Vulnerability details  ## Impact  The LimboDAO.sol contract allows the votingDuration to be modified in the [`setProposalConfig()` function](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L302), but the `makeProposal()` function hard codes this value as two days, which is the initialized value, in the `makeProposal()` fee calculation.  ## Proof of Concept  First, observe the comment on line 209 has a comment: ``` proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours ```  This comment indicates that the quantity of 50,000 EYE is needed for each day. The votingDuration value [is initialized to 2 days](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L208). Later in the code, the "proposalConfig.requiredFateStake" variable is multiplied by 2. Although there is no explanation for this value, given the earlier comment that the "proposalConfig.requiredFateStake" value is required every day, the cost to make a proposal should vary based on the current votingDuration value:  ``` fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2; ```  Because a constant value of 2 is used, most likely assuming a constant 2 day votingDuration, later modifications to the votingDuration will not change the cost of making a proposal. If the votingDuration increases, the proposal cost will be less EYE per hour, and if the votingDuration decreases, the proposal cost will be more EYE per hour.  ## Recommended Mitigation Steps  One of two portions of the code is wrong and needs modification: 1. The comment about "50000 EYE for 24 hours" is wrong because it doesn't take into account the variability of votingDuration. Even if the comment only refers to the initialized values, it should state "50000 EYE for 48 hours" because the votingDuration is 2 days. 2. The `makeProposal()` function calculates the fate cost incorrectly because it never uses the votingDuration variables in its calculation.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `convertFateToFlan()` function in LimboDAO.sol appears to perform a calculate with improper units. The variable "flan" should hold a quantity of flan, but the units used in the calculation of flan don't match this. This incorrect calculation can allow users to call this function and receive much more flan than the fateToFlan exchange rate specifies.  ## Proof of Concept  The `convertFateToFlan()` function is in [the LimboDAO.sol contract](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L239) ```   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");     fateState[msg.sender].fateBalance -= fate;     flan = (fateToFlan * fate) / ONE;     Flan(domainConfig.flan).mint(msg.sender, flan);   } ```  The line where flan is calculated multiplies fateToFlan and fate. The units of fateToFlan are "fate / flan" while the units of fate are "fate". The product of the two has units "fate^2 / flan" as shown below: ``` fate     fate      fate ^ 2 ——   x         =   ———— flan                flan ```  ## Recommended Mitigation Steps  I see two solutions: 1. Modify the line calculating flan to `flan = fate / (fateToFlan * ONE);` 2. Either the fateToFlan value should be renamed to "flanToFate". This would require renaming the `setFateToFlan()` function, the comments describing the respective variable and function, and the unit tests  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The ERC20Burnable.sol file has code copied from the OpenZeppelin ERC20.sol contract. The Behodler code `transferFrom()` function does use the latest version of the OpenZeppelin code, modified earlier in Jan 2022 in [PR 3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085), which can save gas if currentAllowance == type(uint256).max.  A second gas savings that has been present in OpenZeppelin for some time but is not in the Behodler code is to add an unchecked clause around the `approve()` call.  ## Proof of Concept  The Behodler `transferFrom()` function [doesn't use the latest edits from OZ or the unchecked clause on the approve call](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/ERC677/ERC20Burnable.sol#L204-L218). In contrast, the OZ code [does use these edits for gas savings](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4f8af2dceb0fbc36cb32eb2cc14f80c340b9022e/contracts/token/ERC20/ERC20.sol#L156-L172).  ## Recommended Mitigation Steps  Use the latest OZ edits and the unchecked clause for gas savings if it doesn't introduce overflow or underflow conditions.  
# Handle  cmichel   # Vulnerability details  The error message for the `uniLPs` is still referring to `Sushi` instead of `Uniswap`  ```solidity require(UniPairLike(uniLPs[i]).factory() == uniFactory, "LimboDAO: invalid Sushi LP"); ```  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal contract `WithdrawERC20Proposal` allows a the DAO to withdraw ERC20 tokens to a destination the the function [withdrawERC20()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/WithdrawERC20Proposal.sol#L35).  However, this function is not implemented in [Limbo.sol](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol) and thus the execution can never succeed.  ## Recommended Mitigation Steps  Consider implementing this functionality in `Limbo.sol` or deleting the proposal.  
# Handle  CertoraInc   # Vulnerability details  ## Flan.sol (`safeTransfer()` function) The flan contract must have balance (and must have more flan then we want to transfer) in order to allow flan transfers. If it doesn't have any balance, the safeTransfer, which is the only way to transfer flan, will call `_transfer()` function with `amount = 0`. It should check `address(msg.sender)`'s balance instead of `address(this)`'s balance.  ```sol function safeTransfer(address _to, uint256 _amount) external {        uint256 flanBal = balanceOf(address(this)); // the problem is in this line        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;        _transfer(_msgSender(), _to, flanToTransfer);    } ```  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.  ## Proof of Concept  The function [burnFlashGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L124)  will simply overwrite the user's state with `pendingFlashDecision[targetContract][user] = flashGovernanceConfig;` as seen below.  ```   function burnFlashGovernanceAsset(     address targetContract,     address user,     address asset,     uint256 amount   ) public virtual onlySuccessfulProposal {     if (pendingFlashDecision[targetContract][user].assetBurnable) {       Burnable(asset).burn(amount);     }      pendingFlashDecision[targetContract][user] = flashGovernanceConfig;   } ```  Since `flashGovernanceConfig` is not modified in [BurnFlashStakeDeposit.execute()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L39) the user will have `amount` set to the current config amount which is likely what they originally transferred in {assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60).   Furthermore, `unlockTime` will be set to the config unlock time.  The config unlock time is the length of time in seconds that proposal should lock tokens for not the future timestamp. That is unlock time may be say `7 days` rather than `now + 7 days`. As a result the check in [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  `pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,` will always pass unless there is a significant misconfiguration.  ## Recommended Mitigation Steps  Consider deleting the user's data (i.e. `delete pendingFlashDecision[targetContract][user]`) rather than setting it to the config. This would ensure the user cannot withraw any funds afterwards.  Alternatively, only update `pendingFlashDecision[targetContract][user].amount` to subtract the amount sent as a function parameter and leave the remaining fields untouched.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  Users who have not called [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142)  after  they have locked their tokens from a previous proposal (i.e. [assertGovernanceApproved](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60)), will lose their tokens if [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is called again with the same `target` and `sender`.  The `sender` will lose `pendingFlashDecision[target][sender].amount` tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.  The impact of this is worsened by another vulnerability, that is [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is a `public` function and may be called by any arbitrary user so long as the `sender` field has called `approve()` for `FlashGovernanceArbiter` on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary `sender`.  ## Proof of Concept  In [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) as seen below, the line`pendingFlashDecision[target][sender] = flashGovernanceConfig` will overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.  Note that we must wait `pendingFlashDecision[target][sender].unlockTime` between calls.  ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime < block.timestamp     ) {       require(         emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),         "Limbo: flash governance disabled for rest of epoch"       );       pendingFlashDecision[target][sender] = flashGovernanceConfig;       pendingFlashDecision[target][sender].unlockTime += block.timestamp;        security.lastFlashGovernanceAct = block.timestamp;       emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);     } else {       revert("LIMBO: governance decision rejected.");     }   } ```   ## Recommended Mitigation Steps  Consider updating the initial if statement to ensure the `pendingFlashDecision` for that `target` and `sender` is empty, that is: ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime == 0     ) { ... ```  Note we cannot simply add the new `amount` to the previous `amount` incase the underlying `asset` has been changed.  
# Handle  CertoraInc   # Vulnerability details  ## LimboDAO.sol (`updateCurrentProposal()` modifier and `makeProposal()` function) The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an `UpdateMultipleSoulConfigProposal` proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the `vote` function will revert), and the proposal can't be executed - the `execute` function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.  When trying to call the `executeCurrentProposal()` function that activates the `updateCurrentProposal()` modifier, the modifier will check the balance of fate, it will see that it's positive and will call `currentProposalState.proposal.orchestrateExecute()` to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with `voting` state).  When trying to call `makeProposal()` function to make a new proposal it will revert because the current proposal is not equal to address(0).  To sum up, the system can get to a "stuck" state if a bad proposal (proposal that can't be executed) is accepted.  
# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`_unstake()` and `stake()` functions)  not emitting the `ClaimedReward` event when the user claims his rewards (also when staking and getting the current reward, I don't know if it is done in purpose but just making sure)  
# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`stake()` function) if a user has a pending reward and he call the `stake` function with `amount = 0`, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)  that's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward  
# Handle  camden   # Vulnerability details  ## Impact The impact here is that a user can, right at the end of the voting period, flip the decision without triggering the logic to extend the vote duration. The user doesn't even have to be very sophisticated: they can just send one vote in one transaction to go to 0, then in a subsequent transaction send enough to flip the vote.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/608cec2e297867e4d954a63fecd720e80c1d5ae8/contracts/DAO/LimboDAO.sol#L281 You can send exactly enough fate to send the fate amount to 0, then send fate to change the vote. You'll never trigger this logic.  On the first call, to send the currentProposalState.fate to 0, `(fate + currentFate) * fate == 0`, so we won't extend the proposal state.  Then, on the second call, to actually change the vote, `fate * currentFate == 0` because `currentFate` is 0.   ## Recommended Mitigation Steps Make sure that going to 0 is equivalent to a flip, but going away from 0 isn't a flip.  
# Handle  camden   # Vulnerability details  # Impact and PoC https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, `generateFLNQuote` is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a `blockProduced` value of the current block's number.  These quotes are used in the `_ensurePriceStability` function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285  This function will revert if this statement is false: ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration ``` Since `VARS.minQuoteWaitDuration` is a `uint256`, it is at least 0 ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > 0 ``` But, as we've shown above, we can create a transaction in every block that will make `localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced == 0`. In any block we can make any call to `_ensurePriceStability` revert.  `_ensurePriceStability` is called in the `ensurePriceStability` modifier: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L70  This modifier is used in `stabilizeFlan`:  https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L162  Lastly, `stabilizeFlan` is used in `migrate` in `Limbo.sol` https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/Limbo.sol#L234  Therefore, we can grief a migration in any block. In reality, the `minQuoteWaitDuration` would be set to a much higher value than 0, making this even easier to grief for people (you only need to call `generateFLNQuote` every `minQuoteWaitDuration - 1` blocks to be safe).  # Mitigation Mitigation is to just use a time weighted oracle for uniswap.  
# Handle  Ruhum   # Vulnerability details  ## Impact The if else here doesn't really do anything. Might as well just remove it: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol#L132  ## Recommended Mitigation Steps `VARS.precision = precision`  
# Handle  Ruhum   # Vulnerability details  ## Impact The recent events concerning MIM showed that stablecoins are not always worth $1. It might be worth it to add an option to stop accepting a specific stablecoin for the time being in `FlanBackstop`.  https://coinmarketcap.com/currencies/magic-internet-money/  Generally, it would allow someone to mint `PyroFlan` for cheaper than expected. Whether there are more possible attack vectors is not entirely clear to me.  I'd argue that you don't lose much by adding it.  ## Proof of Concept Currently, a backer can only be updated through a proposal which will most likely take too long: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L63  ## Tools Used none  ## Recommended Mitigation Steps Allow pausing the use of specific backers. Using the `governanceApproved()` modifier might be good  
# Handle  Ruhum   # Vulnerability details  ## Impact `LimboDAO.killDAO()` is used to assign control of the contracts to a new DAO. Currently, it only updates `Flan` & `Limbo`. But, `FlanBackstop`, `UniswapHelper`, and `ProposalFactory` also depend on the DAO. Those are not updated. The new DAO loses control over them.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L226  ## Tools Used none  ## Recommended Mitigation Steps Instead of calling `setDAO()` on hardcoded address, the function should allow passing an array of addresses for which `setDAO()` is called.  ```sol function killDAO(address[] calldata a, address newOwner) public onlyOwner isLive {     domainConfig.live = false;     for (uint i; i < a.length; i++) {         Governable(a[i]).setDAO(newOwner);     }     emit daoKilled(newOwner);   } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact There's a duplicate call here: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L93-L94  Remove it to reduce gas   
# Handle  CertoraInc   # Vulnerability details  Similar to ERC20.approve, `approveUnstake()` is unsafe due to the fact that it set the allowance to a fixed number and doesn't increase or decrease it. Usually, the `ERC20.approve` doesn't get much attention because they leave it to the user to make sure his operation is safe, however here the user cannot do it because the `unstakeApproval` state variable is private and there is no getter for it.  In `ERC20.approve` users can simply check the allowance and change it in the same transaction and eliminate the risk, but here it's impossible.  ## Impact Users will not be able to change the allowance of the unstake without the risk of the frontrunning stealing like the classic `ERC20.approve` (there the risk can be removed). This will cause users to not change allowance for users that they don't 100% trust which can be problematic  ## Proof of Concept The function that sets the allowance to a fixed number: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L606-L612  The private map state variable that has no getter (in solidity state variables are automatically private unless declared otherwise) https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L288  ## Tools Used Manual code review  ## Recommended Mitigation Steps If you insist changing the allowance to a fixed number and not increase it or decrease it, at least make the allowance public so it can be checked before changing  
# Handle  0x1f8b   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept Removing the variable `_redeemRate` and using only the call `redeemRate()` in the method `mint` inside the contract `RebaseProxy` it`s possible to save gas. It will save gas if the case of `transferFrom` failure.  ``` function mint(address to, uint256 amount)         public         override         returns (uint256)     {         uint256 _redeemRate = redeemRate();         require(             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)         );         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));         uint256 proxy = (baseBalance * ONE) / _redeemRate;         _mint(to, proxy);     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the mentioned argument.  
# Handle  shw   # Vulnerability details  ## Impact  A logic error in the `burnFlashGovernanceAsset` function that resets a user's `pendingFlashDecision` allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.  ## Proof of Concept  1. An attacker Alice executes a malicious flash governance decision, and her assets are locked in the `FlashGovernanceArbiter` contract. 2. The community disagrees with Alice's flash governance decision and calls `burnFlashGovernanceAsset` to burn her locked assets. However, the `burnFlashGovernanceAsset` function resets Alice's `pendingFlashDecision` to the default config (see line 134). 3. A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.  4. Now, Alice calls `withdrawGovernanceAsset` to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's `pendingFlashDecision` is reset to the default, the `unlockTime < block.timestamp` condition is fulfilled, and the withdrawal succeeds.  Referenced code: [DAO/FlashGovernanceArbiter.sol#L134](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L134) [DAO/FlashGovernanceArbiter.sol#L146](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  ## Recommended Mitigation Steps  Change line 134 to `delete pendingFlashDecision[targetContract][user]` instead of setting the `pendingFlashDecision` to the default.  
# Handle  shw   # Vulnerability details  ## Impact  The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more `fate` than he is supposed to with a relatively low cost.  With the large portion of `fate` he gets, he has more voting power to influence the system's decisions, or even he can convert his `fate` to Flan tokens for a direct profit.  ## Proof of Concept  Below is an example of how the attack works:  1. Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool's total supply is 1000, and the attacker has 100 LP tokens. 2. If the attacker burns his LP tokens, he earns `1000 * 100/1000 * 20 = 2000` amount of `fate`. 3. Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to `x * y = k`, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens. 4. After the manipulation, he burns his LP tokens and gets `2000 * 100/1000 * 20 = 4000` amount of `fate`. 5. Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE. 6. Compared to Step 2, the attacker earns a double amount of `fate` by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more `fate` he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.  The `setEYEBasedAssetStake` function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the [Cheese Bank attack](https://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7) and the [Warp Finance attack](https://peckshield.medium.com/warpfinance-incident-root-cause-analysis-581a4869ee00).  Referenced code: [DAO/LimboDAO.sol#L356](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L356) [DAO/LimboDAO.sol#L392](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L392)  ## Recommended Mitigation Steps  Use a fair pricing formula for the LP tokens, for example, the one proposed by [Alpha Finance](https://blog.alphafinance.io/fair-lp-token-pricing/).  
# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: Limbo.sol ```solidity   FlanLike Flan; ``` TokenProxyLike.sol ```solidity   address internal baseToken; ``` ProposalFactory.sol ```solidity   string public description;   LimboDAOLike DAO; ``` Please review all the state variables and apply immutable where possible.  
# Handle  hyh   # Vulnerability details  ## Impact  No events in Limbo, LimboDAO and FlashGovernanceArbiter contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  Contract's events don't have indices:  Limbo:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L253-260  FlashGovernanceArbiter:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L22  LimboDAO:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L56-61  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all to the addresses of the tokens and accounts broadcasted   
# Handle  Dravee   # Vulnerability details  ## Impact Wrong fateBalance bookkeeping for a user. Wrong fateCreated value emitted.  ## Proof of Concept Taking into account the FOT is done almost everywhere important in the solution already. That's a known practice in the solution.  However, it's missing here (see @audit-info tags): ``` File: LimboDAO.sol 383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate { 384:     require(assetApproved[asset], "LimboDAO: illegal asset"); 385:     address sender = _msgSender(); 386:     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed"); //@audit-info FOT not taken into account 387:     uint256 fateCreated = fateState[_msgSender()].fateBalance; 388:     if (asset == domainConfig.eye) { 389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation 390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation 391:     } else { 392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset); 393:       require(actualEyeBalance > 0, "LimboDAO: No EYE"); 394:       uint256 totalSupply = IERC20(asset).totalSupply(); 395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply; 396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation 397:       fateCreated = impliedEye * 20; 398:     } 399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;   400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted 401:   } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check the balance before and after the transfer to take into account the Fees-On-Transfer  
# Handle  csanuragjain   # Vulnerability details  ## Impact unlockTime is set incorrectly  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol  2. Observe the assertGovernanceApproved function  ``` function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public { ... pendingFlashDecision[target][sender].unlockTime += block.timestamp; ... } ```  3. Assume assertGovernanceApproved is called with sender x and target y and pendingFlashDecision[target][sender].unlockTime is 100 and block.timestamp is 10000 then  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100 ```  4. Again assertGovernanceApproved is called with same argument after timestamp 10100. This time unlockTime is set to very high value  (assume block.timestamp is 10500). This is incorrect  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600 ```  ## Recommended Mitigation Steps unlock time should be calculated like below  ``` constant public CONSTANT_UNLOCK_TIME = 1 days; // example pendingFlashDecision[target][sender].unlockTime = CONSTANT_UNLOCK_TIME +  block.timestamp; ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact Gas savings  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol  2. Observe that in burnAsset function, fateCreated can be initialized with 0 instead of fateState[_msgSender()].fateBalance which takes more gas. Actual value of fateCreated is decided by if-else condition  3. Observe that in vote function isLive modifier should be before incrementFate as if contract is not live then there is no meaning of incrementFate  4. Observe that in vote function below nested condition can be placed beforehand as if this happens further execution is not required  ``` if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) ```  5. Observe that previousProposalState is never used and can be removed  
# Handle  csanuragjain   # Vulnerability details  ## Impact   ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol  2. Observe the configure function which has below require condition  ``` require(priceBoostOvershoot < 100, "Set overshoot to number between 1 and 100."); ```  3. This means priceBoostOvershoot can be set to 0 which contradicts the require statement message mentioning "Set overshoot to number between 1 and 100." ## Tools Used  ## Recommended Mitigation Steps Change the require condition to   ``` require(priceBoostOvershoot < 100 && priceBoostOvershoot > 0, "Set overshoot to number between 1 and 100."); ```  
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  > Consequences: each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )    ## Proof of Concept   ``` UniswapHelper.sol:56:  uint256 constant year = (1 days * 365); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Replace with: ``` UniswapHelper.sol:56:  uint256 constant year = 365 days; ```    
# Handle  sirhashalot   # Vulnerability details  ## Impact  The LimboDAO.sol contract allows the votingDuration to be modified in the [`setProposalConfig()` function](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L302), but the `makeProposal()` function hard codes this value as two days, which is the initialized value, in the `makeProposal()` fee calculation.  ## Proof of Concept  First, observe the comment on line 209 has a comment: ``` proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours ```  This comment indicates that the quantity of 50,000 EYE is needed for each day. The votingDuration value [is initialized to 2 days](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L208). Later in the code, the "proposalConfig.requiredFateStake" variable is multiplied by 2. Although there is no explanation for this value, given the earlier comment that the "proposalConfig.requiredFateStake" value is required every day, the cost to make a proposal should vary based on the current votingDuration value:  ``` fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2; ```  Because a constant value of 2 is used, most likely assuming a constant 2 day votingDuration, later modifications to the votingDuration will not change the cost of making a proposal. If the votingDuration increases, the proposal cost will be less EYE per hour, and if the votingDuration decreases, the proposal cost will be more EYE per hour.  ## Recommended Mitigation Steps  One of two portions of the code is wrong and needs modification: 1. The comment about "50000 EYE for 24 hours" is wrong because it doesn't take into account the variability of votingDuration. Even if the comment only refers to the initialized values, it should state "50000 EYE for 48 hours" because the votingDuration is 2 days. 2. The `makeProposal()` function calculates the fate cost incorrectly because it never uses the votingDuration variables in its calculation.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `convertFateToFlan()` function in LimboDAO.sol appears to perform a calculate with improper units. The variable "flan" should hold a quantity of flan, but the units used in the calculation of flan don't match this. This incorrect calculation can allow users to call this function and receive much more flan than the fateToFlan exchange rate specifies.  ## Proof of Concept  The `convertFateToFlan()` function is in [the LimboDAO.sol contract](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L239) ```   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");     fateState[msg.sender].fateBalance -= fate;     flan = (fateToFlan * fate) / ONE;     Flan(domainConfig.flan).mint(msg.sender, flan);   } ```  The line where flan is calculated multiplies fateToFlan and fate. The units of fateToFlan are "fate / flan" while the units of fate are "fate". The product of the two has units "fate^2 / flan" as shown below: ``` fate     fate      fate ^ 2 ——   x         =   ———— flan                flan ```  ## Recommended Mitigation Steps  I see two solutions: 1. Modify the line calculating flan to `flan = fate / (fateToFlan * ONE);` 2. Either the fateToFlan value should be renamed to "flanToFate". This would require renaming the `setFateToFlan()` function, the comments describing the respective variable and function, and the unit tests  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The ERC20Burnable.sol file has code copied from the OpenZeppelin ERC20.sol contract. The Behodler code `transferFrom()` function does use the latest version of the OpenZeppelin code, modified earlier in Jan 2022 in [PR 3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085), which can save gas if currentAllowance == type(uint256).max.  A second gas savings that has been present in OpenZeppelin for some time but is not in the Behodler code is to add an unchecked clause around the `approve()` call.  ## Proof of Concept  The Behodler `transferFrom()` function [doesn't use the latest edits from OZ or the unchecked clause on the approve call](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/ERC677/ERC20Burnable.sol#L204-L218). In contrast, the OZ code [does use these edits for gas savings](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4f8af2dceb0fbc36cb32eb2cc14f80c340b9022e/contracts/token/ERC20/ERC20.sol#L156-L172).  ## Recommended Mitigation Steps  Use the latest OZ edits and the unchecked clause for gas savings if it doesn't introduce overflow or underflow conditions.  
# Handle  cmichel   # Vulnerability details  The error message for the `uniLPs` is still referring to `Sushi` instead of `Uniswap`  ```solidity require(UniPairLike(uniLPs[i]).factory() == uniFactory, "LimboDAO: invalid Sushi LP"); ```  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal contract `WithdrawERC20Proposal` allows a the DAO to withdraw ERC20 tokens to a destination the the function [withdrawERC20()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/WithdrawERC20Proposal.sol#L35).  However, this function is not implemented in [Limbo.sol](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol) and thus the execution can never succeed.  ## Recommended Mitigation Steps  Consider implementing this functionality in `Limbo.sol` or deleting the proposal.  
# Handle  CertoraInc   # Vulnerability details  ## Flan.sol (`safeTransfer()` function) The flan contract must have balance (and must have more flan then we want to transfer) in order to allow flan transfers. If it doesn't have any balance, the safeTransfer, which is the only way to transfer flan, will call `_transfer()` function with `amount = 0`. It should check `address(msg.sender)`'s balance instead of `address(this)`'s balance.  ```sol function safeTransfer(address _to, uint256 _amount) external {        uint256 flanBal = balanceOf(address(this)); // the problem is in this line        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;        _transfer(_msgSender(), _to, flanToTransfer);    } ```  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.  ## Proof of Concept  The function [burnFlashGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L124)  will simply overwrite the user's state with `pendingFlashDecision[targetContract][user] = flashGovernanceConfig;` as seen below.  ```   function burnFlashGovernanceAsset(     address targetContract,     address user,     address asset,     uint256 amount   ) public virtual onlySuccessfulProposal {     if (pendingFlashDecision[targetContract][user].assetBurnable) {       Burnable(asset).burn(amount);     }      pendingFlashDecision[targetContract][user] = flashGovernanceConfig;   } ```  Since `flashGovernanceConfig` is not modified in [BurnFlashStakeDeposit.execute()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L39) the user will have `amount` set to the current config amount which is likely what they originally transferred in {assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60).   Furthermore, `unlockTime` will be set to the config unlock time.  The config unlock time is the length of time in seconds that proposal should lock tokens for not the future timestamp. That is unlock time may be say `7 days` rather than `now + 7 days`. As a result the check in [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  `pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,` will always pass unless there is a significant misconfiguration.  ## Recommended Mitigation Steps  Consider deleting the user's data (i.e. `delete pendingFlashDecision[targetContract][user]`) rather than setting it to the config. This would ensure the user cannot withraw any funds afterwards.  Alternatively, only update `pendingFlashDecision[targetContract][user].amount` to subtract the amount sent as a function parameter and leave the remaining fields untouched.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  Users who have not called [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142)  after  they have locked their tokens from a previous proposal (i.e. [assertGovernanceApproved](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60)), will lose their tokens if [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is called again with the same `target` and `sender`.  The `sender` will lose `pendingFlashDecision[target][sender].amount` tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.  The impact of this is worsened by another vulnerability, that is [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is a `public` function and may be called by any arbitrary user so long as the `sender` field has called `approve()` for `FlashGovernanceArbiter` on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary `sender`.  ## Proof of Concept  In [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) as seen below, the line`pendingFlashDecision[target][sender] = flashGovernanceConfig` will overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.  Note that we must wait `pendingFlashDecision[target][sender].unlockTime` between calls.  ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime < block.timestamp     ) {       require(         emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),         "Limbo: flash governance disabled for rest of epoch"       );       pendingFlashDecision[target][sender] = flashGovernanceConfig;       pendingFlashDecision[target][sender].unlockTime += block.timestamp;        security.lastFlashGovernanceAct = block.timestamp;       emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);     } else {       revert("LIMBO: governance decision rejected.");     }   } ```   ## Recommended Mitigation Steps  Consider updating the initial if statement to ensure the `pendingFlashDecision` for that `target` and `sender` is empty, that is: ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime == 0     ) { ... ```  Note we cannot simply add the new `amount` to the previous `amount` incase the underlying `asset` has been changed.  
# Handle  CertoraInc   # Vulnerability details  ## LimboDAO.sol (`updateCurrentProposal()` modifier and `makeProposal()` function) The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an `UpdateMultipleSoulConfigProposal` proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the `vote` function will revert), and the proposal can't be executed - the `execute` function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.  When trying to call the `executeCurrentProposal()` function that activates the `updateCurrentProposal()` modifier, the modifier will check the balance of fate, it will see that it's positive and will call `currentProposalState.proposal.orchestrateExecute()` to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with `voting` state).  When trying to call `makeProposal()` function to make a new proposal it will revert because the current proposal is not equal to address(0).  To sum up, the system can get to a "stuck" state if a bad proposal (proposal that can't be executed) is accepted.  
# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`_unstake()` and `stake()` functions)  not emitting the `ClaimedReward` event when the user claims his rewards (also when staking and getting the current reward, I don't know if it is done in purpose but just making sure)  
# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`stake()` function) if a user has a pending reward and he call the `stake` function with `amount = 0`, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)  that's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward  
# Handle  camden   # Vulnerability details  ## Impact The impact here is that a user can, right at the end of the voting period, flip the decision without triggering the logic to extend the vote duration. The user doesn't even have to be very sophisticated: they can just send one vote in one transaction to go to 0, then in a subsequent transaction send enough to flip the vote.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/608cec2e297867e4d954a63fecd720e80c1d5ae8/contracts/DAO/LimboDAO.sol#L281 You can send exactly enough fate to send the fate amount to 0, then send fate to change the vote. You'll never trigger this logic.  On the first call, to send the currentProposalState.fate to 0, `(fate + currentFate) * fate == 0`, so we won't extend the proposal state.  Then, on the second call, to actually change the vote, `fate * currentFate == 0` because `currentFate` is 0.   ## Recommended Mitigation Steps Make sure that going to 0 is equivalent to a flip, but going away from 0 isn't a flip.  
# Handle  camden   # Vulnerability details  # Impact and PoC https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, `generateFLNQuote` is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a `blockProduced` value of the current block's number.  These quotes are used in the `_ensurePriceStability` function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285  This function will revert if this statement is false: ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration ``` Since `VARS.minQuoteWaitDuration` is a `uint256`, it is at least 0 ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > 0 ``` But, as we've shown above, we can create a transaction in every block that will make `localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced == 0`. In any block we can make any call to `_ensurePriceStability` revert.  `_ensurePriceStability` is called in the `ensurePriceStability` modifier: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L70  This modifier is used in `stabilizeFlan`:  https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L162  Lastly, `stabilizeFlan` is used in `migrate` in `Limbo.sol` https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/Limbo.sol#L234  Therefore, we can grief a migration in any block. In reality, the `minQuoteWaitDuration` would be set to a much higher value than 0, making this even easier to grief for people (you only need to call `generateFLNQuote` every `minQuoteWaitDuration - 1` blocks to be safe).  # Mitigation Mitigation is to just use a time weighted oracle for uniswap.  
# Handle  Ruhum   # Vulnerability details  ## Impact The if else here doesn't really do anything. Might as well just remove it: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol#L132  ## Recommended Mitigation Steps `VARS.precision = precision`  
# Handle  Ruhum   # Vulnerability details  ## Impact The recent events concerning MIM showed that stablecoins are not always worth $1. It might be worth it to add an option to stop accepting a specific stablecoin for the time being in `FlanBackstop`.  https://coinmarketcap.com/currencies/magic-internet-money/  Generally, it would allow someone to mint `PyroFlan` for cheaper than expected. Whether there are more possible attack vectors is not entirely clear to me.  I'd argue that you don't lose much by adding it.  ## Proof of Concept Currently, a backer can only be updated through a proposal which will most likely take too long: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L63  ## Tools Used none  ## Recommended Mitigation Steps Allow pausing the use of specific backers. Using the `governanceApproved()` modifier might be good  
# Handle  Ruhum   # Vulnerability details  ## Impact `LimboDAO.killDAO()` is used to assign control of the contracts to a new DAO. Currently, it only updates `Flan` & `Limbo`. But, `FlanBackstop`, `UniswapHelper`, and `ProposalFactory` also depend on the DAO. Those are not updated. The new DAO loses control over them.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L226  ## Tools Used none  ## Recommended Mitigation Steps Instead of calling `setDAO()` on hardcoded address, the function should allow passing an array of addresses for which `setDAO()` is called.  ```sol function killDAO(address[] calldata a, address newOwner) public onlyOwner isLive {     domainConfig.live = false;     for (uint i; i < a.length; i++) {         Governable(a[i]).setDAO(newOwner);     }     emit daoKilled(newOwner);   } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact There's a duplicate call here: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L93-L94  Remove it to reduce gas   
# Handle  CertoraInc   # Vulnerability details  Similar to ERC20.approve, `approveUnstake()` is unsafe due to the fact that it set the allowance to a fixed number and doesn't increase or decrease it. Usually, the `ERC20.approve` doesn't get much attention because they leave it to the user to make sure his operation is safe, however here the user cannot do it because the `unstakeApproval` state variable is private and there is no getter for it.  In `ERC20.approve` users can simply check the allowance and change it in the same transaction and eliminate the risk, but here it's impossible.  ## Impact Users will not be able to change the allowance of the unstake without the risk of the frontrunning stealing like the classic `ERC20.approve` (there the risk can be removed). This will cause users to not change allowance for users that they don't 100% trust which can be problematic  ## Proof of Concept The function that sets the allowance to a fixed number: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L606-L612  The private map state variable that has no getter (in solidity state variables are automatically private unless declared otherwise) https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L288  ## Tools Used Manual code review  ## Recommended Mitigation Steps If you insist changing the allowance to a fixed number and not increase it or decrease it, at least make the allowance public so it can be checked before changing  
# Handle  0x1f8b   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept Removing the variable `_redeemRate` and using only the call `redeemRate()` in the method `mint` inside the contract `RebaseProxy` it`s possible to save gas. It will save gas if the case of `transferFrom` failure.  ``` function mint(address to, uint256 amount)         public         override         returns (uint256)     {         uint256 _redeemRate = redeemRate();         require(             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)         );         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));         uint256 proxy = (baseBalance * ONE) / _redeemRate;         _mint(to, proxy);     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the mentioned argument.  
# Handle  shw   # Vulnerability details  ## Impact  A logic error in the `burnFlashGovernanceAsset` function that resets a user's `pendingFlashDecision` allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.  ## Proof of Concept  1. An attacker Alice executes a malicious flash governance decision, and her assets are locked in the `FlashGovernanceArbiter` contract. 2. The community disagrees with Alice's flash governance decision and calls `burnFlashGovernanceAsset` to burn her locked assets. However, the `burnFlashGovernanceAsset` function resets Alice's `pendingFlashDecision` to the default config (see line 134). 3. A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.  4. Now, Alice calls `withdrawGovernanceAsset` to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's `pendingFlashDecision` is reset to the default, the `unlockTime < block.timestamp` condition is fulfilled, and the withdrawal succeeds.  Referenced code: [DAO/FlashGovernanceArbiter.sol#L134](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L134) [DAO/FlashGovernanceArbiter.sol#L146](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  ## Recommended Mitigation Steps  Change line 134 to `delete pendingFlashDecision[targetContract][user]` instead of setting the `pendingFlashDecision` to the default.  
# Handle  shw   # Vulnerability details  ## Impact  The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more `fate` than he is supposed to with a relatively low cost.  With the large portion of `fate` he gets, he has more voting power to influence the system's decisions, or even he can convert his `fate` to Flan tokens for a direct profit.  ## Proof of Concept  Below is an example of how the attack works:  1. Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool's total supply is 1000, and the attacker has 100 LP tokens. 2. If the attacker burns his LP tokens, he earns `1000 * 100/1000 * 20 = 2000` amount of `fate`. 3. Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to `x * y = k`, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens. 4. After the manipulation, he burns his LP tokens and gets `2000 * 100/1000 * 20 = 4000` amount of `fate`. 5. Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE. 6. Compared to Step 2, the attacker earns a double amount of `fate` by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more `fate` he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.  The `setEYEBasedAssetStake` function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the [Cheese Bank attack](https://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7) and the [Warp Finance attack](https://peckshield.medium.com/warpfinance-incident-root-cause-analysis-581a4869ee00).  Referenced code: [DAO/LimboDAO.sol#L356](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L356) [DAO/LimboDAO.sol#L392](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L392)  ## Recommended Mitigation Steps  Use a fair pricing formula for the LP tokens, for example, the one proposed by [Alpha Finance](https://blog.alphafinance.io/fair-lp-token-pricing/).  
# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: Limbo.sol ```solidity   FlanLike Flan; ``` TokenProxyLike.sol ```solidity   address internal baseToken; ``` ProposalFactory.sol ```solidity   string public description;   LimboDAOLike DAO; ``` Please review all the state variables and apply immutable where possible.  
# Handle  hyh   # Vulnerability details  ## Impact  No events in Limbo, LimboDAO and FlashGovernanceArbiter contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  Contract's events don't have indices:  Limbo:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L253-260  FlashGovernanceArbiter:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L22  LimboDAO:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L56-61  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all to the addresses of the tokens and accounts broadcasted   
# Handle  Dravee   # Vulnerability details  ## Impact Wrong fateBalance bookkeeping for a user. Wrong fateCreated value emitted.  ## Proof of Concept Taking into account the FOT is done almost everywhere important in the solution already. That's a known practice in the solution.  However, it's missing here (see @audit-info tags): ``` File: LimboDAO.sol 383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate { 384:     require(assetApproved[asset], "LimboDAO: illegal asset"); 385:     address sender = _msgSender(); 386:     require(ERC677(asset).transferFrom(sender, address(this), amount), "LimboDAO: transferFailed"); //@audit-info FOT not taken into account 387:     uint256 fateCreated = fateState[_msgSender()].fateBalance; 388:     if (asset == domainConfig.eye) { 389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation 390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation 391:     } else { 392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset); 393:       require(actualEyeBalance > 0, "LimboDAO: No EYE"); 394:       uint256 totalSupply = IERC20(asset).totalSupply(); 395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply; 396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation 397:       fateCreated = impliedEye * 20; 398:     } 399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;   400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted 401:   } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check the balance before and after the transfer to take into account the Fees-On-Transfer  
# Handle  csanuragjain   # Vulnerability details  ## Impact unlockTime is set incorrectly  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol  2. Observe the assertGovernanceApproved function  ``` function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public { ... pendingFlashDecision[target][sender].unlockTime += block.timestamp; ... } ```  3. Assume assertGovernanceApproved is called with sender x and target y and pendingFlashDecision[target][sender].unlockTime is 100 and block.timestamp is 10000 then  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100 ```  4. Again assertGovernanceApproved is called with same argument after timestamp 10100. This time unlockTime is set to very high value  (assume block.timestamp is 10500). This is incorrect  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600 ```  ## Recommended Mitigation Steps unlock time should be calculated like below  ``` constant public CONSTANT_UNLOCK_TIME = 1 days; // example pendingFlashDecision[target][sender].unlockTime = CONSTANT_UNLOCK_TIME +  block.timestamp; ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact Gas savings  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol  2. Observe that in burnAsset function, fateCreated can be initialized with 0 instead of fateState[_msgSender()].fateBalance which takes more gas. Actual value of fateCreated is decided by if-else condition  3. Observe that in vote function isLive modifier should be before incrementFate as if contract is not live then there is no meaning of incrementFate  4. Observe that in vote function below nested condition can be placed beforehand as if this happens further execution is not required  ``` if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) ```  5. Observe that previousProposalState is never used and can be removed  
# Handle  csanuragjain   # Vulnerability details  ## Impact   ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol  2. Observe the configure function which has below require condition  ``` require(priceBoostOvershoot < 100, "Set overshoot to number between 1 and 100."); ```  3. This means priceBoostOvershoot can be set to 0 which contradicts the require statement message mentioning "Set overshoot to number between 1 and 100." ## Tools Used  ## Recommended Mitigation Steps Change the require condition to   ``` require(priceBoostOvershoot < 100 && priceBoostOvershoot > 0, "Set overshoot to number between 1 and 100."); ```  
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  > Consequences: each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )    ## Proof of Concept   ``` UniswapHelper.sol:56:  uint256 constant year = (1 days * 365); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Replace with: ``` UniswapHelper.sol:56:  uint256 constant year = 365 days; ```    
# Handle  sirhashalot   # Vulnerability details  ## Impact  The LimboDAO.sol contract allows the votingDuration to be modified in the [`setProposalConfig()` function](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L302), but the `makeProposal()` function hard codes this value as two days, which is the initialized value, in the `makeProposal()` fee calculation.  ## Proof of Concept  First, observe the comment on line 209 has a comment: ``` proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours ```  This comment indicates that the quantity of 50,000 EYE is needed for each day. The votingDuration value [is initialized to 2 days](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L208). Later in the code, the "proposalConfig.requiredFateStake" variable is multiplied by 2. Although there is no explanation for this value, given the earlier comment that the "proposalConfig.requiredFateStake" value is required every day, the cost to make a proposal should vary based on the current votingDuration value:  ``` fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2; ```  Because a constant value of 2 is used, most likely assuming a constant 2 day votingDuration, later modifications to the votingDuration will not change the cost of making a proposal. If the votingDuration increases, the proposal cost will be less EYE per hour, and if the votingDuration decreases, the proposal cost will be more EYE per hour.  ## Recommended Mitigation Steps  One of two portions of the code is wrong and needs modification: 1. The comment about "50000 EYE for 24 hours" is wrong because it doesn't take into account the variability of votingDuration. Even if the comment only refers to the initialized values, it should state "50000 EYE for 48 hours" because the votingDuration is 2 days. 2. The `makeProposal()` function calculates the fate cost incorrectly because it never uses the votingDuration variables in its calculation.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `convertFateToFlan()` function in LimboDAO.sol appears to perform a calculate with improper units. The variable "flan" should hold a quantity of flan, but the units used in the calculation of flan don't match this. This incorrect calculation can allow users to call this function and receive much more flan than the fateToFlan exchange rate specifies.  ## Proof of Concept  The `convertFateToFlan()` function is in [the LimboDAO.sol contract](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L239) ```   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {     require(fateToFlan > 0, "LimboDAO: Fate conversion to Flan disabled.");     fateState[msg.sender].fateBalance -= fate;     flan = (fateToFlan * fate) / ONE;     Flan(domainConfig.flan).mint(msg.sender, flan);   } ```  The line where flan is calculated multiplies fateToFlan and fate. The units of fateToFlan are "fate / flan" while the units of fate are "fate". The product of the two has units "fate^2 / flan" as shown below: ``` fate     fate      fate ^ 2 ——   x         =   ———— flan                flan ```  ## Recommended Mitigation Steps  I see two solutions: 1. Modify the line calculating flan to `flan = fate / (fateToFlan * ONE);` 2. Either the fateToFlan value should be renamed to "flanToFate". This would require renaming the `setFateToFlan()` function, the comments describing the respective variable and function, and the unit tests  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The ERC20Burnable.sol file has code copied from the OpenZeppelin ERC20.sol contract. The Behodler code `transferFrom()` function does use the latest version of the OpenZeppelin code, modified earlier in Jan 2022 in [PR 3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085), which can save gas if currentAllowance == type(uint256).max.  A second gas savings that has been present in OpenZeppelin for some time but is not in the Behodler code is to add an unchecked clause around the `approve()` call.  ## Proof of Concept  The Behodler `transferFrom()` function [doesn't use the latest edits from OZ or the unchecked clause on the approve call](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/ERC677/ERC20Burnable.sol#L204-L218). In contrast, the OZ code [does use these edits for gas savings](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4f8af2dceb0fbc36cb32eb2cc14f80c340b9022e/contracts/token/ERC20/ERC20.sol#L156-L172).  ## Recommended Mitigation Steps  Use the latest OZ edits and the unchecked clause for gas savings if it doesn't introduce overflow or underflow conditions.  
# Handle  cmichel   # Vulnerability details  The error message for the `uniLPs` is still referring to `Sushi` instead of `Uniswap`  ```solidity require(UniPairLike(uniLPs[i]).factory() == uniFactory, "LimboDAO: invalid Sushi LP"); ```  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal contract `WithdrawERC20Proposal` allows a the DAO to withdraw ERC20 tokens to a destination the the function [withdrawERC20()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/WithdrawERC20Proposal.sol#L35).  However, this function is not implemented in [Limbo.sol](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol) and thus the execution can never succeed.  ## Recommended Mitigation Steps  Consider implementing this functionality in `Limbo.sol` or deleting the proposal.  
# Handle  CertoraInc   # Vulnerability details  ## Flan.sol (`safeTransfer()` function) The flan contract must have balance (and must have more flan then we want to transfer) in order to allow flan transfers. If it doesn't have any balance, the safeTransfer, which is the only way to transfer flan, will call `_transfer()` function with `amount = 0`. It should check `address(msg.sender)`'s balance instead of `address(this)`'s balance.  ```sol function safeTransfer(address _to, uint256 _amount) external {        uint256 flanBal = balanceOf(address(this)); // the problem is in this line        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;        _transfer(_msgSender(), _to, flanToTransfer);    } ```  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.  ## Proof of Concept  The function [burnFlashGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L124)  will simply overwrite the user's state with `pendingFlashDecision[targetContract][user] = flashGovernanceConfig;` as seen below.  ```   function burnFlashGovernanceAsset(     address targetContract,     address user,     address asset,     uint256 amount   ) public virtual onlySuccessfulProposal {     if (pendingFlashDecision[targetContract][user].assetBurnable) {       Burnable(asset).burn(amount);     }      pendingFlashDecision[targetContract][user] = flashGovernanceConfig;   } ```  Since `flashGovernanceConfig` is not modified in [BurnFlashStakeDeposit.execute()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L39) the user will have `amount` set to the current config amount which is likely what they originally transferred in {assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60).   Furthermore, `unlockTime` will be set to the config unlock time.  The config unlock time is the length of time in seconds that proposal should lock tokens for not the future timestamp. That is unlock time may be say `7 days` rather than `now + 7 days`. As a result the check in [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  `pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,` will always pass unless there is a significant misconfiguration.  ## Recommended Mitigation Steps  Consider deleting the user's data (i.e. `delete pendingFlashDecision[targetContract][user]`) rather than setting it to the config. This would ensure the user cannot withraw any funds afterwards.  Alternatively, only update `pendingFlashDecision[targetContract][user].amount` to subtract the amount sent as a function parameter and leave the remaining fields untouched.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  Users who have not called [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142)  after  they have locked their tokens from a previous proposal (i.e. [assertGovernanceApproved](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60)), will lose their tokens if [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is called again with the same `target` and `sender`.  The `sender` will lose `pendingFlashDecision[target][sender].amount` tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.  The impact of this is worsened by another vulnerability, that is [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is a `public` function and may be called by any arbitrary user so long as the `sender` field has called `approve()` for `FlashGovernanceArbiter` on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary `sender`.  ## Proof of Concept  In [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) as seen below, the line`pendingFlashDecision[target][sender] = flashGovernanceConfig` will overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.  Note that we must wait `pendingFlashDecision[target][sender].unlockTime` between calls.  ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime < block.timestamp     ) {       require(         emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),         "Limbo: flash governance disabled for rest of epoch"       );       pendingFlashDecision[target][sender] = flashGovernanceConfig;       pendingFlashDecision[target][sender].unlockTime += block.timestamp;        security.lastFlashGovernanceAct = block.timestamp;       emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);     } else {       revert("LIMBO: governance decision rejected.");     }   } ```   ## Recommended Mitigation Steps  Consider updating the initial if statement to ensure the `pendingFlashDecision` for that `target` and `sender` is empty, that is: ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime == 0     ) { ... ```  Note we cannot simply add the new `amount` to the previous `amount` incase the underlying `asset` has been changed.  
# Handle  CertoraInc   # Vulnerability details  ## LimboDAO.sol (`updateCurrentProposal()` modifier and `makeProposal()` function) The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an `UpdateMultipleSoulConfigProposal` proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the `vote` function will revert), and the proposal can't be executed - the `execute` function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.  When trying to call the `executeCurrentProposal()` function that activates the `updateCurrentProposal()` modifier, the modifier will check the balance of fate, it will see that it's positive and will call `currentProposalState.proposal.orchestrateExecute()` to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with `voting` state).  When trying to call `makeProposal()` function to make a new proposal it will revert because the current proposal is not equal to address(0).  To sum up, the system can get to a "stuck" state if a bad proposal (proposal that can't be executed) is accepted.  
# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`_unstake()` and `stake()` functions)  not emitting the `ClaimedReward` event when the user claims his rewards (also when staking and getting the current reward, I don't know if it is done in purpose but just making sure)  
# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`stake()` function) if a user has a pending reward and he call the `stake` function with `amount = 0`, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)  that's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward  
# Handle  camden   # Vulnerability details  ## Impact The impact here is that a user can, right at the end of the voting period, flip the decision without triggering the logic to extend the vote duration. The user doesn't even have to be very sophisticated: they can just send one vote in one transaction to go to 0, then in a subsequent transaction send enough to flip the vote.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/608cec2e297867e4d954a63fecd720e80c1d5ae8/contracts/DAO/LimboDAO.sol#L281 You can send exactly enough fate to send the fate amount to 0, then send fate to change the vote. You'll never trigger this logic.  On the first call, to send the currentProposalState.fate to 0, `(fate + currentFate) * fate == 0`, so we won't extend the proposal state.  Then, on the second call, to actually change the vote, `fate * currentFate == 0` because `currentFate` is 0.   ## Recommended Mitigation Steps Make sure that going to 0 is equivalent to a flip, but going away from 0 isn't a flip.  
# Handle  camden   # Vulnerability details  # Impact and PoC https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, `generateFLNQuote` is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a `blockProduced` value of the current block's number.  These quotes are used in the `_ensurePriceStability` function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285  This function will revert if this statement is false: ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration ``` Since `VARS.minQuoteWaitDuration` is a `uint256`, it is at least 0 ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > 0 ``` But, as we've shown above, we can create a transaction in every block that will make `localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced == 0`. In any block we can make any call to `_ensurePriceStability` revert.  `_ensurePriceStability` is called in the `ensurePriceStability` modifier: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L70  This modifier is used in `stabilizeFlan`:  https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L162  Lastly, `stabilizeFlan` is used in `migrate` in `Limbo.sol` https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/Limbo.sol#L234  Therefore, we can grief a migration in any block. In reality, the `minQuoteWaitDuration` would be set to a much higher value than 0, making this even easier to grief for people (you only need to call `generateFLNQuote` every `minQuoteWaitDuration - 1` blocks to be safe).  # Mitigation Mitigation is to just use a time weighted oracle for uniswap.  
# Handle  Ruhum   # Vulnerability details  ## Impact The if else here doesn't really do anything. Might as well just remove it: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol#L132  ## Recommended Mitigation Steps `VARS.precision = precision`  
# Handle  Ruhum   # Vulnerability details  ## Impact The recent events concerning MIM showed that stablecoins are not always worth $1. It might be worth it to add an option to stop accepting a specific stablecoin for the time being in `FlanBackstop`.  https://coinmarketcap.com/currencies/magic-internet-money/  Generally, it would allow someone to mint `PyroFlan` for cheaper than expected. Whether there are more possible attack vectors is not entirely clear to me.  I'd argue that you don't lose much by adding it.  ## Proof of Concept Currently, a backer can only be updated through a proposal which will most likely take too long: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L63  ## Tools Used none  ## Recommended Mitigation Steps Allow pausing the use of specific backers. Using the `governanceApproved()` modifier might be good  
# Handle  Ruhum   # Vulnerability details  ## Impact `LimboDAO.killDAO()` is used to assign control of the contracts to a new DAO. Currently, it only updates `Flan` & `Limbo`. But, `FlanBackstop`, `UniswapHelper`, and `ProposalFactory` also depend on the DAO. Those are not updated. The new DAO loses control over them.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L226  ## Tools Used none  ## Recommended Mitigation Steps Instead of calling `setDAO()` on hardcoded address, the function should allow passing an array of addresses for which `setDAO()` is called.  ```sol function killDAO(address[] calldata a, address newOwner) public onlyOwner isLive {     domainConfig.live = false;     for (uint i; i < a.length; i++) {         Governable(a[i]).setDAO(newOwner);     }     emit daoKilled(newOwner);   } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact There's a duplicate call here: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L93-L94  Remove it to reduce gas   
# Handle  CertoraInc   # Vulnerability details  Similar to ERC20.approve, `approveUnstake()` is unsafe due to the fact that it set the allowance to a fixed number and doesn't increase or decrease it. Usually, the `ERC20.approve` doesn't get much attention because they leave it to the user to make sure his operation is safe, however here the user cannot do it because the `unstakeApproval` state variable is private and there is no getter for it.  In `ERC20.approve` users can simply check the allowance and change it in the same transaction and eliminate the risk, but here it's impossible.  ## Impact Users will not be able to change the allowance of the unstake without the risk of the frontrunning stealing like the classic `ERC20.approve` (there the risk can be removed). This will cause users to not change allowance for users that they don't 100% trust which can be problematic  ## Proof of Concept The function that sets the allowance to a fixed number: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L606-L612  The private map state variable that has no getter (in solidity state variables are automatically private unless declared otherwise) https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L288  ## Tools Used Manual code review  ## Recommended Mitigation Steps If you insist changing the allowance to a fixed number and not increase it or decrease it, at least make the allowance public so it can be checked before changing  
# Handle  0x1f8b   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept Removing the variable `_redeemRate` and using only the call `redeemRate()` in the method `mint` inside the contract `RebaseProxy` it`s possible to save gas. It will save gas if the case of `transferFrom` failure.  ``` function mint(address to, uint256 amount)         public         override         returns (uint256)     {         uint256 _redeemRate = redeemRate();         require(             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)         );         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));         uint256 proxy = (baseBalance * ONE) / _redeemRate;         _mint(to, proxy);     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the mentioned argument.  
