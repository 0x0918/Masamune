# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142   # Vulnerability details  ## Impact Users can lose their funds  ## Proof of Concept https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142  The code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.  Users will have withdrawed without getting their funds back.   ## Recommended Mitigation Steps Return the function after the success check  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125 https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137   # Vulnerability details  ## Impact [GeneralVault.sol#L125](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125) GeneralVault set a hardcoded slippage control of 99%. However, the underlying yield tokens price may go down. If Luna/UST things happen again, users' funds may get locked.  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137) Moreover, the withdrawal of the lidoVault takes a swap from the curve pool. 1 stEth worth 0.98 ETH at the time of writing. The vault can not withdraw at the current market.  Given that users' funds would be locked in the lidoVault, I consider this a high-risk issue.  ## Proof of Concept [1 stEth  = 0.98 Eth](https://twitter.com/hasufl/status/1524717773959700481/photo/1)  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137)   ## Tools Used  ## Recommended Mitigation Steps  There are different ways to set the slippage.   The first one is to let users determine the maximum slippage they're willing to take. The protocol front-end should set the recommended value for them. ```solidity   function withdrawCollateral(     address _asset,     uint256 _amount,     address _to,     uint256 _minReceiveAmount   ) external virtual {       // ...     require(withdrawAmount >= _minReceiveAmount, Errors.VT_WITHDRAW_AMOUNT_MISMATCH);   } ```   The second one is have a slippage control parameters that's set by the operator.  ```solidity     // Exchange stETH -> ETH via Curve     uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(       _addressesProvider,       _addressesProvider.getAddress('STETH_ETH_POOL'),       LIDO,       ETH,       yieldStETH,       maxSlippage     ); ```  ```solidity     function setMaxSlippage(uint256 _slippage) external onlyOperator {         maxSlippage = _slippage;          //@audit This action usually emit an event.         emit SetMaxSlippage(msg.sender, slippage);     } ```  These are two common ways to deal with this issue. I prefer the first one. The market may corrupt really fast before the operator takes action. It's nothing fun watching the number go down while having no option.  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124   # Vulnerability details  ## Impact  Withdrawing ETH collateral via the `withdrawCollateral` function using `type(uint256).max` for the `_amount` parameter reverts the transaction due to `_asset` being the zero-address and `IERC20Detailed(_asset).decimals()` not working for native ETH.  ## Proof of Concept  [GeneralVault.sol#L121-L124](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124)  ```solidity if (_amount == type(uint256).max) {     uint256 decimal = IERC20Detailed(_asset).decimals(); // @audit-info does not work for native ETH. Transaction reverts     _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Check `_asset` and use hard coded decimal value (`18`) for native ETH  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82   # Vulnerability details  Now there are no checks for the amounts to be transferred via _transferYield and _processTreasury. As reward token list is external and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the reward retrieval can become unavailable.  I.e. processYield() can be fully blocked for even an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality for the system and its availability is affected.  ## Proof of Concept  _transferYield proceeds with sending the amounts to treasury and yieldManager without checking:  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82  ```solidity     // transfer to treasury     if (_vaultFee > 0) {       uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);       yieldAmount = yieldAmount.sub(treasuryAmount);     }      // transfer to yieldManager     address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');     TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); ```  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L205-L209  ```solidity   function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {     uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);     IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);     return treasuryAmount;   } ```  The incentive token can be arbitrary. Some ERC20 do not allow zero amounts to be sent:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  In a situation of such a token added to reward list and zero incentive amount earned the whole processYield call will revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned. Both are external processes and arenâ€™t controllable.  ## Recommended Mitigation Steps  Consider running the transfers in _transferYield only when yieldAmount is positive:  ```solidity + if (yieldAmount > 0) {      // transfer to treasury      if (_vaultFee > 0) {        uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);        yieldAmount = yieldAmount.sub(treasuryAmount);      }       // transfer to yieldManager      address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');      TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); +  } ```  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136   # Vulnerability details  ## Impact Yields will not be able to be distributed to lenders because attempts to do so will revert  ## Proof of Concept The `processYield()` function loops overall of the extra rewards and transfers them ```solidity File: smart-contracts/ConvexCurveLPVault.sol   #1  105       uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength(); 106       for (uint256 i = 0; i < extraRewardsLength; i++) { 107         address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i); 108         address _rewardToken = IRewards(_extraReward).rewardToken(); 109         _transferYield(_rewardToken); 110       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110  There is no guarantee that the tokens involved will be efficient in their use of gas, and there are no upper bounds on the number of extra rewards:  ```solidity     function extraRewardsLength() external view returns (uint256) {         return extraRewards.length;     }       function addExtraReward(address _reward) external returns(bool){         require(msg.sender == rewardManager, "!authorized");         require(_reward != address(0),"!reward setting");           extraRewards.push(_reward);         return true;     } ``` https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L105-L115  Even if not every extra reward token has a balance, an attacker can sprinkle each one with dust, forcing a transfer by this function  `_getAssetYields()` has a similar issue: ```solidity File: smart-contracts/YieldManager.sol   #X  129       AssetYield[] memory assetYields = _getAssetYields(exchangedAmount); 130       for (uint256 i = 0; i < assetYields.length; i++) { 131         if (assetYields[i].amount > 0) { 132           uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount); 133           // 3. deposit Yield to pool for suppliers 134           _depositYield(assetYields[i].asset, _amount); 135         } 136       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include an offset and length as is done in `YieldManager.distributeYield()`   
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L75-L89 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L79-L104 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L131-L149   # Vulnerability details  ## Impact Possible lost value in `depositCollateral` function call  ## Proof of Concept In call `depositCollateral` can will send value and the asset can be an ERC20(!= address(0)), if `LidoVault` and `ConvexCurveLPVault` contract receive this call the fouds will lost Also in **LidoVault, L88**, if send as asset ETH(== address(0)) and send more value than `_amount`(msg.value > _amount), the exedent will lost  ## Recommended Mitigation Steps  In **GeneralVault**, `depositCollateral` function:  - Check if the `msg.value` is zero when the `_asset` is ERC20(!= address(0))  - Check if the `msg.value` is equeal to `_amount` when the `_asset` ETH(== address(0))  ```solidity function depositCollateral(address _asset, uint256 _amount) external payable virtual {   if (_asset != address(0)) { // asset = ERC20     require(msg.value == 0, <AN ERROR FROM Errors LIBRARY>);   } else { // asset = ETH     require(msg.value == _amount, <AN ERROR FROM Errors LIBRARY>);   }    // Deposit asset to vault and receive stAsset   // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido   (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);    // Deposit stAsset to lendingPool, then user will get aToken of stAsset   ILendingPool(_addressesProvider.getLendingPool()).deposit(     _stAsset,     _stAssetAmount,     msg.sender,     0   );    emit DepositCollateral(_asset, msg.sender, _amount); } ``` Also can remove the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` in **LidoVault, L88**   
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L184   # Vulnerability details  ## Impact In [`YieldManager`](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50).â€¨   ## Proof of Concept For example for CRV / USDC, the optimal route is currently CRV -> ETH and ETH -> USDC, and the pool ETH / USDC with 1% fees is tiny compared to the ones with 0.3 or 0.1%. Therefore using the current implementation would create a significant loss of revenue.   ## Recommended Mitigation Steps Basic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like itâ€™s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.  Then, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal.  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142   # Vulnerability details  ## Impact Users can lose their funds  ## Proof of Concept https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142  The code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.  Users will have withdrawed without getting their funds back.   ## Recommended Mitigation Steps Return the function after the success check  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125 https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137   # Vulnerability details  ## Impact [GeneralVault.sol#L125](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125) GeneralVault set a hardcoded slippage control of 99%. However, the underlying yield tokens price may go down. If Luna/UST things happen again, users' funds may get locked.  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137) Moreover, the withdrawal of the lidoVault takes a swap from the curve pool. 1 stEth worth 0.98 ETH at the time of writing. The vault can not withdraw at the current market.  Given that users' funds would be locked in the lidoVault, I consider this a high-risk issue.  ## Proof of Concept [1 stEth  = 0.98 Eth](https://twitter.com/hasufl/status/1524717773959700481/photo/1)  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137)   ## Tools Used  ## Recommended Mitigation Steps  There are different ways to set the slippage.   The first one is to let users determine the maximum slippage they're willing to take. The protocol front-end should set the recommended value for them. ```solidity   function withdrawCollateral(     address _asset,     uint256 _amount,     address _to,     uint256 _minReceiveAmount   ) external virtual {       // ...     require(withdrawAmount >= _minReceiveAmount, Errors.VT_WITHDRAW_AMOUNT_MISMATCH);   } ```   The second one is have a slippage control parameters that's set by the operator.  ```solidity     // Exchange stETH -> ETH via Curve     uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(       _addressesProvider,       _addressesProvider.getAddress('STETH_ETH_POOL'),       LIDO,       ETH,       yieldStETH,       maxSlippage     ); ```  ```solidity     function setMaxSlippage(uint256 _slippage) external onlyOperator {         maxSlippage = _slippage;          //@audit This action usually emit an event.         emit SetMaxSlippage(msg.sender, slippage);     } ```  These are two common ways to deal with this issue. I prefer the first one. The market may corrupt really fast before the operator takes action. It's nothing fun watching the number go down while having no option.  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124   # Vulnerability details  ## Impact  Withdrawing ETH collateral via the `withdrawCollateral` function using `type(uint256).max` for the `_amount` parameter reverts the transaction due to `_asset` being the zero-address and `IERC20Detailed(_asset).decimals()` not working for native ETH.  ## Proof of Concept  [GeneralVault.sol#L121-L124](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124)  ```solidity if (_amount == type(uint256).max) {     uint256 decimal = IERC20Detailed(_asset).decimals(); // @audit-info does not work for native ETH. Transaction reverts     _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Check `_asset` and use hard coded decimal value (`18`) for native ETH  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82   # Vulnerability details  Now there are no checks for the amounts to be transferred via _transferYield and _processTreasury. As reward token list is external and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the reward retrieval can become unavailable.  I.e. processYield() can be fully blocked for even an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality for the system and its availability is affected.  ## Proof of Concept  _transferYield proceeds with sending the amounts to treasury and yieldManager without checking:  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82  ```solidity     // transfer to treasury     if (_vaultFee > 0) {       uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);       yieldAmount = yieldAmount.sub(treasuryAmount);     }      // transfer to yieldManager     address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');     TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); ```  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L205-L209  ```solidity   function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {     uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);     IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);     return treasuryAmount;   } ```  The incentive token can be arbitrary. Some ERC20 do not allow zero amounts to be sent:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  In a situation of such a token added to reward list and zero incentive amount earned the whole processYield call will revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned. Both are external processes and arenâ€™t controllable.  ## Recommended Mitigation Steps  Consider running the transfers in _transferYield only when yieldAmount is positive:  ```solidity + if (yieldAmount > 0) {      // transfer to treasury      if (_vaultFee > 0) {        uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);        yieldAmount = yieldAmount.sub(treasuryAmount);      }       // transfer to yieldManager      address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');      TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); +  } ```  
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136   # Vulnerability details  ## Impact Yields will not be able to be distributed to lenders because attempts to do so will revert  ## Proof of Concept The `processYield()` function loops overall of the extra rewards and transfers them ```solidity File: smart-contracts/ConvexCurveLPVault.sol   #1  105       uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength(); 106       for (uint256 i = 0; i < extraRewardsLength; i++) { 107         address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i); 108         address _rewardToken = IRewards(_extraReward).rewardToken(); 109         _transferYield(_rewardToken); 110       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110  There is no guarantee that the tokens involved will be efficient in their use of gas, and there are no upper bounds on the number of extra rewards:  ```solidity     function extraRewardsLength() external view returns (uint256) {         return extraRewards.length;     }       function addExtraReward(address _reward) external returns(bool){         require(msg.sender == rewardManager, "!authorized");         require(_reward != address(0),"!reward setting");           extraRewards.push(_reward);         return true;     } ``` https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L105-L115  Even if not every extra reward token has a balance, an attacker can sprinkle each one with dust, forcing a transfer by this function  `_getAssetYields()` has a similar issue: ```solidity File: smart-contracts/YieldManager.sol   #X  129       AssetYield[] memory assetYields = _getAssetYields(exchangedAmount); 130       for (uint256 i = 0; i < assetYields.length; i++) { 131         if (assetYields[i].amount > 0) { 132           uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount); 133           // 3. deposit Yield to pool for suppliers 134           _depositYield(assetYields[i].asset, _amount); 135         } 136       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include an offset and length as is done in `YieldManager.distributeYield()`   
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L75-L89 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L79-L104 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L131-L149   # Vulnerability details  ## Impact Possible lost value in `depositCollateral` function call  ## Proof of Concept In call `depositCollateral` can will send value and the asset can be an ERC20(!= address(0)), if `LidoVault` and `ConvexCurveLPVault` contract receive this call the fouds will lost Also in **LidoVault, L88**, if send as asset ETH(== address(0)) and send more value than `_amount`(msg.value > _amount), the exedent will lost  ## Recommended Mitigation Steps  In **GeneralVault**, `depositCollateral` function:  - Check if the `msg.value` is zero when the `_asset` is ERC20(!= address(0))  - Check if the `msg.value` is equeal to `_amount` when the `_asset` ETH(== address(0))  ```solidity function depositCollateral(address _asset, uint256 _amount) external payable virtual {   if (_asset != address(0)) { // asset = ERC20     require(msg.value == 0, <AN ERROR FROM Errors LIBRARY>);   } else { // asset = ETH     require(msg.value == _amount, <AN ERROR FROM Errors LIBRARY>);   }    // Deposit asset to vault and receive stAsset   // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido   (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);    // Deposit stAsset to lendingPool, then user will get aToken of stAsset   ILendingPool(_addressesProvider.getLendingPool()).deposit(     _stAsset,     _stAssetAmount,     msg.sender,     0   );    emit DepositCollateral(_asset, msg.sender, _amount); } ``` Also can remove the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` in **LidoVault, L88**   
# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L184   # Vulnerability details  ## Impact In [`YieldManager`](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50).â€¨   ## Proof of Concept For example for CRV / USDC, the optimal route is currently CRV -> ETH and ETH -> USDC, and the pool ETH / USDC with 1% fees is tiny compared to the ones with 0.3 or 0.1%. Therefore using the current implementation would create a significant loss of revenue.   ## Recommended Mitigation Steps Basic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like itâ€™s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.  Then, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal.  
