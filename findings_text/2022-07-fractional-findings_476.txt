# 1. Code Summary  #### Code Quality and Test Coverage  In summary, the code quality of the Fractional was found to be high. The codes were also found to be well-documented and the team took the efforts to document the NatSpec for all the functions within the contracts. As a result, it is easy for the reader to understand the overall architecture and design of the system. However, some minor errors within the comments were observed. Although it does not cause any technical issues or result in a loss of fund, it is recommended for the team to review them and update them accordingly to ensure that the documentation reflects what the system does accurately.  Further improvement to the code readability can be made by using a modifier, refer to the "Use modifier for better readability and code reuse" below. Another key concern that is the functions within the `Supply` and `Transfer` contracts are implemented entirely in assembly. Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code. Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.  Test coverage was found to be high. All the key features were found to be covered in the test.  # 2. Key Risks & Improvement Opportunities  #### Excessive Power Holds By Vault Owner  Fractional allows vault owners to install custom plugins to extend the functionality of the vault during or after deployment. The plugins within the vault could theoretically perform any task such as transferring the asset from the vault to an arbitrary wallet address or minting any amount of new fractional tokens. Therefore, it is critical for the fractional token holders of a vault to be aware of this risk and the token holders must ensure that the vault owner is trustworthy.  Under normal circumstances, the vault owner will be Fractional's `VaultRegistry` contract, which does not pose much of an issue because `VaultRegistry` contract is considered a trusted entity within Fractional protocol. However, potential fractional token investors should take note that some vaults can be created via `VaultRegistry.createFor`, which will transfer the ownership of the vault to an arbitrary address. In such a case, potential investors must ensure that the new vault owner is trustworthy enough not to perform a rug pull or steal the assets in the vault.  Consider documenting this risk if needed so that potential fractional token holders can make an informed decision.  #### Conflicting Module Might Block Functionality Of Another Module  Both the `Buyout` and `Migration` modules depend heavily on the state of the vault (e.g. INACTIVE, LIVE, SUCCESS) to determine if a function can be executed at any point in time. For instance, a buyout can only be started only if the vault state is "INACTIVE", or a migration can only be settled if the vault state is "SUCCESS".  A module changing the vault state might cause unintended behavior in another module. For instance, when a buyer starts an auction within the `Buyout` module, it will cause the vault state to change to `State.LIVE`. As a result, it will cause contributors of a proposal within the `Migration` module to be unable to withdraw their contributed assets from the proposal because the `Migration.withdrawContribution` function requires the vault state to be `State.INACTIVE`. Thus, contributor assets are stuck in the `Migration` contract whenever a buyer starts an auction in the `Buyout` module.  It is recommended to take extra caution when writing the module to ensure that it does not accidentally block the functionality of another module.  #### Step In A Process Can Be Bypassed Or Triggered In An Out-of-Order Manner  To ensure that the vault operates in an expected manner, it is important that the contracts prevent users from calling functions in an out-of-order manner or bypassing certain step in a process. It was observed that it is possible for users to call the function in an out-of-order manner or bypass certain step in a process entirely. Following illustrates some of the examples:   - A user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions` - A contributor should call `Migration.leave` to leave a proposed migration to get back their asset if the proposal has not been committed yet. However, instead of calling `Migration.leave`, the contributor can choose to call `Migration.withdrawContribution` which will succeed without any revert.  Ensure that the sequence in a process (e.g. buyout or migration process) is strictly followed and enforced.  #### Re-entrancy Risks  The key features of the protocols were found to be following the "Checks Effects Interactions" pattern rigorously, which helps to prevent any possible re-entrancy attack. So far no re-entrancy attack that can lead to loss of asset was observed during the contest. However, further improvements can be made to guard against future re-entrancy attacks in case any attack vector is missed out by C4's wardens during the contest.   A number of key functions within `Buyout` and `Migration` modules deal with ERC1155, which contains a hook that will make a callback to the recipient whenever a transfer occurs, thus increasing the risk of a re-entrancy attack. Refer to the "Lack Of Reentrancy Guards" issue for more details.  Thus, it would be prudent to implement additional reentrancy prevention wherever possible by utilizing the `nonReentrant` modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy as a defense-in-depth measure.  #### Input Validation  Although input validation has been already implemented in the majority of the functions, it can be further strengthened to thwart potential attacks or prevent unexpected behavior in the future. For instance, `Vault.transferOwnership` does not check if the ownership is being transferred to `address(0)`, which might affect the functionality of the vault.  # 3. Summary Of Findings  The following is a summary of the low and non-critical findings observed during the contest.  | No.  | Title                                                        | Risk Rating  | | ---- | ------------------------------------------------------------ | ------------ | | 4.1  | Lack Of Reentrancy Guards                                    | Low          | | 4.2  | Migration Sequence Not Enforced                              | Low          | | 4.3  | State Variable Visibility Is Not Set                         | Low          | | 4.4  | Risk of Plugins                                              | Low          | | 4.5  | Ether Might Stuck In `Vault.sol`                             | Low          | | 4.6  | Ownership May Be Burned                                      | Low          | | 4.7  | Array Length Not Validated                                   | Low          | | 4.8  | Consider Two-Phase Ownership Transfer                        | Low          | | 4.9  | Migration Proposer Can Hijack Other User's Buyout To Settle A Vault | Low          | | 5.1  | Incorrect Comment                                            | Non-Critical | | 5.2  | Use Modifier For Better Readability And Code Reuse           | Non-Critical | | 5.3  | Assembly Within `Supply.sol` and `Transfer.sol`              | Non-Critical | | 5.4  | Variable Should Be Called `isInit` Instead Of `Nonce`        | Non-Critical |    # 4. Low Risk Issues  ## 4.1   Lack Of Reentrancy Guards  #### Description  Whenever `IERC1155(token).safeTransferFrom` is called, the `to` address can re-enter back to the contracts due to the `ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data)` code (hook)  https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L55  ```solidity function safeTransferFrom(     address from,     address to,     uint256 id,     uint256 amount,     bytes calldata data ) public virtual {     require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");      balanceOf[from][id] -= amount;     balanceOf[to][id] += amount;      emit TransferSingle(msg.sender, from, to, id, amount);      require(         to.code.length == 0             ? to != address(0)             : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==                 ERC1155TokenReceiver.onERC1155Received.selector,         "UNSAFE_RECIPIENT"     ); } ```  The following functions utilise `IERC1155(token).safeTransferFrom` that allows the caller or proposer to re-enter back to the contracts  - [`Buyout.buyFractions`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L149)  - [`Buyout.end`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L184)  - [`Migration.leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141)  - [`Migration.withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292)  #### Recommendation  Apply necessary reentrancy prevention by utilizing the OpenZeppelin's nonReentrant modifier to block possible re-entrancy.    ## 4.2 Migration Sequence Not Enforced  #### Description  Functions should be called in the following sequence to migrate a vault after a successful buyout.  1. `Migration.settleVault` - Create new vault  2. `Migration.settleFractions` - Mint new fractional tokens to new vault  3. `Migration.migrateFractions` - Give investors the new fractional token  However, a user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions`.  Although it does not result in any loss of asset, allowing users to call the functions pertaining to migration in an out-of-order manner might cause unintended consequence in the future.  #### Recommendation  After the `Migration.settleFractions` has been executed, the `migrationInfo[_vault][_proposalId].fractionsMigrated` will be set to `true`.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L257  ```solidity function settleFractions(     address _vault,     uint256 _proposalId,     bytes32[] calldata _mintProof ) external {     ..SNIP..     migrationInfo[_vault][_proposalId].fractionsMigrated = true; } ```  Within the `Migration.migrateFractions` function, check that `migrationInfo[_vault][_proposalId].fractionsMigrated == true` to ensure that the `Migration.settleFractions` has been executed.  ```diff function migrateFractions(address _vault, uint256 _proposalId) external { + // Fractional tokens must be minted first before migrating + require(migrationInfo[_vault][_proposalId].fractionsMigrated, "Fractional token not minted yet");     // Reverts if address is not a registered vault     (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);     if (id == 0) revert NotVault(_vault);     // Reverts if buyout state is not successful     (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(         _vault     );     State required = State.SUCCESS;     if (current != required) revert IBuyout.InvalidState(required, current);     // Reverts if proposer of buyout is not this contract     if (proposer != address(this)) revert NotProposalBuyout(); ```    ## 4.3 State Variable Visibility Is Not Set  #### Description  Visibility is not set for the `token` state variable.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L13  ```solidity /// @title Metadata /// @author Fractional Art /// @notice Utility contract for storing metadata of an FERC1155 token contract Metadata {     /// @notice Address of FERC1155 token contract     address immutable token; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L12  ```solidity /// @title Supply /// @author Fractional Art /// @notice Reference implementation for the optimized Supply target contract contract SupplyReference is ISupply {     /// @notice Address of VaultRegistry contract     address immutable registry; ```  #### Recommendation  It is best practice to set the visibility of state variables explicitly. The default visibility for "token" is internal. Other possible visibility settings are public and private.    ## 4.4 Risk of Plugins  #### Description  All plugins' functions within the vault can be called by any public user. If the plugins contain any unprotected privileged functions, it can be called by malicious user.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ```solidity /// @dev Callback for handling plugin transactions /// @param _data Transaction data /// @return response Return data from executing plugin // prettier-ignore fallback(bytes calldata _data) external payable returns (bytes memory response) {     address plugin = methods[msg.sig]; // @audit-issue what if we have the diff contract with same function name? Collision?     (,response) = _execute(plugin, _data); } ```  #### Recommendation  Include a warning in the comments or documentation so that the vault owner is aware that any plugin's function added can be called by the public users. Vault owners should ensure that plugin's functions have the necessary access control in place so that only authorised users can trigger the functions.    ## 4.5 Ether Might Stuck In `Vault.sol`  #### Description  If a user accidentally sent ether to the `Vault` contract, the ether will be stuck in the vault with no way to retrieve them.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32  ```solidity /// @dev Callback for receiving Ether when the calldata is empty receive() external payable {} ```  #### Recommendation  Consider if there is a need for the `Vault` contract to receive ethers. Otherwise, remove it.    ## 4.6 Ownership May Be Burned  #### Description  It was observed that the vault owner can transfer the ownership to `address(0)`, which effectively burn the ownership.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  #### Recommendation  It is recommended to implement a validation check to ensure that the ownership is not transferred to `address(0)`.  ```diff function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_newOwner != 0, "Invalid new owner: address(0)");     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```    ## 4.7 Array Length Not Validated  #### Description  The `Vault.install` function did not validate that the length of `_selectors` and `_plugins` arrays is the same. If the array length is different, it might cause unexpected behavior.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73  ```solidity /// @notice Installs plugin by setting function selector to contract address /// @param _selectors List of function selectors /// @param _plugins Addresses of plugin contracts function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); }  ```  #### Recommendation  It is recommended to implement validation to ensure that the length of `_selectors` and `_plugins` arrays is the same.  ```diff function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_selectors.length == _plugins.length, "Length of selectors and plugins is not the same");     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); } ```    ## 4.8 Consider Two-Phase Ownership Transfer  #### Description  Owner can calls `Vault.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  Controller can calls `ERC1155.transferController` function to transfers the controller role to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a controller.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229  ```solidity /// @notice Updates the controller address for the FERC1155 token contract /// @param _newController Address of new controlling entity function transferController(address _newController)     external     onlyController {     if (_newController == address(0)) revert ZeroAddress();     _controller = _newController;     emit ControllerTransferred(_newController); } ```  ### Recommendation  Consider implementing a two step process where the owner or controller nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.    ## 4.9 Migration Proposer Can Hijack Other User's Buyout To Settle A Vault  #### Description  `Migration.settleVault` function should only be callable if the buyout initiated by the migration proposal is successful. However, it was observed that it is possible to call `Migration.settleVault` successfully even though the buyout initiated by the migration proposal has failed.  The following aims to demonstrate the issue:  1. Alice (attacker) creates a migration proposal by calling `Migration.propose` function. Then, she calls `Migration.commit` to kick off the buyout process for the migration, and Alice's proposal's `isCommited` is set to `true`. 2. Alice's buyout is unsuccessful. At this point in time, note that Alice's proposal's `isCommited` still remains as `true`, and the vault state reverts back to `State.INACTIVE`. 3. In order for the `Migration.settleVault` function to run successfully, the following three (3) requirements must be met:    - 1st requirement - Proposal must be committed    - 2nd requirement - Vault state must be set to `status.SUCCESS`    - 3rd requirement - `proposal.newVault` must not be initialised, which means that new vault has not been deployed yet 4. If Alice attempts to call `Migration.settleVault` function, it will revert because the vault state is not set to `State.SUCCESS` due to the failed buyout. In summary, her migration proposal meets all the requirements except for the 2nd requirement.  5. Bob decides to buy out the NFTs in the vault, therefore, he calls the `Buyout.start` to kick start the auction. After the buyout period (4 days), the vault pool has more than 51% of the total supply, thus the buyout is successful. 6. Bob proceeds to call the `Buyout.end` to end the auction. Since the buyout is successful, the vault state is set to `State.SUCCESS` now. 7. Alice decided to hijack Bob's buyout. Therefore, immediately after Bob called the `Buyout.end` function, Alice calls the `Migration.settleVault` function.   8. Alice's `Migration.settleVault` function call will succeed this time because the vault state has been set to `status.SUCCESS`.  This attack does not lead to loss of asset. Thus, I'm marking this as "Low". Even though the migration proposal has settled the vault successfully, when Alice calls `Migration.migrateVaultERC[20|721|1155]`, it will revert because the `Buyout.withdrawERC[20|721|1155]` will detect that the caller (`Migration` module) is not the actual auction winner.   However, `Migration.settleVault` function could still be called successfully in a situation where it should be failing, thus it is something to be raised.  #### Recommendation  Ensure that the `Migration.settleVault` can only be called if the buyout initiated by the migration proposal (within `Migration.commit`) has succeeded.    # 5. Non-Critical Issues    ## 5.1 Incorrect Comment  ### Instance #1 - Buyout  #### Description  The comment mentioned that if a pool has more than 51% of the total supply after 4 days, the buyout is successful.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L21  > /// @title Buyout > /// @author Fractional Art > /// @notice Module contract for vaults to hold buyout pools > /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool. > /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether. > /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether. > /// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer  However, based on the actual implementation, the buyout will be successful as long as the pool has more than 50% of the total supply.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206  ```solidity uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id); // Checks totalSupply of auction pool to determine if buyout is successful or not if (     (tokenBalance * 1000) /         IVaultRegistry(registry).totalSupply(_vault) >     500 )  ```  #### Recommendation  Update the comment to clearly reflect the actual implementation.  ```diff /// @title Buyout /// @author Fractional Art /// @notice Module contract for vaults to hold buyout pools /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool. /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether. /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether. -/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer +/// - If a pool has more than 50% of the total supply after 4 days, the buyout is successful and the proposer ```  ### Instance #2 - FERC1155  #### Description  The comment mentioned that the `FERC1155.royaltyInfo` function is to set the token royalties. However, the actual implementation is to read the token royalties.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241  ```solidity /// @notice Sets the token royalties /// @param _id Token ID royalties are being updated for /// @param _salePrice Sale price to calculate the royalty for function royaltyInfo(uint256 _id, uint256 _salePrice)     external     view     returns (address receiver, uint256 royaltyAmount) {     receiver = royaltyAddress[_id];     royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; } ```  #### Recommendation  Update the comment to clearly reflect the actual implementation.  ```diff -/// @notice Sets the token royalties +/// @notice Reads the token royalties /// @param _id Token ID royalties are being updated for /// @param _salePrice Sale price to calculate the royalty for function royaltyInfo(uint256 _id, uint256 _salePrice)     external     view     returns (address receiver, uint256 royaltyAmount) {     receiver = royaltyAddress[_id];     royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; } ```    ## 5.2 Use Modifier For Better Readability And Code Reuse  #### Description  To improve readability and code reuse, a `onlyOwner` modifer can be defined instead of performing a manual conditional check `if (owner != msg.sender) revert NotOwner(owner, msg.sender);` within the following affected functions:  - [`Vault.setMerkleRoot`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86) - [`Vault.transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [`Vault.uninstall`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101) - [`Vault.install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  #### Recommendation  It is recommended to define a modifier for access control and use it consistently throughout the codebase.  Following illustrates an example of the changes made to `Vault.setMerkleRoot` function.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86  ```solidity modifier modifier onlyOwner { {   if (owner == msg.sender) {      _;   } } ```  ```diff + function setMerkleRoot(bytes32 _rootHash) external onlyOwner { - function setMerkleRoot(bytes32 _rootHash) external { -    if (owner != msg.sender) revert NotOwner(owner, msg.sender);     merkleRoot = _rootHash; } ```    ## 5.3 Assembly Within `Supply.sol` and `Transfer.sol`  #### Description  The following functions were implemented in assembly:  - [`Supply .mint`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L23) - [`Supply.burn`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L113) - [`Transfer.ERC20Transfer`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L18) - [`Transfer.ERC721TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L222) - [`Transfer.ERC1155TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L341) - [`Transfer.ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474)  Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code.  #### Recommendation  Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.    ## 5.4 Variable Should Be Called `isInit` Instead Of `Nonce`  **Description**  The purpose of the `nonce` is to ensure that the `Vault.init` function is only called once.  Consider renaming it to `isInit` for better readability.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L24  ```solidity /// @dev Initializes nonce and proxy owner function init() external {     if (nonce != 0) revert Initialized(owner, msg.sender, nonce);     nonce = 1;     owner = msg.sender;     emit TransferOwnership(address(0), msg.sender); } ```
