# Handle  leastwood   # Vulnerability details  ## Impact  The treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.  However, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), "no fee recipient allowed");      // MakerToken should never be WETH     require(makerToken != address(WETH), "maker token must not be WETH");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), "taker token must be WETH");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), "price oracle not defined");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, "slippage limit not defined");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, "slippage is too high"); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.  
# Handle  IllIllI   # Vulnerability details  ## Impact When the value of the post-loop increment/decrement is not stored or used in any calculations, the prefix increment/decrement operators (`++i`/`--i`) cost less gas PER LOOP than the postfix increment/decrement operators (`i++`/`i--`)  ## Proof of Concept There is one example of this issue in the codebase:  ```Solidity for (uint256 i; i < currencies.length; i++) {         ``` https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L157   ## Tools Used Code inspection  ## Recommended Mitigation Steps Use `++i` rather than `i++` in all places  
# Handle  leastwood   # Vulnerability details  ## Impact  The `getVotingPower` function is an essential part of Notional's on-chain governance. However, the `priceRatio` calculation includes a division which slightly truncates the result which is then used in calculating `noteAmount` which also divides the result.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider performing all multiplication before division to minimise the degree of truncation by the final result.  
# Handle  Tomio   # Vulnerability details  ## Impact The check to make sure account is not in cool down is happening twice, on _mint() and _beforeTokenTransfer(), _beforeTokenTransfer() already has a _requireAccountNotInCoolDown() an the _mint() inside erc20upgradable will call the _beforeTokenTransfer(), this can make unnecessary call in the https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Tools Used  ## Recommended Mitigation Steps  
# Handle  Tomio   # Vulnerability details  ## Impact There is unnecessary if else condition on _redeemAndTransfer(), and can be optimized by removing the inline if else condition on line https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Tools Used  ## Recommended Mitigation Steps From: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();         }          address underlyingAddress = underlying.tokenAddress == address(0)             ? address(WETH)             : underlying.tokenAddress;         IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); ```  To: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();             IERC20(WETH).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         }else{             IERC20(underlying.tokenAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         } ```  
# Handle  gellej   # Vulnerability details  ## Impact   The function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.   Presumably, this 50% limit is in place to prevent the owner from "rug-pulling" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).   However, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.   As the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)  # Proof of Concept  See above. The code affected is here: https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100    ## Recommended Mitigation Steps  Rewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% _per week_ (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)  
# Handle  pauliax   # Vulnerability details  ## Impact Unused state variables: ```solidity     uint256 public constant BPT_TOKEN_PRECISION = 1e18;     uint256 internal constant ETH_PRECISION = 1e18;     uint32 public refundGasPrice; ``` Either remove them or use them where intended.  
# Handle  cmichel   # Vulnerability details  The `reserveInternal.subNoNeg(bufferInternal)` computation in `TreasuryAction.transferReserveToTreasury` can be a standard, unchecked subtraction as `if (reserveInternal <= bufferInternal) continue;` is checked before this computation.   
# Handle  cmichel   # Vulnerability details  The `EIP1271Wallet._validateOrder` function computes a `makerPrice` which ends up in `takerAmount` decimals which are 18 decimals as `takerToken` is always `WETH`. It is compared to the `priceFloor` return value from chainlink which must therefore also be in 18 decimals. This seems to be the case for this old deprecated API but should be fixed and adjusted to use the oracle decimals if Chainlink is upgraded to the new API.  ## Recommended Mitigation Steps Upgrade and adjust the decimals of `makerPrice` to match `priceFloor` decimals.   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `TreasuryManager.setPriceOracle: oracleAddress`: could break things - `TreasuryManager.setSlippageLimit: slippageLimit`: should be `<= SLIPPAGE_LIMIT_PRECISION`  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  WatchPug   # Vulnerability details  ttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209  ```solidity BALANCER_VAULT.joinPool{value: msgValue}(     NOTE_ETH_POOL_ID,     address(this),     address(this), // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) ); ```  The current implementation of `mintFromNOTE()` and `mintFromETH()` and `mintFromWETH()` (all are using `_mintFromAssets()` with `minimumBPT` hardcoded to `0`) provides no parameter for slippage control, making it vulnerable to front-run attacks.  ### Recommendation  Consider adding a `minAmountOut` parameter for these functions.  
# Handle  SolidityScan   # Vulnerability details  ## Description The value of `totalSupply()` at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L260 does not check if the value of totalSupply is 0 or not and it is per   ## Impact The return value for the function `getPoolTokenShare` can be invalid because if there's an error in the `totalSupply()` the code at Line 260 will evaluate to divide by zero creating inconsistencies in the function logic.   ## Proof of Concept 1. Check the function at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L257-L261 2. At line 260 we will notice that the value of totalSupply() is directly being used to perform division to the multiplication of `bptBalance * sNOTEAmount`   ## Recommended Mitigation Steps Add a check if the value of `totalSupply()` is zero or not or some other edge cases that can cause inconsistencies.   
# Handle  leastwood   # Vulnerability details  ## Impact  As `NOTE` continues to be staked in the `sNOTE` contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power `sNOTE` has in terms of its equivalent `NOTE` amount.   `getVotingPower` is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their `sNOTE` to another account to then vote again.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a `getPriorVotingPower` function which takes in a `blockNumber` argument and returns the correct balance at that specific block.  
# Handle  gzeon   # Vulnerability details  ## Impact In `_requireAccountNotInCoolDown` if `block.timestamp < coolDown.redeemWindowEnd`, we must have `coolDown.redeemWindowEnd > 0` hence `0 < coolDown.redeemWindowBegin`  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L308 ```         bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);         require(!isInCoolDown, "Account in Cool Down"); ``` to  ```         require(block.timestamp >= coolDown.redeemWindowEnd, "Account in Cool Down"); ```  
# Handle  leastwood   # Vulnerability details  ## Impact  The `EIP1271Wallet` contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the `TreasuryManager` contract, which holds harvested assets/`COMP` from Notional. While the `EIP1271Wallet._validateOrder` function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the `takerAddress` and `senderAddress` are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in `makerPrice`, the manager is able to extract value from the treasury by maximising the allowed slippage.  By setting `takerAddress` to the zero address, any user can be the taker of an off-chain order. By setting `senderAddress` to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66 ``` address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order. ```  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374   https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), "no fee recipient allowed");      // MakerToken should never be WETH     require(makerToken != address(WETH), "maker token must not be WETH");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), "taker token must be WETH");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), "price oracle not defined");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, "slippage limit not defined");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, "slippage is too high"); } ```  ## Tools Used  Manual code review. Discussions with Notional team.  ## Recommended Mitigation Steps  Consider adding `require(takerAddress == address(0), "manager cannot set taker");` and `require(senderAddress == address(0), "manager cannot set sender");` statements to `_validateOrder`. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.  
# Handle  hyh   # Vulnerability details    ## Impact  No events in TreasuryManager and sNOTE contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  TreasuryManager events don't have indices:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryManager.sol#L38-41  sNOTE events also aren't indexed:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L43-50  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all owner and account addresses   
# Handle  Dravee   # Vulnerability details  Here's the only `_investWETHToBuyNOTE()` call: ``` File: TreasuryManager.sol 140:     function investWETHToBuyNOTE(uint256 wethAmount) external onlyManager { 141:         _investWETHToBuyNOTE(wethAmount); 142:     } ```  While I can understand why some functions have the same style, these other functions are as such because they are calling an inherited function, as an example for `setSlippageLimit()`, which really is calling an inherited function from `EIP1271Wallet.sol`: ``` File: TreasuryManager.sol 89:     function setSlippageLimit(address tokenAddress, uint256 slippageLimit) 90:         external 91:         onlyOwner 92:     { 93:         _setSlippageLimit(tokenAddress, slippageLimit); 94:     } ```  However, for `_investWETHToBuyNOTE()`, this style doesn't hold.   ## Recommended Mitigation Steps All the logic from `_investWETHToBuyNOTE()` should be inlined in `investWETHToBuyNOTE()` to save gas.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary arithmetic operation  ## Proof of Concept See the @audit-info tag: ``` File: Bitmap.sol 46:     function getMSB(uint256 x) internal pure returns (uint256 msb) { 47:         // If x == 0 then there is no MSB and this method will return zero. That would 48:         // be the same as the return value when x == 1 (MSB is zero indexed), so instead 49:         // we have this require here to ensure that the values don't get mixed up. 50:         require(x != 0); // dev: get msb zero value 51:         if (x >= 0x100000000000000000000000000000000) { 52:             x >>= 128; 53:             msb += 128; //@audit-info this one and only can be replaced with =  54:         } 55:         if (x >= 0x10000000000000000) { 56:             x >>= 64; 57:             msb += 64; 58:         } 59:         if (x >= 0x100000000) { 60:             x >>= 32; 61:             msb += 32; 62:         } 63:         if (x >= 0x10000) { 64:             x >>= 16; 65:             msb += 16; 66:         } 67:         if (x >= 0x100) { 68:             x >>= 8; 69:             msb += 8; 70:         } 71:         if (x >= 0x10) { 72:             x >>= 4; 73:             msb += 4; 74:         } 75:         if (x >= 0x4) { 76:             x >>= 2; 77:             msb += 2; 78:         } 79:         if (x >= 0x2) msb += 1; // No need to shift xc anymore 80:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps On line 53, and only there, it is absolutely certain that `+=` can be replaced with `=`, which would look like this: ``` 53:             msb = 128; ```  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept `store` is a variable used only once. A comment should suffice instead of a variable (see @audit-info): ``` File: BalanceHandler.sol 72:         mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage(); //@audit-info store is used only once, below 73:         BalanceStorage storage balanceStorage = store[account][currencyId]; ``` ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable. Inline it instead: ``` BalanceStorage storage balanceStorage = LibStorage.getBalanceStorage()[account][currencyId]; ```    
# Handle  sirhashalot   # Vulnerability details  ## Impact  The sNOTE.sol `_beforeTokenTransfer()` function overrides the ERC20 `_beforeTokenTransfer()` function, but also calls `super._beforeTokenTransfer()`. This call to the parent function is unnecessary because no actions are performed, so it can be removed to save gas. This function call is probably placed here for consistency with the `_afterTokenTransfer()` function, but it is unnecessary with the current code (unlike the call in the `_afterTokenTransfer()` function)  ## Proof of Concept  [Line 374 of sNOTE.sol](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L374) calls super._beforeTokenTransfer(), which does not need to be called because it performs no actions.  ## Recommended Mitigation Steps  Remove line 374 from sNOTE.sol to remove the `super._beforeTokenTransfer()` call   
# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b)  ## Proof of Concept  There are multiple examples of this gas optimization opportunity, including but not limited to: - TreasuryAction.sol [line 41](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryAction.sol#L41)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, the code could be modified to use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  
# Handle  GeekyLumberjack   # Vulnerability details  ## Impact There is a fairly decent chance that setReserveCashBalance will mistakenly be set too low. Unlike the case for addresses, the number required is more likely to be manually typed. This will lead to higher chance of a mistype causing unusable reserves. With some functions risks like these are unavoidable. However, in this case, the actions are already performed with a trusted party.  ## Proof of Concept 1. call [setReserveCashBalance()](https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L80-L91) with the newBalance parameter set to 1. 2. call setReserveCashBalance() with newBalance parameter set to 100. 3. balanceStorage.cashBalance will still be set to 1. Step 2 would have reverted due to `require(newBalance < reserveBalance, "cannot increase reserve balance");`  ## Tools Used Manual Analysis  ## Recommended Mitigation Step Consider removing `require(newBalance < reserveBalance, "cannot increase reserve balance");`  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L88   
# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode) `owner` costs 100 gas (SLOAD opcode) The `onlyOwner` modifier already checks that `msg.sender == owner`.  ## Proof of Concept Instances include: ``` contracts\sNOTE.sol:118:            payable(owner), // Owner will receive the NOTE and WETH contracts\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`  
# Handle  Dravee   # Vulnerability details  ## Impact   Checking non-zero transfer values can avoid an external call to save gas.      ## Proof of Concept   Instances missing a non-zero check on amount transfered:   ```   contracts\sNOTE.sol:142:        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount); contracts\sNOTE.sol:150:        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount); contracts\sNOTE.sol:178:        WETH.safeTransferFrom(msg.sender, address(this), wethAmount); contracts\sNOTE.sol:251:        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem); contracts\TreasuryAction.sol:113:        COMP.safeTransfer(treasuryManagerContract, amountClaimed); contracts\TreasuryAction.sol:140:        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); contracts\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Check if transfer amount > 0.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  `sNOTE.redeem` burns an amount of sNOTE other than `sNOTEAmount`, potentially giving a better rate to redeemers than it should.  ## Proof of Concept  Following the process of burning sNOTE for BPT:  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L238-L252  1. We pass an amount of sNOTE to burn which is converted into BPT. (L248)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315-L323  2. We calculate the what fraction of the total amount of BPT this user is entitled to this amount of BPT represents and then multiply that by their balance of sNOTE (L320)  Rather than burning `sNOTEAmount` we then end up burning   ``` realSNOTEAmount = balanceOf(account) * getPoolTokenShare(sNOTEAmount) / getPoolTokenShare(balanceOf(account)) ```  This looks to round down such that we end up burning less sNOTE than expected. We're then going to be giving the user a slightly better rate of BPT for sNOTE than we should whereas any rounding should be in favour of the sNOTE contract.  In any case, we're performing many reads from storage (including from other contracts) in order to calculate a value which was originally passed by the user so using `sNOTEAmount` directly would be a gas optimisation.  ## Recommended Mitigation Steps  Change `_burn` to take an amount of sNOTE to burn as an argument rather than an amount of BPT which is equivalent to the amount of sNOTE to be burnt. `sNOTEAmount` can then be passed from the `redeem` function directly. `bptToRedeem` will still be rounded down so sNOTE will always have favourable rounding.  
# Handle  ShippooorDAO   # Vulnerability details  ## Impact Cooldown and redeem windows can be rendered useless.  ## Proof of Concept - Given an account that has not staked sNOTE. - Account calls sNOTE.startCooldown - Account waits for the duration of the cooldown period. Redeem period starts. - Account can then deposit and redeem as they wish, making the cooldown useless. - Multiple accounts could be used to "hop" between redeem windows by transfering between them, making the redeem window effictively useless.  Could be used for voting power attacks using flash loan if voting process is not monitored  https://www.coindesk.com/tech/2020/10/29/flash-loans-have-made-their-way-to-manipulating-protocol-elections/  ## Tools Used - Eyes - Brain - VS Code  ## Recommended Mitigation Steps A few ways to mitigate this problem: Option A: Remove the cooldown/redeem period as it's not really preventing much in current state. Option B: Let the contract start the cooldown on mint, and bind the cooldown/redeem window to the amount that was minted at that time by the account. Don't make sNOTE.startCooldown() available externally. Redeem should verify amount of token available using this new logic.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  TreasuryManager has a `_investWETHToBuyNOTE` function which deposits WETH stored on the contract into the NOTE-WETH Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L168-L211  Note there's a bit of a disconnect between the function name and what it's actually doing. You could argue that you're buying NOTE as you'll end up with an 80% note position but I think it's  more helpful for the purposes of this function to think of it as a "trade" of WETH for BPT.  The current function is as so: ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  queries[0].variable = IPriceOracle.Variable.PAIR_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 noteOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) );  uint256 noteSpotPrice = _getNOTESpotPrice();  // Calculate the max spot price based on the purchase limit uint256 maxPrice = noteOraclePrice +     (noteOraclePrice * notePurchaseLimit) /     NOTE_PURCHASE_LIMIT_PRECISION; ```  In this function we query the recent price average between NOTE and ETH, perform an unconditional join and then check that the spot price of NOTE in terms of ETH is below some maximum value to ensure that the pool's balances haven't been manipulated such that ETH is being undervalued.  This seems like a fairly roundabout method to set a slippage limit on a join which would be simpler if we queried the exchange rate between BPT and WETH. That allows us to specify a minimum amount of BPT we'd accept.  We'd then avoid using the function `_getNOTESpotPrice` entirely and could save the costs of querying the pool's balances again.  ## Recommended Mitigation Steps  Consider changing to something along the lines of  ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  // Note we're querying the BPT price rather than the pair price now queries[0].variable = IPriceOracle.Variable.BPT_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 bptOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  uint256 minBptOut = (bptOraclePrice * notePurchaseLimit) /  NOTE_PURCHASE_LIMIT_PRECISION;  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             minBptOut         ),         false // Don't use internal balances     ) ); ```  We're directly enforcing a slippage limit on the WETH -> BPT conversion rather than doing it in a roundabout way so it's easier to reason about. We save having to query the pool's balances again so save gas and also in the case where the slippage limit is triggered it'll be hit earlier, again saving gas.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra boilerplate code (including the whole of the _afterTokenTransfer function)  ## Proof of Concept  sNOTE inherits from both ERC20Upgradeable and ERC20VotesUpgradeable.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L15  This causes us to have to add explicit helpers for how to handle the inheritance tree to a bunch of functions  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L328  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L362  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L381  If we look at OZ however, we can see that ERC20VotesUpgradeable inherits from ERC20PermitUpgradeable which in turn inherits from ERC20Upgradeable   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L28  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol#L23  There's then no real reason for sNOTE to inherit from ERC20Upgradeable directly. Removing this inheritance should allow you to remove a bunch of the explicit overrides you have.  ## Recommended Mitigation Steps  Remove direct inheritance of ERC20Upgradeable and remove all the `override(ERC20Upgradeable, ERC20VotesUpgradeable)` stuff. You should be able to just delete `_afterTokenTransfer` in its entirety.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs. ## Proof of Concept  In a number of places we create an array and then fill every element with zero. There's no need to do this as a newly declared array will have zero-valued elements by default. We can then avoid the costs of writing a new zero to them.  For example we could remove these three lines entirely: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L111-L113  We can then just pass an empty array in the lines below as so. ``` BALANCER_VAULT.exitPool(   NOTE_ETH_POOL_ID,   address(this),   payable(owner), // Owner will receive the NOTE and WETH   IVault.ExitPoolRequest(       assets,       new uint256[](2), // inlined here       abi.encode(           IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,           bptExitAmount       ),       false // Don't use internal balances   ) ); ```  This also crops up elsewhere: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L156 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L169 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L185  ## Tools Used  ## Recommended Mitigation Steps  Omit lines writing zeros to an empty array.  
# Handle  Jujic   # Vulnerability details  ## Impact The require statement can be placed earlier (`before get coolDown`) to reduce gas usage.   ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L240 ``` function redeem(uint256 sNOTEAmount) external nonReentrant {         AccountCoolDown memory coolDown = accountCoolDown[msg.sender];         require(sNOTEAmount <= balanceOf(msg.sender), "Insufficient balance");         require(             coolDown.redeemWindowBegin != 0 &&             coolDown.redeemWindowBegin < block.timestamp &&             block.timestamp < coolDown.redeemWindowEnd,             "Not in Redemption Window"         );          uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);         _burn(msg.sender, bptToRedeem);          BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);     } ``` ## Tools Used Remix ## Recommended Mitigation Steps Relocate the require statement upper.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Increases gas costs due to manipulating redeemWindowEnd and usage of structs for `AccountCooldown`  ## Proof of Concept  `redeemWindowEnd` will always equal `redeemWindowBegin + REDEEM_WINDOW_SECONDS` so it can just be calculated when needed (excluding the situation where both of these are zero which is already handled in the code.)  We then don't need to store both of these values in storage and deal with the overhead of using structs.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L244  We can then just replace this line with   ``` block.timestamp < coolDown.redeemWindowBegin + REDEEM_WINDOW_SECONDS ```  ## Recommended Mitigation Steps  Remove `coolDown.redeemWindowEnd` and store cooldowns as a simple uint rather than a struct.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  ## Proof of Concept  This comment should refer to WETH not NOTE  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L177  ## Recommended Mitigation Steps  Change to refer to WETH  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Greater flexibility for users and better conversion between a mix of ETH/NOTE and sNOTE.  ## Proof of Concept  `sNOTE` allows users to provider either NOTE, ETH or WETH to provide liquidity in return for BPT to mint sNOTE with through the functions `mintFromNOTE`, `mintFromETH` and `mintFromWETH`.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L146-L188  Balancer allows users to deposit multiple assets at once so the same functionality while being more flexible (by allowing deposits in both NOTE and ETH at the same time) and giving users better execution (A user depositing NOTE and ETH together gets more SNOTE than one who deposits NOTE and then ETH afterwards)  Consider the code snippet:  ``` /// @notice Mints sNOTE from some amount of NOTE and ETH /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromETH(uint256 noteAmount) payable external nonReentrant {     IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(0));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = msg.value;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); }  /// @notice Mints sNOTE from some amount of NOTE and WETH /// @param wethAmount amount of WETH to transfer into the sNOTE contract /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromWETH(uint256 wethAmount, uint256 noteAmount) external nonReentrant {     // Transfer the WETH and NOTE balance into sNOTE first     WETH.safeTransferFrom(msg.sender, address(this), wethAmount);     NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);      IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(WETH));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = wethAmount;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); } ```  ## Recommended Mitigation Steps  Replace current functions with above versions  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs ## Proof of Concept  Here we check that `_noteETHPoolId` corresponds to a registered Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L59  `_balancerVault.getPool(_noteETHPoolId)` will revert if _noteETHPoolId is not a registered poolId  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L93  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L56  The require statement on the next line is impossible to fail unless we somehow manage to deploy a balancer pool to the zero address (which would be impressive)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L60  We can then safely remove this statement without any change in behaviour.  ## Recommended Mitigation Steps  Remove require statement.  
# Handle  0x1f8b   # Vulnerability details  ## Impact `_getToken` return empty values instead of revert.  ## Proof of Concept The library `TokenHandler` has the `_getToken` method and this method returns an empty struct instead of revert if the currencyId was not found, this can produce in unexpected errors.  ## Tools Used Manual review.  ## Recommended Mitigation Steps revert if it was not found.  
# Handle  leastwood   # Vulnerability details  ## Impact  The treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.  However, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), "no fee recipient allowed");      // MakerToken should never be WETH     require(makerToken != address(WETH), "maker token must not be WETH");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), "taker token must be WETH");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), "price oracle not defined");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, "slippage limit not defined");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, "slippage is too high"); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.  
# Handle  IllIllI   # Vulnerability details  ## Impact When the value of the post-loop increment/decrement is not stored or used in any calculations, the prefix increment/decrement operators (`++i`/`--i`) cost less gas PER LOOP than the postfix increment/decrement operators (`i++`/`i--`)  ## Proof of Concept There is one example of this issue in the codebase:  ```Solidity for (uint256 i; i < currencies.length; i++) {         ``` https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L157   ## Tools Used Code inspection  ## Recommended Mitigation Steps Use `++i` rather than `i++` in all places  
# Handle  leastwood   # Vulnerability details  ## Impact  The `getVotingPower` function is an essential part of Notional's on-chain governance. However, the `priceRatio` calculation includes a division which slightly truncates the result which is then used in calculating `noteAmount` which also divides the result.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider performing all multiplication before division to minimise the degree of truncation by the final result.  
# Handle  Tomio   # Vulnerability details  ## Impact The check to make sure account is not in cool down is happening twice, on _mint() and _beforeTokenTransfer(), _beforeTokenTransfer() already has a _requireAccountNotInCoolDown() an the _mint() inside erc20upgradable will call the _beforeTokenTransfer(), this can make unnecessary call in the https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Tools Used  ## Recommended Mitigation Steps  
# Handle  Tomio   # Vulnerability details  ## Impact There is unnecessary if else condition on _redeemAndTransfer(), and can be optimized by removing the inline if else condition on line https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Tools Used  ## Recommended Mitigation Steps From: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();         }          address underlyingAddress = underlying.tokenAddress == address(0)             ? address(WETH)             : underlying.tokenAddress;         IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); ```  To: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();             IERC20(WETH).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         }else{             IERC20(underlying.tokenAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         } ```  
# Handle  gellej   # Vulnerability details  ## Impact   The function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.   Presumably, this 50% limit is in place to prevent the owner from "rug-pulling" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).   However, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.   As the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)  # Proof of Concept  See above. The code affected is here: https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100    ## Recommended Mitigation Steps  Rewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% _per week_ (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)  
# Handle  pauliax   # Vulnerability details  ## Impact Unused state variables: ```solidity     uint256 public constant BPT_TOKEN_PRECISION = 1e18;     uint256 internal constant ETH_PRECISION = 1e18;     uint32 public refundGasPrice; ``` Either remove them or use them where intended.  
# Handle  cmichel   # Vulnerability details  The `reserveInternal.subNoNeg(bufferInternal)` computation in `TreasuryAction.transferReserveToTreasury` can be a standard, unchecked subtraction as `if (reserveInternal <= bufferInternal) continue;` is checked before this computation.   
# Handle  cmichel   # Vulnerability details  The `EIP1271Wallet._validateOrder` function computes a `makerPrice` which ends up in `takerAmount` decimals which are 18 decimals as `takerToken` is always `WETH`. It is compared to the `priceFloor` return value from chainlink which must therefore also be in 18 decimals. This seems to be the case for this old deprecated API but should be fixed and adjusted to use the oracle decimals if Chainlink is upgraded to the new API.  ## Recommended Mitigation Steps Upgrade and adjust the decimals of `makerPrice` to match `priceFloor` decimals.   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `TreasuryManager.setPriceOracle: oracleAddress`: could break things - `TreasuryManager.setSlippageLimit: slippageLimit`: should be `<= SLIPPAGE_LIMIT_PRECISION`  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  WatchPug   # Vulnerability details  ttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209  ```solidity BALANCER_VAULT.joinPool{value: msgValue}(     NOTE_ETH_POOL_ID,     address(this),     address(this), // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) ); ```  The current implementation of `mintFromNOTE()` and `mintFromETH()` and `mintFromWETH()` (all are using `_mintFromAssets()` with `minimumBPT` hardcoded to `0`) provides no parameter for slippage control, making it vulnerable to front-run attacks.  ### Recommendation  Consider adding a `minAmountOut` parameter for these functions.  
# Handle  SolidityScan   # Vulnerability details  ## Description The value of `totalSupply()` at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L260 does not check if the value of totalSupply is 0 or not and it is per   ## Impact The return value for the function `getPoolTokenShare` can be invalid because if there's an error in the `totalSupply()` the code at Line 260 will evaluate to divide by zero creating inconsistencies in the function logic.   ## Proof of Concept 1. Check the function at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L257-L261 2. At line 260 we will notice that the value of totalSupply() is directly being used to perform division to the multiplication of `bptBalance * sNOTEAmount`   ## Recommended Mitigation Steps Add a check if the value of `totalSupply()` is zero or not or some other edge cases that can cause inconsistencies.   
# Handle  leastwood   # Vulnerability details  ## Impact  As `NOTE` continues to be staked in the `sNOTE` contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power `sNOTE` has in terms of its equivalent `NOTE` amount.   `getVotingPower` is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their `sNOTE` to another account to then vote again.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a `getPriorVotingPower` function which takes in a `blockNumber` argument and returns the correct balance at that specific block.  
# Handle  gzeon   # Vulnerability details  ## Impact In `_requireAccountNotInCoolDown` if `block.timestamp < coolDown.redeemWindowEnd`, we must have `coolDown.redeemWindowEnd > 0` hence `0 < coolDown.redeemWindowBegin`  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L308 ```         bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);         require(!isInCoolDown, "Account in Cool Down"); ``` to  ```         require(block.timestamp >= coolDown.redeemWindowEnd, "Account in Cool Down"); ```  
# Handle  leastwood   # Vulnerability details  ## Impact  The `EIP1271Wallet` contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the `TreasuryManager` contract, which holds harvested assets/`COMP` from Notional. While the `EIP1271Wallet._validateOrder` function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the `takerAddress` and `senderAddress` are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in `makerPrice`, the manager is able to extract value from the treasury by maximising the allowed slippage.  By setting `takerAddress` to the zero address, any user can be the taker of an off-chain order. By setting `senderAddress` to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66 ``` address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order. ```  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374   https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), "no fee recipient allowed");      // MakerToken should never be WETH     require(makerToken != address(WETH), "maker token must not be WETH");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), "taker token must be WETH");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), "price oracle not defined");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, "slippage limit not defined");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, "slippage is too high"); } ```  ## Tools Used  Manual code review. Discussions with Notional team.  ## Recommended Mitigation Steps  Consider adding `require(takerAddress == address(0), "manager cannot set taker");` and `require(senderAddress == address(0), "manager cannot set sender");` statements to `_validateOrder`. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.  
# Handle  hyh   # Vulnerability details    ## Impact  No events in TreasuryManager and sNOTE contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  TreasuryManager events don't have indices:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryManager.sol#L38-41  sNOTE events also aren't indexed:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L43-50  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all owner and account addresses   
# Handle  Dravee   # Vulnerability details  Here's the only `_investWETHToBuyNOTE()` call: ``` File: TreasuryManager.sol 140:     function investWETHToBuyNOTE(uint256 wethAmount) external onlyManager { 141:         _investWETHToBuyNOTE(wethAmount); 142:     } ```  While I can understand why some functions have the same style, these other functions are as such because they are calling an inherited function, as an example for `setSlippageLimit()`, which really is calling an inherited function from `EIP1271Wallet.sol`: ``` File: TreasuryManager.sol 89:     function setSlippageLimit(address tokenAddress, uint256 slippageLimit) 90:         external 91:         onlyOwner 92:     { 93:         _setSlippageLimit(tokenAddress, slippageLimit); 94:     } ```  However, for `_investWETHToBuyNOTE()`, this style doesn't hold.   ## Recommended Mitigation Steps All the logic from `_investWETHToBuyNOTE()` should be inlined in `investWETHToBuyNOTE()` to save gas.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary arithmetic operation  ## Proof of Concept See the @audit-info tag: ``` File: Bitmap.sol 46:     function getMSB(uint256 x) internal pure returns (uint256 msb) { 47:         // If x == 0 then there is no MSB and this method will return zero. That would 48:         // be the same as the return value when x == 1 (MSB is zero indexed), so instead 49:         // we have this require here to ensure that the values don't get mixed up. 50:         require(x != 0); // dev: get msb zero value 51:         if (x >= 0x100000000000000000000000000000000) { 52:             x >>= 128; 53:             msb += 128; //@audit-info this one and only can be replaced with =  54:         } 55:         if (x >= 0x10000000000000000) { 56:             x >>= 64; 57:             msb += 64; 58:         } 59:         if (x >= 0x100000000) { 60:             x >>= 32; 61:             msb += 32; 62:         } 63:         if (x >= 0x10000) { 64:             x >>= 16; 65:             msb += 16; 66:         } 67:         if (x >= 0x100) { 68:             x >>= 8; 69:             msb += 8; 70:         } 71:         if (x >= 0x10) { 72:             x >>= 4; 73:             msb += 4; 74:         } 75:         if (x >= 0x4) { 76:             x >>= 2; 77:             msb += 2; 78:         } 79:         if (x >= 0x2) msb += 1; // No need to shift xc anymore 80:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps On line 53, and only there, it is absolutely certain that `+=` can be replaced with `=`, which would look like this: ``` 53:             msb = 128; ```  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept `store` is a variable used only once. A comment should suffice instead of a variable (see @audit-info): ``` File: BalanceHandler.sol 72:         mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage(); //@audit-info store is used only once, below 73:         BalanceStorage storage balanceStorage = store[account][currencyId]; ``` ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable. Inline it instead: ``` BalanceStorage storage balanceStorage = LibStorage.getBalanceStorage()[account][currencyId]; ```    
# Handle  sirhashalot   # Vulnerability details  ## Impact  The sNOTE.sol `_beforeTokenTransfer()` function overrides the ERC20 `_beforeTokenTransfer()` function, but also calls `super._beforeTokenTransfer()`. This call to the parent function is unnecessary because no actions are performed, so it can be removed to save gas. This function call is probably placed here for consistency with the `_afterTokenTransfer()` function, but it is unnecessary with the current code (unlike the call in the `_afterTokenTransfer()` function)  ## Proof of Concept  [Line 374 of sNOTE.sol](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L374) calls super._beforeTokenTransfer(), which does not need to be called because it performs no actions.  ## Recommended Mitigation Steps  Remove line 374 from sNOTE.sol to remove the `super._beforeTokenTransfer()` call   
# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b)  ## Proof of Concept  There are multiple examples of this gas optimization opportunity, including but not limited to: - TreasuryAction.sol [line 41](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryAction.sol#L41)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, the code could be modified to use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  
# Handle  GeekyLumberjack   # Vulnerability details  ## Impact There is a fairly decent chance that setReserveCashBalance will mistakenly be set too low. Unlike the case for addresses, the number required is more likely to be manually typed. This will lead to higher chance of a mistype causing unusable reserves. With some functions risks like these are unavoidable. However, in this case, the actions are already performed with a trusted party.  ## Proof of Concept 1. call [setReserveCashBalance()](https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L80-L91) with the newBalance parameter set to 1. 2. call setReserveCashBalance() with newBalance parameter set to 100. 3. balanceStorage.cashBalance will still be set to 1. Step 2 would have reverted due to `require(newBalance < reserveBalance, "cannot increase reserve balance");`  ## Tools Used Manual Analysis  ## Recommended Mitigation Step Consider removing `require(newBalance < reserveBalance, "cannot increase reserve balance");`  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L88   
# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode) `owner` costs 100 gas (SLOAD opcode) The `onlyOwner` modifier already checks that `msg.sender == owner`.  ## Proof of Concept Instances include: ``` contracts\sNOTE.sol:118:            payable(owner), // Owner will receive the NOTE and WETH contracts\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`  
# Handle  Dravee   # Vulnerability details  ## Impact   Checking non-zero transfer values can avoid an external call to save gas.      ## Proof of Concept   Instances missing a non-zero check on amount transfered:   ```   contracts\sNOTE.sol:142:        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount); contracts\sNOTE.sol:150:        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount); contracts\sNOTE.sol:178:        WETH.safeTransferFrom(msg.sender, address(this), wethAmount); contracts\sNOTE.sol:251:        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem); contracts\TreasuryAction.sol:113:        COMP.safeTransfer(treasuryManagerContract, amountClaimed); contracts\TreasuryAction.sol:140:        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); contracts\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Check if transfer amount > 0.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  `sNOTE.redeem` burns an amount of sNOTE other than `sNOTEAmount`, potentially giving a better rate to redeemers than it should.  ## Proof of Concept  Following the process of burning sNOTE for BPT:  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L238-L252  1. We pass an amount of sNOTE to burn which is converted into BPT. (L248)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315-L323  2. We calculate the what fraction of the total amount of BPT this user is entitled to this amount of BPT represents and then multiply that by their balance of sNOTE (L320)  Rather than burning `sNOTEAmount` we then end up burning   ``` realSNOTEAmount = balanceOf(account) * getPoolTokenShare(sNOTEAmount) / getPoolTokenShare(balanceOf(account)) ```  This looks to round down such that we end up burning less sNOTE than expected. We're then going to be giving the user a slightly better rate of BPT for sNOTE than we should whereas any rounding should be in favour of the sNOTE contract.  In any case, we're performing many reads from storage (including from other contracts) in order to calculate a value which was originally passed by the user so using `sNOTEAmount` directly would be a gas optimisation.  ## Recommended Mitigation Steps  Change `_burn` to take an amount of sNOTE to burn as an argument rather than an amount of BPT which is equivalent to the amount of sNOTE to be burnt. `sNOTEAmount` can then be passed from the `redeem` function directly. `bptToRedeem` will still be rounded down so sNOTE will always have favourable rounding.  
# Handle  ShippooorDAO   # Vulnerability details  ## Impact Cooldown and redeem windows can be rendered useless.  ## Proof of Concept - Given an account that has not staked sNOTE. - Account calls sNOTE.startCooldown - Account waits for the duration of the cooldown period. Redeem period starts. - Account can then deposit and redeem as they wish, making the cooldown useless. - Multiple accounts could be used to "hop" between redeem windows by transfering between them, making the redeem window effictively useless.  Could be used for voting power attacks using flash loan if voting process is not monitored  https://www.coindesk.com/tech/2020/10/29/flash-loans-have-made-their-way-to-manipulating-protocol-elections/  ## Tools Used - Eyes - Brain - VS Code  ## Recommended Mitigation Steps A few ways to mitigate this problem: Option A: Remove the cooldown/redeem period as it's not really preventing much in current state. Option B: Let the contract start the cooldown on mint, and bind the cooldown/redeem window to the amount that was minted at that time by the account. Don't make sNOTE.startCooldown() available externally. Redeem should verify amount of token available using this new logic.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  TreasuryManager has a `_investWETHToBuyNOTE` function which deposits WETH stored on the contract into the NOTE-WETH Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L168-L211  Note there's a bit of a disconnect between the function name and what it's actually doing. You could argue that you're buying NOTE as you'll end up with an 80% note position but I think it's  more helpful for the purposes of this function to think of it as a "trade" of WETH for BPT.  The current function is as so: ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  queries[0].variable = IPriceOracle.Variable.PAIR_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 noteOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) );  uint256 noteSpotPrice = _getNOTESpotPrice();  // Calculate the max spot price based on the purchase limit uint256 maxPrice = noteOraclePrice +     (noteOraclePrice * notePurchaseLimit) /     NOTE_PURCHASE_LIMIT_PRECISION; ```  In this function we query the recent price average between NOTE and ETH, perform an unconditional join and then check that the spot price of NOTE in terms of ETH is below some maximum value to ensure that the pool's balances haven't been manipulated such that ETH is being undervalued.  This seems like a fairly roundabout method to set a slippage limit on a join which would be simpler if we queried the exchange rate between BPT and WETH. That allows us to specify a minimum amount of BPT we'd accept.  We'd then avoid using the function `_getNOTESpotPrice` entirely and could save the costs of querying the pool's balances again.  ## Recommended Mitigation Steps  Consider changing to something along the lines of  ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  // Note we're querying the BPT price rather than the pair price now queries[0].variable = IPriceOracle.Variable.BPT_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 bptOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  uint256 minBptOut = (bptOraclePrice * notePurchaseLimit) /  NOTE_PURCHASE_LIMIT_PRECISION;  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             minBptOut         ),         false // Don't use internal balances     ) ); ```  We're directly enforcing a slippage limit on the WETH -> BPT conversion rather than doing it in a roundabout way so it's easier to reason about. We save having to query the pool's balances again so save gas and also in the case where the slippage limit is triggered it'll be hit earlier, again saving gas.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra boilerplate code (including the whole of the _afterTokenTransfer function)  ## Proof of Concept  sNOTE inherits from both ERC20Upgradeable and ERC20VotesUpgradeable.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L15  This causes us to have to add explicit helpers for how to handle the inheritance tree to a bunch of functions  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L328  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L362  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L381  If we look at OZ however, we can see that ERC20VotesUpgradeable inherits from ERC20PermitUpgradeable which in turn inherits from ERC20Upgradeable   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L28  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol#L23  There's then no real reason for sNOTE to inherit from ERC20Upgradeable directly. Removing this inheritance should allow you to remove a bunch of the explicit overrides you have.  ## Recommended Mitigation Steps  Remove direct inheritance of ERC20Upgradeable and remove all the `override(ERC20Upgradeable, ERC20VotesUpgradeable)` stuff. You should be able to just delete `_afterTokenTransfer` in its entirety.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs. ## Proof of Concept  In a number of places we create an array and then fill every element with zero. There's no need to do this as a newly declared array will have zero-valued elements by default. We can then avoid the costs of writing a new zero to them.  For example we could remove these three lines entirely: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L111-L113  We can then just pass an empty array in the lines below as so. ``` BALANCER_VAULT.exitPool(   NOTE_ETH_POOL_ID,   address(this),   payable(owner), // Owner will receive the NOTE and WETH   IVault.ExitPoolRequest(       assets,       new uint256[](2), // inlined here       abi.encode(           IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,           bptExitAmount       ),       false // Don't use internal balances   ) ); ```  This also crops up elsewhere: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L156 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L169 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L185  ## Tools Used  ## Recommended Mitigation Steps  Omit lines writing zeros to an empty array.  
# Handle  Jujic   # Vulnerability details  ## Impact The require statement can be placed earlier (`before get coolDown`) to reduce gas usage.   ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L240 ``` function redeem(uint256 sNOTEAmount) external nonReentrant {         AccountCoolDown memory coolDown = accountCoolDown[msg.sender];         require(sNOTEAmount <= balanceOf(msg.sender), "Insufficient balance");         require(             coolDown.redeemWindowBegin != 0 &&             coolDown.redeemWindowBegin < block.timestamp &&             block.timestamp < coolDown.redeemWindowEnd,             "Not in Redemption Window"         );          uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);         _burn(msg.sender, bptToRedeem);          BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);     } ``` ## Tools Used Remix ## Recommended Mitigation Steps Relocate the require statement upper.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Increases gas costs due to manipulating redeemWindowEnd and usage of structs for `AccountCooldown`  ## Proof of Concept  `redeemWindowEnd` will always equal `redeemWindowBegin + REDEEM_WINDOW_SECONDS` so it can just be calculated when needed (excluding the situation where both of these are zero which is already handled in the code.)  We then don't need to store both of these values in storage and deal with the overhead of using structs.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L244  We can then just replace this line with   ``` block.timestamp < coolDown.redeemWindowBegin + REDEEM_WINDOW_SECONDS ```  ## Recommended Mitigation Steps  Remove `coolDown.redeemWindowEnd` and store cooldowns as a simple uint rather than a struct.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  ## Proof of Concept  This comment should refer to WETH not NOTE  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L177  ## Recommended Mitigation Steps  Change to refer to WETH  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Greater flexibility for users and better conversion between a mix of ETH/NOTE and sNOTE.  ## Proof of Concept  `sNOTE` allows users to provider either NOTE, ETH or WETH to provide liquidity in return for BPT to mint sNOTE with through the functions `mintFromNOTE`, `mintFromETH` and `mintFromWETH`.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L146-L188  Balancer allows users to deposit multiple assets at once so the same functionality while being more flexible (by allowing deposits in both NOTE and ETH at the same time) and giving users better execution (A user depositing NOTE and ETH together gets more SNOTE than one who deposits NOTE and then ETH afterwards)  Consider the code snippet:  ``` /// @notice Mints sNOTE from some amount of NOTE and ETH /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromETH(uint256 noteAmount) payable external nonReentrant {     IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(0));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = msg.value;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); }  /// @notice Mints sNOTE from some amount of NOTE and WETH /// @param wethAmount amount of WETH to transfer into the sNOTE contract /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromWETH(uint256 wethAmount, uint256 noteAmount) external nonReentrant {     // Transfer the WETH and NOTE balance into sNOTE first     WETH.safeTransferFrom(msg.sender, address(this), wethAmount);     NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);      IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(WETH));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = wethAmount;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); } ```  ## Recommended Mitigation Steps  Replace current functions with above versions  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs ## Proof of Concept  Here we check that `_noteETHPoolId` corresponds to a registered Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L59  `_balancerVault.getPool(_noteETHPoolId)` will revert if _noteETHPoolId is not a registered poolId  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L93  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L56  The require statement on the next line is impossible to fail unless we somehow manage to deploy a balancer pool to the zero address (which would be impressive)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L60  We can then safely remove this statement without any change in behaviour.  ## Recommended Mitigation Steps  Remove require statement.  
# Handle  0x1f8b   # Vulnerability details  ## Impact `_getToken` return empty values instead of revert.  ## Proof of Concept The library `TokenHandler` has the `_getToken` method and this method returns an empty struct instead of revert if the currencyId was not found, this can produce in unexpected errors.  ## Tools Used Manual review.  ## Recommended Mitigation Steps revert if it was not found.  
# Handle  leastwood   # Vulnerability details  ## Impact  The treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.  However, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), "no fee recipient allowed");      // MakerToken should never be WETH     require(makerToken != address(WETH), "maker token must not be WETH");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), "taker token must be WETH");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), "price oracle not defined");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, "slippage limit not defined");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, "slippage is too high"); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.  
# Handle  IllIllI   # Vulnerability details  ## Impact When the value of the post-loop increment/decrement is not stored or used in any calculations, the prefix increment/decrement operators (`++i`/`--i`) cost less gas PER LOOP than the postfix increment/decrement operators (`i++`/`i--`)  ## Proof of Concept There is one example of this issue in the codebase:  ```Solidity for (uint256 i; i < currencies.length; i++) {         ``` https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L157   ## Tools Used Code inspection  ## Recommended Mitigation Steps Use `++i` rather than `i++` in all places  
# Handle  leastwood   # Vulnerability details  ## Impact  The `getVotingPower` function is an essential part of Notional's on-chain governance. However, the `priceRatio` calculation includes a division which slightly truncates the result which is then used in calculating `noteAmount` which also divides the result.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider performing all multiplication before division to minimise the degree of truncation by the final result.  
# Handle  Tomio   # Vulnerability details  ## Impact The check to make sure account is not in cool down is happening twice, on _mint() and _beforeTokenTransfer(), _beforeTokenTransfer() already has a _requireAccountNotInCoolDown() an the _mint() inside erc20upgradable will call the _beforeTokenTransfer(), this can make unnecessary call in the https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Tools Used  ## Recommended Mitigation Steps  
# Handle  Tomio   # Vulnerability details  ## Impact There is unnecessary if else condition on _redeemAndTransfer(), and can be optimized by removing the inline if else condition on line https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Tools Used  ## Recommended Mitigation Steps From: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();         }          address underlyingAddress = underlying.tokenAddress == address(0)             ? address(WETH)             : underlying.tokenAddress;         IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); ```  To: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();             IERC20(WETH).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         }else{             IERC20(underlying.tokenAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         } ```  
# Handle  gellej   # Vulnerability details  ## Impact   The function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.   Presumably, this 50% limit is in place to prevent the owner from "rug-pulling" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).   However, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.   As the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)  # Proof of Concept  See above. The code affected is here: https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100    ## Recommended Mitigation Steps  Rewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% _per week_ (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)  
# Handle  pauliax   # Vulnerability details  ## Impact Unused state variables: ```solidity     uint256 public constant BPT_TOKEN_PRECISION = 1e18;     uint256 internal constant ETH_PRECISION = 1e18;     uint32 public refundGasPrice; ``` Either remove them or use them where intended.  
# Handle  cmichel   # Vulnerability details  The `reserveInternal.subNoNeg(bufferInternal)` computation in `TreasuryAction.transferReserveToTreasury` can be a standard, unchecked subtraction as `if (reserveInternal <= bufferInternal) continue;` is checked before this computation.   
# Handle  cmichel   # Vulnerability details  The `EIP1271Wallet._validateOrder` function computes a `makerPrice` which ends up in `takerAmount` decimals which are 18 decimals as `takerToken` is always `WETH`. It is compared to the `priceFloor` return value from chainlink which must therefore also be in 18 decimals. This seems to be the case for this old deprecated API but should be fixed and adjusted to use the oracle decimals if Chainlink is upgraded to the new API.  ## Recommended Mitigation Steps Upgrade and adjust the decimals of `makerPrice` to match `priceFloor` decimals.   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `TreasuryManager.setPriceOracle: oracleAddress`: could break things - `TreasuryManager.setSlippageLimit: slippageLimit`: should be `<= SLIPPAGE_LIMIT_PRECISION`  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  WatchPug   # Vulnerability details  ttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209  ```solidity BALANCER_VAULT.joinPool{value: msgValue}(     NOTE_ETH_POOL_ID,     address(this),     address(this), // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) ); ```  The current implementation of `mintFromNOTE()` and `mintFromETH()` and `mintFromWETH()` (all are using `_mintFromAssets()` with `minimumBPT` hardcoded to `0`) provides no parameter for slippage control, making it vulnerable to front-run attacks.  ### Recommendation  Consider adding a `minAmountOut` parameter for these functions.  
# Handle  SolidityScan   # Vulnerability details  ## Description The value of `totalSupply()` at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L260 does not check if the value of totalSupply is 0 or not and it is per   ## Impact The return value for the function `getPoolTokenShare` can be invalid because if there's an error in the `totalSupply()` the code at Line 260 will evaluate to divide by zero creating inconsistencies in the function logic.   ## Proof of Concept 1. Check the function at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L257-L261 2. At line 260 we will notice that the value of totalSupply() is directly being used to perform division to the multiplication of `bptBalance * sNOTEAmount`   ## Recommended Mitigation Steps Add a check if the value of `totalSupply()` is zero or not or some other edge cases that can cause inconsistencies.   
# Handle  leastwood   # Vulnerability details  ## Impact  As `NOTE` continues to be staked in the `sNOTE` contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power `sNOTE` has in terms of its equivalent `NOTE` amount.   `getVotingPower` is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their `sNOTE` to another account to then vote again.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a `getPriorVotingPower` function which takes in a `blockNumber` argument and returns the correct balance at that specific block.  
# Handle  gzeon   # Vulnerability details  ## Impact In `_requireAccountNotInCoolDown` if `block.timestamp < coolDown.redeemWindowEnd`, we must have `coolDown.redeemWindowEnd > 0` hence `0 < coolDown.redeemWindowBegin`  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L308 ```         bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);         require(!isInCoolDown, "Account in Cool Down"); ``` to  ```         require(block.timestamp >= coolDown.redeemWindowEnd, "Account in Cool Down"); ```  
# Handle  leastwood   # Vulnerability details  ## Impact  The `EIP1271Wallet` contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the `TreasuryManager` contract, which holds harvested assets/`COMP` from Notional. While the `EIP1271Wallet._validateOrder` function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the `takerAddress` and `senderAddress` are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in `makerPrice`, the manager is able to extract value from the treasury by maximising the allowed slippage.  By setting `takerAddress` to the zero address, any user can be the taker of an off-chain order. By setting `senderAddress` to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66 ``` address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order. ```  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374   https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), "no fee recipient allowed");      // MakerToken should never be WETH     require(makerToken != address(WETH), "maker token must not be WETH");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), "taker token must be WETH");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), "price oracle not defined");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, "slippage limit not defined");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, "slippage is too high"); } ```  ## Tools Used  Manual code review. Discussions with Notional team.  ## Recommended Mitigation Steps  Consider adding `require(takerAddress == address(0), "manager cannot set taker");` and `require(senderAddress == address(0), "manager cannot set sender");` statements to `_validateOrder`. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.  
# Handle  hyh   # Vulnerability details    ## Impact  No events in TreasuryManager and sNOTE contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  TreasuryManager events don't have indices:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryManager.sol#L38-41  sNOTE events also aren't indexed:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L43-50  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all owner and account addresses   
# Handle  Dravee   # Vulnerability details  Here's the only `_investWETHToBuyNOTE()` call: ``` File: TreasuryManager.sol 140:     function investWETHToBuyNOTE(uint256 wethAmount) external onlyManager { 141:         _investWETHToBuyNOTE(wethAmount); 142:     } ```  While I can understand why some functions have the same style, these other functions are as such because they are calling an inherited function, as an example for `setSlippageLimit()`, which really is calling an inherited function from `EIP1271Wallet.sol`: ``` File: TreasuryManager.sol 89:     function setSlippageLimit(address tokenAddress, uint256 slippageLimit) 90:         external 91:         onlyOwner 92:     { 93:         _setSlippageLimit(tokenAddress, slippageLimit); 94:     } ```  However, for `_investWETHToBuyNOTE()`, this style doesn't hold.   ## Recommended Mitigation Steps All the logic from `_investWETHToBuyNOTE()` should be inlined in `investWETHToBuyNOTE()` to save gas.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary arithmetic operation  ## Proof of Concept See the @audit-info tag: ``` File: Bitmap.sol 46:     function getMSB(uint256 x) internal pure returns (uint256 msb) { 47:         // If x == 0 then there is no MSB and this method will return zero. That would 48:         // be the same as the return value when x == 1 (MSB is zero indexed), so instead 49:         // we have this require here to ensure that the values don't get mixed up. 50:         require(x != 0); // dev: get msb zero value 51:         if (x >= 0x100000000000000000000000000000000) { 52:             x >>= 128; 53:             msb += 128; //@audit-info this one and only can be replaced with =  54:         } 55:         if (x >= 0x10000000000000000) { 56:             x >>= 64; 57:             msb += 64; 58:         } 59:         if (x >= 0x100000000) { 60:             x >>= 32; 61:             msb += 32; 62:         } 63:         if (x >= 0x10000) { 64:             x >>= 16; 65:             msb += 16; 66:         } 67:         if (x >= 0x100) { 68:             x >>= 8; 69:             msb += 8; 70:         } 71:         if (x >= 0x10) { 72:             x >>= 4; 73:             msb += 4; 74:         } 75:         if (x >= 0x4) { 76:             x >>= 2; 77:             msb += 2; 78:         } 79:         if (x >= 0x2) msb += 1; // No need to shift xc anymore 80:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps On line 53, and only there, it is absolutely certain that `+=` can be replaced with `=`, which would look like this: ``` 53:             msb = 128; ```  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept `store` is a variable used only once. A comment should suffice instead of a variable (see @audit-info): ``` File: BalanceHandler.sol 72:         mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage(); //@audit-info store is used only once, below 73:         BalanceStorage storage balanceStorage = store[account][currencyId]; ``` ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable. Inline it instead: ``` BalanceStorage storage balanceStorage = LibStorage.getBalanceStorage()[account][currencyId]; ```    
# Handle  sirhashalot   # Vulnerability details  ## Impact  The sNOTE.sol `_beforeTokenTransfer()` function overrides the ERC20 `_beforeTokenTransfer()` function, but also calls `super._beforeTokenTransfer()`. This call to the parent function is unnecessary because no actions are performed, so it can be removed to save gas. This function call is probably placed here for consistency with the `_afterTokenTransfer()` function, but it is unnecessary with the current code (unlike the call in the `_afterTokenTransfer()` function)  ## Proof of Concept  [Line 374 of sNOTE.sol](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L374) calls super._beforeTokenTransfer(), which does not need to be called because it performs no actions.  ## Recommended Mitigation Steps  Remove line 374 from sNOTE.sol to remove the `super._beforeTokenTransfer()` call   
# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b)  ## Proof of Concept  There are multiple examples of this gas optimization opportunity, including but not limited to: - TreasuryAction.sol [line 41](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryAction.sol#L41)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, the code could be modified to use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  
# Handle  GeekyLumberjack   # Vulnerability details  ## Impact There is a fairly decent chance that setReserveCashBalance will mistakenly be set too low. Unlike the case for addresses, the number required is more likely to be manually typed. This will lead to higher chance of a mistype causing unusable reserves. With some functions risks like these are unavoidable. However, in this case, the actions are already performed with a trusted party.  ## Proof of Concept 1. call [setReserveCashBalance()](https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L80-L91) with the newBalance parameter set to 1. 2. call setReserveCashBalance() with newBalance parameter set to 100. 3. balanceStorage.cashBalance will still be set to 1. Step 2 would have reverted due to `require(newBalance < reserveBalance, "cannot increase reserve balance");`  ## Tools Used Manual Analysis  ## Recommended Mitigation Step Consider removing `require(newBalance < reserveBalance, "cannot increase reserve balance");`  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L88   
# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode) `owner` costs 100 gas (SLOAD opcode) The `onlyOwner` modifier already checks that `msg.sender == owner`.  ## Proof of Concept Instances include: ``` contracts\sNOTE.sol:118:            payable(owner), // Owner will receive the NOTE and WETH contracts\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`  
# Handle  Dravee   # Vulnerability details  ## Impact   Checking non-zero transfer values can avoid an external call to save gas.      ## Proof of Concept   Instances missing a non-zero check on amount transfered:   ```   contracts\sNOTE.sol:142:        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount); contracts\sNOTE.sol:150:        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount); contracts\sNOTE.sol:178:        WETH.safeTransferFrom(msg.sender, address(this), wethAmount); contracts\sNOTE.sol:251:        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem); contracts\TreasuryAction.sol:113:        COMP.safeTransfer(treasuryManagerContract, amountClaimed); contracts\TreasuryAction.sol:140:        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); contracts\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Check if transfer amount > 0.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  `sNOTE.redeem` burns an amount of sNOTE other than `sNOTEAmount`, potentially giving a better rate to redeemers than it should.  ## Proof of Concept  Following the process of burning sNOTE for BPT:  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L238-L252  1. We pass an amount of sNOTE to burn which is converted into BPT. (L248)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315-L323  2. We calculate the what fraction of the total amount of BPT this user is entitled to this amount of BPT represents and then multiply that by their balance of sNOTE (L320)  Rather than burning `sNOTEAmount` we then end up burning   ``` realSNOTEAmount = balanceOf(account) * getPoolTokenShare(sNOTEAmount) / getPoolTokenShare(balanceOf(account)) ```  This looks to round down such that we end up burning less sNOTE than expected. We're then going to be giving the user a slightly better rate of BPT for sNOTE than we should whereas any rounding should be in favour of the sNOTE contract.  In any case, we're performing many reads from storage (including from other contracts) in order to calculate a value which was originally passed by the user so using `sNOTEAmount` directly would be a gas optimisation.  ## Recommended Mitigation Steps  Change `_burn` to take an amount of sNOTE to burn as an argument rather than an amount of BPT which is equivalent to the amount of sNOTE to be burnt. `sNOTEAmount` can then be passed from the `redeem` function directly. `bptToRedeem` will still be rounded down so sNOTE will always have favourable rounding.  
# Handle  ShippooorDAO   # Vulnerability details  ## Impact Cooldown and redeem windows can be rendered useless.  ## Proof of Concept - Given an account that has not staked sNOTE. - Account calls sNOTE.startCooldown - Account waits for the duration of the cooldown period. Redeem period starts. - Account can then deposit and redeem as they wish, making the cooldown useless. - Multiple accounts could be used to "hop" between redeem windows by transfering between them, making the redeem window effictively useless.  Could be used for voting power attacks using flash loan if voting process is not monitored  https://www.coindesk.com/tech/2020/10/29/flash-loans-have-made-their-way-to-manipulating-protocol-elections/  ## Tools Used - Eyes - Brain - VS Code  ## Recommended Mitigation Steps A few ways to mitigate this problem: Option A: Remove the cooldown/redeem period as it's not really preventing much in current state. Option B: Let the contract start the cooldown on mint, and bind the cooldown/redeem window to the amount that was minted at that time by the account. Don't make sNOTE.startCooldown() available externally. Redeem should verify amount of token available using this new logic.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  TreasuryManager has a `_investWETHToBuyNOTE` function which deposits WETH stored on the contract into the NOTE-WETH Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L168-L211  Note there's a bit of a disconnect between the function name and what it's actually doing. You could argue that you're buying NOTE as you'll end up with an 80% note position but I think it's  more helpful for the purposes of this function to think of it as a "trade" of WETH for BPT.  The current function is as so: ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  queries[0].variable = IPriceOracle.Variable.PAIR_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 noteOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) );  uint256 noteSpotPrice = _getNOTESpotPrice();  // Calculate the max spot price based on the purchase limit uint256 maxPrice = noteOraclePrice +     (noteOraclePrice * notePurchaseLimit) /     NOTE_PURCHASE_LIMIT_PRECISION; ```  In this function we query the recent price average between NOTE and ETH, perform an unconditional join and then check that the spot price of NOTE in terms of ETH is below some maximum value to ensure that the pool's balances haven't been manipulated such that ETH is being undervalued.  This seems like a fairly roundabout method to set a slippage limit on a join which would be simpler if we queried the exchange rate between BPT and WETH. That allows us to specify a minimum amount of BPT we'd accept.  We'd then avoid using the function `_getNOTESpotPrice` entirely and could save the costs of querying the pool's balances again.  ## Recommended Mitigation Steps  Consider changing to something along the lines of  ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  // Note we're querying the BPT price rather than the pair price now queries[0].variable = IPriceOracle.Variable.BPT_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 bptOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  uint256 minBptOut = (bptOraclePrice * notePurchaseLimit) /  NOTE_PURCHASE_LIMIT_PRECISION;  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             minBptOut         ),         false // Don't use internal balances     ) ); ```  We're directly enforcing a slippage limit on the WETH -> BPT conversion rather than doing it in a roundabout way so it's easier to reason about. We save having to query the pool's balances again so save gas and also in the case where the slippage limit is triggered it'll be hit earlier, again saving gas.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra boilerplate code (including the whole of the _afterTokenTransfer function)  ## Proof of Concept  sNOTE inherits from both ERC20Upgradeable and ERC20VotesUpgradeable.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L15  This causes us to have to add explicit helpers for how to handle the inheritance tree to a bunch of functions  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L328  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L362  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L381  If we look at OZ however, we can see that ERC20VotesUpgradeable inherits from ERC20PermitUpgradeable which in turn inherits from ERC20Upgradeable   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L28  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol#L23  There's then no real reason for sNOTE to inherit from ERC20Upgradeable directly. Removing this inheritance should allow you to remove a bunch of the explicit overrides you have.  ## Recommended Mitigation Steps  Remove direct inheritance of ERC20Upgradeable and remove all the `override(ERC20Upgradeable, ERC20VotesUpgradeable)` stuff. You should be able to just delete `_afterTokenTransfer` in its entirety.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs. ## Proof of Concept  In a number of places we create an array and then fill every element with zero. There's no need to do this as a newly declared array will have zero-valued elements by default. We can then avoid the costs of writing a new zero to them.  For example we could remove these three lines entirely: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L111-L113  We can then just pass an empty array in the lines below as so. ``` BALANCER_VAULT.exitPool(   NOTE_ETH_POOL_ID,   address(this),   payable(owner), // Owner will receive the NOTE and WETH   IVault.ExitPoolRequest(       assets,       new uint256[](2), // inlined here       abi.encode(           IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,           bptExitAmount       ),       false // Don't use internal balances   ) ); ```  This also crops up elsewhere: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L156 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L169 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L185  ## Tools Used  ## Recommended Mitigation Steps  Omit lines writing zeros to an empty array.  
# Handle  Jujic   # Vulnerability details  ## Impact The require statement can be placed earlier (`before get coolDown`) to reduce gas usage.   ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L240 ``` function redeem(uint256 sNOTEAmount) external nonReentrant {         AccountCoolDown memory coolDown = accountCoolDown[msg.sender];         require(sNOTEAmount <= balanceOf(msg.sender), "Insufficient balance");         require(             coolDown.redeemWindowBegin != 0 &&             coolDown.redeemWindowBegin < block.timestamp &&             block.timestamp < coolDown.redeemWindowEnd,             "Not in Redemption Window"         );          uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);         _burn(msg.sender, bptToRedeem);          BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);     } ``` ## Tools Used Remix ## Recommended Mitigation Steps Relocate the require statement upper.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Increases gas costs due to manipulating redeemWindowEnd and usage of structs for `AccountCooldown`  ## Proof of Concept  `redeemWindowEnd` will always equal `redeemWindowBegin + REDEEM_WINDOW_SECONDS` so it can just be calculated when needed (excluding the situation where both of these are zero which is already handled in the code.)  We then don't need to store both of these values in storage and deal with the overhead of using structs.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L244  We can then just replace this line with   ``` block.timestamp < coolDown.redeemWindowBegin + REDEEM_WINDOW_SECONDS ```  ## Recommended Mitigation Steps  Remove `coolDown.redeemWindowEnd` and store cooldowns as a simple uint rather than a struct.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  ## Proof of Concept  This comment should refer to WETH not NOTE  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L177  ## Recommended Mitigation Steps  Change to refer to WETH  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Greater flexibility for users and better conversion between a mix of ETH/NOTE and sNOTE.  ## Proof of Concept  `sNOTE` allows users to provider either NOTE, ETH or WETH to provide liquidity in return for BPT to mint sNOTE with through the functions `mintFromNOTE`, `mintFromETH` and `mintFromWETH`.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L146-L188  Balancer allows users to deposit multiple assets at once so the same functionality while being more flexible (by allowing deposits in both NOTE and ETH at the same time) and giving users better execution (A user depositing NOTE and ETH together gets more SNOTE than one who deposits NOTE and then ETH afterwards)  Consider the code snippet:  ``` /// @notice Mints sNOTE from some amount of NOTE and ETH /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromETH(uint256 noteAmount) payable external nonReentrant {     IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(0));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = msg.value;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); }  /// @notice Mints sNOTE from some amount of NOTE and WETH /// @param wethAmount amount of WETH to transfer into the sNOTE contract /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromWETH(uint256 wethAmount, uint256 noteAmount) external nonReentrant {     // Transfer the WETH and NOTE balance into sNOTE first     WETH.safeTransferFrom(msg.sender, address(this), wethAmount);     NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);      IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(WETH));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = wethAmount;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); } ```  ## Recommended Mitigation Steps  Replace current functions with above versions  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs ## Proof of Concept  Here we check that `_noteETHPoolId` corresponds to a registered Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L59  `_balancerVault.getPool(_noteETHPoolId)` will revert if _noteETHPoolId is not a registered poolId  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L93  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L56  The require statement on the next line is impossible to fail unless we somehow manage to deploy a balancer pool to the zero address (which would be impressive)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L60  We can then safely remove this statement without any change in behaviour.  ## Recommended Mitigation Steps  Remove require statement.  
# Handle  0x1f8b   # Vulnerability details  ## Impact `_getToken` return empty values instead of revert.  ## Proof of Concept The library `TokenHandler` has the `_getToken` method and this method returns an empty struct instead of revert if the currencyId was not found, this can produce in unexpected errors.  ## Tools Used Manual review.  ## Recommended Mitigation Steps revert if it was not found.  
