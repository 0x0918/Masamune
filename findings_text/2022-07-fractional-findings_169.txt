## Summary The developers have opted for a highly optimized and flexible smart contract architecture with the use of quite novel code (createWithImmutableArgs) and extensive assembly. However, as the developers are most likely fully aware, comes at the cost of much lower readability and can make the architecture and interdependence between different contracts quite confusing. I believe a small flow diagram to showcase how an example architecture would be deployed would be a massive help in understanding the architecture. On the other hand, the developers went above and beyond in commenting the code which was vitally important especially for such a complex architecture. In the future, I would be very careful when developing and adding new modules as in this case the contract is only as strong as its weakest link. When adding a new module, I would not only make sure that the module itself is secure but if it interacts with other modules then it does not introduce new vulnerabilities as the interdependence between modules is not always straightforward.  ### Issue #1 Incorrect memory expansion gas cost calculation Code used to calculate memory expansion cost is inconsistent with equation 326 in the [ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf)  This can cause incorrect errors to be reported  Currently the code is `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords**2 - msizeWords**2) / MEMORY_EXPANSION_COEFFICIENT` when it should be `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords - msizeWords)**2 / MEMORY_EXPANSION_COEFFICIENT`  Change ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     sub(                                         mul(returnDataWords, returnDataWords),                                         mul(msizeWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ``` to ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     mul(                                         sub(returnDataWords, msizeWords),                                         sub(returnDataWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L66-L81 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L156-L171 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L96-L117 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L281-L296 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L412-L427 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L642-L657 ### Issue #2 Storage check in `_execute()` from Vault.sol is obselete Currently `_execute()` contains the line: ```solidity         if (owner_ != owner) revert OwnerChanged(owner_, owner); ``` to make sure that the owner storage variable is not modified after the delegatecall. This check can be easily bypassed by modifying the other storage variables such as `nonce` (allows a user to reinitalise contract), `merkleRoot` (user can execute malicious permissions) or `methods` (a malicious plugin can be installed)  1. Either you can trust that the `_target` contracts will all be stateless and just remove the check to save gas OR 2. add extra checks to include the other storage variables (recommended)  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L132 ### Issue #3 Use of magic values Throughout the contracts, there is an inconsistent use of magic values where sometimes constants are used and sometimes magic values are used  e.g. Change ```solidity         uint256 buyoutPrice = (msg.value * 100) /             (100 - ((depositAmount * 100) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ``` to ```solidity uint256 public immutable PRECISION = 100; ...         uint256 buyoutPrice = (msg.value * PRECISION) /             (PRECISION - ((depositAmount * PRECISION) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L86-L88 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L199 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L37 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L315 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L452 ### Issue #4 No check that `newVault` is not zero address in `migrateFractions()` In `migrateFractions()` from Migration.sol, the `newVault` address is read with no check that the address is not the zero address (which can occur if someone calls `migrateFractions()` before `settleVault()` is called). This causes the transaction to revert with no proper error message when the function attempts to send tokens.   Consider adding a check to produce a custom error if `newVault == address(0)`  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L466
