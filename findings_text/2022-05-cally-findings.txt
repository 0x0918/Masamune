# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201   # Vulnerability details  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201  ```solidity function createVault(     uint256 tokenIdOrAmount,     address token,     ... ) external returns (uint256 vaultId) {     ...     Vault memory vault = Vault({         ...     });      // vault index should always be odd     vaultIndex += 2;     vaultId = vaultIndex;     _vaults[vaultId] = vault;      // give msg.sender vault token     _mint(msg.sender, vaultId);      emit NewVault(vaultId, msg.sender, token);      // transfer the NFTs or ERC20s to the contract     vault.tokenType == TokenType.ERC721         ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)         : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); } ```  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L23-L34  ```solidity import "solmate/utils/SafeTransferLib.sol";  ...  contract Cally is CallyNft, ReentrancyGuard, Ownable {     using SafeTransferLib for ERC20;     ... ```  When creating a new vault, solmate's `SafeTransferLib` is used for pulling `vault.token` from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead.  That's because there is a subtle difference between the implementation of solmate's `SafeTransferLib` and OZ's `SafeERC20`:  OZ's `SafeERC20` checks if the token is a contract or not, solmate's `SafeTransferLib` does not.  See: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9  > Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.  As a result, when the token's address has no code, the transaction will just succeed with no error.  This attack vector was made well-known by the qBridge hack back in Jan 2022.  For our project, this alone still won't be a problem, a vault created and wrongfully accounted for a certain amount of balance for a non-existing token won't be much of a problem, there will be no fund loss as long as the token stays that way (being non-existing).  However, it's becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.  For example: $1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.  A sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.  ### PoC  Given:  - ProjectA has TokenA on another network; - ProjectB has TokenB on another network; - ProjectC has TokenC on another network;  1. The attacker `createVault()` for `TokenA`, `TokenB`, and `TokenC` with `10000e18` as `tokenIdOrAmount` each; 2. A few months later, ProjectB lunched `TokenB` on the local network at the same address; 3. Alice created a vault with `11000e18 TokenB`; 4. The attacker called `initiateWithdraw()` and then `withdraw()` to receive `10000e18 TokenB`.  In summary, one of the traps set by the attacker was activated by the deployment of  `TokenB` and Alice was the victim. As a result, `10000e18 TokenB` was stolen by the attacker.  ### Recommendation  Consider using OZ's `SafeERC20` instead.  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193 https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193) - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199)  Currently it’s possible to create an ERC-721 vault using Cally’ own address as `token`, and using the freshly minted vault id as `tokenIdOrAmount`. This results in a new vault whose ownership is passed to Cally contract immediately upon creation.  The vault allows users to perform `buyOption` and increase the ETH balance of the Cally contract itself, which is still the vault beneficiary. As soon as an user calls `exercise`, she will receive the `vault.tokenIdOrAmount` in exchange, which in this case coincides with the vault nft. However this is of no good because the final user may just initiate a withdrawal, which will:  - always fail because the vault id is burned ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335)) and then transferred back to the user ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344)) - leave all the ETH unredemable in Cally contract  So the vault will be unusable and the ETH deposited by users to buy/exercise options will remain locked in Cally contract  ## Proof of Concept  - Current vault id is, let’s say, 11 - User deploys a vault with Cally’ address as `token` and `13` as `tokenIdOrAmount` - Since `createVault()` mints the vault token to the user, and then transfers the underlying address from the user, an user is able to create a vault with something she doesn’t own at the moment of the `createVault()` function call, because it’s created while the function runs - The vault `13` is pretty limited in functionality, because Cally’ smart contract is the owner - However, users can still buy options: so Alice and Bob deposit their premiums - Whoever `exercise` the active option, becomes the vault owner now; this is of no good because no one can actually call `withdraw()` as it will always revert, and no one can recover the ETH deposited by Alice and Bob as they are locked forever  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add the following check at the start of `createVault()`:  ```jsx require(token != address(this), "Cant use Cally as token"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L406-L423   # Vulnerability details   The vulnerability or bug is in the implementation of the function getDutchAuctionStrike() The AUCTION_DURATION is defined as 24 hours, and consider that the dutchAuctionReserveStrike (or reserveStrike) will never be set to 0 by user.  Now if a vault is created with startingStrike value of 55 and reserveStrike of 13.5 , the auction price will drop from 55 to 13.5 midway at ~12 hours. So, after 12 hours from start of auction, the rate will be constant at reserveStrike of 13.5, and remaining time of 12 hours of auction is a waste.   Some other examples : ``` startStrike, reserveStrike, time-to-reach-reserveStrike 55 , 13.5  , ~12 hours 55 , 5     , ~16.7 hours 55 , 1.5   , ~20 hours 5  , 1.5   , ~11 hours ``` ## Impact The impact is high wrt Usability, where users have reduced available time to participate in the auction (when price is expected to change). The vault-Creators or the option-Buyers may or may not be aware of this inefficiency, i.e., how much effective time is available for auction.  ## Proof of Concept Contract : Cally.sol Function : getDutchAuctionStrike ()  ## Recommended Mitigation Steps The function getDutchAuctionStrike() can be modified such that price drops to the reserveStrike exactly at 24 hours from start of auction. ```         /*             delta = max(auctionEnd - currentTimestamp, 0)             progress = delta / auctionDuration             auctionStrike = progress^2 * (startingStrike - reserveStrike)             << Changes here             strike = auctionStrike + reserveStrike                                    << Changes here         */         uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;         uint256 progress = (1e18 * delta) / AUCTION_DURATION;         uint256 auctionStrike = (progress * progress * (startingStrike-reserveStrike)) / (1e18 * 1e18);          strike = auctionStrike + reserveStrike; ```   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L200   # Vulnerability details  ## Impact A griefer is able to create as many vaults as they want by simply calling `createVault()` with `tokenIdOrAmount = 0`. This will most likely pose problems on the front-end of the Cally protocol because there will be a ridiculously high number of malicious vaults displayed to actual users.  I define these vaults as malicious because it is possible that a user accidently buys a call on this vault which provides 0 value in return. Overall, the presence of zero-amount vaults is damaging to Cally's product image and functionality.  ## Proof of Concept - User calls `createVault(0,,,,);` with an ERC20 type. - There is no validation that `amount > 0` - Function will complete successfully, granting the new vault NFT to the caller. - Cally protocol is filled with unwanted 0 amount vaults.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the simple check `require(tokenIdOrAmount > 0, "Amount must be greater than 0");`  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L198-L200   # Vulnerability details  ## Impact Some ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the `createVault()` function to initialize the vault without providing any tokens. A good example of such a token is *ZRX*: [Etherscan code](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L64)  When such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds.  ## Proof of Concept The trick is to create a vault with an ERC20 token but use ERC721 as the vault's type. Then, instead of calling `safeTransferFrom()` the function calls `transferFrom()` which won't catch the token returning false.  Here's a test that showcases the issue:  ```solidity // CreateVault.t.sol     function testStealFunds() public {         // address of 0x on mainnet         address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);         vm.startPrank(babe);         require(ERC20(t).balanceOf(babe) == 0);         uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);         // check that neither the Cally contract nor the vault creator         // had any 0x tokens         require(ERC20(t).balanceOf(babe) == 0);         require(ERC20(t).balanceOf(address(c)) == 0);          // check whether vault was created properly         Cally.Vault memory v = c.vaults(vaultId);         require(v.token == t);         require(v.tokenIdOrAmount == 100);         vm.stopPrank();         // So now there's a vault for 100 0x tokens although the Cally contract doesn't         // have any.         // If someone buys & exercises the option they won't receive any tokens.         uint premium = 0.025 ether;         uint strike = 2 ether;         require(address(c).balance == 0, "shouldn't have any balance at the beginning");         require(payable(address(this)).balance > 0, "not enough balance");          uint optionId = c.buyOption{value: premium}(vaultId);         c.exercise{value: strike}(optionId);          // buyer of option (`address(this)`) got zero 0x tokens         // But buyer lost their Ether         require(ERC20(t).balanceOf(address(this)) == 0);         require(address(c).balance > 0, "got some money");     } ```  To run it, you need to use forge's forking mode: `forge test --fork-url <alchemy/infura URL> --match testStealFunds`  ## Tools Used none  ## Recommended Mitigation Steps I think the easiest solution is to use `safeTransferFrom()` when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature shouldn't exist on ERC20 tokens.  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L223-L224   # Vulnerability details  ## Impact  It is possible for a user purchasing an option to accidentally overpay the premium during `buyOption()`.  Any excess funds paid for in excess of the premium will be transferred to the vault creator.  The premium is fixed at the time the vault is first created by `vault.premiumIndex`. Hence there is no need to allow users to overpay since there will be no benefit.   ## Proof of Concept  `buyOption()` allows `msg.value > premium`  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value >= premium, "Incorrect ETH amount sent"); ```  ## Recommended Mitigation Steps  Consider modifying the check such that the `msg.value` is exactly equal to the `premuim`. e.g.  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value == premium, "Incorrect ETH amount sent"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L198-L200 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L294-L296 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L343-L345   # Vulnerability details  ## Impact  Some ERC20 tokens charge a transaction fee for every transfer (used to encourage staking, add to liquidity pool, pay a fee to contract owner, etc.). If any such token is used in the `createVault()` function, either the token cannot be withdrawn from the contract (due to insufficient token balance), or it could be exploited by other such token holders and the `Cally` contract would lose economic value and some users would be unable to withdraw the underlying asset.    ## Proof of Concept  Plenty of ERC20 tokens charge a fee for every transfer (e.g. Safemoon and its forks), in which the amount of token received is less than the amount being sent. When a fee token is used as the `token` in the `createVault()` function, the amount received by the contract would be less than the amount being sent. To be more precise, the increase in the `cally` contract token balance would be less than `vault.tokenIdOrAmount` for such ERC20 token because of the fee.   ```         vault.tokenType == TokenType.ERC721             ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)             : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); ```  The implication is that both the `exercise()` function and the `withdraw()` function are guaranteed to revert if there's no other vault in the contract that contains the same fee tokens, due to insufficient token balance in the `Cally` contract.   When an attacker observes that a vault is being created that contains such fee tokens, the attacker could create a new vault himself that contains the same token, and then withdraw the same amount. Essentially the `Cally` contract would be paying the transfer fee for the attacker because of how the token amount is recorded. This causes loss of user fund and loss of value from the `Cally` contract. It would make economic sense for the attacker when the fee charged by the token accrue to the attacker. The attacker would essentially use the `Cally` contract as a conduit to generate fee income.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend disallowing fee tokens from being used in the vault. This can be done by adding a `require()` statement to check that the amount increase of the `token` balance in the `Cally` contract is equal to the amount being sent by the caller of the `createVault()` function.   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289   # Vulnerability details  ## Impact The owner can force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens  ## Proof of Concept After a buyer buys an option owned by the owner, the owner can change the fee rate to be close to `type(uint256).max`, which will cause the subtraction below to always underflow, preventing the exercise of the option. Once the option expires, the owner can change the fee back and wait for another buyer  ```solidity File: contracts/src/Cally.sol   #1  288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add reasonable fee rate bounds checks in the `setFee()` function   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121   # Vulnerability details  ## Impact Owner can steal the exercise cost which should have gone to the option seller  ## Proof of Concept There are no restrictions on when the owner can set the `feeRate`: ```solidity File: contracts/src/Cally.sol   #1  117       /// @notice Sets the fee that is applied on exercise 118       /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18 119       function setFee(uint256 feeRate_) external onlyOwner { 120           feeRate = feeRate_; 121       } ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121  By using a rate that consumes the exercise cost, the owner can steal Ether from the seller: ```solidity File: contracts/src/Cally.sol   #2  282           uint256 fee = 0; 283           if (feeRate > 0) { 284               fee = (msg.value * feeRate) / 1e18; 285               protocolUnclaimedFees += fee; 286           } 287    288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L282-L289  The owner can wait for a particularly large-value NFT, snipe that one option, then retire  ## Tools Used Code inspection  ## Recommended Mitigation Steps Fix the fee rate per vault during vault creation   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L199 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L295 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L344   # Vulnerability details  ## Details & Impact  The `transferFrom()` method is used instead of `safeTransferFrom()`, presumably to save gas. I however argue that this isn’t recommended because:  - [OpenZeppelin’s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`, use `safeTransferFrom()` whenever possible - Given that any NFT can be used for the call option, there are a few NFTs (here’s an [example](https://github.com/sz-piotr/eth-card-game/blob/master/src/ethereum/contracts/ERC721Market.sol#L20-L31)) that have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`  ## Recommended Mitigation Steps  Call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. Note that the `CallyNft` contract should inherit the `ERC721TokenReceiver` contract as a consequence.  ```solidity abstract contract CallyNft is ERC721("Cally", "CALL"), ERC721TokenReceiver {...} ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L238   # Vulnerability details  ## Details & Impact  `vault.durationDays` is of type `uint8`, thus allowing a maximum value of 255. `1 days = 86400`, thus fitting into a `uint24`. Solc creates a temporary variable to hold the result of the intermittent multiplication `vault.durationDays * 1 days` using the data type of the larger operand.  In this case, the intermittent data type used would be `uint24`, which has a maximum value of `2**24 - 1 = 16777215`. The maximum number allowable before overflow achieved is therefore `(2**24 - 1) / 86400 = 194`.  ## Proof of Concept  Insert this test case into [BuyOption.t.sol](https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/test/units/BuyOption.t.sol)  ```solidity  function testCannotBuyDueToOverflow() public {   vm.startPrank(babe);   bayc.mint(babe, 2);   // duration of 195 days   vaultId = c.createVault(2, address(bayc), premiumIndex, 195, strikeIndex, 0, Cally.TokenType.ERC721);   vm.stopPrank();    vm.expectRevert(stdError.arithmeticError);   c.buyOption{value: premium}(vaultId); } ```  Then run  ``` forge test --match-contract TestBuyOption --match-test testCannotBuyDueToOverflow ```  ## Tidbit  This was the 1 high-severity bug that I wanted to mention at the end of the [C4 TrustX showcase](https://youtu.be/up9eqFRLgMQ?t=5722) but unfortunately could not due to a lack of time :( It can be found in the [vulnerable lottery contract](https://gist.github.com/HickupHH3/d214cfe6e4d003f428a63ae7d127af2d) on L39. Credits to Pauliax / Thunder for the recommendation and raising awareness of this bug =p  ## Reference  [Article](https://muellerberndt.medium.com/building-a-secure-nft-gaming-experience-a-herdsmans-diary-1-91aab11139dc)  ## Recommended Mitigation Steps  Cast the multiplication into `uint32`.  ```solidity vault.currentExpiration = uint32(block.timestamp) + uint32(vault.durationDays) * 1 days; ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201   # Vulnerability details  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201  ```solidity function createVault(     uint256 tokenIdOrAmount,     address token,     ... ) external returns (uint256 vaultId) {     ...     Vault memory vault = Vault({         ...     });      // vault index should always be odd     vaultIndex += 2;     vaultId = vaultIndex;     _vaults[vaultId] = vault;      // give msg.sender vault token     _mint(msg.sender, vaultId);      emit NewVault(vaultId, msg.sender, token);      // transfer the NFTs or ERC20s to the contract     vault.tokenType == TokenType.ERC721         ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)         : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); } ```  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L23-L34  ```solidity import "solmate/utils/SafeTransferLib.sol";  ...  contract Cally is CallyNft, ReentrancyGuard, Ownable {     using SafeTransferLib for ERC20;     ... ```  When creating a new vault, solmate's `SafeTransferLib` is used for pulling `vault.token` from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead.  That's because there is a subtle difference between the implementation of solmate's `SafeTransferLib` and OZ's `SafeERC20`:  OZ's `SafeERC20` checks if the token is a contract or not, solmate's `SafeTransferLib` does not.  See: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9  > Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.  As a result, when the token's address has no code, the transaction will just succeed with no error.  This attack vector was made well-known by the qBridge hack back in Jan 2022.  For our project, this alone still won't be a problem, a vault created and wrongfully accounted for a certain amount of balance for a non-existing token won't be much of a problem, there will be no fund loss as long as the token stays that way (being non-existing).  However, it's becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.  For example: $1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.  A sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.  ### PoC  Given:  - ProjectA has TokenA on another network; - ProjectB has TokenB on another network; - ProjectC has TokenC on another network;  1. The attacker `createVault()` for `TokenA`, `TokenB`, and `TokenC` with `10000e18` as `tokenIdOrAmount` each; 2. A few months later, ProjectB lunched `TokenB` on the local network at the same address; 3. Alice created a vault with `11000e18 TokenB`; 4. The attacker called `initiateWithdraw()` and then `withdraw()` to receive `10000e18 TokenB`.  In summary, one of the traps set by the attacker was activated by the deployment of  `TokenB` and Alice was the victim. As a result, `10000e18 TokenB` was stolen by the attacker.  ### Recommendation  Consider using OZ's `SafeERC20` instead.  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193 https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193) - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199)  Currently it’s possible to create an ERC-721 vault using Cally’ own address as `token`, and using the freshly minted vault id as `tokenIdOrAmount`. This results in a new vault whose ownership is passed to Cally contract immediately upon creation.  The vault allows users to perform `buyOption` and increase the ETH balance of the Cally contract itself, which is still the vault beneficiary. As soon as an user calls `exercise`, she will receive the `vault.tokenIdOrAmount` in exchange, which in this case coincides with the vault nft. However this is of no good because the final user may just initiate a withdrawal, which will:  - always fail because the vault id is burned ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335)) and then transferred back to the user ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344)) - leave all the ETH unredemable in Cally contract  So the vault will be unusable and the ETH deposited by users to buy/exercise options will remain locked in Cally contract  ## Proof of Concept  - Current vault id is, let’s say, 11 - User deploys a vault with Cally’ address as `token` and `13` as `tokenIdOrAmount` - Since `createVault()` mints the vault token to the user, and then transfers the underlying address from the user, an user is able to create a vault with something she doesn’t own at the moment of the `createVault()` function call, because it’s created while the function runs - The vault `13` is pretty limited in functionality, because Cally’ smart contract is the owner - However, users can still buy options: so Alice and Bob deposit their premiums - Whoever `exercise` the active option, becomes the vault owner now; this is of no good because no one can actually call `withdraw()` as it will always revert, and no one can recover the ETH deposited by Alice and Bob as they are locked forever  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add the following check at the start of `createVault()`:  ```jsx require(token != address(this), "Cant use Cally as token"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L406-L423   # Vulnerability details   The vulnerability or bug is in the implementation of the function getDutchAuctionStrike() The AUCTION_DURATION is defined as 24 hours, and consider that the dutchAuctionReserveStrike (or reserveStrike) will never be set to 0 by user.  Now if a vault is created with startingStrike value of 55 and reserveStrike of 13.5 , the auction price will drop from 55 to 13.5 midway at ~12 hours. So, after 12 hours from start of auction, the rate will be constant at reserveStrike of 13.5, and remaining time of 12 hours of auction is a waste.   Some other examples : ``` startStrike, reserveStrike, time-to-reach-reserveStrike 55 , 13.5  , ~12 hours 55 , 5     , ~16.7 hours 55 , 1.5   , ~20 hours 5  , 1.5   , ~11 hours ``` ## Impact The impact is high wrt Usability, where users have reduced available time to participate in the auction (when price is expected to change). The vault-Creators or the option-Buyers may or may not be aware of this inefficiency, i.e., how much effective time is available for auction.  ## Proof of Concept Contract : Cally.sol Function : getDutchAuctionStrike ()  ## Recommended Mitigation Steps The function getDutchAuctionStrike() can be modified such that price drops to the reserveStrike exactly at 24 hours from start of auction. ```         /*             delta = max(auctionEnd - currentTimestamp, 0)             progress = delta / auctionDuration             auctionStrike = progress^2 * (startingStrike - reserveStrike)             << Changes here             strike = auctionStrike + reserveStrike                                    << Changes here         */         uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;         uint256 progress = (1e18 * delta) / AUCTION_DURATION;         uint256 auctionStrike = (progress * progress * (startingStrike-reserveStrike)) / (1e18 * 1e18);          strike = auctionStrike + reserveStrike; ```   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L200   # Vulnerability details  ## Impact A griefer is able to create as many vaults as they want by simply calling `createVault()` with `tokenIdOrAmount = 0`. This will most likely pose problems on the front-end of the Cally protocol because there will be a ridiculously high number of malicious vaults displayed to actual users.  I define these vaults as malicious because it is possible that a user accidently buys a call on this vault which provides 0 value in return. Overall, the presence of zero-amount vaults is damaging to Cally's product image and functionality.  ## Proof of Concept - User calls `createVault(0,,,,);` with an ERC20 type. - There is no validation that `amount > 0` - Function will complete successfully, granting the new vault NFT to the caller. - Cally protocol is filled with unwanted 0 amount vaults.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the simple check `require(tokenIdOrAmount > 0, "Amount must be greater than 0");`  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L198-L200   # Vulnerability details  ## Impact Some ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the `createVault()` function to initialize the vault without providing any tokens. A good example of such a token is *ZRX*: [Etherscan code](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L64)  When such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds.  ## Proof of Concept The trick is to create a vault with an ERC20 token but use ERC721 as the vault's type. Then, instead of calling `safeTransferFrom()` the function calls `transferFrom()` which won't catch the token returning false.  Here's a test that showcases the issue:  ```solidity // CreateVault.t.sol     function testStealFunds() public {         // address of 0x on mainnet         address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);         vm.startPrank(babe);         require(ERC20(t).balanceOf(babe) == 0);         uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);         // check that neither the Cally contract nor the vault creator         // had any 0x tokens         require(ERC20(t).balanceOf(babe) == 0);         require(ERC20(t).balanceOf(address(c)) == 0);          // check whether vault was created properly         Cally.Vault memory v = c.vaults(vaultId);         require(v.token == t);         require(v.tokenIdOrAmount == 100);         vm.stopPrank();         // So now there's a vault for 100 0x tokens although the Cally contract doesn't         // have any.         // If someone buys & exercises the option they won't receive any tokens.         uint premium = 0.025 ether;         uint strike = 2 ether;         require(address(c).balance == 0, "shouldn't have any balance at the beginning");         require(payable(address(this)).balance > 0, "not enough balance");          uint optionId = c.buyOption{value: premium}(vaultId);         c.exercise{value: strike}(optionId);          // buyer of option (`address(this)`) got zero 0x tokens         // But buyer lost their Ether         require(ERC20(t).balanceOf(address(this)) == 0);         require(address(c).balance > 0, "got some money");     } ```  To run it, you need to use forge's forking mode: `forge test --fork-url <alchemy/infura URL> --match testStealFunds`  ## Tools Used none  ## Recommended Mitigation Steps I think the easiest solution is to use `safeTransferFrom()` when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature shouldn't exist on ERC20 tokens.  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L223-L224   # Vulnerability details  ## Impact  It is possible for a user purchasing an option to accidentally overpay the premium during `buyOption()`.  Any excess funds paid for in excess of the premium will be transferred to the vault creator.  The premium is fixed at the time the vault is first created by `vault.premiumIndex`. Hence there is no need to allow users to overpay since there will be no benefit.   ## Proof of Concept  `buyOption()` allows `msg.value > premium`  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value >= premium, "Incorrect ETH amount sent"); ```  ## Recommended Mitigation Steps  Consider modifying the check such that the `msg.value` is exactly equal to the `premuim`. e.g.  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value == premium, "Incorrect ETH amount sent"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L198-L200 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L294-L296 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L343-L345   # Vulnerability details  ## Impact  Some ERC20 tokens charge a transaction fee for every transfer (used to encourage staking, add to liquidity pool, pay a fee to contract owner, etc.). If any such token is used in the `createVault()` function, either the token cannot be withdrawn from the contract (due to insufficient token balance), or it could be exploited by other such token holders and the `Cally` contract would lose economic value and some users would be unable to withdraw the underlying asset.    ## Proof of Concept  Plenty of ERC20 tokens charge a fee for every transfer (e.g. Safemoon and its forks), in which the amount of token received is less than the amount being sent. When a fee token is used as the `token` in the `createVault()` function, the amount received by the contract would be less than the amount being sent. To be more precise, the increase in the `cally` contract token balance would be less than `vault.tokenIdOrAmount` for such ERC20 token because of the fee.   ```         vault.tokenType == TokenType.ERC721             ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)             : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); ```  The implication is that both the `exercise()` function and the `withdraw()` function are guaranteed to revert if there's no other vault in the contract that contains the same fee tokens, due to insufficient token balance in the `Cally` contract.   When an attacker observes that a vault is being created that contains such fee tokens, the attacker could create a new vault himself that contains the same token, and then withdraw the same amount. Essentially the `Cally` contract would be paying the transfer fee for the attacker because of how the token amount is recorded. This causes loss of user fund and loss of value from the `Cally` contract. It would make economic sense for the attacker when the fee charged by the token accrue to the attacker. The attacker would essentially use the `Cally` contract as a conduit to generate fee income.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend disallowing fee tokens from being used in the vault. This can be done by adding a `require()` statement to check that the amount increase of the `token` balance in the `Cally` contract is equal to the amount being sent by the caller of the `createVault()` function.   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289   # Vulnerability details  ## Impact The owner can force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens  ## Proof of Concept After a buyer buys an option owned by the owner, the owner can change the fee rate to be close to `type(uint256).max`, which will cause the subtraction below to always underflow, preventing the exercise of the option. Once the option expires, the owner can change the fee back and wait for another buyer  ```solidity File: contracts/src/Cally.sol   #1  288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add reasonable fee rate bounds checks in the `setFee()` function   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121   # Vulnerability details  ## Impact Owner can steal the exercise cost which should have gone to the option seller  ## Proof of Concept There are no restrictions on when the owner can set the `feeRate`: ```solidity File: contracts/src/Cally.sol   #1  117       /// @notice Sets the fee that is applied on exercise 118       /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18 119       function setFee(uint256 feeRate_) external onlyOwner { 120           feeRate = feeRate_; 121       } ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121  By using a rate that consumes the exercise cost, the owner can steal Ether from the seller: ```solidity File: contracts/src/Cally.sol   #2  282           uint256 fee = 0; 283           if (feeRate > 0) { 284               fee = (msg.value * feeRate) / 1e18; 285               protocolUnclaimedFees += fee; 286           } 287    288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L282-L289  The owner can wait for a particularly large-value NFT, snipe that one option, then retire  ## Tools Used Code inspection  ## Recommended Mitigation Steps Fix the fee rate per vault during vault creation   
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L199 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L295 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L344   # Vulnerability details  ## Details & Impact  The `transferFrom()` method is used instead of `safeTransferFrom()`, presumably to save gas. I however argue that this isn’t recommended because:  - [OpenZeppelin’s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`, use `safeTransferFrom()` whenever possible - Given that any NFT can be used for the call option, there are a few NFTs (here’s an [example](https://github.com/sz-piotr/eth-card-game/blob/master/src/ethereum/contracts/ERC721Market.sol#L20-L31)) that have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`  ## Recommended Mitigation Steps  Call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. Note that the `CallyNft` contract should inherit the `ERC721TokenReceiver` contract as a consequence.  ```solidity abstract contract CallyNft is ERC721("Cally", "CALL"), ERC721TokenReceiver {...} ```  
# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L238   # Vulnerability details  ## Details & Impact  `vault.durationDays` is of type `uint8`, thus allowing a maximum value of 255. `1 days = 86400`, thus fitting into a `uint24`. Solc creates a temporary variable to hold the result of the intermittent multiplication `vault.durationDays * 1 days` using the data type of the larger operand.  In this case, the intermittent data type used would be `uint24`, which has a maximum value of `2**24 - 1 = 16777215`. The maximum number allowable before overflow achieved is therefore `(2**24 - 1) / 86400 = 194`.  ## Proof of Concept  Insert this test case into [BuyOption.t.sol](https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/test/units/BuyOption.t.sol)  ```solidity  function testCannotBuyDueToOverflow() public {   vm.startPrank(babe);   bayc.mint(babe, 2);   // duration of 195 days   vaultId = c.createVault(2, address(bayc), premiumIndex, 195, strikeIndex, 0, Cally.TokenType.ERC721);   vm.stopPrank();    vm.expectRevert(stdError.arithmeticError);   c.buyOption{value: premium}(vaultId); } ```  Then run  ``` forge test --match-contract TestBuyOption --match-test testCannotBuyDueToOverflow ```  ## Tidbit  This was the 1 high-severity bug that I wanted to mention at the end of the [C4 TrustX showcase](https://youtu.be/up9eqFRLgMQ?t=5722) but unfortunately could not due to a lack of time :( It can be found in the [vulnerable lottery contract](https://gist.github.com/HickupHH3/d214cfe6e4d003f428a63ae7d127af2d) on L39. Credits to Pauliax / Thunder for the recommendation and raising awareness of this bug =p  ## Reference  [Article](https://muellerberndt.medium.com/building-a-secure-nft-gaming-experience-a-herdsmans-diary-1-91aab11139dc)  ## Recommended Mitigation Steps  Cast the multiplication into `uint32`.  ```solidity vault.currentExpiration = uint32(block.timestamp) + uint32(vault.durationDays) * 1 days; ```  
