# Report    * [Non-Critical](#non-critical)     * [emit events for address or important state changes](#emit-events-for-address-or-important-state-changes)     * [don't convert to a smaller bit uint without verifying its value](#dont-convert-to-a-smaller-bit-uint-without-verifying-its-value)   * [Low](#low)     * [use SafeERC20 or check return value of ERC20 functions](#use-safeerc20-or-check-return-value-of-erc20-functions)     * [Shelter donations result in wrong internal balance if fee-on-transfer token is used](#shelter-donations-result-in-wrong-internal-balance-if-fee-on-transfer-token-is-used)     * [Shelter can delay the user's ability to withdraw their funds indefinitely](#shelter-can-delay-the-users-ability-to-withdraw-their-funds-indefinitely)      ## Non-Critical  ### emit events for address or important state changes  Stuff like a guardian being added to the contract or the treasury address being changed. All of that should be accompanied by an event.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L60-L66 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L83  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L87 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L70  ### don't convert to a smaller bit uint without verifying its value  When converting to a smaller bit uint it might result in a smaller number if the value is higher than the maximum value of that uint type. Before converting it check whether the passed value is small enough.  ```sol require(x <= type(uint192).max); uint192 y = uint192(x); ```  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235  It shouldn't really be an issue here tho and since I don't expect anybody to have more than `2 ** 196 - 1` tokens to abuse this.  ## Low  ### use SafeERC20 or check return value of ERC20 functions  Some tokens don't revert if a transfer fails. Instead they just return `false`. Since the `ConvexStakingWrapper` contract [potentially works with arbitrary ERC20 tokens](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L129-L136) it's recommended to use SafeERC20 when working with it. Or at least check the return values:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L179 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   ### Shelter donations result in wrong internal balance if fee-on-transfer token is used  In case of a fee-on-transfer ERC20 token the `savedTokens` balance will not represent the actual balance of the contract:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34-L35  You can either disable the use of fee-on-transfer tokens for donations or use the actual balance:  ```sol // disable uint oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _amount); uint newBalance = _token.balanceOf(address(this)); require(_amount == (newBalance - oldBalance)); savedTokens[_token] += _amount; ```  ```sol // use actual balance _token.safeTransferFrom(msg.sender, address(this), _amount); savedTokens[_token] = _token.balanceOf(address(this)); ```  ### Shelter can delay the user's ability to withdraw their funds indefinitely  By repedeatly calling the `activate()` function for a specific token they can extend the timestamp at which withdrawal by users is enabled.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L39 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L53  With each call `activated[_token]` is reset to `block.timestamp`. Thus the require statement in `withdraw()` will fail for another week. There's nothing stopping the client from calling the function multiple times to keep delaying the withdrawal.  Fix it by not allowing already activated tokens to be reactivated. But with the current implementation of the contract, the client could deactivate and reactivate it.  ```sol function activate(IERC20 _token) external override onlyClient {     require(!activated[_token]);     activated[_token] = block.timestamp;     savedTokens[_token] = _token.balanceOf(address(this));     emit ShelterActivated(_token); } ``` 
