# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L192-L235   # Vulnerability details  ## Impact Using any of the `lend` function mentioned, will result in loss of funds to the lender - as the funds are transferred from them but no iPTs are sent back to them! Basically making lending via these external PTs unusable.   ## Proof of Concept There is no minting of iPTs to the lender (or at all) in the 2 `lend` functions below: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367  Corresponding to lending of (respectively): swivel element  Furthermore, in: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L227-L234 Comment says "Purchase illuminate PTs directly to msg.sender", but this is not happening. sending yield PTs at best.  ## Recommended Mitigation Steps Mint the appropriate amount of iPTs to the lender - like in the rest of the lend functions.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657   # Vulnerability details  Swapping function in Marketplace and Lender's yield() can be sandwiched as there is no slippage control option. Trades can happen at a manipulated price and end up receiving fewer tokens than current market price dictates.  Placing severity to be medium as those are system core operations, while funds there can be substantial, so sandwich attacks are often enough economically viable and thus probable, while they result in a partial fund loss.  ## Proof of Concept  All four swapping functions of Marketplace do not allow for slippage control:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189  ```solidity     /// @notice sells the PT for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of PT bought     function sellPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying tokens to sell     /// @return uint128 amount of PT received     function buyPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);     }      /// @notice sells the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying to swap     /// @return uint128 amount of underlying sold     function sellUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.sellBase(msg.sender, pool.sellBasePreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of underlying bought     function buyUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);     } ```  Similarly, Lender's yield does the swapping without the ability to control the slippage:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657  ```solidity     /// @notice transfers excess funds to yield pool after principal tokens have been lent out     /// @dev this method is only used by the yield, illuminate and swivel protocols     /// @param u address of an underlying asset     /// @param y the yield pool to lend to     /// @param a the amount of underlying tokens to lend     /// @param r the receiving address for PTs     /// @return uint256 the amount of tokens sent to the yield pool     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned);          return returned;     } ```  ## Recommended Mitigation Steps  Consider adding minimum accepted return argument to the five mentioned functions and condition execution success on it so the caller can control for the realized slippage and sustain the sandwich attacks to an extent.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128   # Vulnerability details  Illuminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.  Setting the severity to be high as this allows for system-wide stealing of user's funds.  ## Proof of Concept  Redeemer's Illuminate redeem() checks the balance of msg.sender, but burns from the balance of user supplied `o` address:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128  L120:  ```solidity uint256 amount = token.balanceOf(msg.sender); ```  L126:  ```solidity token.burn(o, amount); ```  ```solidity         address principal = IMarketPlace(marketPlace).markets(u, m, p);          if (p == uint8(MarketPlace.Principals.Illuminate)) {             // Get Illuminate's principal token             IERC5095 token = IERC5095(principal);             // Get the amount of tokens to be redeemed from the sender             uint256 amount = token.balanceOf(msg.sender);             // Make sure the market has matured             if (block.timestamp < token.maturity()) {                 revert Invalid('not matured');             }             // Burn the prinicipal token from Illuminate             token.burn(o, amount);             // Transfer the original underlying token back to the user             Safe.transferFrom(IERC20(u), lender, address(this), amount); ```  `o` address isn't validated and used as provided.  Burning proceeds as usual, Illuminate PT burns second argument `a` from the first argument `f`, i.e. `f`'s balance to be reduced by `a`:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L121-L127  ```solidity     /// @param f Address to burn from     /// @param a Amount to burn     /// @return bool true if successful     function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {         _burn(f, a);         return true;     } ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L7  ```solidity contract ERC5095 is ERC20Permit, IERC5095 { ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC20.sol#L187-L196  ```solidity     function _burn(address src, uint wad) internal virtual returns (bool) {         unchecked {             require(_balanceOf[src] >= wad, "ERC20: Insufficient balance");             _balanceOf[src] = _balanceOf[src] - wad;             _totalSupply = _totalSupply - wad;             emit Transfer(src, address(0), wad);         }          return true;     } ```  This way a malicious user owning some Illuminate PT can burn the same amount of PT as she owns from any another account, that is essentially from all other accounts, obtaining all the underlying tokens from the system. The behavior is somewhat similar to the public burn case.  ## Recommended Mitigation Steps  `o` address looks to be not needed in Illuminate PT case.  Consider burning the shares from `msg.sender`, for example:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L125-L126  ```solidity             // Burn the prinicipal token from Illuminate -           token.burn(o, amount); +           token.burn(msg.sender, amount); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120   # Vulnerability details  ## Impact Funds may be stuck when `redeeming` for Illuminate.  ## Proof of Concept Assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is to redeem the Illuminate principal held by the lender or the redeemer, then there is an issue because the wrong [balance](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120) is checked. So if no `msg.sender` has a positive balance funds will be lost.   Now assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is for users to redeem their Illuminate principal and receive the underlying as suggested by this [comment](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L127), then the underlying is not sent back to users because `Safe.transferFrom(IERC20(u), lender, address(this), amount);` send the funds to the redeemer, not the user.    ## Recommended Mitigation Steps Clarify the purpose of this function and fix the corresponding bug.  
# Lines of code  [Lender.sol#L192-L235](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235) [Lender.sol#L486-L534](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534) [Lender.sol#L545-L589](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589)   # Vulnerability details  ## Impact  Some of the ```lend``` functions do not validate addresses sent as input which could lead to a malicous user being able to mint more PT tokens than they should.  Functions affect:  - [Illuminate and Yield ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235).  - [Sense ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534).  - [APWine ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589).  ## Proof of Concept  In the Illuminate and Yield ```lend``` function:  1. Let the Yieldspace pool ```y``` be a malicious contract that implements the ```IYield``` interface.  2. The ```base``` and ```maturity``` functions for ```y``` may return any value so the conditions on lines 208 and 210 are easily passed.  3. The caller of ```lend``` sends any amount ```a``` for the desired underlying ```u```.  4. If principal token ```p``` corresponds to the Yield principal, then the ```yield``` function is called which has a [return value controlled by the malicious contract ```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L648).  5. The ```mint``` function is then called for the principal token with an underlying ```u``` and a maturity ```m``` which will then mint the ```returned``` amount of principal tokens to the malicious user.    In the Sense ```lend``` function:  1. Let the amm ```x``` input variable be a malicous contract that implements the ```ISense``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. Since the amm isn't validated, the ```swapUnderlyingForPTs``` function can return any amount for ```returned``` that is used to mint the Illuminate tokens.  4. The malicious user gains a disproportionate amount of PT.    In the APWine ```lend``` function:  1. Let the APWine ```pool``` input variable be a malicous contract that implements the ```IAPWineRouter``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. The ```swapExactAmountIn``` function of the malicious ```pool``` contract returns any amount for ```returned```.  4. The ```mint``` function is called for the PT with underlying ```u``` and maturity ```m``` with the attacker controlled ```returned``` amount.  ## Recommmended Mitigation Steps  Consider validating the input addresses of [```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L197), [```x```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L492) and [```pool```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L551) through a whitelisting procedure if possible or validating that the ```returned``` amounts correspond with the amount of PT gained from the protocols by checking the balance before and after the PTs are gained and checking the difference is equal to ```returned```.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305   # Vulnerability details  ## Impact Assuming admin decides to pause an external principle when it's dangerous, malicious or unprofitable, Bypassing the admins decision can result in loss of funds for the project.  ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305  * The principals enum `p` is only used for `unpaused(p)` modifier, and to emit an event. * Attacker can bypass the `unpaused(p)` modifier check by simply passing an enum of another principle that is not paused. * The function will just continue as normal, without any other side-effect, as if the `pause` is simple ignored.  ## Recommended Mitigation Steps Add this check at the beginning of the function (just like in similar functions of this solution) `        if (p != uint8(MarketPlace.Principals.Swivel)) {             revert Invalid('principal');         } `  
# Lines of code  [Redeemer.sol#L193](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L193)   # Vulnerability details  ## Impact  The ```maxRedeem``` function is a view function which only returns the balance of the ```Redeemer.sol``` contract. After this value is obtained, the PT is not redeemed from Notional. The user will be unable to redeem PT from Notional through ```Redeemer.sol```.  ## Proof of Concept  Notional code: ```     function maxRedeem(address owner) public view override returns (uint256) {         return balanceOf(owner);     } ```  ## Recommmended Mitigation Steps  Call [```redeem```](https://github.com/notional-finance/wrapped-fcash/blob/019cfa20369d5e0d9e7a38fea936cc649704780d/contracts/wfCashERC4626.sol#L205) from Notional using the ```amount``` from ```maxRedeem``` as the ```shares``` input after the call to ```maxRedeem```.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654   # Vulnerability details  The function `yield` is using the input from `sellBasePreview` and then using it.  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654  ```solidity     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned); ```  The output of `sellBasePreview` is meant to be used off-chain to avoid front-running and price changes, additionally no validation is performed on this value (is it zero, is it less than 95% of amount) meaning the check is equivalent to setting `returned = 0`  I'd recommend to add checks, or ideally have a trusted keeper bulk `sellBase` with an additional slippage check as the function parameter  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L136   # Vulnerability details  Redeeming APWine and Tempus PT will always fail, causing a portion of iPT to not be able to be redeemed for the underlying token.  The issue is caused by the incorrect implementation of `redeem`: ``` uint256 amount = IERC20(principal).balanceOf(lender); Safe.transferFrom(IERC20(u), lender, address(this), amount); ``` The first line correctly calculates the balance of PT token available in `Lender`. However, the second line tries to transfer the underlying token `u` instead of `principal` from Lender to `Redeemer`. Therefore, the redeeming process will always fail as both `APWine.withdraw` and `ITempus.redeemToBacking` will try to redeem non-existent PT.  ## Recommended Mitigation Steps Fix the transfer line: ``` Safe.transferFrom(IERC20(principal), lender, address(this), amount); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172   # Vulnerability details  Lender's `mint` function [does not check](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172) whether the supplied market is paused.  ## Impact Even if a market is paused due to insolvency/bugs, an attacker can issue iPTs. This renders the whole pause and insolvency protection mechanism ineffective. See POC.  ## Proof of Concept Let's say market P has become insolvent, and Illuminate pauses that market, as it doesn't want to create further bad debt. Let's say P's principal tokens's value has declined severely in the market because of the insolvency. An attacker can buy many worthless P principal tokens for cheap, then call Lender and mint from them iPT. The attacker is now owed underlying which belongs to the legitimate users. There won't be enough funds to repay everybody.  ## Recommended Mitigation Steps Check in `mint` that the market is not paused.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100   # Vulnerability details  ERC5095's `redeem`/`withdraw` allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.  ## Impact User Mal can burn more tokens than Alice allowed him to. He can set himself to be the receiver of the underlying, therefore Alice will lose funds.  ## Proof of Concept [`withdraw`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100) and [`redeem`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens: ```             require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals'); ``` But they do not update the allowances. They then call `authRedeem`, which also does not update the allowances. Therefore, an approved user could "re-use his approval" again and again and redeem whole of approver's funds to himself.  ## Recommended Mitigation Steps Update the allowances upon spending.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L262   # Vulnerability details  Sense's `redeem` can be totally DOSd due to user supplied input.  ## Impact Using this attack, Sense market can not be redeemed.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L253:#L262) is how Sense market is being redeemed: ```         IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));         uint256 amount = token.balanceOf(lender);         Safe.transferFrom(token, lender, address(this), amount);         ISense(d).redeem(o, m, amount); ``` The problem is that `d` is user supplied input and the function only tries to redeem the amount that was transferred from Lender.  A user can supply malicious `d` contract which does nothing on `redeem(o, m, amount)`. The user will then call Redeemer's `redeem` with his malicious contract. Redeemer will transfer all the prinicipal from Lender to itself, will call `d` (noop), and finish. Sense market has not been redeemed.  Now if somebody tries to call Sense market's `redeem` again, the `amount` variable will be 0, and Redeemer will try to redeem 0 from Sense.  All the original principal is locked and lost in the contract, like tears in rain.  ## Recommended Mitigation Steps I think you should either use a whitelisted Sense address, or send to `ISense(d).redeem` Redeemer's whole principal balance.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L466   # Vulnerability details  The Tempus `lend` method calculates the amount of tokens to mint as `amountReturnedFromTempus - lenderBalanceOfMetaPrincipalToken`. This seems wrong as there's no connection between the two items. Tempus has no relation to the iPT token.  ## Impact Wrong amount of iPT will be minted to the user. If the Lender contract has iPT balance, the function will revert, otherwise, user will get minted 0 iPT tokes.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L469) is how the `lend` method calculates the amount of iPT tokens to mint: ```         uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -             illuminateToken.balanceOf(address(this));         illuminateToken.mint(msg.sender, returned); ``` The Tempus `depositAndFix` method [does not return](https://etherscan.io/address/0xdB5fD0678eED82246b599da6BC36B56157E4beD8#code#F1#L127) anything. Therefore this calculation will revert if `illuminateToken.balanceOf(address(this)) > 0`, or will return 0 if the balance is 0.  [Note: there's another issue here where the depositAndFix sends wrong parameters - I will submit it in another issue.]  ## Recommended Mitigation Steps I believe that what you intended to do is to check how many Tempus principal tokens the contract received. So you need to check Lender's `x.tempusPool().principalShare()` before and after the swap, and the delta is the amount received.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L705-L720 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L659-L675   # Vulnerability details  ```withdrawFee``` of eToken requires the amount of eToken in ```Lender.sol``` >= ```fees[eToken]``` so ```Safe.transfer``` will not revert. However if the admin ```withdraw(eToken)``` first, the balance of eToken in ```Lender.sol``` will equal to zero while ```fees[eToken]``` remains the same and ```withdrawFee(eToken)``` will become unfunctioning since eToken in the contract does not match ```fees[eToken]```. The admin will need to rely on ```withdraw```, which takes 3 days before transfering, to get the future fees of eToken.  ### Mitigations add ```fees[eToken] = 0;``` after ```withdrawals[e] = 0;```  in ```withdraw```.   
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L185-L235   # Vulnerability details  Normally the amount of fees after ```calculateFee``` should be added into ```fees[u]``` so that the admin could withdraw it through ```withdrawFee```. However, illuminate ledning does not track ```fees[u]```. Therefore, the only way to get fees back is through ```withdraw``` which admin needs to wait at least 3 days before receiving the fees.    ### Mitigations  Add the amount of fee after each transaction into ```fees[u]``` like other lending method.   for example: ``` fees[u] += calculateFee(a);```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L297   # Vulnerability details  The Swivel `lend` method adds to `fees[u]` the order fee, but does not pull that fee from the user. It only pulls the order-post-fee amount.  ## Impact `withdrawFee` will fail, as it tries to transfer more tokens than are in the contract.  ## Proof of Concept The Swivel `lend` method [sums up](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L279:#L283) the fees to `totalFee`, and the amount to send to Swivel in `lent`: ```                     totalFee += fee;                     // Amount lent for this order                     uint256 amountLent = amount - fee;                     // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                     lent += amountLent; ``` It then [increments](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L294:#L297) `fees[u]` by `totalFee`, but only pulls from the user `lent`: ```             fees[u] += totalFee;             // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent); ``` Therefore, `totalFee` has not been pulled from the user. The `fees` variable now includes tokens which are not in the contract, and `withdrawFee` will fail as [it tries to transfer](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L667) `fees[u]`.  ## Recommended Mitigation Steps Pull `lent + totalFee` from the user.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187   # Vulnerability details  ## Impact Redeemer.redeem() for Element withdraws PT to wrong address. This might cause a result of loss of PT.   ## Proof of Concept According to the ReadMe.md, Redeemer should transfer external principal tokens from Lender.sol to Redeemer.sol. But it transfers to the "marketPlace" and it would lose the PT.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Modify [IElementToken(principal).withdrawPrincipal(amount, marketPlace);](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187) like this.  ``` IElementToken(principal).withdrawPrincipal(amount, address(this)); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L446   # Vulnerability details  ## Impact The lend function for tempus will fail with the right market.  ## Proof of concept checks `if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u))`, while it should check `ITempus(principal).backingToken()`   ## Recommendation Do this instead: ```     if (ITempus(principal).backingToken() != IERC20Metadata(u)) ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Safe.sol#L82-L105   # Vulnerability details   ## `Safe.sol` allow success transaction to fail Some ERC20 token implementations return more than 32 bytes(common Curve token). This can be a real concern since all core component using the same Safe Transfer Lib   After some test using  [https://github.com/Rari-Capital/solmate.git]  ``` [BAIL] testTransferFromWithReturnsTooMuch() [FAIL] testTransferFromWithReturnsTooMuch(address,address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 0x0000000000000000000000000000000000000001, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0x) [BAIL] testApproveWithReturnsTooMuch() [FAIL] testFailApproveWithReturnsTwo(address,uint256,bytes). Counterexample: (0x000000000000000000000000000000000004C0E4, 0, 0x) [FAIL] testApproveWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 1, 0x) [FAIL] testTransferWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000fFFFf, 27379694730619439495811032571422462501613862458272780721729846947764021554765, 0x) [BAIL] testTransferWithReturnsTooMuch() [FAIL] testFailTransferWithGarbage(address,uint256,bytes,bytes). Counterexample: (0x00000000000000000000000000000000000F40ae, 68959440145808540021340254471931488759807906017241826129032747446, 0x15dedf2835614b24353f20baa93783e58366c16defd811eddd5de9d9057489ca, 0xd946b45606da60c706edf8c4eb76e0d281d8f063f14850d952ea10c697f0931756bec369411fa90953093f29086d44a50b2cf829a5815f5a72124ff447ac4a69) ```   ## Impact If a transaction fail or success will not be considered and this will pass any call of Safe lib  ## Proof of Concept  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol  Safe lib used here ``` ./lender/Lender.sol ./marketplace/marketplace.sol ./redeemer/redeemer.sol ```      1- no data     if iszero(r) {         // Copy the revert message into memory.         returndatacopy(0, 0, returnDataSize)          // Revert with the same message.         revert(0, returnDataSize)     }      2- returndatasize > 32 bytes     default {         // It returned some malformed input.         result := 0     }      3- reverting     require(success(result), 'transfer from failed');  ### Tools Used dapp-tools, vim  ### Recommended Mitigation Steps Use the latest Safe Transfer lib available   
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L411   # Vulnerability details  ## Impact  The function `swapExactTokensForTokens()` will return and array with the 0 index being the input amount follow by each output amount. The 0 index is incorrectly used in Pendle `lend()` function as the output amount. As a result the value of `returned` will be the invalid (i.e. the input rather than the output).  Since this impacts how many PTs will be minted to the `msg.sender`, the value will very likely be significantly over or under stated depending on the exchange rate. Hence the `msg.sender` will receive an invalid number of PT tokens.  ## Proof of Concept  ```solidity             address[] memory path = new address[](2);             path[0] = u;             path[1] = principal;              returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0]; ```   ## Recommended Mitigation Steps  The amount of `principal` returned should be index 1 of the array returned by `swapExactTokensForTokens()`.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L299   # Vulnerability details  ## Impact  Swivel `lend()` does not validate the `o.exit` and `o.vault` for each order before making the external call to Swivel. These values determine which internal functions is [called in Swivel](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L64-L77).  The intended code path is `initiateZcTokenFillingVaultInitiate()` which takes the underlying tokens and mints zcTokens to the `Lender`. If one of the other functions is called the accounting in `lend()`. Swivel may transfer more tokens from `Lender` to `Swivel` than paid for by the caller of `lend()`.  The impact is that underlying tokens may be stolen from `Lender`.  ## Proof of Concept  Consider the example where [initiateZcTokenFillingZcTokenExit()](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L162) is called. This will transfer `a - premiumFilled + fee` from `Lender` to `Swivel` rather than the expected `a + fee`.  ## Recommended Mitigation Steps  In `lend()` restrict the values of `o.exit` and `o.vault` so only one case can be triggered in `Swivel.initiate()`.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280   # Vulnerability details  ## Impact  There is a division before multiplication bug that exists in [`lend()`](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280) for the Swivel case.  If `order.premium` is less than `order.principal` then `returned` will round to zero due to the integer rounding.  When this occurs the user's funds are essentially lost. That is because they transfer in the underlying tokens but the amount sent to `yield(u, y, returned, address(this))` will be zero.  ## Proof of Concept  ```solidity     function lend(         uint8 p,         address u,         uint256 m,         uint256[] calldata a,         address y,         Swivel.Order[] calldata o,         Swivel.Components[] calldata s     ) public unpaused(p) returns (uint256) {          // lent represents the number of underlying tokens lent         uint256 lent;         // returned represents the number of underlying tokens to lend to yield         uint256 returned;          {             uint256 totalFee;             // iterate through each order a calculate the total lent and returned             for (uint256 i = 0; i < o.length; ) {                 Swivel.Order memory order = o[i];                 // Require the Swivel order provided matches the underlying and maturity market provided                 if (order.underlying != u) {                     revert NotEqual('underlying');                 } else if (order.maturity > m) {                     revert NotEqual('maturity');                 }                 // Determine the fee                 uint256 fee = calculateFee(a[i]);                 // Track accumulated fees                 totalFee += fee;                 // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                 lent += a[i] - fee;                 // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)                 returned += (a[i] - fee) * (order.premium / order.principal);                  unchecked {                     i++;                 }             }             // Track accumulated fee             fees[u] += totalFee;              // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);             // fill the orders on swivel protocol             ISwivel(swivelAddr).initiate(o, a, s);              yield(u, y, returned, address(this));         }          emit Lend(p, u, m, lent);         return lent;     } ```  Specifically the function `returned += (a[i] - fee) * (order.premium / order.principal);`  ## Recommended Mitigation Steps  The multiplication should occur before division, that is `((a[i] - fee) * order.premium) / order.principal);`.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453   # Vulnerability details  ## Impact The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus. This will cause the contract to mint an incorrect number of illuminateTokens to the user. ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453 https://github.com/tempus-finance/tempus-protocol/blob/master/contracts/TempusController.sol#L52-L76 ## Tools Used None ## Recommended Mitigation Steps interfaces.sol ``` interface ITempus {     function maturityTime() external view returns (uint256);      function yieldBearingToken() external view returns (IERC20Metadata);      function depositAndFix(         Any,         Any,         uint256,         bool,         uint256,         uint256     ) external returns (uint256, uint256); } ``` Lender.sol ```         (,uint256 returned) = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d);         returned -= illuminateToken.balanceOf(address(this)); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/3ca41a9f529980b17fdc67baf8cbee5a8035afab/marketplace/MarketPlace.sol#L136-L189   # Vulnerability details  ## Impact Fund loss from marketplace  ## Proof of Concept sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying are all unpermissioned and use marketplace funds to complete the action but send the resulting tokens to msg.sender. This means that any address can call these functions and steal the resulting funds  ## Tools Used  ## Recommended Mitigation Steps All functions should use safetransfer to get funds from msg.sender not from marketplace  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L192-L235   # Vulnerability details  ## Impact Using any of the `lend` function mentioned, will result in loss of funds to the lender - as the funds are transferred from them but no iPTs are sent back to them! Basically making lending via these external PTs unusable.   ## Proof of Concept There is no minting of iPTs to the lender (or at all) in the 2 `lend` functions below: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367  Corresponding to lending of (respectively): swivel element  Furthermore, in: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L227-L234 Comment says "Purchase illuminate PTs directly to msg.sender", but this is not happening. sending yield PTs at best.  ## Recommended Mitigation Steps Mint the appropriate amount of iPTs to the lender - like in the rest of the lend functions.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657   # Vulnerability details  Swapping function in Marketplace and Lender's yield() can be sandwiched as there is no slippage control option. Trades can happen at a manipulated price and end up receiving fewer tokens than current market price dictates.  Placing severity to be medium as those are system core operations, while funds there can be substantial, so sandwich attacks are often enough economically viable and thus probable, while they result in a partial fund loss.  ## Proof of Concept  All four swapping functions of Marketplace do not allow for slippage control:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189  ```solidity     /// @notice sells the PT for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of PT bought     function sellPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying tokens to sell     /// @return uint128 amount of PT received     function buyPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);     }      /// @notice sells the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying to swap     /// @return uint128 amount of underlying sold     function sellUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.sellBase(msg.sender, pool.sellBasePreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of underlying bought     function buyUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);     } ```  Similarly, Lender's yield does the swapping without the ability to control the slippage:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657  ```solidity     /// @notice transfers excess funds to yield pool after principal tokens have been lent out     /// @dev this method is only used by the yield, illuminate and swivel protocols     /// @param u address of an underlying asset     /// @param y the yield pool to lend to     /// @param a the amount of underlying tokens to lend     /// @param r the receiving address for PTs     /// @return uint256 the amount of tokens sent to the yield pool     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned);          return returned;     } ```  ## Recommended Mitigation Steps  Consider adding minimum accepted return argument to the five mentioned functions and condition execution success on it so the caller can control for the realized slippage and sustain the sandwich attacks to an extent.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128   # Vulnerability details  Illuminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.  Setting the severity to be high as this allows for system-wide stealing of user's funds.  ## Proof of Concept  Redeemer's Illuminate redeem() checks the balance of msg.sender, but burns from the balance of user supplied `o` address:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128  L120:  ```solidity uint256 amount = token.balanceOf(msg.sender); ```  L126:  ```solidity token.burn(o, amount); ```  ```solidity         address principal = IMarketPlace(marketPlace).markets(u, m, p);          if (p == uint8(MarketPlace.Principals.Illuminate)) {             // Get Illuminate's principal token             IERC5095 token = IERC5095(principal);             // Get the amount of tokens to be redeemed from the sender             uint256 amount = token.balanceOf(msg.sender);             // Make sure the market has matured             if (block.timestamp < token.maturity()) {                 revert Invalid('not matured');             }             // Burn the prinicipal token from Illuminate             token.burn(o, amount);             // Transfer the original underlying token back to the user             Safe.transferFrom(IERC20(u), lender, address(this), amount); ```  `o` address isn't validated and used as provided.  Burning proceeds as usual, Illuminate PT burns second argument `a` from the first argument `f`, i.e. `f`'s balance to be reduced by `a`:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L121-L127  ```solidity     /// @param f Address to burn from     /// @param a Amount to burn     /// @return bool true if successful     function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {         _burn(f, a);         return true;     } ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L7  ```solidity contract ERC5095 is ERC20Permit, IERC5095 { ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC20.sol#L187-L196  ```solidity     function _burn(address src, uint wad) internal virtual returns (bool) {         unchecked {             require(_balanceOf[src] >= wad, "ERC20: Insufficient balance");             _balanceOf[src] = _balanceOf[src] - wad;             _totalSupply = _totalSupply - wad;             emit Transfer(src, address(0), wad);         }          return true;     } ```  This way a malicious user owning some Illuminate PT can burn the same amount of PT as she owns from any another account, that is essentially from all other accounts, obtaining all the underlying tokens from the system. The behavior is somewhat similar to the public burn case.  ## Recommended Mitigation Steps  `o` address looks to be not needed in Illuminate PT case.  Consider burning the shares from `msg.sender`, for example:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L125-L126  ```solidity             // Burn the prinicipal token from Illuminate -           token.burn(o, amount); +           token.burn(msg.sender, amount); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120   # Vulnerability details  ## Impact Funds may be stuck when `redeeming` for Illuminate.  ## Proof of Concept Assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is to redeem the Illuminate principal held by the lender or the redeemer, then there is an issue because the wrong [balance](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120) is checked. So if no `msg.sender` has a positive balance funds will be lost.   Now assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is for users to redeem their Illuminate principal and receive the underlying as suggested by this [comment](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L127), then the underlying is not sent back to users because `Safe.transferFrom(IERC20(u), lender, address(this), amount);` send the funds to the redeemer, not the user.    ## Recommended Mitigation Steps Clarify the purpose of this function and fix the corresponding bug.  
# Lines of code  [Lender.sol#L192-L235](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235) [Lender.sol#L486-L534](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534) [Lender.sol#L545-L589](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589)   # Vulnerability details  ## Impact  Some of the ```lend``` functions do not validate addresses sent as input which could lead to a malicous user being able to mint more PT tokens than they should.  Functions affect:  - [Illuminate and Yield ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235).  - [Sense ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534).  - [APWine ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589).  ## Proof of Concept  In the Illuminate and Yield ```lend``` function:  1. Let the Yieldspace pool ```y``` be a malicious contract that implements the ```IYield``` interface.  2. The ```base``` and ```maturity``` functions for ```y``` may return any value so the conditions on lines 208 and 210 are easily passed.  3. The caller of ```lend``` sends any amount ```a``` for the desired underlying ```u```.  4. If principal token ```p``` corresponds to the Yield principal, then the ```yield``` function is called which has a [return value controlled by the malicious contract ```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L648).  5. The ```mint``` function is then called for the principal token with an underlying ```u``` and a maturity ```m``` which will then mint the ```returned``` amount of principal tokens to the malicious user.    In the Sense ```lend``` function:  1. Let the amm ```x``` input variable be a malicous contract that implements the ```ISense``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. Since the amm isn't validated, the ```swapUnderlyingForPTs``` function can return any amount for ```returned``` that is used to mint the Illuminate tokens.  4. The malicious user gains a disproportionate amount of PT.    In the APWine ```lend``` function:  1. Let the APWine ```pool``` input variable be a malicous contract that implements the ```IAPWineRouter``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. The ```swapExactAmountIn``` function of the malicious ```pool``` contract returns any amount for ```returned```.  4. The ```mint``` function is called for the PT with underlying ```u``` and maturity ```m``` with the attacker controlled ```returned``` amount.  ## Recommmended Mitigation Steps  Consider validating the input addresses of [```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L197), [```x```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L492) and [```pool```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L551) through a whitelisting procedure if possible or validating that the ```returned``` amounts correspond with the amount of PT gained from the protocols by checking the balance before and after the PTs are gained and checking the difference is equal to ```returned```.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305   # Vulnerability details  ## Impact Assuming admin decides to pause an external principle when it's dangerous, malicious or unprofitable, Bypassing the admins decision can result in loss of funds for the project.  ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305  * The principals enum `p` is only used for `unpaused(p)` modifier, and to emit an event. * Attacker can bypass the `unpaused(p)` modifier check by simply passing an enum of another principle that is not paused. * The function will just continue as normal, without any other side-effect, as if the `pause` is simple ignored.  ## Recommended Mitigation Steps Add this check at the beginning of the function (just like in similar functions of this solution) `        if (p != uint8(MarketPlace.Principals.Swivel)) {             revert Invalid('principal');         } `  
# Lines of code  [Redeemer.sol#L193](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L193)   # Vulnerability details  ## Impact  The ```maxRedeem``` function is a view function which only returns the balance of the ```Redeemer.sol``` contract. After this value is obtained, the PT is not redeemed from Notional. The user will be unable to redeem PT from Notional through ```Redeemer.sol```.  ## Proof of Concept  Notional code: ```     function maxRedeem(address owner) public view override returns (uint256) {         return balanceOf(owner);     } ```  ## Recommmended Mitigation Steps  Call [```redeem```](https://github.com/notional-finance/wrapped-fcash/blob/019cfa20369d5e0d9e7a38fea936cc649704780d/contracts/wfCashERC4626.sol#L205) from Notional using the ```amount``` from ```maxRedeem``` as the ```shares``` input after the call to ```maxRedeem```.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654   # Vulnerability details  The function `yield` is using the input from `sellBasePreview` and then using it.  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654  ```solidity     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned); ```  The output of `sellBasePreview` is meant to be used off-chain to avoid front-running and price changes, additionally no validation is performed on this value (is it zero, is it less than 95% of amount) meaning the check is equivalent to setting `returned = 0`  I'd recommend to add checks, or ideally have a trusted keeper bulk `sellBase` with an additional slippage check as the function parameter  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L136   # Vulnerability details  Redeeming APWine and Tempus PT will always fail, causing a portion of iPT to not be able to be redeemed for the underlying token.  The issue is caused by the incorrect implementation of `redeem`: ``` uint256 amount = IERC20(principal).balanceOf(lender); Safe.transferFrom(IERC20(u), lender, address(this), amount); ``` The first line correctly calculates the balance of PT token available in `Lender`. However, the second line tries to transfer the underlying token `u` instead of `principal` from Lender to `Redeemer`. Therefore, the redeeming process will always fail as both `APWine.withdraw` and `ITempus.redeemToBacking` will try to redeem non-existent PT.  ## Recommended Mitigation Steps Fix the transfer line: ``` Safe.transferFrom(IERC20(principal), lender, address(this), amount); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172   # Vulnerability details  Lender's `mint` function [does not check](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172) whether the supplied market is paused.  ## Impact Even if a market is paused due to insolvency/bugs, an attacker can issue iPTs. This renders the whole pause and insolvency protection mechanism ineffective. See POC.  ## Proof of Concept Let's say market P has become insolvent, and Illuminate pauses that market, as it doesn't want to create further bad debt. Let's say P's principal tokens's value has declined severely in the market because of the insolvency. An attacker can buy many worthless P principal tokens for cheap, then call Lender and mint from them iPT. The attacker is now owed underlying which belongs to the legitimate users. There won't be enough funds to repay everybody.  ## Recommended Mitigation Steps Check in `mint` that the market is not paused.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100   # Vulnerability details  ERC5095's `redeem`/`withdraw` allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.  ## Impact User Mal can burn more tokens than Alice allowed him to. He can set himself to be the receiver of the underlying, therefore Alice will lose funds.  ## Proof of Concept [`withdraw`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100) and [`redeem`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens: ```             require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals'); ``` But they do not update the allowances. They then call `authRedeem`, which also does not update the allowances. Therefore, an approved user could "re-use his approval" again and again and redeem whole of approver's funds to himself.  ## Recommended Mitigation Steps Update the allowances upon spending.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L262   # Vulnerability details  Sense's `redeem` can be totally DOSd due to user supplied input.  ## Impact Using this attack, Sense market can not be redeemed.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L253:#L262) is how Sense market is being redeemed: ```         IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));         uint256 amount = token.balanceOf(lender);         Safe.transferFrom(token, lender, address(this), amount);         ISense(d).redeem(o, m, amount); ``` The problem is that `d` is user supplied input and the function only tries to redeem the amount that was transferred from Lender.  A user can supply malicious `d` contract which does nothing on `redeem(o, m, amount)`. The user will then call Redeemer's `redeem` with his malicious contract. Redeemer will transfer all the prinicipal from Lender to itself, will call `d` (noop), and finish. Sense market has not been redeemed.  Now if somebody tries to call Sense market's `redeem` again, the `amount` variable will be 0, and Redeemer will try to redeem 0 from Sense.  All the original principal is locked and lost in the contract, like tears in rain.  ## Recommended Mitigation Steps I think you should either use a whitelisted Sense address, or send to `ISense(d).redeem` Redeemer's whole principal balance.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L466   # Vulnerability details  The Tempus `lend` method calculates the amount of tokens to mint as `amountReturnedFromTempus - lenderBalanceOfMetaPrincipalToken`. This seems wrong as there's no connection between the two items. Tempus has no relation to the iPT token.  ## Impact Wrong amount of iPT will be minted to the user. If the Lender contract has iPT balance, the function will revert, otherwise, user will get minted 0 iPT tokes.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L469) is how the `lend` method calculates the amount of iPT tokens to mint: ```         uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -             illuminateToken.balanceOf(address(this));         illuminateToken.mint(msg.sender, returned); ``` The Tempus `depositAndFix` method [does not return](https://etherscan.io/address/0xdB5fD0678eED82246b599da6BC36B56157E4beD8#code#F1#L127) anything. Therefore this calculation will revert if `illuminateToken.balanceOf(address(this)) > 0`, or will return 0 if the balance is 0.  [Note: there's another issue here where the depositAndFix sends wrong parameters - I will submit it in another issue.]  ## Recommended Mitigation Steps I believe that what you intended to do is to check how many Tempus principal tokens the contract received. So you need to check Lender's `x.tempusPool().principalShare()` before and after the swap, and the delta is the amount received.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L705-L720 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L659-L675   # Vulnerability details  ```withdrawFee``` of eToken requires the amount of eToken in ```Lender.sol``` >= ```fees[eToken]``` so ```Safe.transfer``` will not revert. However if the admin ```withdraw(eToken)``` first, the balance of eToken in ```Lender.sol``` will equal to zero while ```fees[eToken]``` remains the same and ```withdrawFee(eToken)``` will become unfunctioning since eToken in the contract does not match ```fees[eToken]```. The admin will need to rely on ```withdraw```, which takes 3 days before transfering, to get the future fees of eToken.  ### Mitigations add ```fees[eToken] = 0;``` after ```withdrawals[e] = 0;```  in ```withdraw```.   
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L185-L235   # Vulnerability details  Normally the amount of fees after ```calculateFee``` should be added into ```fees[u]``` so that the admin could withdraw it through ```withdrawFee```. However, illuminate ledning does not track ```fees[u]```. Therefore, the only way to get fees back is through ```withdraw``` which admin needs to wait at least 3 days before receiving the fees.    ### Mitigations  Add the amount of fee after each transaction into ```fees[u]``` like other lending method.   for example: ``` fees[u] += calculateFee(a);```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L297   # Vulnerability details  The Swivel `lend` method adds to `fees[u]` the order fee, but does not pull that fee from the user. It only pulls the order-post-fee amount.  ## Impact `withdrawFee` will fail, as it tries to transfer more tokens than are in the contract.  ## Proof of Concept The Swivel `lend` method [sums up](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L279:#L283) the fees to `totalFee`, and the amount to send to Swivel in `lent`: ```                     totalFee += fee;                     // Amount lent for this order                     uint256 amountLent = amount - fee;                     // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                     lent += amountLent; ``` It then [increments](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L294:#L297) `fees[u]` by `totalFee`, but only pulls from the user `lent`: ```             fees[u] += totalFee;             // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent); ``` Therefore, `totalFee` has not been pulled from the user. The `fees` variable now includes tokens which are not in the contract, and `withdrawFee` will fail as [it tries to transfer](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L667) `fees[u]`.  ## Recommended Mitigation Steps Pull `lent + totalFee` from the user.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187   # Vulnerability details  ## Impact Redeemer.redeem() for Element withdraws PT to wrong address. This might cause a result of loss of PT.   ## Proof of Concept According to the ReadMe.md, Redeemer should transfer external principal tokens from Lender.sol to Redeemer.sol. But it transfers to the "marketPlace" and it would lose the PT.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Modify [IElementToken(principal).withdrawPrincipal(amount, marketPlace);](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187) like this.  ``` IElementToken(principal).withdrawPrincipal(amount, address(this)); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L446   # Vulnerability details  ## Impact The lend function for tempus will fail with the right market.  ## Proof of concept checks `if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u))`, while it should check `ITempus(principal).backingToken()`   ## Recommendation Do this instead: ```     if (ITempus(principal).backingToken() != IERC20Metadata(u)) ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Safe.sol#L82-L105   # Vulnerability details   ## `Safe.sol` allow success transaction to fail Some ERC20 token implementations return more than 32 bytes(common Curve token). This can be a real concern since all core component using the same Safe Transfer Lib   After some test using  [https://github.com/Rari-Capital/solmate.git]  ``` [BAIL] testTransferFromWithReturnsTooMuch() [FAIL] testTransferFromWithReturnsTooMuch(address,address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 0x0000000000000000000000000000000000000001, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0x) [BAIL] testApproveWithReturnsTooMuch() [FAIL] testFailApproveWithReturnsTwo(address,uint256,bytes). Counterexample: (0x000000000000000000000000000000000004C0E4, 0, 0x) [FAIL] testApproveWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 1, 0x) [FAIL] testTransferWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000fFFFf, 27379694730619439495811032571422462501613862458272780721729846947764021554765, 0x) [BAIL] testTransferWithReturnsTooMuch() [FAIL] testFailTransferWithGarbage(address,uint256,bytes,bytes). Counterexample: (0x00000000000000000000000000000000000F40ae, 68959440145808540021340254471931488759807906017241826129032747446, 0x15dedf2835614b24353f20baa93783e58366c16defd811eddd5de9d9057489ca, 0xd946b45606da60c706edf8c4eb76e0d281d8f063f14850d952ea10c697f0931756bec369411fa90953093f29086d44a50b2cf829a5815f5a72124ff447ac4a69) ```   ## Impact If a transaction fail or success will not be considered and this will pass any call of Safe lib  ## Proof of Concept  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol  Safe lib used here ``` ./lender/Lender.sol ./marketplace/marketplace.sol ./redeemer/redeemer.sol ```      1- no data     if iszero(r) {         // Copy the revert message into memory.         returndatacopy(0, 0, returnDataSize)          // Revert with the same message.         revert(0, returnDataSize)     }      2- returndatasize > 32 bytes     default {         // It returned some malformed input.         result := 0     }      3- reverting     require(success(result), 'transfer from failed');  ### Tools Used dapp-tools, vim  ### Recommended Mitigation Steps Use the latest Safe Transfer lib available   
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L411   # Vulnerability details  ## Impact  The function `swapExactTokensForTokens()` will return and array with the 0 index being the input amount follow by each output amount. The 0 index is incorrectly used in Pendle `lend()` function as the output amount. As a result the value of `returned` will be the invalid (i.e. the input rather than the output).  Since this impacts how many PTs will be minted to the `msg.sender`, the value will very likely be significantly over or under stated depending on the exchange rate. Hence the `msg.sender` will receive an invalid number of PT tokens.  ## Proof of Concept  ```solidity             address[] memory path = new address[](2);             path[0] = u;             path[1] = principal;              returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0]; ```   ## Recommended Mitigation Steps  The amount of `principal` returned should be index 1 of the array returned by `swapExactTokensForTokens()`.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L299   # Vulnerability details  ## Impact  Swivel `lend()` does not validate the `o.exit` and `o.vault` for each order before making the external call to Swivel. These values determine which internal functions is [called in Swivel](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L64-L77).  The intended code path is `initiateZcTokenFillingVaultInitiate()` which takes the underlying tokens and mints zcTokens to the `Lender`. If one of the other functions is called the accounting in `lend()`. Swivel may transfer more tokens from `Lender` to `Swivel` than paid for by the caller of `lend()`.  The impact is that underlying tokens may be stolen from `Lender`.  ## Proof of Concept  Consider the example where [initiateZcTokenFillingZcTokenExit()](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L162) is called. This will transfer `a - premiumFilled + fee` from `Lender` to `Swivel` rather than the expected `a + fee`.  ## Recommended Mitigation Steps  In `lend()` restrict the values of `o.exit` and `o.vault` so only one case can be triggered in `Swivel.initiate()`.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280   # Vulnerability details  ## Impact  There is a division before multiplication bug that exists in [`lend()`](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280) for the Swivel case.  If `order.premium` is less than `order.principal` then `returned` will round to zero due to the integer rounding.  When this occurs the user's funds are essentially lost. That is because they transfer in the underlying tokens but the amount sent to `yield(u, y, returned, address(this))` will be zero.  ## Proof of Concept  ```solidity     function lend(         uint8 p,         address u,         uint256 m,         uint256[] calldata a,         address y,         Swivel.Order[] calldata o,         Swivel.Components[] calldata s     ) public unpaused(p) returns (uint256) {          // lent represents the number of underlying tokens lent         uint256 lent;         // returned represents the number of underlying tokens to lend to yield         uint256 returned;          {             uint256 totalFee;             // iterate through each order a calculate the total lent and returned             for (uint256 i = 0; i < o.length; ) {                 Swivel.Order memory order = o[i];                 // Require the Swivel order provided matches the underlying and maturity market provided                 if (order.underlying != u) {                     revert NotEqual('underlying');                 } else if (order.maturity > m) {                     revert NotEqual('maturity');                 }                 // Determine the fee                 uint256 fee = calculateFee(a[i]);                 // Track accumulated fees                 totalFee += fee;                 // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                 lent += a[i] - fee;                 // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)                 returned += (a[i] - fee) * (order.premium / order.principal);                  unchecked {                     i++;                 }             }             // Track accumulated fee             fees[u] += totalFee;              // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);             // fill the orders on swivel protocol             ISwivel(swivelAddr).initiate(o, a, s);              yield(u, y, returned, address(this));         }          emit Lend(p, u, m, lent);         return lent;     } ```  Specifically the function `returned += (a[i] - fee) * (order.premium / order.principal);`  ## Recommended Mitigation Steps  The multiplication should occur before division, that is `((a[i] - fee) * order.premium) / order.principal);`.  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453   # Vulnerability details  ## Impact The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus. This will cause the contract to mint an incorrect number of illuminateTokens to the user. ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453 https://github.com/tempus-finance/tempus-protocol/blob/master/contracts/TempusController.sol#L52-L76 ## Tools Used None ## Recommended Mitigation Steps interfaces.sol ``` interface ITempus {     function maturityTime() external view returns (uint256);      function yieldBearingToken() external view returns (IERC20Metadata);      function depositAndFix(         Any,         Any,         uint256,         bool,         uint256,         uint256     ) external returns (uint256, uint256); } ``` Lender.sol ```         (,uint256 returned) = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d);         returned -= illuminateToken.balanceOf(address(this)); ```  
# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/3ca41a9f529980b17fdc67baf8cbee5a8035afab/marketplace/MarketPlace.sol#L136-L189   # Vulnerability details  ## Impact Fund loss from marketplace  ## Proof of Concept sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying are all unpermissioned and use marketplace funds to complete the action but send the resulting tokens to msg.sender. This means that any address can call these functions and steal the resulting funds  ## Tools Used  ## Recommended Mitigation Steps All functions should use safetransfer to get funds from msg.sender not from marketplace  
