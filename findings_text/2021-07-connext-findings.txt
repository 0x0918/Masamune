# Handle  shw   # Vulnerability details  ## Impact  In general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L122-L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125) [TransactionManager.sol#L254-L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260)  ## Recommended Mitigation Steps  Rewrite #L122-L125 as follows:  ```solidity uint256 balance = routerBalances[msg.sender][assetId]; require(balance >= amount, "removeLiquidity: INSUFFICIENT_FUNDS");  // Update router balances routerBalances[msg.sender][assetId] = balance - amount; ```  Rewrite #L254-L260 as follows:  ```solidity uint256 balance = routerBalances[invariantData.router][invariantData.receivingAssetId]; require(     balance >= amount,     "prepare: INSUFFICIENT_LIQUIDITY" );  // Decrement the router liquidity routerBalances[invariantData.router][invariantData.receivingAssetId] = balance - amount; ```  
# Handle  shw   # Vulnerability details  ## Impact  Using the `unchecked` keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.  ## Proof of Concept  We can apply the `unchecked` keyword in the following lines of code since there are `require` statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  Referenced code: [TransactionManager.sol#L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L125) [TransactionManager.sol#L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L260) [TransactionManager.sol#L364](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) [TransactionManager.sol#L520](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L520)  ## Recommended Mitigation Steps  For example, change the code at line 364 to:  ```solidity unchecked {     uint256 toSend = txData.amount - relayerFee; } ```  
# Handle  shw   # Vulnerability details  ## Impact  When a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than that is recorded in the `routerBalances` variable.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97) [TransactionManager.sol#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101)  ## Recommended Mitigation Steps  Get the received token amount by calculating the difference of token balance before and after the transfer, for example:  ```solidity uint256 balanceBefore = getOwnBalance(assetId); require(LibERC20.transferFrom(assetId, router, address(this), amount, "addLiquidity: ERC20_TRANSFER_FAILED"); uint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;  // Update the router balances routerBalances[router][assetId] += receivedAmount; ```  
# Handle  0xsanson   # Vulnerability details  ## Impact The currect implementation of NatSpec of fulfill function lacks @param callData  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps It's suggested to complete adding @param callData  
# Handle  hrkrshnn   # Vulnerability details  ## Revert strings  ### Consider using custom errors instead of revert strings  Can save gas when the revert condition has been met. And also during runtime.  ### Consider shortening revert strings to less than 32 bytes  Revert strings more than 32 bytes require at least one additional `mstore`, along with additional operations for computing memory offset, etc.  Even if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.  Here are some examples of strings that can be shortened from codebase:  ``` txt ./contracts/TransactionManager.sol:96:      "addLiquidity: ETH_WITH_ERC_TRANSFER" ./contracts/TransactionManager.sol:97:      "addLiquidity: ERC20_TRANSFER_FAILED" ./contracts/TransactionManager.sol:122:     "removeLiquidity: INSUFFICIENT_FUNDS" ```  Note that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.    
# Handle  pauliax   # Vulnerability details  ## Impact I think it would make sense not to check the user's signature in recoverCancelSignature or recoverFulfillSignature if the caller is the user himself.   ## Recommended Mitigation Steps Replace: require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, "cancel: INVALID_SIGNATURE"); require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, "fulfill: INVALID_SIGNATURE"); with: require(msg.sender == txData.user || recoverCancelSignature(txData, relayerFee, signature) == txData.user, "cancel: INVALID_SIGNATURE"); require(msg.sender == txData.user || recoverFulfillSignature(txData, relayerFee, signature) == txData.user, "fulfill: INVALID_SIGNATURE");  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact  The code uses `hashVariantTransactionData` to verify the hash of the VariantTransactionData It also uses ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  To generate VariantTransactionData with `preparedBlockNumber` set to 0  A simple refactoring of: ```   function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     return hashVariantTransaction(txData.amount, txData.expiry, txData.preparedBlockNumber)   }    function hashVariantTransaction(uint256 amount, uint256 expiry, uint256 prepareBlocNumber) internal pure returns (bytes32) {     return keccak256(abi.encode(VariantTransactionData({       amount: amount,       expiry: expiry,       preparedBlockNumber: preparedBlockNumber     })));   }  ```  This would allow to further steamline the code from ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  to  ```     variantTransactionData[digest] = hashVariantTransaction(txData.amount, txData.expiry, 0) ```  ## Recommended Mitigation Steps This has no particular benefit beside making all code related to Variant Data consistent   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks are in general a best-practice. However, addLiquidity() and removeLiquidity() are missing zero-address checks on router and recipient addresses respectively.    addLiquidity() on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.  For ERC20 assets, token.transfer() generally implements this check but the Eth transfer using transferEth() does not have this check and calls addr.call(value) which will lead to burning in the case of removeLiquidity().   The checks may be more important because assetID is 0 for Eth. So a router may accidentally use 0 values for both assetID and router/recipient.  There is also a missing zero-address check on sendingChainFallback which is relevant for Eth transfers in cancel(). The comment on L178 indicates the need for this but the following check on L179 ends up checking receivingAddress instead (which is also necessary).   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L101-L104  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L116 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128-L131  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permissionless, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option.  ## Proof of Concept  Lack of owner, whitelisting, thresholds, pause/unpause in the protocol.  See https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present) then the cancel transaction from the relayer will always revert and user’s funds will remain locked on the sending chain.  Impact: Expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change receivingAssetId to sendingAssetId in transferAsset() on L514.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  During fulfill() on the receiving chain, if the user has set up an external contract at txData.callTo, the catch blocks for both IFulfillHelper.addFunds() and IFulfillHelper.excute() perform transferAsset to the predetermined fallback address txData.receivingAddress.  If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.   Scenario: User sets up receiver chain txData.callTo contract such that both addFunds() and execute() calls revert and that will let him get twice the toSend amount credited to the receivingAddress. So effectively, Alice locks 100 tokenAs on chain A and can get 200 tokenAs (or twice the amount of any token she is supposed to get on chainB from the router), minus relayer fee, on chainB. Router liquidity is double-dipped by Alice and router loses funds.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The second catch block for execute() should likely not have the transferAsset() call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Checking if toSend > 0 before making the external library call to LibAsset.transferAsset() can save 2600 gas by avoiding the external call in such situations.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L375-L380  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L364  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toSend > 0 to predicate on L375 similar to check on L387.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.  Functions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two SSTORES (getting more expensive with the London fork EIP-3529) to its _status state variable.   Example 1: In addLiquidity(), by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.  Example 2: removeLiquidity() already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.  prepare() can be slightly restructured to follow CEI pattern as well. However, fulfill() and cancel() are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.  Impact: Save gas by removing nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600.   Impact: A LibAsset.transferAsset() call from TransactionManager.sol makes LibERC20.transfer() call for ERC20 which in turn makes another external call to LibUtils.revertIfCallFailed() in wrapCall. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call assetId.call(..) external calls -> LibAsset -> LibERC20 -> LibUtils, which costs 2600*3 = 7800 gas.   Combining these functions into a single library or making them all internal to TransactionManager.sol can convert these delegatecalls into JMPs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L58  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L44  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L64  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L369  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L378  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L406  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L425  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L514  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L525  And other Lib* calls.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider moving all the library functions internal to this contract or to a single library to save gas from external calls each of which costs 2600 gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. LibUtils.revertIfCallFailed() reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibUtils.sol#L10-L19  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L35  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the boolean parameter from revertIfCallFailed() and move the conditional check logic to the call sites.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.   Impact: Considering these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, removeUserActiveBlocks() removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for fulfill() and cancel() functions that call removeUserActiveBlocks()  can consider using access lists for all the storage state (of user’s active blocks) they touch (read + write) to reduce gas.   ## Proof of Concept  https://eips.ethereum.org/EIPS/eip-2929  https://eips.ethereum.org/EIPS/eip-2930  https://hackmd.io/@fvictorio/gas-costs-after-berlin  https://github.com/gakonst/ethers-rs/issues/265  SLOADs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L580  SSTOREs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L583  Calls: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L346  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L490   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the feasibility of using access lists to save gas due to EIPs 2929 & 2930 post-Berlin hard fork. The tooling support is WIP.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a MIN_TIMEOUT for the expiry but I think you should also introduce a MAX_TIMEOUT to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx so the other side then has to wait and leave the funds locked for 100 years or so.  ## Recommended Mitigation Steps Introduce a reasonable MAX_TIMEOUT.  
# Handle  pauliax   # Vulnerability details  ## Impact Function fulfill first approves the callTo to transfer an amount of toSend tokens and tries to call IFulfillHelper but if the call fails it transfers these assets directly. However, in such case the approval is not reset so a malicous callTo can pull these tokens later:     // First, approve the funds to the helper if needed         if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {           require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), "fulfill: APPROVAL_FAILED");         }          // Next, call `addFunds` on the helper. Helpers should internally         // track funds to make sure no one user is able to take all funds         // for tx         if (toSend > 0) {           try             IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(               txData.user,               txData.transactionId,               txData.receivingAssetId,               toSend             )           {} catch {             // Regardless of error within the callData execution, send funds             // to the predetermined fallback address             require(               LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),               "fulfill: TRANSFER_FAILED"             );           }         }  ## Recommended Mitigation Steps Approve should be placed inside the try/catch block or approval needs to be reset if the call fails.  
# Handle  pauliax   # Vulnerability details  ## Impact ETHER_ASSETID is a bit missleading name, I think a better name would be NATIVE_ASSETID:    address constant ETHER_ASSETID = address(0);  Misleading comment (should be 'for fulfillment'):   // The structure of the signed data for cancellations   struct SignedFulfillData {  MIN_TIMEOUT could be expressed in days:  uint256 public constant MIN_TIMEOUT = 1 days; // 24 hours   
# Handle  pauliax   # Vulnerability details  ## Impact function fulfill treats txData.expiry = block.timestamp as expired tx:     // Make sure the expiry has not elapsed     require(txData.expiry > block.timestamp, "fulfill: EXPIRED");  However, function cancel has an inclusive check for the same condition:     if (txData.expiry >= block.timestamp) {     // Timeout has not expired and tx may only be cancelled by router  ## Recommended Mitigation Steps Unify that to make the code coherent. Probably txData.expiry = block.timestamp should be treated as expired everywhere.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a potential issue in function removeUserActiveBlocks and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for activeTransactionBlocks it may grow so large that the for loop may never finish. You should consider introducing an upper limit for activeTransactionBlocks. Also, a malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push activeTransactionBlocks to the specified user until it is no longer possible to remove them from the array.  This is also a gas issue as function removeUserActiveBlocks iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an EnumerableMap so you can find and remove elements in O(1) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol It depends on what is the usual number of activeTransactionBlocks. If it is expected to be low (e.g. less than 5), then the current approach will work, but with larger arrays, I expect EnumerableMap would be more efficient.  ## Recommended Mitigation Steps An upper limit will not fully mitigate this issue as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. As you need to improve both the security and performance of removeUserActiveBlocks I think that EnumerableMap may be a go-to solution.  
# Handle  greiart   # Vulnerability details  ### Proof of Concept  `hashVariantTransactionData()` should follow the same style of `hashInvariantTransactionData()` and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.  ```jsx function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     VariantTransactionData memory variant = VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: txData.preparedBlockNumber   });   return keccak256(abi.encode(variant));   } ```  ### Alternative View on Notion  [https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21](https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21)  
# Handle  cmichel   # Vulnerability details  Both the `recoverFulfillSignature` and `recoverCancelSignature` functions take a large `TransactionData` object as their first argument but only use the `transactionId` field of the struct. It should be more efficient to only pass `txData.transactionId` as the parameter.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See [Line 201](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) The `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.  ## Impact Repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:  ``` require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), "fulfill: APPROVAL_FAILED"); ```  ## Recommended Mitigation Steps `LiibERC20.approve` should do two `approve` calls, one setting it to `0` first, then the real one. Check OpenZeppelin's `safeApprove`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function wrapCall is not completely safe for all possible ERC20 contracts.  If the returnData.length is larger than 1 the "abi.decode(returnData, (bool));" will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.  ## Proof of Concept // https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibERC20.sol#L21     function wrapCall(address assetId, bytes memory callData) internal returns (bool) {         ...         (bool success, bytes memory returnData) = assetId.call(callData);         LibUtils.revertIfCallFailed(success, returnData);         return returnData.length == 0 || abi.decode(returnData, (bool));     }  ## Tools Used  ## Recommended Mitigation Steps Change return returnData.length == 0 || abi.decode(returnData, (bool)); to: return (returnData.length == 0) || (returnData.length == 1 && abi.decode(returnData, (bool)));  
# Handle  gpersoon   # Vulnerability details  ## Impact The function revertIfCallFailed of LibUtils.sol uses "assembly" to log error information in a revert situation.  In the latest solidity version this can be done in solidity using the "error" keyword. See: https://docs.soliditylang.org/en/latest/control-structures.html?#revert Using pure solidity improves readability.  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10  function revertIfCallFailed(bool success, bytes memory returnData) internal pure {         if (!success) {             assembly {  revert(add(returnData, 0x20), mload(returnData))  }         }     }  ## Tools Used   ## Recommended Mitigation Steps use the error constructs of solidity 0.8.4+    
# Handle  shw   # Vulnerability details  ## Impact  In general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L122-L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125) [TransactionManager.sol#L254-L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260)  ## Recommended Mitigation Steps  Rewrite #L122-L125 as follows:  ```solidity uint256 balance = routerBalances[msg.sender][assetId]; require(balance >= amount, "removeLiquidity: INSUFFICIENT_FUNDS");  // Update router balances routerBalances[msg.sender][assetId] = balance - amount; ```  Rewrite #L254-L260 as follows:  ```solidity uint256 balance = routerBalances[invariantData.router][invariantData.receivingAssetId]; require(     balance >= amount,     "prepare: INSUFFICIENT_LIQUIDITY" );  // Decrement the router liquidity routerBalances[invariantData.router][invariantData.receivingAssetId] = balance - amount; ```  
# Handle  shw   # Vulnerability details  ## Impact  Using the `unchecked` keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.  ## Proof of Concept  We can apply the `unchecked` keyword in the following lines of code since there are `require` statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  Referenced code: [TransactionManager.sol#L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L125) [TransactionManager.sol#L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L260) [TransactionManager.sol#L364](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) [TransactionManager.sol#L520](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L520)  ## Recommended Mitigation Steps  For example, change the code at line 364 to:  ```solidity unchecked {     uint256 toSend = txData.amount - relayerFee; } ```  
# Handle  shw   # Vulnerability details  ## Impact  When a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than that is recorded in the `routerBalances` variable.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97) [TransactionManager.sol#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101)  ## Recommended Mitigation Steps  Get the received token amount by calculating the difference of token balance before and after the transfer, for example:  ```solidity uint256 balanceBefore = getOwnBalance(assetId); require(LibERC20.transferFrom(assetId, router, address(this), amount, "addLiquidity: ERC20_TRANSFER_FAILED"); uint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;  // Update the router balances routerBalances[router][assetId] += receivedAmount; ```  
# Handle  0xsanson   # Vulnerability details  ## Impact The currect implementation of NatSpec of fulfill function lacks @param callData  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps It's suggested to complete adding @param callData  
# Handle  hrkrshnn   # Vulnerability details  ## Revert strings  ### Consider using custom errors instead of revert strings  Can save gas when the revert condition has been met. And also during runtime.  ### Consider shortening revert strings to less than 32 bytes  Revert strings more than 32 bytes require at least one additional `mstore`, along with additional operations for computing memory offset, etc.  Even if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.  Here are some examples of strings that can be shortened from codebase:  ``` txt ./contracts/TransactionManager.sol:96:      "addLiquidity: ETH_WITH_ERC_TRANSFER" ./contracts/TransactionManager.sol:97:      "addLiquidity: ERC20_TRANSFER_FAILED" ./contracts/TransactionManager.sol:122:     "removeLiquidity: INSUFFICIENT_FUNDS" ```  Note that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.    
# Handle  pauliax   # Vulnerability details  ## Impact I think it would make sense not to check the user's signature in recoverCancelSignature or recoverFulfillSignature if the caller is the user himself.   ## Recommended Mitigation Steps Replace: require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, "cancel: INVALID_SIGNATURE"); require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, "fulfill: INVALID_SIGNATURE"); with: require(msg.sender == txData.user || recoverCancelSignature(txData, relayerFee, signature) == txData.user, "cancel: INVALID_SIGNATURE"); require(msg.sender == txData.user || recoverFulfillSignature(txData, relayerFee, signature) == txData.user, "fulfill: INVALID_SIGNATURE");  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact  The code uses `hashVariantTransactionData` to verify the hash of the VariantTransactionData It also uses ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  To generate VariantTransactionData with `preparedBlockNumber` set to 0  A simple refactoring of: ```   function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     return hashVariantTransaction(txData.amount, txData.expiry, txData.preparedBlockNumber)   }    function hashVariantTransaction(uint256 amount, uint256 expiry, uint256 prepareBlocNumber) internal pure returns (bytes32) {     return keccak256(abi.encode(VariantTransactionData({       amount: amount,       expiry: expiry,       preparedBlockNumber: preparedBlockNumber     })));   }  ```  This would allow to further steamline the code from ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  to  ```     variantTransactionData[digest] = hashVariantTransaction(txData.amount, txData.expiry, 0) ```  ## Recommended Mitigation Steps This has no particular benefit beside making all code related to Variant Data consistent   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks are in general a best-practice. However, addLiquidity() and removeLiquidity() are missing zero-address checks on router and recipient addresses respectively.    addLiquidity() on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.  For ERC20 assets, token.transfer() generally implements this check but the Eth transfer using transferEth() does not have this check and calls addr.call(value) which will lead to burning in the case of removeLiquidity().   The checks may be more important because assetID is 0 for Eth. So a router may accidentally use 0 values for both assetID and router/recipient.  There is also a missing zero-address check on sendingChainFallback which is relevant for Eth transfers in cancel(). The comment on L178 indicates the need for this but the following check on L179 ends up checking receivingAddress instead (which is also necessary).   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L101-L104  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L116 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128-L131  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permissionless, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option.  ## Proof of Concept  Lack of owner, whitelisting, thresholds, pause/unpause in the protocol.  See https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present) then the cancel transaction from the relayer will always revert and user’s funds will remain locked on the sending chain.  Impact: Expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change receivingAssetId to sendingAssetId in transferAsset() on L514.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  During fulfill() on the receiving chain, if the user has set up an external contract at txData.callTo, the catch blocks for both IFulfillHelper.addFunds() and IFulfillHelper.excute() perform transferAsset to the predetermined fallback address txData.receivingAddress.  If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.   Scenario: User sets up receiver chain txData.callTo contract such that both addFunds() and execute() calls revert and that will let him get twice the toSend amount credited to the receivingAddress. So effectively, Alice locks 100 tokenAs on chain A and can get 200 tokenAs (or twice the amount of any token she is supposed to get on chainB from the router), minus relayer fee, on chainB. Router liquidity is double-dipped by Alice and router loses funds.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The second catch block for execute() should likely not have the transferAsset() call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Checking if toSend > 0 before making the external library call to LibAsset.transferAsset() can save 2600 gas by avoiding the external call in such situations.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L375-L380  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L364  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toSend > 0 to predicate on L375 similar to check on L387.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.  Functions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two SSTORES (getting more expensive with the London fork EIP-3529) to its _status state variable.   Example 1: In addLiquidity(), by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.  Example 2: removeLiquidity() already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.  prepare() can be slightly restructured to follow CEI pattern as well. However, fulfill() and cancel() are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.  Impact: Save gas by removing nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600.   Impact: A LibAsset.transferAsset() call from TransactionManager.sol makes LibERC20.transfer() call for ERC20 which in turn makes another external call to LibUtils.revertIfCallFailed() in wrapCall. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call assetId.call(..) external calls -> LibAsset -> LibERC20 -> LibUtils, which costs 2600*3 = 7800 gas.   Combining these functions into a single library or making them all internal to TransactionManager.sol can convert these delegatecalls into JMPs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L58  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L44  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L64  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L369  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L378  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L406  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L425  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L514  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L525  And other Lib* calls.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider moving all the library functions internal to this contract or to a single library to save gas from external calls each of which costs 2600 gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. LibUtils.revertIfCallFailed() reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibUtils.sol#L10-L19  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L35  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the boolean parameter from revertIfCallFailed() and move the conditional check logic to the call sites.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.   Impact: Considering these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, removeUserActiveBlocks() removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for fulfill() and cancel() functions that call removeUserActiveBlocks()  can consider using access lists for all the storage state (of user’s active blocks) they touch (read + write) to reduce gas.   ## Proof of Concept  https://eips.ethereum.org/EIPS/eip-2929  https://eips.ethereum.org/EIPS/eip-2930  https://hackmd.io/@fvictorio/gas-costs-after-berlin  https://github.com/gakonst/ethers-rs/issues/265  SLOADs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L580  SSTOREs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L583  Calls: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L346  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L490   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the feasibility of using access lists to save gas due to EIPs 2929 & 2930 post-Berlin hard fork. The tooling support is WIP.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a MIN_TIMEOUT for the expiry but I think you should also introduce a MAX_TIMEOUT to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx so the other side then has to wait and leave the funds locked for 100 years or so.  ## Recommended Mitigation Steps Introduce a reasonable MAX_TIMEOUT.  
# Handle  pauliax   # Vulnerability details  ## Impact Function fulfill first approves the callTo to transfer an amount of toSend tokens and tries to call IFulfillHelper but if the call fails it transfers these assets directly. However, in such case the approval is not reset so a malicous callTo can pull these tokens later:     // First, approve the funds to the helper if needed         if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {           require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), "fulfill: APPROVAL_FAILED");         }          // Next, call `addFunds` on the helper. Helpers should internally         // track funds to make sure no one user is able to take all funds         // for tx         if (toSend > 0) {           try             IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(               txData.user,               txData.transactionId,               txData.receivingAssetId,               toSend             )           {} catch {             // Regardless of error within the callData execution, send funds             // to the predetermined fallback address             require(               LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),               "fulfill: TRANSFER_FAILED"             );           }         }  ## Recommended Mitigation Steps Approve should be placed inside the try/catch block or approval needs to be reset if the call fails.  
# Handle  pauliax   # Vulnerability details  ## Impact ETHER_ASSETID is a bit missleading name, I think a better name would be NATIVE_ASSETID:    address constant ETHER_ASSETID = address(0);  Misleading comment (should be 'for fulfillment'):   // The structure of the signed data for cancellations   struct SignedFulfillData {  MIN_TIMEOUT could be expressed in days:  uint256 public constant MIN_TIMEOUT = 1 days; // 24 hours   
# Handle  pauliax   # Vulnerability details  ## Impact function fulfill treats txData.expiry = block.timestamp as expired tx:     // Make sure the expiry has not elapsed     require(txData.expiry > block.timestamp, "fulfill: EXPIRED");  However, function cancel has an inclusive check for the same condition:     if (txData.expiry >= block.timestamp) {     // Timeout has not expired and tx may only be cancelled by router  ## Recommended Mitigation Steps Unify that to make the code coherent. Probably txData.expiry = block.timestamp should be treated as expired everywhere.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a potential issue in function removeUserActiveBlocks and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for activeTransactionBlocks it may grow so large that the for loop may never finish. You should consider introducing an upper limit for activeTransactionBlocks. Also, a malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push activeTransactionBlocks to the specified user until it is no longer possible to remove them from the array.  This is also a gas issue as function removeUserActiveBlocks iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an EnumerableMap so you can find and remove elements in O(1) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol It depends on what is the usual number of activeTransactionBlocks. If it is expected to be low (e.g. less than 5), then the current approach will work, but with larger arrays, I expect EnumerableMap would be more efficient.  ## Recommended Mitigation Steps An upper limit will not fully mitigate this issue as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. As you need to improve both the security and performance of removeUserActiveBlocks I think that EnumerableMap may be a go-to solution.  
# Handle  greiart   # Vulnerability details  ### Proof of Concept  `hashVariantTransactionData()` should follow the same style of `hashInvariantTransactionData()` and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.  ```jsx function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     VariantTransactionData memory variant = VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: txData.preparedBlockNumber   });   return keccak256(abi.encode(variant));   } ```  ### Alternative View on Notion  [https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21](https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21)  
# Handle  cmichel   # Vulnerability details  Both the `recoverFulfillSignature` and `recoverCancelSignature` functions take a large `TransactionData` object as their first argument but only use the `transactionId` field of the struct. It should be more efficient to only pass `txData.transactionId` as the parameter.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See [Line 201](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) The `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.  ## Impact Repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:  ``` require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), "fulfill: APPROVAL_FAILED"); ```  ## Recommended Mitigation Steps `LiibERC20.approve` should do two `approve` calls, one setting it to `0` first, then the real one. Check OpenZeppelin's `safeApprove`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function wrapCall is not completely safe for all possible ERC20 contracts.  If the returnData.length is larger than 1 the "abi.decode(returnData, (bool));" will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.  ## Proof of Concept // https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibERC20.sol#L21     function wrapCall(address assetId, bytes memory callData) internal returns (bool) {         ...         (bool success, bytes memory returnData) = assetId.call(callData);         LibUtils.revertIfCallFailed(success, returnData);         return returnData.length == 0 || abi.decode(returnData, (bool));     }  ## Tools Used  ## Recommended Mitigation Steps Change return returnData.length == 0 || abi.decode(returnData, (bool)); to: return (returnData.length == 0) || (returnData.length == 1 && abi.decode(returnData, (bool)));  
# Handle  gpersoon   # Vulnerability details  ## Impact The function revertIfCallFailed of LibUtils.sol uses "assembly" to log error information in a revert situation.  In the latest solidity version this can be done in solidity using the "error" keyword. See: https://docs.soliditylang.org/en/latest/control-structures.html?#revert Using pure solidity improves readability.  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10  function revertIfCallFailed(bool success, bytes memory returnData) internal pure {         if (!success) {             assembly {  revert(add(returnData, 0x20), mload(returnData))  }         }     }  ## Tools Used   ## Recommended Mitigation Steps use the error constructs of solidity 0.8.4+    
# Handle  shw   # Vulnerability details  ## Impact  In general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L122-L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125) [TransactionManager.sol#L254-L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260)  ## Recommended Mitigation Steps  Rewrite #L122-L125 as follows:  ```solidity uint256 balance = routerBalances[msg.sender][assetId]; require(balance >= amount, "removeLiquidity: INSUFFICIENT_FUNDS");  // Update router balances routerBalances[msg.sender][assetId] = balance - amount; ```  Rewrite #L254-L260 as follows:  ```solidity uint256 balance = routerBalances[invariantData.router][invariantData.receivingAssetId]; require(     balance >= amount,     "prepare: INSUFFICIENT_LIQUIDITY" );  // Decrement the router liquidity routerBalances[invariantData.router][invariantData.receivingAssetId] = balance - amount; ```  
# Handle  shw   # Vulnerability details  ## Impact  Using the `unchecked` keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.  ## Proof of Concept  We can apply the `unchecked` keyword in the following lines of code since there are `require` statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  Referenced code: [TransactionManager.sol#L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L125) [TransactionManager.sol#L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L260) [TransactionManager.sol#L364](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) [TransactionManager.sol#L520](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L520)  ## Recommended Mitigation Steps  For example, change the code at line 364 to:  ```solidity unchecked {     uint256 toSend = txData.amount - relayerFee; } ```  
# Handle  shw   # Vulnerability details  ## Impact  When a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than that is recorded in the `routerBalances` variable.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97) [TransactionManager.sol#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101)  ## Recommended Mitigation Steps  Get the received token amount by calculating the difference of token balance before and after the transfer, for example:  ```solidity uint256 balanceBefore = getOwnBalance(assetId); require(LibERC20.transferFrom(assetId, router, address(this), amount, "addLiquidity: ERC20_TRANSFER_FAILED"); uint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;  // Update the router balances routerBalances[router][assetId] += receivedAmount; ```  
# Handle  0xsanson   # Vulnerability details  ## Impact The currect implementation of NatSpec of fulfill function lacks @param callData  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps It's suggested to complete adding @param callData  
# Handle  hrkrshnn   # Vulnerability details  ## Revert strings  ### Consider using custom errors instead of revert strings  Can save gas when the revert condition has been met. And also during runtime.  ### Consider shortening revert strings to less than 32 bytes  Revert strings more than 32 bytes require at least one additional `mstore`, along with additional operations for computing memory offset, etc.  Even if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.  Here are some examples of strings that can be shortened from codebase:  ``` txt ./contracts/TransactionManager.sol:96:      "addLiquidity: ETH_WITH_ERC_TRANSFER" ./contracts/TransactionManager.sol:97:      "addLiquidity: ERC20_TRANSFER_FAILED" ./contracts/TransactionManager.sol:122:     "removeLiquidity: INSUFFICIENT_FUNDS" ```  Note that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.    
# Handle  pauliax   # Vulnerability details  ## Impact I think it would make sense not to check the user's signature in recoverCancelSignature or recoverFulfillSignature if the caller is the user himself.   ## Recommended Mitigation Steps Replace: require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, "cancel: INVALID_SIGNATURE"); require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, "fulfill: INVALID_SIGNATURE"); with: require(msg.sender == txData.user || recoverCancelSignature(txData, relayerFee, signature) == txData.user, "cancel: INVALID_SIGNATURE"); require(msg.sender == txData.user || recoverFulfillSignature(txData, relayerFee, signature) == txData.user, "fulfill: INVALID_SIGNATURE");  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact  The code uses `hashVariantTransactionData` to verify the hash of the VariantTransactionData It also uses ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  To generate VariantTransactionData with `preparedBlockNumber` set to 0  A simple refactoring of: ```   function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     return hashVariantTransaction(txData.amount, txData.expiry, txData.preparedBlockNumber)   }    function hashVariantTransaction(uint256 amount, uint256 expiry, uint256 prepareBlocNumber) internal pure returns (bytes32) {     return keccak256(abi.encode(VariantTransactionData({       amount: amount,       expiry: expiry,       preparedBlockNumber: preparedBlockNumber     })));   }  ```  This would allow to further steamline the code from ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  to  ```     variantTransactionData[digest] = hashVariantTransaction(txData.amount, txData.expiry, 0) ```  ## Recommended Mitigation Steps This has no particular benefit beside making all code related to Variant Data consistent   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks are in general a best-practice. However, addLiquidity() and removeLiquidity() are missing zero-address checks on router and recipient addresses respectively.    addLiquidity() on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.  For ERC20 assets, token.transfer() generally implements this check but the Eth transfer using transferEth() does not have this check and calls addr.call(value) which will lead to burning in the case of removeLiquidity().   The checks may be more important because assetID is 0 for Eth. So a router may accidentally use 0 values for both assetID and router/recipient.  There is also a missing zero-address check on sendingChainFallback which is relevant for Eth transfers in cancel(). The comment on L178 indicates the need for this but the following check on L179 ends up checking receivingAddress instead (which is also necessary).   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L101-L104  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L116 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128-L131  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permissionless, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option.  ## Proof of Concept  Lack of owner, whitelisting, thresholds, pause/unpause in the protocol.  See https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present) then the cancel transaction from the relayer will always revert and user’s funds will remain locked on the sending chain.  Impact: Expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change receivingAssetId to sendingAssetId in transferAsset() on L514.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  During fulfill() on the receiving chain, if the user has set up an external contract at txData.callTo, the catch blocks for both IFulfillHelper.addFunds() and IFulfillHelper.excute() perform transferAsset to the predetermined fallback address txData.receivingAddress.  If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.   Scenario: User sets up receiver chain txData.callTo contract such that both addFunds() and execute() calls revert and that will let him get twice the toSend amount credited to the receivingAddress. So effectively, Alice locks 100 tokenAs on chain A and can get 200 tokenAs (or twice the amount of any token she is supposed to get on chainB from the router), minus relayer fee, on chainB. Router liquidity is double-dipped by Alice and router loses funds.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The second catch block for execute() should likely not have the transferAsset() call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Checking if toSend > 0 before making the external library call to LibAsset.transferAsset() can save 2600 gas by avoiding the external call in such situations.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L375-L380  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L364  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toSend > 0 to predicate on L375 similar to check on L387.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.  Functions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two SSTORES (getting more expensive with the London fork EIP-3529) to its _status state variable.   Example 1: In addLiquidity(), by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.  Example 2: removeLiquidity() already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.  prepare() can be slightly restructured to follow CEI pattern as well. However, fulfill() and cancel() are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.  Impact: Save gas by removing nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600.   Impact: A LibAsset.transferAsset() call from TransactionManager.sol makes LibERC20.transfer() call for ERC20 which in turn makes another external call to LibUtils.revertIfCallFailed() in wrapCall. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call assetId.call(..) external calls -> LibAsset -> LibERC20 -> LibUtils, which costs 2600*3 = 7800 gas.   Combining these functions into a single library or making them all internal to TransactionManager.sol can convert these delegatecalls into JMPs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L58  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L44  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L64  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L369  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L378  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L406  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L425  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L514  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L525  And other Lib* calls.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider moving all the library functions internal to this contract or to a single library to save gas from external calls each of which costs 2600 gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. LibUtils.revertIfCallFailed() reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibUtils.sol#L10-L19  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L35  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the boolean parameter from revertIfCallFailed() and move the conditional check logic to the call sites.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.   Impact: Considering these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, removeUserActiveBlocks() removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for fulfill() and cancel() functions that call removeUserActiveBlocks()  can consider using access lists for all the storage state (of user’s active blocks) they touch (read + write) to reduce gas.   ## Proof of Concept  https://eips.ethereum.org/EIPS/eip-2929  https://eips.ethereum.org/EIPS/eip-2930  https://hackmd.io/@fvictorio/gas-costs-after-berlin  https://github.com/gakonst/ethers-rs/issues/265  SLOADs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L580  SSTOREs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L583  Calls: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L346  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L490   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the feasibility of using access lists to save gas due to EIPs 2929 & 2930 post-Berlin hard fork. The tooling support is WIP.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a MIN_TIMEOUT for the expiry but I think you should also introduce a MAX_TIMEOUT to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx so the other side then has to wait and leave the funds locked for 100 years or so.  ## Recommended Mitigation Steps Introduce a reasonable MAX_TIMEOUT.  
# Handle  pauliax   # Vulnerability details  ## Impact Function fulfill first approves the callTo to transfer an amount of toSend tokens and tries to call IFulfillHelper but if the call fails it transfers these assets directly. However, in such case the approval is not reset so a malicous callTo can pull these tokens later:     // First, approve the funds to the helper if needed         if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {           require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), "fulfill: APPROVAL_FAILED");         }          // Next, call `addFunds` on the helper. Helpers should internally         // track funds to make sure no one user is able to take all funds         // for tx         if (toSend > 0) {           try             IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(               txData.user,               txData.transactionId,               txData.receivingAssetId,               toSend             )           {} catch {             // Regardless of error within the callData execution, send funds             // to the predetermined fallback address             require(               LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),               "fulfill: TRANSFER_FAILED"             );           }         }  ## Recommended Mitigation Steps Approve should be placed inside the try/catch block or approval needs to be reset if the call fails.  
# Handle  pauliax   # Vulnerability details  ## Impact ETHER_ASSETID is a bit missleading name, I think a better name would be NATIVE_ASSETID:    address constant ETHER_ASSETID = address(0);  Misleading comment (should be 'for fulfillment'):   // The structure of the signed data for cancellations   struct SignedFulfillData {  MIN_TIMEOUT could be expressed in days:  uint256 public constant MIN_TIMEOUT = 1 days; // 24 hours   
# Handle  pauliax   # Vulnerability details  ## Impact function fulfill treats txData.expiry = block.timestamp as expired tx:     // Make sure the expiry has not elapsed     require(txData.expiry > block.timestamp, "fulfill: EXPIRED");  However, function cancel has an inclusive check for the same condition:     if (txData.expiry >= block.timestamp) {     // Timeout has not expired and tx may only be cancelled by router  ## Recommended Mitigation Steps Unify that to make the code coherent. Probably txData.expiry = block.timestamp should be treated as expired everywhere.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a potential issue in function removeUserActiveBlocks and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for activeTransactionBlocks it may grow so large that the for loop may never finish. You should consider introducing an upper limit for activeTransactionBlocks. Also, a malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push activeTransactionBlocks to the specified user until it is no longer possible to remove them from the array.  This is also a gas issue as function removeUserActiveBlocks iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an EnumerableMap so you can find and remove elements in O(1) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol It depends on what is the usual number of activeTransactionBlocks. If it is expected to be low (e.g. less than 5), then the current approach will work, but with larger arrays, I expect EnumerableMap would be more efficient.  ## Recommended Mitigation Steps An upper limit will not fully mitigate this issue as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. As you need to improve both the security and performance of removeUserActiveBlocks I think that EnumerableMap may be a go-to solution.  
# Handle  greiart   # Vulnerability details  ### Proof of Concept  `hashVariantTransactionData()` should follow the same style of `hashInvariantTransactionData()` and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.  ```jsx function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     VariantTransactionData memory variant = VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: txData.preparedBlockNumber   });   return keccak256(abi.encode(variant));   } ```  ### Alternative View on Notion  [https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21](https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21)  
# Handle  cmichel   # Vulnerability details  Both the `recoverFulfillSignature` and `recoverCancelSignature` functions take a large `TransactionData` object as their first argument but only use the `transactionId` field of the struct. It should be more efficient to only pass `txData.transactionId` as the parameter.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See [Line 201](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) The `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.  ## Impact Repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:  ``` require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), "fulfill: APPROVAL_FAILED"); ```  ## Recommended Mitigation Steps `LiibERC20.approve` should do two `approve` calls, one setting it to `0` first, then the real one. Check OpenZeppelin's `safeApprove`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function wrapCall is not completely safe for all possible ERC20 contracts.  If the returnData.length is larger than 1 the "abi.decode(returnData, (bool));" will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.  ## Proof of Concept // https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibERC20.sol#L21     function wrapCall(address assetId, bytes memory callData) internal returns (bool) {         ...         (bool success, bytes memory returnData) = assetId.call(callData);         LibUtils.revertIfCallFailed(success, returnData);         return returnData.length == 0 || abi.decode(returnData, (bool));     }  ## Tools Used  ## Recommended Mitigation Steps Change return returnData.length == 0 || abi.decode(returnData, (bool)); to: return (returnData.length == 0) || (returnData.length == 1 && abi.decode(returnData, (bool)));  
# Handle  gpersoon   # Vulnerability details  ## Impact The function revertIfCallFailed of LibUtils.sol uses "assembly" to log error information in a revert situation.  In the latest solidity version this can be done in solidity using the "error" keyword. See: https://docs.soliditylang.org/en/latest/control-structures.html?#revert Using pure solidity improves readability.  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10  function revertIfCallFailed(bool success, bytes memory returnData) internal pure {         if (!success) {             assembly {  revert(add(returnData, 0x20), mload(returnData))  }         }     }  ## Tools Used   ## Recommended Mitigation Steps use the error constructs of solidity 0.8.4+    
