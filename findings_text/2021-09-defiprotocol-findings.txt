# Handle  tensors   # Vulnerability details  ## Impact In L92 of Basket.sol there is an unnecessary require check that the user balance is greater than or equal to amount. If the amount is larger than user balance then the _burn() method will fail, causing the function to revert anyway.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92  ## Recommended Mitigation Steps Remove the unnecessary check.  
# Handle  tensors   # Vulnerability details  I recommend adding reentrancy checks throughout Basket.sol and Auction.sol using a mutex lock. Many external calls are made to potentially unsafe token contracts. In the case that not all token contracts are properly vetted, this preventative step could be worthwhile.  
# Handle  0xsanson   # Vulnerability details  ## Impact The owner of Factory contract can modify the values of `auctionMultiplier` and `auctionDecrement` at any time. During an auction, these values are used to calculate `newRatio` and thereby `tokensNeeded`: specifically, it's easy to set the factory parameters so that `tokensNeeded = 0` (or close to zero) for every token. This way the owner can participate at an auction, change the parameters, and get the underlying tokens from a Basket without transferring any pending tokens.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a Timelock to these Factory functions. Otherwise a way to not modify them if an auction is ongoing (maybe Auction saves the values it reads when `startAuction` is called).  
# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, `handleFees` computes the following: `uint256 newIbRatio = ibRatio * startSupply / totalSupply()`.  In the case that `totalSupply() = 0` (every holder burned their basket), the function reverts since there's a 0/0. This issue won't let new people mint, since `handleFees` is called before any minting.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L124  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a check before the division. ``` if (startSupply == 0) {  return; } ```  
# Handle  0xsanson   # Vulnerability details  ## Impact The function `Factory.proposeBasketLicense` at the end emits `BasketLicenseProposed(msg.sender, tokenName)` and returns the id of the proposal. This `id` should also be written to the log, since it's needed by the proposer (for createBasket), and they may not see the return value of an external function.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87-L90  ## Tools Used editor  ## Recommended Mitigation Steps Consider redefining the event to contain the id of the proposal.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, there is a function `mintTo(uint256 amount, address to)`. It's best practice to use as first argument `to`, and as second `amount`; see also the order used in L84 (_mint(to, amount)) and L86 (Minted(to, amount)).  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L76  ## Tools Used editor  ## Recommended Mitigation Steps Consider switching the arguments (also don't forget to change the calls to the function).  
# Handle  goatbug   # Vulnerability details  ## Impact Long list of functions should be set from public to external since they are not called anywhere by the contract itself.     ## Proof of Concept  There are too many to list them all from all the contracts.  Just some examples in the Factory contract.  There are lots in every contract that should rather be external.      function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {         minLicenseFee = newMinLicenseFee;     }      function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {         auctionDecrement = newAuctionDecrement;     }      function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {         auctionMultiplier = newAuctionMultiplier;     }      function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {         bondPercentDiv = newBondPercentDiv;     }      function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {         require(newOwnerSplit <= 2e17); // 20%          ownerSplit = newOwnerSplit;     }  ## Tools Used  ## Recommended Mitigation Steps  
# Handle  goatbug   # Vulnerability details  ## Impact Use less storage slots  ## Proof of Concept     struct Proposal {         uint256 licenseFee;         string tokenName;         string tokenSymbol;         address proposer;         address[] tokens;         uint256[] weights;         address basket;     } License fee is a smaller number does not need to be uint256.   Could use an 8 bit value and pack it comfortable with one of the addresses to save a full storage slot.   ## Tools Used  ## Recommended Mitigation Steps  
# Handle  hrkrshnn   # Vulnerability details  ## Replace `tokenList.length` by existing variable `length`  ``` diff modified   contracts/contracts/Basket.sol @@ -61,7 +61,7 @@ contract Basket is IBasket, ERC20Upgradeable {              require(_tokens[i] != address(0));              require(_weights[i] > 0);  -            for (uint256 x = 0; x < tokenList.length; x++) { +            for (uint256 x = 0; x < length; x++) {                  require(_tokens[i] != tokenList[x]);              } ```  Context: <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L64>  The value `tokenList.length` is read from memory and therefore requires a `mload(...)` (6 gas for `push memory_offset` + `mload`). On the other hand, this value is already available in the stack as `length` and could just be `dup-ed` (3 gas). Saves 3 gas for each loop iteration of the interior loop.   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  ### Examples  1.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L65> 2.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69> 3.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L140> 4.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36> 5.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53> 6.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L170>   
# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changeLicenseFee` function ensures that `pendingLicenseFee.licenseFee == newLicenseFee` which means setting `licenseFee = newLicenseFee` is equivalent to `licenseFee = pendingLicenseFee.licenseFee` but the former saves an expensive storage load operation.  
# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changePublisher` function ensures that `pendingPublisher.publisher == newPublisher` which means setting `publisher = newPublisher` is equivalent to `publisher = pendingPublisher.publisher` but the former saves an expensive storage load operation.  
# Handle  cmichel   # Vulnerability details  The `Auction.initialize` function accepts a `factory_` parameter. However, as this contract is always initialized directly from the factory, it can just use `msg.sender`.  ## Recommended Mitigation Steps Removing the additional `factory_` parameter and using `msg.sender` instead will save gas. This is already done for the other `Basket` contract.   
# Handle  cmichel   # Vulnerability details  Note that the `Basket` contract approved the `Auction` contract with all tokens and the `settleAuction` function allows the auction bonder to transfer all funds out of the basket to themselves. The only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:  ``` // this is the safety check if basket still has all the tokens after removing arbitrary amounts for (uint256 i = 0; i < pendingWeights.length; i++) {     uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;     require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded); } ```  The bonder can pass in any `inputTokens`, even malicious ones they created. This allows them to re-enter the `settleAuction` multiple times for the same auction.  Calling this function at the correct time (such that `bondTimestamp - auctionStart` makes `newRatio < basket.ibRatio()`), the attacker can drain more funds each time, eventually draining the entire basket.  ## POC Assume that the current `basket.ibRatio` is `1e18` (the initial value). The basket publisher calls `basket.publishNewIndex` with some tokens and weights. For simplicity, assume that the pending `tokens` are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio. The function call then starts the auction.  The important step to note is that the `tokensNeeded` value in `settleAuction` determines how many tokens need to stay in the `basket`. If we can continuously lower this value, we can keep removing tokens from the `basket` until it is empty.  The `tokensNeeded` variable is computed as `basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. The only variable that changes in the computation when re-entering the function is `newRatio` (no basket tokens are burned, and the pending weights are never cleared).  Thus if we can show that `newRatio` decreases on each re-entrant call, we can move out more and more funds each time.  #### newRatio decreases on each call After some time, the attacker calls `bondForRebalance`. This determines the `bondTimestamp - auctionStart` value in `settleAuction`. The attack is possible as soon as `newRatio < basket.ibRatio()`. For example, using the standard parameters the calculation would be:  ```solidity // a = 2 * ibRatio uint256 a = factory.auctionMultiplier() * basket.ibRatio(); // b = (bondTimestamp - auctionStart) * 1e14 uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); // newRatio = a - b = 2 * ibRatio - (bondTimestamp - auctionStart) * 1e14 uint256 newRatio = a - b; ```  With our initial assumption of `ibRatio = 1e18` and calling `bondForRebalance` after 11,000 seconds (~3 hours) we will get our result that `newRatio` is less than the initial `ibRatio`:  ```python newRatio = a - b = 2 * 1e18 - (11000) * 1e14 = 2e18 - 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio ```  > This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when `newRatio > basket.ibRatio` as they would put in more total value in tokens as they can take out of the basket.  #### re-enter on settleAuction The attacker creates a custom token `attackerToken` that re-enters the `Auction.settleAuction` function on `transferFrom` with parameters we will specify.  They call `settleAuction` with `inputTokens = [attackerToken]` to re-enter several times.  In the inner-most call where `newRatio = 0.9e18`, they choose the `inputTokens`/`outputTokens` parameters in a way to pass the initial `require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);` check - transferring out any other tokens of `basket` with `outputTokens`.  The function will continue to run and call `basket.setNewWeights();` and `basket.updateIBRatio(newRatio);` which will set the new weights (but not clear the pending ones) and set the new `basket.ibRatio`.  Execution then jumps to the 2nd inner call after the `IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...)` and has the chance to transfer out tokens again. It will compute `newRatio` with the new lowered `basket.ibRatio` of `0.9e18`: `newRatio = a - b = 2 * 0.9e18 - 1.1e18 = 0.7e18`. Therefore, `tokensNeeded` is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen `outputWeights`.  This repeats with `newRatio = 0.3`.  The attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the `bondAmount` tokens to the `auction` contract which are then each time transferred back in the function body. But I believe this should work.  ## Impact The basket funds can be stolen.  ## Recommended Mitigation Steps Add re-entrancy checks (for example, OpenZeppelin's "locks") to the `settleAuction` function.    
# Handle  cmichel   # Vulnerability details  The `Basket.changePublisher` function is used for both setting a new pending publisher as well as accepting the publisher transfer **from** the pending publisher.  ## Impact Once a pending publisher has been set, no other publisher can be set and if the pending publisher does not accept it, the contract is locked out of setting any other publishers. Setting a wrong publisher can naturally occur.  ## Recommended Mitigation Steps Add an option to set a new pending publisher even if there already is a pending publisher.   
# Handle  cmichel   # Vulnerability details  A basket creator can specify a custom token that allows them to re-enter in `Factory.createBasket`.  ## Impact As new auction and basket contracts are created every time, no cross-basket issues arise. However, note that the official `BasketCreated` event is emitted for all of them, but only the last basket is stored for the `idNumber`. This could lead to issues for some backend / frontend scripts that use the `BasketCreated` event.  ## Recommended Mitigation Steps Set `_proposals[idNumber].basket = address(newBasket);` immediately after the `newBasket` contract clone has been created to avoid the re-entrancy.   
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why you need this new local variable called newIbRatio if you instantly update and use the storage variable afterwards:   uint256 newIbRatio = ibRatio * startSupply / totalSupply();   ibRatio = newIbRatio;  ## Recommended Mitigation Steps   ibRatio = ibRatio * startSupply / totalSupply();  
# Handle  pauliax   # Vulnerability details  ## Impact This can be refactored to improve precision and gas usage:   _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);   _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);  ## Recommended Mitigation Steps Proposed solution:   uint256 factoryOwnerFee = fee * factory.ownerSplit() / BASE;   uint256 publisherFee = fee - factoryOwnerFee;   _mint(Ownable(address(factory)).owner(), factoryOwnerFee);   _mint(publisher, publisherFee); This will result in fewer math operations and better precision cuz multiplication and division are replaced with subtraction.  
# Handle  pauliax   # Vulnerability details  ## Impact BLOCK_DECREMENT state variable in Auction is not used anywhere.  ## Recommended Mitigation Steps Consider removing unused variables.  
# Handle  pauliax   # Vulnerability details  ## Impact This double division by BASE can be eliminated to improve precision and reduce gas costs:    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps if you introduce a constant variable, e.g.:    uint256 private constant BASE_2X = BASE * 2;    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE_2X;  
# Handle  pauliax   # Vulnerability details  ## Impact I think function initialize should also emit NewIBRatio event as it sets the initial value:  ibRatio = BASE;  ## Recommended Mitigation Steps emit NewIBRatio(ibRatio) in function initialize.  
# Handle  pauliax   # Vulnerability details  ## Impact Hardcoding numbers that depend on other variables is error-prone, e.g.     require(newOwnerSplit <= 2e17); // 20% You must not forget to update this if you decide to change the BASE value.  ## Recommended Mitigation Steps  Better define a separate constant that directly depends on the BASE, e.g.:     uint256 private constant MAX_OWNER_SPLIT = BASE / 5; // 20%     require(newOwnerSplit <= MAX_OWNER_SPLIT);  
# Handle  pauliax   # Vulnerability details  ## Impact In function settleAuction user needs to decide what bounties he/she wants to claim:     function settleAuction(         uint256[] memory bountyIDs     ...     withdrawBounty(bountyIDs); but bounties are stored in a private variable:    Bounty[] private _bounties; and there are no getter (view) functions to view bounties so I think that makes it very inconvenient for the end-user to find the appropriate ids that are relevant, especially considering there could be SPAM bounties as anyone can call addBounty.  ## Recommended Mitigation Steps Consider exposing public view functions to view bounties.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L14  BLOCK_DECREMENT is never used.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L146   `transfer()` might return false instead of reverting, in this case, ignoring return value leads to considering it successful.  use `safeTransfer()` or check the return value if length of returned data is > 0.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While safeApprove is used in the Factory contract, the use of ERC20 approve in approveUnderlying() (instead of safeApprove) is presumably to handle the reapprovals during changing of index but is susceptible to the historical ERC20 approve() race condition.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L106  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Be aware that this is susceptible to race-condition but this it unlikely a concern because the spender is always the auction contract which is cloned and therefore trusted.  
# Handle  0xRajeev   # Vulnerability details  ## Impact Another big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to generate an event when the new address or license fee is registered for change, pending the timelock duration. This is to warn protocol users that a pending change is upcoming (after the timelock) via offchain signalling so they can monitor/notice and decide to engage/exit based on their perception of the impact from the change.  The current implementation only emits an event when the pending change is enforced but not when it is made pending which does not provide one of the biggest benefits of a 2-step change.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L143-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L161-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add another event when the new publisher or licenseFee is made pending.  
# Handle  0xRajeev   # Vulnerability details  ## Impact A big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to allow any incorrectly used new addresses/values to be changed during the timelock period. This requires allowing the newPublisher or newLicenseFee to be a different value from the one used during the earlier approve and resetting the timelock again.  The current implementation only allows setting it once to a non-zero address/value and prevents any such corrections from being made (by checking that the address/value used is the same as that used during the first approve) which enforces the timelock to prevent surprises to users but does not provide the other accident benefits of using a timelock.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L137  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L155  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Recommend adding "&& pendingPublisher.publisher == newPublisher” and "&& pendingLicenseFee.licenseFee == newLicenseFee" to the if conditional predicate expression along with removing of the require() statement for equality check inside the conditional, to allow resetting the pending address/value to a new one if previously used one was incorrect.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Renouncing ownership is desirable in certain scenarios and is typically allowed by libraries such as Ownable.  The same may be true of the publisher role in this protocol as well to prevent changing the license fee or re-indexing the basket forever.   This is typically done by assigning a zero address to such a role i.e. burning it. However, by requiring any new proposed publisher address to be != zero address, the current implementation does not provide an option to renounce a publisher role by burning it.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L134  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support to renounce the publisher role or specify why this is not a desirable requirement for the protocol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Hardcoded constants in code is risky for auditability/readability/maintainability. The Factory contract uses 2e17 as a threshold check for ownerSplit instead of using a contract constant as done in other places.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L56  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Create a contract constant and use that as done in other places.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  None of the Factory owner setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  The impact of this is that a malicious/compromised/careless owner can intentionally/accidentally changes the minLicenseFee, auctionDecrement, auctionMultiplier, bondPercentDiv or ownerSplit values that significantly change the security/financial posture/perception of the protocol. No events are emitted and users may lose funds/confidence without being a chance to exit/engage protocol. The protocol takes a reputation hit.   See similar high-severity finding in OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and medium-severity finding OpenZeppelin’s Audit of UMA Phase 4: https://blog.openzeppelin.com/uma-audit-phase-4/.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L39-L41  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L47-L49  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L51-L53  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L55-L59   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend to consider emitting events when protocol critical values are updated by owner. This will be more transparent and it will make it easier to keep track of the status of the system.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawBounty() loops through the _bounties array looking for active bounties and transferring amounts from active ones. However, the data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference. So when bounty.active is set to false, this is changing only the memory copy and not the array element of the storage variable. This results in bounties never being set to inactive, keeping them always active forever and every withdrawBounty() will attempt to transfer bounty amount from the Auction contract to the msg.sender.  Therefore, while the transfer will work the first time, subsequent attempts to claim this bounty will revert on transfer (because the Auction contract will not have required amount of bounty tokens) causing withdrawBounty() to always revert and therefore preventing settling of any auction.   A malicious attacker can add a tiny bounty on any/every Auction contract to prevent any reindexing on that contract to happen because it will always revert on auction settling. This can be used to cause DoS on any auctionBonder so as to make them lose their bondAmount because their bonded auction cannot be settled.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143-L147  https://docs.soliditylang.org/en/v0.8.7/types.html#data-location-and-assignment-behaviour  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend changing storage specifier of bounty to "storage" instead of “memory".  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Given that there is no removal of claimed/inactive bounties, the bounty list could grow very long over time requiring a lot of gas for traversal.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L126-L151  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend pruning the claimed bounties by deleting them from the list.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87  ``` emit BasketLicenseProposed(msg.sender, tokenName); ```  same event can be emitted with excat same parameters multiple times causing confusion to actors relying on it.   Mitigation:  Add proposal id or some other parameter  
# Handle  leastwood   # Vulnerability details  ## Impact  The `validateWeights()` function can be better optimised by using a hashmap to measure token uniqueness. Currently, the function utilises an `O(n^2)` solution. By first iterating through each hashmap index for `_tokens`, any previously set tokens can be first cleared . This improves the current solution to `O(n)`.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53-L70  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using a hashmap to measure token uniqueness. However, this hashmap needs to first be cleared out before using it each time in `validateWeights()`.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  killAuction() is missing a require() to check that auctionOngoing == true before setting it to false. While currently, the caller publishNewIndex() in Basket has this condition checked, any other usages may accidentally call this when auction is not ongoing.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L175-L187  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add require(auctionOngoing == true)  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unused constant BLOCK_DECREMENT may be an indication of missing logic or redundant code. In this case, this appears to be a redundant constant same as Factory.auctionDecrement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L14  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Use the constant or remove it.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Choosing either named return or explicit instead of specifying both may reduce gas due to unnecessary bytecode introduced. proposeBasketLicense() uses a named return variable which is never assigned and instead uses an explicit return statement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L71  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L90  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Choose either explicit return or named return, not both  
# Handle  0xRajeev   # Vulnerability details  ## Impact Unnecessary return of argument value via state variable which costs a SLOAD, returns the same value as argument back to caller where the return value is ignored.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L221  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L216-L222  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L104  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove return value for this function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are places across contracts where the same external calls are made multiple times within a function. Caching return values of such calls in local/memory variables avoids CALLs to save gas. CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache factory.ownerSplit() return value to save 2600 gas in this function which gets called at every mint/burn.: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Hoist basketAsERC20.totalSupply() external call out of the loop because it remains the same and each call costs 2600 gas: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L96-L99  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache return values of external calls in local/memory variables  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are numerous places across contracts where the same state variables are read multiple times within a function. Caching state variables in local/memory variables avoids SLOADs to save gas. Warm SLOADs cost 100 gas after Berlin upgrade. MLOADs cost only 3 gas units. ## Proof of Concept  bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L62-L66  Cache basket, bondTimestamp, factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L78-L99  Cache basket and bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L116-L121  Cache pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L50  Cache lastFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L111-L116  Cache factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Cache pendingPublisher: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L139  Cache pendingLicenseFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L157  Cache auction & pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L173-L182  Cache publisher and auction: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208-L213  Cache proposals: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L62   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache state variables in local/memory variables to save gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L47-L52  `Auction.sol#initialize()` is using the factory_ parameter as the value of `factory`, while `Basket.sol#initialize()` uses `msg.sender`.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L39  Consider changing to `msg.sender` and remove the `factory_` parameter for the purpose of consistency and gas saving.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L143  ```solidity=140 function withdrawBounty(uint256[] memory bountyIds) internal {     // withdraw bounties     for (uint256 i = 0; i < bountyIds.length; i++) {         Bounty memory bounty = _bounties[bountyIds[i]];         require(bounty.active);          IERC20(bounty.token).transfer(msg.sender, bounty.amount);         bounty.active = false;          emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);     } } ```  In the `withdrawBounty` function, `bounty.active` should be set to `false` when the bounty is claimed.  However, since `bounty` is stored in memory, the state update will not succeed.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.   ### Proof of Concept  1. Create an auction; 2. Add a bounty; 3. Auction settled with bounty claimed; 4. Create a new auction; 5. Add a new bounty; 6. Calling `settleAuction()` with the bountyIds of the 2 seemly active bounties always reverts.  ### Recommended Mitigation Steps  Change to:  ```solidity= Bounty storage bounty = _bounties[bountyIds[i]]; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108  Given the `auctionBurn()` function will `_burn()` the auction bond without updating the `ibRatio`. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.bondPercentDiv = 400 basket.totalSupply = 400 basket.tokens = [BTC, ETH] basket.weights = [1, 1]  1. Create an auction; 2. Bond with 1 BASKET TOKEN; 3. Wait for 24 hrs and call `auctionBurn()`;  `basket.ibRatio` remains to be 1e18; basket.totalSupply = 399.  Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.  ### Recommended Mitigation Steps  Change to:  ```solidity= function auctionBurn(uint256 amount) onlyAuction external override {     handleFees();     uint256 startSupply = totalSupply();     _burn(msg.sender, amount);      uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);     ibRatio = newIbRatio;      emit NewIBRatio(newIbRatio);     emit Burned(msg.sender, amount); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact More fees are actually charged than intended   ## Mitigation Steps  [Basket.sol line 118](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118)   Assume that license fee is 10% i.e. 1e17 and time diff = half a year.   When you calculate `feePct`, you expect to get 5e16 since that's 5% and the actual amount of fee to be charged should be totalSupply * feePct (5) / BASE (100) but on line 118, we are actually dividing by BASE - feePct i.e. 95.   5 / 95 = 0.052 instead of the intended 0.05.  Solution is to replace `BASE - feePct` in the denominator with `BASE`.  
# Handle  nikitastupin   # Vulnerability details  Here https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L143-L143 the `bounty` variable is copied from Storage to Memory. Later it's assigned to false https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147. However, this assignment has no effect because `bounty` variable located at Memory so it's basically just thrown away when loop iteration finishes.  I think the intention was to make the `bounty.active` false so the same bounty isn't claimed twice or more times https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L144. However, the `bounty.active` will always be true because it never changes to false except for https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147 (which has no effect).  ## Impact  I don't see the direct impact here, however it may arise with the future changes to the contracts.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Do `_bounties[bountyIds[i]].active = false` instead of `bounty.active = false` if you need this check or just remove `bounty.active = false` and `require(bounty.active)` lines to save a gas otherwise.  
# Handle  nikitastupin   # Vulnerability details  Usually timelock is used in order to give a users of a protocol time to react on protocol changes (e.g. to withdraw their funds). Thus timelock implementations have Proposal and Execution steps. The main way to monitor blockchain changes and react to them is to listen for emitted events. However, none of the timelocked functions (`changePublisher`, `changeLicenseFee`, `publishNewIndex`) emits an event on Proposal step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L144-L147), they emit an event only on Execution step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L143-L143).  ## Impact  Events aren't emitted at critical functions.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Add events after (1) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L145-L146, (2) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L163-L164, (3) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L189-L192 and https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L182-L186.  
# Handle  JMukesh   # Vulnerability details  ## Impact by using approve() , we are not checking the value returned by the approve ,wether it got failed or successfully executed. so it is safe to use safeApproval()  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  ## Tools Used manual review  ## Recommended Mitigation Steps use safeApprove()  
# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking of array parameters in settleAuction()  , these array parameters can have different length which can lead to error.  inputWeight is iterated over the length of inputToken if one of the parameter have less length than other one will become inaccessible   which can lead to error  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  ## Tools Used  manual review  ## Recommended Mitigation Steps  
# Handle  t11s   # Vulnerability details  ## Impact Gas is wasted making `settleAuction` public, and using `memory` Instead of calldata for its arguments.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  If tokensNeeded is 0, it is possible to remove all the funds in the basket since no tokens are required to pass the balanceOf checks. The chances of this happening is very unlikely however it is better to be safe than sorry.   ## Recommended Mitigation Steps  Add a require statement to check that the numerator (`basketAsERC20.totalSupply() * pendingWeights[i] * newRatio`) is greater than or eq to the denominator (`BASE * BASE`). This will ensure that it can never round down i.e. tokensNeeded can never be 0.  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation  ## Recommended Mitigation Steps  The if branch in the handleFee() function is only there to handle the very first time handleFees are called. Thereafter, this condition will always fail so it makes more sense to initialize it with the initialize() function.  ```jsx function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {     publisher = proposal.proposer;     licenseFee = proposal.licenseFee;     factory = IFactory(msg.sender);     auction = auction_;     ibRatio = BASE;     tokens = proposal.tokens;     weights = proposal.weights;   lastFee = block.timestamp;      // updated lastFee here     approveUnderlying(address(auction));      __ERC20_init(proposal.tokenName, proposal.tokenSymbol); } ...  function handleFees() private {     // if (lastFee == 0) {            // delete this     //     lastFee = block.timestamp; // delete this     // } else {                       // delete this     uint256 startSupply = totalSupply();      uint256 timeDiff = (block.timestamp - lastFee);     uint256 feePct = timeDiff * licenseFee / ONE_YEAR;     uint256 fee = startSupply * feePct / (BASE - feePct);      _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);     _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);     lastFee = block.timestamp;      uint256 newIbRatio = ibRatio * startSupply / totalSupply();     ibRatio = newIbRatio;      emit NewIBRatio(ibRatio);     // }                              // delete this } ```  
# Handle  WatchPug   # Vulnerability details  The `newRatio` that determines `tokensNeeded` to settle the auction is calculated based on `auctionMultiplier`, `bondTimestamp - auctionStart` and `auctionDecrement`.  ```solidity= uint256 a = factory.auctionMultiplier() * basket.ibRatio(); uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); uint256 newRatio = a - b; ```  However, if an auction is bonded late (`bondTimestamp - auctionStart` is a large number), and/or the `auctionMultiplier` is small enough, and/or the `auctionDecrement` is small enough, that makes `b` to be greater than `a`, so that `uint256 newRatio = a - b;` will revert on underflow.  This might seem to be an edge case issue, but considering that a rebalance auction of a bag of shitcoin to high-value tokens might just end up being bonded at the last minute, with a `newRatio` near zero. When we take the time between the bonder submits the transaction and it got packed into a block, it's quite possible that the final `bondTimestamp` gets large enough to revet `a - b`.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled, and the user will lose the bond.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.auctionDecrement = 5760 (Blocks per day) factory.auctionMultiplier = 2  1. Create an auction; 2. The auction remain inactive (not get bonded) for more than 2 days (>11,520 blocks); 3. Call `bondForRebalance()` and it will succeed; 4. Calling `settleAuction()` will always revert.  ### Recommended Mitigation Steps  Calculate and require `newRatio > 0` in `bondForRebalance()`, or limit the max value of decrement and make sure newRatio always > 0 in `settleAuction()`.  
# Handle  shenwilly   # Vulnerability details  ## Impact OpenZeppelin ERC20Upgradeable `_burn` already checks for account balance, so another check is unnecessary.   ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92   ## Recommended Mitigation Steps Remove the require statement  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that zero value has not been checked on that "ibRatio" variable. That can cause  miscalculation of the liquidity.   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol" 2. Go to the line #217.  """         ibRatio = newRatio; """  3. Onlyauction modifier can assign ibRation to 0. 4. That can affect tokenAmount on the function.   """     function pushUnderlying(uint256 amount, address to) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransfer(to, tokenAmount);         }     } """  ## Tools Used  None  ## Recommended Mitigation Steps  Validate to ibRatio variable is more than zero.  """ require(ibRation > 0 , "ibRatio should be more than zero"); """  
# Handle  kenzo   # Vulnerability details  If a user is minting small amount of shares (like 1 - amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted. If the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with - although a miniscule amount.  ## Impact User can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.  ## Proof of Concept Add the following test to Basket.test.js. The user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE, and ends with 5e18+4, 1e18+4, 1e18+4. ``` it("should give to user more than he deserves", async () => {         await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            console.log("User balance before minting:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());                   await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));          console.log("\nUser balance after minting 1 share 5 times:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());          await basket.connect(owner).burn(await basket.balanceOf(owner.address));         console.log("\nUser balance after burning all shares:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());     }); ```  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to ```pullUnderlying```: ``` require(tokenAmount > 0); ``` I think it makes sense that if a user is trying to mint an amount so small that no tokens could be pulled from him, the mint request should be denied. Per my tests, for an initial ibRatio, this number (the minimal amount of shares that can be minted) is 2 for weights in magnitude of 1e18, and if the weights are eg. smaller by 100, this number will be 101.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110-L129  ```solidity= function handleFees() private {     if (lastFee == 0) {         lastFee = block.timestamp;     } else {         uint256 startSupply = totalSupply();          uint256 timeDiff = (block.timestamp - lastFee);         uint256 feePct = timeDiff * licenseFee / ONE_YEAR;         uint256 fee = startSupply * feePct / (BASE - feePct);          _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);         _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);         lastFee = block.timestamp;          uint256 newIbRatio = ibRatio * startSupply / totalSupply();         ibRatio = newIbRatio;          emit NewIBRatio(ibRatio);     } } ```  `timeDiff * licenseFee` can be greater than `ONE_YEAR` when `timeDiff` and/or `licenseFee` is large enough, which makes `feePct` to be greater than `BASE` so that `BASE - feePct` will revert on underflow.   ## Impact  Minting and burning of the basket token are being disrupted until the publisher update the `licenseFee`.  ## Proof of Concept  1. Create a basket with a `licenseFee` of `1e19` or 1000% per year and mint 1 basket token; 2. The basket remain inactive (not being minted or burned) for 2 months; 3. Calling `mint` and `burn` reverts at `handleFees()`.  ## Recommended Mitigation Steps  Limit the max value of `feePct`.  
# Handle  chasemartin01   # Vulnerability details  ## Impact Gas optimisation  ## Example As an example, you can change the declaration of `inputTokens`, `inputWeights`, `outputTokens`, `outputWeights` to be `calldata` as a gas optimisation  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69-L75  There's other instances of this in `Basket.sol` and`Factory.sol` ## Explanation When you specify `memory` for a function param for an external function, the following happens: the compiler copies elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change all instances of `memory` to `calldata` where the function parameter isn't being modified  
# Handle  WatchPug   # Vulnerability details  As defined in the ERC20 Specification, the approve function returns a bool that signals the success of the call. However, in `Basket.sol#approveUnderlying()` the value returned from calls to approve is ignored.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L224-L228  ## Recommended Mitigation Steps  To handle calls to approve safely, consider using the safeApprove function in OpenZeppelin’s SafeERC20 contract for all approvals.  
# Handle  loop   # Vulnerability details  `proposal` is declared as both a function name and the name for a Proposal object.  ## Proof of Concept Factory.sol line 35: `function proposal(uint256 proposalId) external override view returns (Proposal memory) {` Factory.sol line 77: `Proposal memory proposal = Proposal({`  ## Tools Used Remix  ## Recommended Mitigation Steps Change function name to `getProposal` to avoid double naming and be more in line with other getter/setter functions used.  
# Handle  loop   # Vulnerability details  In basket.sol there is one use of `uint` rather than `uint256`, which is used in the rest of the codebase.  ## Impact No real impact considering `uint` functions as a `uint256`.  ## Proof of Concept Basket.sol - line 60: `for (uint i = 0; i < length; i++) {`  
# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts: it("should divide by 0", async () => {       await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));       await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));        await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await basket.connect(addr1).mint(ethers.BigNumber.from(1));   });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  
# Handle  kenzo   # Vulnerability details  The ```handleFees``` function divides by ```(BASE - ((block.timestamp - lastFee)* licenseFee / ONE_YEAR))```. For initial BASE of 1e18 and licenseFee of 1e16, it means that if nobody calls this function in 100 years, the function will divide by 0.  ## Impact After 100 years of no usage, handleFees will always revert and nobody will be able to mint, burn etc'.  ## Proof of Concept Vulnerable line which will divide by 0: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L118 To test this, you can deploy to testnet a contract, then use a time machine to travel to 100 years in the future and try to use mint(). If for some reason you don't want to use your time machine, you may use this function to simulate the passage of time: ``` async function skipTime(seconds) {   let blockNumber = await hre.network.provider.request({     method: "eth_blockNumber",     params: [],   });   let block = await ethers.provider.getBlock(blockNumber["result"]);   await hre.network.provider.request({     method: "evm_mine",     params: [block["timestamp"]+seconds],   }); } ```  ## Tools Used Manual analysis, hardhat, time machine.  ## Recommended Mitigation Steps Tell your grandchildren to call mint(1) in 99 years.  
# Handle  kenzo   # Vulnerability details  The DeletedNewIndex log emits "publisher", but it might be the auction that called the function. Note: the event is defined as: event DeletedNewIndex(address _publisher); So if you wanted to anyway emit just the publisher, this is not a bug. However as this function call be called from both publisher and auction, I have a feeling you wanted to emit the msg.sender.  ## Impact Inaccurate data supplied.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Emit msg.sender instead of publisher.  
# Handle  gpersoon   # Vulnerability details  ## Impact If the functions mintTo and burn of Basket.sol are called twice in the same block then block.timestamp will stay the same and timeDiff ==0. Then it is not necessary to _mint () tokens, as this will be 0 tokens anyway.  So checking for timeDiff ==0 could save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110  function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();              uint256 timeDiff = (block.timestamp - lastFee);             uint256 feePct = timeDiff * licenseFee / ONE_YEAR;             uint256 fee = startSupply * feePct / (BASE - feePct);              _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);             _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);             lastFee = block.timestamp;             uint256 newIbRatio = ibRatio * startSupply / totalSupply();             ibRatio = newIbRatio;              emit NewIBRatio(ibRatio);         }     } ## Tools Used  ## Recommended Mitigation Steps Add an extra if in the following way:   function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();             uint256 timeDiff = (block.timestamp - lastFee);             if (timeDiff !=0) {                                                                      // ===> extra if                 uint256 feePct = timeDiff * licenseFee / ONE_YEAR;                 uint256 fee = startSupply * feePct / (BASE - feePct);                 _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);                 _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);                 lastFee = block.timestamp;                 uint256 newIbRatio = ibRatio * startSupply / totalSupply();                 ibRatio = newIbRatio;                 emit NewIBRatio(ibRatio);            }         }     }     
# Handle  gpersoon   # Vulnerability details  ## Impact When using the Openzeppelin upgradability pattern, the initialize() function should you the modifier initializer. However the initialize() function of Basket.sol doesn't have this modifier.  This won't give problems in practice because __ERC20_init() does have this modifier and prevents initialize() from being called twice. However forks of the projects or future developers might not be aware of this any make risky changes.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36 import { ERC20Upgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";  contract Basket is IBasket, ERC20Upgradeable { ..  function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {        ...          __ERC20_init(proposal.tokenName, proposal.tokenSymbol);     }  ## Tools Used  ## Recommended Mitigation Steps Add the modifier initializer to the function initialize()  
# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondTimestamp, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L89:#L99 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondTimestamp increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ```  
# Handle  kenzo   # Vulnerability details  When using few times an unchanging value from external contract call, the result can be saved and used without recalling the external contract.  ## Impact Some gas can be saved.  ## Proof of Concept In settleAuction, the basket's totalSupply stays constant through the loop's iterations. ``` for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L97  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Save basketAsERC20.totalSupply() to a local variable outside the loop, and use that variable inside the loop.  
# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  There's a chance that `newRatio` would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to [Black Thursday for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)  Given the chance that all user may lose their money, I consider this is a medium-risk issue.   ## Proof of Concept [Black Thursfay for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6) [bug-impacting-over-50-of-ethereum-clients-leads-to-fork](https://www.theblockcrypto.com/post/115822/bug-impacting-over-50-of-ethereum-clients-leads-to-fork)  ## Tools Used None  ## Recommended Mitigation Steps  I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low.  
# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  In this equation, `a` would not always be greater than `b`. The ` auctionBonder` may lock the token in `bondForRebalance()` at a point that `a-b` would always revert.  The contract should not allow users to lock the token at the point that not gonna succeed. Given the possible (huge) loss of the user may suffer, I consider this is a medium-risk issue.   ## Proof of Concept Here's a web3.py script to trigger this bug. ```python basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  for i in range(4 * 60 * 24):     w3.provider.make_request('evm_mine', []) basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  print('auction on going', auction.functions.auctionOngoing().call()) for i in range(20000):     w3.provider.make_request('evm_mine', [])  all_token = basket.functions.balanceOf(user).call() basket.functions.approve(auction.address, all_token).transact() auction.functions.bondForRebalance().transact() # error Log # {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'} auction.functions.settleAuction([], [], [], [], []).transact() ```   ## Tools Used None  ## Recommended Mitigation Steps Recommend to calculate the new irate in `bondForRebalance`. I understand the `auctionBonder` should take the risk to get the profit. However, the contract should protect the user in the first place when this auction is doomed to fail.  
# Handle  kenzo   # Vulnerability details  In some places where data is discarded such as ```bondBurn```, part of the data is set to 0 (```auctionBonder```), and other parts are not (```bondTimestamp```). Setting unnecessary data back to 0 will save gas.  ## Impact Almost 2000 gas saved for each variable reset. In some places, like ```createBasket``` (which only needs to save the proposal's "basket" field after creating the basket), this can save almost 15000 gas.  ## Proof of Concept Places where data is not reset: Factory's createBasket (set all _proposals[idNumber]'s fields to be 0 except basket) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L112 Basket's changePublisher: (set pendingPublisher.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L141 Basket's changeLicenseFee: (set pendingLicenseFee.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L159 Basket's setNewWeights and deleteNewIndex: (set pendingWeights.tokens and pendingWeights.weights to empty arrays) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L200 https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L212 Auction's killAuction: (set auctionStart = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L44 Auction's settleAuction: (set bondTimestamp, auctionBonder = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L107 Auction's bondBurn: (set bondTimestamp = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L120 Auction's withdrawBounty: (set bounty.token, bounty.token = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L148  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Detailed above.  
# Handle  kenzo   # Vulnerability details  The settleAuction() function calls withdrawBounty() before setting auctionOngoing = false, thereby allowing reentrancy.  ## Impact A malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to. At worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.  ## Proof of Concept 1. The publisher (a contract) will propose new valid index and bond the auction. To settle the auction, the publisher will execute the following steps in the same transaction: 2. Add a bounty of an ERC20 contract with a malicious transfer() function. 3. Settle the valid new weights correctly (using settleAuction() with the correct parameters, and passing the malicious bounty id). 4. settleAuction() will call withdrawBounty() which upon transfer will call the publisher's malicious ERC20 contract. 5. The contract will call settleAuction() again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, settleAuction() will finish correctly and call setNewWeights() which will set the new valid weights and set pendingWeights.pending = false. 6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's publishNewIndex(), with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set pendingWeights.pending = false. 7. Now the malicious withdrawBounty() has ended, and the original settleAuction() is resuming, but now with malicious weights in pendingWeights (set in step 6). settleAuction() will now call setNewWeights() which will set the basket's weights to be the malicious pending weights. 8. Now settleAuction has finished, and the publisher (within the same transaction) will burn() all his shares of the basket, thereby transferring all the tokens to himself.  POC exploit: Password to both files: "exploit". AttackPublisher.sol , to be put under contracts/contracts/Exploit: https://pastebin.com/efHZjstS ExploitPublisher.test.js , to be put under contracts/test: https://pastebin.com/knBtcWkk  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps In settleAuction(), move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern.  
# Handle  joeysantoro   # Vulnerability details  ## Impact If any of the timelocked variables of a basket are pending a change, a transaction to change the target will revert during the timelock window.  ## Proof of Concept Publisher wants to change license fee. They submit a change request but fat finger with the wrong value. The only way to change the pending licenseFee is to complete the change to the incorrect value (after timelock period) then resubmit a new request.  In the case of changing index this can be mitigated by using deleteNewIndex(), however changePublisher and changeLicenseFee cannot be mitigated.  ## Recommended Mitigation Steps Introduce a "setPendingX" method for each of  liscenceFee, publisher, and index. This cleanly separates the logic and allows for overwrite of pending during timelock window.  
# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that _bounties variable is global per basket. Also you are allowed to add 0 amount in bounty. This means if user adds uint256 max times bounty with amount 0, no one can add further bounty on this basket  ## Proof of Concept 1. User calls addBounty function with amount 0 uint256 max times  ```     function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {         // add bounty to basket         token.safeTransferFrom(msg.sender, address(this), amount);         _bounties.push(Bounty({             token: address(token),             amount: amount,             active: true         }));          uint256 id = _bounties.length - 1;         emit BountyAdded(token, amount, id);         return id;     } ```  2. Now noone can call bounty on this basket anymore  ## Recommended Mitigation Steps _bounties should be cleared once auction has been settled  
# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc The issue was discovered in validateWeights function of Basket contract   ## Proof of Concept 1. User proposes a new Basket with 0 tokens and weights using proposeBasketLicense function in Factory contract  ```  Proposal memory proposal = Proposal({             licenseFee: 10,             tokenName: abc,             tokenSymbol: aa,             proposer: 0xabc,             tokens: {},             weights: {},             basket: address(0)         }); ```  2. validateWeights function is called and it returns success as the only check performed is _tokens.length == _weights.length (0=0)  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length == _weights.length);         uint256 length = _tokens.length;         address[] memory tokenList = new address[](length);          // check uniqueness of tokens and not token(0)          for (uint i = 0; i < length; i++) {            ...         }     } ```  3. A new proposal gets created  ``` _proposals.push(proposal); ```  4. User creates new Basket with this proposal using createBasket function  ``` function createBasket(uint256 idNumber) external override returns (IBasket) {         Proposal memory bProposal = _proposals[idNumber];         require(bProposal.basket == address(0));          ....          for (uint256 i = 0; i < bProposal.weights.length; i++) {             ...         }   ...         return newBasket;     } ```  5. Since no weights and tokens were in this proposal so no token transfer is required (bProposal.weights.length will be 0 so loop won't run)  6. Basket gets created and user becomes publisher for this basket  ```         newBasket.mintTo(BASE, msg.sender);         _proposals[idNumber].basket = address(newBasket); ```  7. Publisher owned address calls the mint function with say amount 10 on Basket.sol contract  ```     function mint(uint256 amount) public override {         mintTo(amount, msg.sender);     }      function mintTo(uint256 amount, address to) public override {         ...          pullUnderlying(amount, msg.sender);          _mint(to, amount);          ...     } ```  8. Since there is no weights so pullUnderlying function does nothing (weights.length is 0)  ```     function pullUnderlying(uint256 amount, address from) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);         }     } ```  9. Full amount 10 is minted to Publisher owned address setting balanceOf(msg.sender) = 10  ``` _mint(to, amount); ```  10. Now Publisher calls the publishNewIndex to set new weights. Since pendingWeights.pending is false, else condition gets executed  ```     function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {         validateWeights(_tokens, _weights);          if (pendingWeights.pending) {             require(block.number >= pendingWeights.block + TIMELOCK_DURATION);             if (auction.auctionOngoing() == false) {                 auction.startAuction();                  emit PublishedNewIndex(publisher);             } else if (auction.hasBonded()) {              } else {                 auction.killAuction();                  pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.block = block.number;             }         } else {             pendingWeights.pending = true;             pendingWeights.tokens = _tokens;             pendingWeights.weights = _weights;             pendingWeights.block = block.number;         }     } ```   11. Publisher calls the publishNewIndex again which starts the Auction. This auction is later settled using the settleAuction function in Auction contract  12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his balanceOf(msg.sender) = 10 (Step 9)  ```     function burn(uint256 amount) public override {         require(auction.auctionOngoing() == false);         require(amount > 0);         require(balanceOf(msg.sender) >= amount);          handleFees();          pushUnderlying(amount, msg.sender);         _burn(msg.sender, amount);                  emit Burned(msg.sender, amount);     } ```  ## Recommended Mitigation Steps Change validateWeights to check for 0 length token  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length>0);   ...     } ```  
# Handle  bw   # Vulnerability details  ## Impact  A [require](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74) statement in `Factory.sol` could be performed prior to an expensive cross contract call, reducing the amount of gas wasted if the validation fails.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74  ## Tools Used  N/A  ## Recommended Mitigation Steps  Move the require statement before `basketImpl.validateWeights(tokens, weights);`  
# Handle  bw   # Vulnerability details  ## Impact  The implementation contracts that are used by proxies are not initialized by default, this creates the possibility that the contracts will not be initialized after deployment.  Uninitialized implementations could result in Denial of Service exploits. This often involves initializing the contract so that it is possible to `delegatecall` into a contract that has the `selfdestruct` opcode.   The contracts in-scope did not contain any `delegatecalls` that could be exploited. However, it is still regarded as best practice to ensure that the contracts cannot be initialized after deployment.  ## Proof of Concept  As a defence in-depth measure, the implementations should be initialized during deployed by adding the following: ```diff diff --git a/contracts/contracts/Auction.sol b/contracts/contracts/Auction.sol index f07df8b..f7c21eb 100644 --- a/contracts/contracts/Auction.sol +++ b/contracts/contracts/Auction.sol @@ -44,6 +44,10 @@ contract Auction is IAuction {          auctionOngoing = false;      }   +    constructor() { +        initialized = true; +    } +      function initialize(address basket_, address factory_) public override {          require(!initialized);          basket = IBasket(basket_); diff --git a/contracts/contracts/Basket.sol b/contracts/contracts/Basket.sol index 5fef21b..4549365 100644 --- a/contracts/contracts/Basket.sol +++ b/contracts/contracts/Basket.sol @@ -33,6 +33,10 @@ contract Basket is IBasket, ERC20Upgradeable {        uint256 public override lastFee;   +    constructor() { +        __ERC20_init("",  ""); +    } +      function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {          publisher = proposal.proposer;          licenseFee = proposal.licenseFee; ```  * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L9 * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L12  ## Tools Used  N/A  ## Recommended Mitigation Steps  Initialize implementations during deployment by adding a constructor.     
# Handle  bw   # Vulnerability details  ## Impact The [`Factory.sol`](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L19) contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  For more information regarding the `immutable` keyword: https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Proof of Concept  ### Code Diff  ```diff diff --git a/contracts/contracts/Factory.sol b/contracts/contracts/Factory.sol index 271945d..3bbdd4f 100644 --- a/contracts/contracts/Factory.sol +++ b/contracts/contracts/Factory.sol @@ -23,8 +23,8 @@ contract Factory is IFactory, Ownable {        Proposal[] private _proposals;   -    IAuction public override auctionImpl; -    IBasket public override basketImpl; +    IAuction public immutable override auctionImpl; +    IBasket public immutable override basketImpl;        uint256 public override minLicenseFee = 1e15; // 1e15 0.1%      uint256 public override auctionDecrement = 10000; ```  ### Gas Improvement  ```diff diff --git a/base.gas b/factory-immutable.gas index 9d48ade..1447433 100644 --- a/base.gas +++ b/factory-immutable.gas @@ -23,9 +23,9 @@  ·····················|························|·············|·············|···········|···············|··············  |  ERC20Upgradeable  ·  approve               ·          -  ·          -  ·    48900  ·            3  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· -|  Factory           ·  createBasket          ·     880031  ·     908831  ·   882911  ·           10  ·          -  │ +|  Factory           ·  createBasket          ·     875780  ·     904580  ·   878660  ·           10  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· -|  Factory           ·  proposeBasketLicense  ·     335488  ·     335512  ·   335505  ·           12  ·          -  │ +|  Factory           ·  proposeBasketLicense  ·     333388  ·     333412  ·   333405  ·           12  ·          -  │  ·····················|························|·············|·············|···········|···············|··············  |  Factory           ·  setOwnerSplit         ·          -  ·          -  ·    46173  ·            1  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· @@ -39,7 +39,7 @@  ··············································|·············|·············|···········|···············|··············  |  Basket                                     ·          -  ·          -  ·  2390793  ·          8 %  ·          -  │  ··············································|·············|·············|···········|···············|·············· -|  Factory                                    ·          -  ·          -  ·  1706801  ·        5.7 %  ·          -  │ +|  Factory                                    ·          -  ·          -  ·  1684215  ·        5.6 %  ·          -  │  ··············································|·············|·············|···········|···············|··············  |  TestToken                                  ·     653145  ·     653193  ·   653163  ·        2.2 %  ·          -  │  ·---------------------------------------------|-------------|-------------|-----------|---------------|-------------·  ```  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the immutable key word to all variables that are only set during the constructor.   
# Handle  jah   # Vulnerability details  ## Impact the initialize function will not be called from the contract and  it  doesn't require public visibility so the visibility should be changed to external to save gas as  described in https://mudit.blog/solidity-gas-optimization-tips/: “For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from calldata directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”     ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L36  ## Tools Used manual analysis  ## Recommended Mitigation Steps change the visibility to external  
# Handle  tensors   # Vulnerability details  ## Impact In L92 of Basket.sol there is an unnecessary require check that the user balance is greater than or equal to amount. If the amount is larger than user balance then the _burn() method will fail, causing the function to revert anyway.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92  ## Recommended Mitigation Steps Remove the unnecessary check.  
# Handle  tensors   # Vulnerability details  I recommend adding reentrancy checks throughout Basket.sol and Auction.sol using a mutex lock. Many external calls are made to potentially unsafe token contracts. In the case that not all token contracts are properly vetted, this preventative step could be worthwhile.  
# Handle  0xsanson   # Vulnerability details  ## Impact The owner of Factory contract can modify the values of `auctionMultiplier` and `auctionDecrement` at any time. During an auction, these values are used to calculate `newRatio` and thereby `tokensNeeded`: specifically, it's easy to set the factory parameters so that `tokensNeeded = 0` (or close to zero) for every token. This way the owner can participate at an auction, change the parameters, and get the underlying tokens from a Basket without transferring any pending tokens.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a Timelock to these Factory functions. Otherwise a way to not modify them if an auction is ongoing (maybe Auction saves the values it reads when `startAuction` is called).  
# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, `handleFees` computes the following: `uint256 newIbRatio = ibRatio * startSupply / totalSupply()`.  In the case that `totalSupply() = 0` (every holder burned their basket), the function reverts since there's a 0/0. This issue won't let new people mint, since `handleFees` is called before any minting.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L124  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a check before the division. ``` if (startSupply == 0) {  return; } ```  
# Handle  0xsanson   # Vulnerability details  ## Impact The function `Factory.proposeBasketLicense` at the end emits `BasketLicenseProposed(msg.sender, tokenName)` and returns the id of the proposal. This `id` should also be written to the log, since it's needed by the proposer (for createBasket), and they may not see the return value of an external function.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87-L90  ## Tools Used editor  ## Recommended Mitigation Steps Consider redefining the event to contain the id of the proposal.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, there is a function `mintTo(uint256 amount, address to)`. It's best practice to use as first argument `to`, and as second `amount`; see also the order used in L84 (_mint(to, amount)) and L86 (Minted(to, amount)).  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L76  ## Tools Used editor  ## Recommended Mitigation Steps Consider switching the arguments (also don't forget to change the calls to the function).  
# Handle  goatbug   # Vulnerability details  ## Impact Long list of functions should be set from public to external since they are not called anywhere by the contract itself.     ## Proof of Concept  There are too many to list them all from all the contracts.  Just some examples in the Factory contract.  There are lots in every contract that should rather be external.      function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {         minLicenseFee = newMinLicenseFee;     }      function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {         auctionDecrement = newAuctionDecrement;     }      function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {         auctionMultiplier = newAuctionMultiplier;     }      function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {         bondPercentDiv = newBondPercentDiv;     }      function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {         require(newOwnerSplit <= 2e17); // 20%          ownerSplit = newOwnerSplit;     }  ## Tools Used  ## Recommended Mitigation Steps  
# Handle  goatbug   # Vulnerability details  ## Impact Use less storage slots  ## Proof of Concept     struct Proposal {         uint256 licenseFee;         string tokenName;         string tokenSymbol;         address proposer;         address[] tokens;         uint256[] weights;         address basket;     } License fee is a smaller number does not need to be uint256.   Could use an 8 bit value and pack it comfortable with one of the addresses to save a full storage slot.   ## Tools Used  ## Recommended Mitigation Steps  
# Handle  hrkrshnn   # Vulnerability details  ## Replace `tokenList.length` by existing variable `length`  ``` diff modified   contracts/contracts/Basket.sol @@ -61,7 +61,7 @@ contract Basket is IBasket, ERC20Upgradeable {              require(_tokens[i] != address(0));              require(_weights[i] > 0);  -            for (uint256 x = 0; x < tokenList.length; x++) { +            for (uint256 x = 0; x < length; x++) {                  require(_tokens[i] != tokenList[x]);              } ```  Context: <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L64>  The value `tokenList.length` is read from memory and therefore requires a `mload(...)` (6 gas for `push memory_offset` + `mload`). On the other hand, this value is already available in the stack as `length` and could just be `dup-ed` (3 gas). Saves 3 gas for each loop iteration of the interior loop.   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  ### Examples  1.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L65> 2.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69> 3.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L140> 4.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36> 5.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53> 6.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L170>   
# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changeLicenseFee` function ensures that `pendingLicenseFee.licenseFee == newLicenseFee` which means setting `licenseFee = newLicenseFee` is equivalent to `licenseFee = pendingLicenseFee.licenseFee` but the former saves an expensive storage load operation.  
# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changePublisher` function ensures that `pendingPublisher.publisher == newPublisher` which means setting `publisher = newPublisher` is equivalent to `publisher = pendingPublisher.publisher` but the former saves an expensive storage load operation.  
# Handle  cmichel   # Vulnerability details  The `Auction.initialize` function accepts a `factory_` parameter. However, as this contract is always initialized directly from the factory, it can just use `msg.sender`.  ## Recommended Mitigation Steps Removing the additional `factory_` parameter and using `msg.sender` instead will save gas. This is already done for the other `Basket` contract.   
# Handle  cmichel   # Vulnerability details  Note that the `Basket` contract approved the `Auction` contract with all tokens and the `settleAuction` function allows the auction bonder to transfer all funds out of the basket to themselves. The only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:  ``` // this is the safety check if basket still has all the tokens after removing arbitrary amounts for (uint256 i = 0; i < pendingWeights.length; i++) {     uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;     require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded); } ```  The bonder can pass in any `inputTokens`, even malicious ones they created. This allows them to re-enter the `settleAuction` multiple times for the same auction.  Calling this function at the correct time (such that `bondTimestamp - auctionStart` makes `newRatio < basket.ibRatio()`), the attacker can drain more funds each time, eventually draining the entire basket.  ## POC Assume that the current `basket.ibRatio` is `1e18` (the initial value). The basket publisher calls `basket.publishNewIndex` with some tokens and weights. For simplicity, assume that the pending `tokens` are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio. The function call then starts the auction.  The important step to note is that the `tokensNeeded` value in `settleAuction` determines how many tokens need to stay in the `basket`. If we can continuously lower this value, we can keep removing tokens from the `basket` until it is empty.  The `tokensNeeded` variable is computed as `basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. The only variable that changes in the computation when re-entering the function is `newRatio` (no basket tokens are burned, and the pending weights are never cleared).  Thus if we can show that `newRatio` decreases on each re-entrant call, we can move out more and more funds each time.  #### newRatio decreases on each call After some time, the attacker calls `bondForRebalance`. This determines the `bondTimestamp - auctionStart` value in `settleAuction`. The attack is possible as soon as `newRatio < basket.ibRatio()`. For example, using the standard parameters the calculation would be:  ```solidity // a = 2 * ibRatio uint256 a = factory.auctionMultiplier() * basket.ibRatio(); // b = (bondTimestamp - auctionStart) * 1e14 uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); // newRatio = a - b = 2 * ibRatio - (bondTimestamp - auctionStart) * 1e14 uint256 newRatio = a - b; ```  With our initial assumption of `ibRatio = 1e18` and calling `bondForRebalance` after 11,000 seconds (~3 hours) we will get our result that `newRatio` is less than the initial `ibRatio`:  ```python newRatio = a - b = 2 * 1e18 - (11000) * 1e14 = 2e18 - 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio ```  > This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when `newRatio > basket.ibRatio` as they would put in more total value in tokens as they can take out of the basket.  #### re-enter on settleAuction The attacker creates a custom token `attackerToken` that re-enters the `Auction.settleAuction` function on `transferFrom` with parameters we will specify.  They call `settleAuction` with `inputTokens = [attackerToken]` to re-enter several times.  In the inner-most call where `newRatio = 0.9e18`, they choose the `inputTokens`/`outputTokens` parameters in a way to pass the initial `require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);` check - transferring out any other tokens of `basket` with `outputTokens`.  The function will continue to run and call `basket.setNewWeights();` and `basket.updateIBRatio(newRatio);` which will set the new weights (but not clear the pending ones) and set the new `basket.ibRatio`.  Execution then jumps to the 2nd inner call after the `IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...)` and has the chance to transfer out tokens again. It will compute `newRatio` with the new lowered `basket.ibRatio` of `0.9e18`: `newRatio = a - b = 2 * 0.9e18 - 1.1e18 = 0.7e18`. Therefore, `tokensNeeded` is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen `outputWeights`.  This repeats with `newRatio = 0.3`.  The attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the `bondAmount` tokens to the `auction` contract which are then each time transferred back in the function body. But I believe this should work.  ## Impact The basket funds can be stolen.  ## Recommended Mitigation Steps Add re-entrancy checks (for example, OpenZeppelin's "locks") to the `settleAuction` function.    
# Handle  cmichel   # Vulnerability details  The `Basket.changePublisher` function is used for both setting a new pending publisher as well as accepting the publisher transfer **from** the pending publisher.  ## Impact Once a pending publisher has been set, no other publisher can be set and if the pending publisher does not accept it, the contract is locked out of setting any other publishers. Setting a wrong publisher can naturally occur.  ## Recommended Mitigation Steps Add an option to set a new pending publisher even if there already is a pending publisher.   
# Handle  cmichel   # Vulnerability details  A basket creator can specify a custom token that allows them to re-enter in `Factory.createBasket`.  ## Impact As new auction and basket contracts are created every time, no cross-basket issues arise. However, note that the official `BasketCreated` event is emitted for all of them, but only the last basket is stored for the `idNumber`. This could lead to issues for some backend / frontend scripts that use the `BasketCreated` event.  ## Recommended Mitigation Steps Set `_proposals[idNumber].basket = address(newBasket);` immediately after the `newBasket` contract clone has been created to avoid the re-entrancy.   
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why you need this new local variable called newIbRatio if you instantly update and use the storage variable afterwards:   uint256 newIbRatio = ibRatio * startSupply / totalSupply();   ibRatio = newIbRatio;  ## Recommended Mitigation Steps   ibRatio = ibRatio * startSupply / totalSupply();  
# Handle  pauliax   # Vulnerability details  ## Impact This can be refactored to improve precision and gas usage:   _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);   _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);  ## Recommended Mitigation Steps Proposed solution:   uint256 factoryOwnerFee = fee * factory.ownerSplit() / BASE;   uint256 publisherFee = fee - factoryOwnerFee;   _mint(Ownable(address(factory)).owner(), factoryOwnerFee);   _mint(publisher, publisherFee); This will result in fewer math operations and better precision cuz multiplication and division are replaced with subtraction.  
# Handle  pauliax   # Vulnerability details  ## Impact BLOCK_DECREMENT state variable in Auction is not used anywhere.  ## Recommended Mitigation Steps Consider removing unused variables.  
# Handle  pauliax   # Vulnerability details  ## Impact This double division by BASE can be eliminated to improve precision and reduce gas costs:    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps if you introduce a constant variable, e.g.:    uint256 private constant BASE_2X = BASE * 2;    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE_2X;  
# Handle  pauliax   # Vulnerability details  ## Impact I think function initialize should also emit NewIBRatio event as it sets the initial value:  ibRatio = BASE;  ## Recommended Mitigation Steps emit NewIBRatio(ibRatio) in function initialize.  
# Handle  pauliax   # Vulnerability details  ## Impact Hardcoding numbers that depend on other variables is error-prone, e.g.     require(newOwnerSplit <= 2e17); // 20% You must not forget to update this if you decide to change the BASE value.  ## Recommended Mitigation Steps  Better define a separate constant that directly depends on the BASE, e.g.:     uint256 private constant MAX_OWNER_SPLIT = BASE / 5; // 20%     require(newOwnerSplit <= MAX_OWNER_SPLIT);  
# Handle  pauliax   # Vulnerability details  ## Impact In function settleAuction user needs to decide what bounties he/she wants to claim:     function settleAuction(         uint256[] memory bountyIDs     ...     withdrawBounty(bountyIDs); but bounties are stored in a private variable:    Bounty[] private _bounties; and there are no getter (view) functions to view bounties so I think that makes it very inconvenient for the end-user to find the appropriate ids that are relevant, especially considering there could be SPAM bounties as anyone can call addBounty.  ## Recommended Mitigation Steps Consider exposing public view functions to view bounties.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L14  BLOCK_DECREMENT is never used.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L146   `transfer()` might return false instead of reverting, in this case, ignoring return value leads to considering it successful.  use `safeTransfer()` or check the return value if length of returned data is > 0.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While safeApprove is used in the Factory contract, the use of ERC20 approve in approveUnderlying() (instead of safeApprove) is presumably to handle the reapprovals during changing of index but is susceptible to the historical ERC20 approve() race condition.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L106  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Be aware that this is susceptible to race-condition but this it unlikely a concern because the spender is always the auction contract which is cloned and therefore trusted.  
# Handle  0xRajeev   # Vulnerability details  ## Impact Another big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to generate an event when the new address or license fee is registered for change, pending the timelock duration. This is to warn protocol users that a pending change is upcoming (after the timelock) via offchain signalling so they can monitor/notice and decide to engage/exit based on their perception of the impact from the change.  The current implementation only emits an event when the pending change is enforced but not when it is made pending which does not provide one of the biggest benefits of a 2-step change.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L143-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L161-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add another event when the new publisher or licenseFee is made pending.  
# Handle  0xRajeev   # Vulnerability details  ## Impact A big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to allow any incorrectly used new addresses/values to be changed during the timelock period. This requires allowing the newPublisher or newLicenseFee to be a different value from the one used during the earlier approve and resetting the timelock again.  The current implementation only allows setting it once to a non-zero address/value and prevents any such corrections from being made (by checking that the address/value used is the same as that used during the first approve) which enforces the timelock to prevent surprises to users but does not provide the other accident benefits of using a timelock.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L137  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L155  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Recommend adding "&& pendingPublisher.publisher == newPublisher” and "&& pendingLicenseFee.licenseFee == newLicenseFee" to the if conditional predicate expression along with removing of the require() statement for equality check inside the conditional, to allow resetting the pending address/value to a new one if previously used one was incorrect.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Renouncing ownership is desirable in certain scenarios and is typically allowed by libraries such as Ownable.  The same may be true of the publisher role in this protocol as well to prevent changing the license fee or re-indexing the basket forever.   This is typically done by assigning a zero address to such a role i.e. burning it. However, by requiring any new proposed publisher address to be != zero address, the current implementation does not provide an option to renounce a publisher role by burning it.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L134  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support to renounce the publisher role or specify why this is not a desirable requirement for the protocol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Hardcoded constants in code is risky for auditability/readability/maintainability. The Factory contract uses 2e17 as a threshold check for ownerSplit instead of using a contract constant as done in other places.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L56  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Create a contract constant and use that as done in other places.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  None of the Factory owner setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  The impact of this is that a malicious/compromised/careless owner can intentionally/accidentally changes the minLicenseFee, auctionDecrement, auctionMultiplier, bondPercentDiv or ownerSplit values that significantly change the security/financial posture/perception of the protocol. No events are emitted and users may lose funds/confidence without being a chance to exit/engage protocol. The protocol takes a reputation hit.   See similar high-severity finding in OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and medium-severity finding OpenZeppelin’s Audit of UMA Phase 4: https://blog.openzeppelin.com/uma-audit-phase-4/.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L39-L41  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L47-L49  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L51-L53  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L55-L59   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend to consider emitting events when protocol critical values are updated by owner. This will be more transparent and it will make it easier to keep track of the status of the system.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawBounty() loops through the _bounties array looking for active bounties and transferring amounts from active ones. However, the data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference. So when bounty.active is set to false, this is changing only the memory copy and not the array element of the storage variable. This results in bounties never being set to inactive, keeping them always active forever and every withdrawBounty() will attempt to transfer bounty amount from the Auction contract to the msg.sender.  Therefore, while the transfer will work the first time, subsequent attempts to claim this bounty will revert on transfer (because the Auction contract will not have required amount of bounty tokens) causing withdrawBounty() to always revert and therefore preventing settling of any auction.   A malicious attacker can add a tiny bounty on any/every Auction contract to prevent any reindexing on that contract to happen because it will always revert on auction settling. This can be used to cause DoS on any auctionBonder so as to make them lose their bondAmount because their bonded auction cannot be settled.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143-L147  https://docs.soliditylang.org/en/v0.8.7/types.html#data-location-and-assignment-behaviour  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend changing storage specifier of bounty to "storage" instead of “memory".  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Given that there is no removal of claimed/inactive bounties, the bounty list could grow very long over time requiring a lot of gas for traversal.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L126-L151  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend pruning the claimed bounties by deleting them from the list.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87  ``` emit BasketLicenseProposed(msg.sender, tokenName); ```  same event can be emitted with excat same parameters multiple times causing confusion to actors relying on it.   Mitigation:  Add proposal id or some other parameter  
# Handle  leastwood   # Vulnerability details  ## Impact  The `validateWeights()` function can be better optimised by using a hashmap to measure token uniqueness. Currently, the function utilises an `O(n^2)` solution. By first iterating through each hashmap index for `_tokens`, any previously set tokens can be first cleared . This improves the current solution to `O(n)`.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53-L70  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using a hashmap to measure token uniqueness. However, this hashmap needs to first be cleared out before using it each time in `validateWeights()`.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  killAuction() is missing a require() to check that auctionOngoing == true before setting it to false. While currently, the caller publishNewIndex() in Basket has this condition checked, any other usages may accidentally call this when auction is not ongoing.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L175-L187  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add require(auctionOngoing == true)  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unused constant BLOCK_DECREMENT may be an indication of missing logic or redundant code. In this case, this appears to be a redundant constant same as Factory.auctionDecrement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L14  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Use the constant or remove it.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Choosing either named return or explicit instead of specifying both may reduce gas due to unnecessary bytecode introduced. proposeBasketLicense() uses a named return variable which is never assigned and instead uses an explicit return statement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L71  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L90  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Choose either explicit return or named return, not both  
# Handle  0xRajeev   # Vulnerability details  ## Impact Unnecessary return of argument value via state variable which costs a SLOAD, returns the same value as argument back to caller where the return value is ignored.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L221  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L216-L222  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L104  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove return value for this function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are places across contracts where the same external calls are made multiple times within a function. Caching return values of such calls in local/memory variables avoids CALLs to save gas. CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache factory.ownerSplit() return value to save 2600 gas in this function which gets called at every mint/burn.: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Hoist basketAsERC20.totalSupply() external call out of the loop because it remains the same and each call costs 2600 gas: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L96-L99  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache return values of external calls in local/memory variables  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are numerous places across contracts where the same state variables are read multiple times within a function. Caching state variables in local/memory variables avoids SLOADs to save gas. Warm SLOADs cost 100 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L62-L66  Cache basket, bondTimestamp, factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L78-L99  Cache basket and bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L116-L121  Cache pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L50  Cache lastFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L111-L116  Cache factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Cache pendingPublisher: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L139  Cache pendingLicenseFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L157  Cache auction & pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L173-L182  Cache publisher and auction: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208-L213  Cache proposals: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L62   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache state variables in local/memory variables to save gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L47-L52  `Auction.sol#initialize()` is using the factory_ parameter as the value of `factory`, while `Basket.sol#initialize()` uses `msg.sender`.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L39  Consider changing to `msg.sender` and remove the `factory_` parameter for the purpose of consistency and gas saving.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L143  ```solidity=140 function withdrawBounty(uint256[] memory bountyIds) internal {     // withdraw bounties     for (uint256 i = 0; i < bountyIds.length; i++) {         Bounty memory bounty = _bounties[bountyIds[i]];         require(bounty.active);          IERC20(bounty.token).transfer(msg.sender, bounty.amount);         bounty.active = false;          emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);     } } ```  In the `withdrawBounty` function, `bounty.active` should be set to `false` when the bounty is claimed.  However, since `bounty` is stored in memory, the state update will not succeed.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.   ### Proof of Concept  1. Create an auction; 2. Add a bounty; 3. Auction settled with bounty claimed; 4. Create a new auction; 5. Add a new bounty; 6. Calling `settleAuction()` with the bountyIds of the 2 seemly active bounties always reverts.  ### Recommended Mitigation Steps  Change to:  ```solidity= Bounty storage bounty = _bounties[bountyIds[i]]; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108  Given the `auctionBurn()` function will `_burn()` the auction bond without updating the `ibRatio`. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.bondPercentDiv = 400 basket.totalSupply = 400 basket.tokens = [BTC, ETH] basket.weights = [1, 1]  1. Create an auction; 2. Bond with 1 BASKET TOKEN; 3. Wait for 24 hrs and call `auctionBurn()`;  `basket.ibRatio` remains to be 1e18; basket.totalSupply = 399.  Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.  ### Recommended Mitigation Steps  Change to:  ```solidity= function auctionBurn(uint256 amount) onlyAuction external override {     handleFees();     uint256 startSupply = totalSupply();     _burn(msg.sender, amount);      uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);     ibRatio = newIbRatio;      emit NewIBRatio(newIbRatio);     emit Burned(msg.sender, amount); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact More fees are actually charged than intended   ## Mitigation Steps  [Basket.sol line 118](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118)   Assume that license fee is 10% i.e. 1e17 and time diff = half a year.   When you calculate `feePct`, you expect to get 5e16 since that's 5% and the actual amount of fee to be charged should be totalSupply * feePct (5) / BASE (100) but on line 118, we are actually dividing by BASE - feePct i.e. 95.   5 / 95 = 0.052 instead of the intended 0.05.  Solution is to replace `BASE - feePct` in the denominator with `BASE`.  
# Handle  nikitastupin   # Vulnerability details  Here https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L143-L143 the `bounty` variable is copied from Storage to Memory. Later it's assigned to false https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147. However, this assignment has no effect because `bounty` variable located at Memory so it's basically just thrown away when loop iteration finishes.  I think the intention was to make the `bounty.active` false so the same bounty isn't claimed twice or more times https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L144. However, the `bounty.active` will always be true because it never changes to false except for https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147 (which has no effect).  ## Impact  I don't see the direct impact here, however it may arise with the future changes to the contracts.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Do `_bounties[bountyIds[i]].active = false` instead of `bounty.active = false` if you need this check or just remove `bounty.active = false` and `require(bounty.active)` lines to save a gas otherwise.  
# Handle  nikitastupin   # Vulnerability details  Usually timelock is used in order to give a users of a protocol time to react on protocol changes (e.g. to withdraw their funds). Thus timelock implementations have Proposal and Execution steps. The main way to monitor blockchain changes and react to them is to listen for emitted events. However, none of the timelocked functions (`changePublisher`, `changeLicenseFee`, `publishNewIndex`) emits an event on Proposal step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L144-L147), they emit an event only on Execution step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L143-L143).  ## Impact  Events aren't emitted at critical functions.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Add events after (1) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L145-L146, (2) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L163-L164, (3) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L189-L192 and https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L182-L186.  
# Handle  JMukesh   # Vulnerability details  ## Impact by using approve() , we are not checking the value returned by the approve ,wether it got failed or successfully executed. so it is safe to use safeApproval()  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  ## Tools Used manual review  ## Recommended Mitigation Steps use safeApprove()  
# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking of array parameters in settleAuction()  , these array parameters can have different length which can lead to error.  inputWeight is iterated over the length of inputToken if one of the parameter have less length than other one will become inaccessible   which can lead to error  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  ## Tools Used  manual review  ## Recommended Mitigation Steps  
# Handle  t11s   # Vulnerability details  ## Impact Gas is wasted making `settleAuction` public, and using `memory` Instead of calldata for its arguments.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  If tokensNeeded is 0, it is possible to remove all the funds in the basket since no tokens are required to pass the balanceOf checks. The chances of this happening is very unlikely however it is better to be safe than sorry.   ## Recommended Mitigation Steps  Add a require statement to check that the numerator (`basketAsERC20.totalSupply() * pendingWeights[i] * newRatio`) is greater than or eq to the denominator (`BASE * BASE`). This will ensure that it can never round down i.e. tokensNeeded can never be 0.  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation  ## Recommended Mitigation Steps  The if branch in the handleFee() function is only there to handle the very first time handleFees are called. Thereafter, this condition will always fail so it makes more sense to initialize it with the initialize() function.  ```jsx function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {     publisher = proposal.proposer;     licenseFee = proposal.licenseFee;     factory = IFactory(msg.sender);     auction = auction_;     ibRatio = BASE;     tokens = proposal.tokens;     weights = proposal.weights;   lastFee = block.timestamp;      // updated lastFee here     approveUnderlying(address(auction));      __ERC20_init(proposal.tokenName, proposal.tokenSymbol); } ...  function handleFees() private {     // if (lastFee == 0) {            // delete this     //     lastFee = block.timestamp; // delete this     // } else {                       // delete this     uint256 startSupply = totalSupply();      uint256 timeDiff = (block.timestamp - lastFee);     uint256 feePct = timeDiff * licenseFee / ONE_YEAR;     uint256 fee = startSupply * feePct / (BASE - feePct);      _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);     _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);     lastFee = block.timestamp;      uint256 newIbRatio = ibRatio * startSupply / totalSupply();     ibRatio = newIbRatio;      emit NewIBRatio(ibRatio);     // }                              // delete this } ```  
# Handle  WatchPug   # Vulnerability details  The `newRatio` that determines `tokensNeeded` to settle the auction is calculated based on `auctionMultiplier`, `bondTimestamp - auctionStart` and `auctionDecrement`.  ```solidity= uint256 a = factory.auctionMultiplier() * basket.ibRatio(); uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); uint256 newRatio = a - b; ```  However, if an auction is bonded late (`bondTimestamp - auctionStart` is a large number), and/or the `auctionMultiplier` is small enough, and/or the `auctionDecrement` is small enough, that makes `b` to be greater than `a`, so that `uint256 newRatio = a - b;` will revert on underflow.  This might seem to be an edge case issue, but considering that a rebalance auction of a bag of shitcoin to high-value tokens might just end up being bonded at the last minute, with a `newRatio` near zero. When we take the time between the bonder submits the transaction and it got packed into a block, it's quite possible that the final `bondTimestamp` gets large enough to revet `a - b`.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled, and the user will lose the bond.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.auctionDecrement = 5760 (Blocks per day) factory.auctionMultiplier = 2  1. Create an auction; 2. The auction remain inactive (not get bonded) for more than 2 days (>11,520 blocks); 3. Call `bondForRebalance()` and it will succeed; 4. Calling `settleAuction()` will always revert.  ### Recommended Mitigation Steps  Calculate and require `newRatio > 0` in `bondForRebalance()`, or limit the max value of decrement and make sure newRatio always > 0 in `settleAuction()`.  
# Handle  shenwilly   # Vulnerability details  ## Impact OpenZeppelin ERC20Upgradeable `_burn` already checks for account balance, so another check is unnecessary.   ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92   ## Recommended Mitigation Steps Remove the require statement  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that zero value has not been checked on that "ibRatio" variable. That can cause  miscalculation of the liquidity.   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol" 2. Go to the line #217.  """         ibRatio = newRatio; """  3. Onlyauction modifier can assign ibRation to 0. 4. That can affect tokenAmount on the function.   """     function pushUnderlying(uint256 amount, address to) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransfer(to, tokenAmount);         }     } """  ## Tools Used  None  ## Recommended Mitigation Steps  Validate to ibRatio variable is more than zero.  """ require(ibRation > 0 , "ibRatio should be more than zero"); """  
# Handle  kenzo   # Vulnerability details  If a user is minting small amount of shares (like 1 - amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted. If the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with - although a miniscule amount.  ## Impact User can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.  ## Proof of Concept Add the following test to Basket.test.js. The user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE, and ends with 5e18+4, 1e18+4, 1e18+4. ``` it("should give to user more than he deserves", async () => {         await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            console.log("User balance before minting:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());                   await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));          console.log("\nUser balance after minting 1 share 5 times:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());          await basket.connect(owner).burn(await basket.balanceOf(owner.address));         console.log("\nUser balance after burning all shares:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());     }); ```  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to ```pullUnderlying```: ``` require(tokenAmount > 0); ``` I think it makes sense that if a user is trying to mint an amount so small that no tokens could be pulled from him, the mint request should be denied. Per my tests, for an initial ibRatio, this number (the minimal amount of shares that can be minted) is 2 for weights in magnitude of 1e18, and if the weights are eg. smaller by 100, this number will be 101.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110-L129  ```solidity= function handleFees() private {     if (lastFee == 0) {         lastFee = block.timestamp;     } else {         uint256 startSupply = totalSupply();          uint256 timeDiff = (block.timestamp - lastFee);         uint256 feePct = timeDiff * licenseFee / ONE_YEAR;         uint256 fee = startSupply * feePct / (BASE - feePct);          _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);         _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);         lastFee = block.timestamp;          uint256 newIbRatio = ibRatio * startSupply / totalSupply();         ibRatio = newIbRatio;          emit NewIBRatio(ibRatio);     } } ```  `timeDiff * licenseFee` can be greater than `ONE_YEAR` when `timeDiff` and/or `licenseFee` is large enough, which makes `feePct` to be greater than `BASE` so that `BASE - feePct` will revert on underflow.   ## Impact  Minting and burning of the basket token are being disrupted until the publisher update the `licenseFee`.  ## Proof of Concept  1. Create a basket with a `licenseFee` of `1e19` or 1000% per year and mint 1 basket token; 2. The basket remain inactive (not being minted or burned) for 2 months; 3. Calling `mint` and `burn` reverts at `handleFees()`.  ## Recommended Mitigation Steps  Limit the max value of `feePct`.  
# Handle  chasemartin01   # Vulnerability details  ## Impact Gas optimisation  ## Example As an example, you can change the declaration of `inputTokens`, `inputWeights`, `outputTokens`, `outputWeights` to be `calldata` as a gas optimisation  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69-L75  There's other instances of this in `Basket.sol` and`Factory.sol` ## Explanation When you specify `memory` for a function param for an external function, the following happens: the compiler copies elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change all instances of `memory` to `calldata` where the function parameter isn't being modified  
# Handle  WatchPug   # Vulnerability details  As defined in the ERC20 Specification, the approve function returns a bool that signals the success of the call. However, in `Basket.sol#approveUnderlying()` the value returned from calls to approve is ignored.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L224-L228  ## Recommended Mitigation Steps  To handle calls to approve safely, consider using the safeApprove function in OpenZeppelin’s SafeERC20 contract for all approvals.  
# Handle  loop   # Vulnerability details  `proposal` is declared as both a function name and the name for a Proposal object.  ## Proof of Concept Factory.sol line 35: `function proposal(uint256 proposalId) external override view returns (Proposal memory) {` Factory.sol line 77: `Proposal memory proposal = Proposal({`  ## Tools Used Remix  ## Recommended Mitigation Steps Change function name to `getProposal` to avoid double naming and be more in line with other getter/setter functions used.  
# Handle  loop   # Vulnerability details  In basket.sol there is one use of `uint` rather than `uint256`, which is used in the rest of the codebase.  ## Impact No real impact considering `uint` functions as a `uint256`.  ## Proof of Concept Basket.sol - line 60: `for (uint i = 0; i < length; i++) {`  
# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts: it("should divide by 0", async () => {       await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));       await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));        await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await basket.connect(addr1).mint(ethers.BigNumber.from(1));   });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  
# Handle  kenzo   # Vulnerability details  The ```handleFees``` function divides by ```(BASE - ((block.timestamp - lastFee)* licenseFee / ONE_YEAR))```. For initial BASE of 1e18 and licenseFee of 1e16, it means that if nobody calls this function in 100 years, the function will divide by 0.  ## Impact After 100 years of no usage, handleFees will always revert and nobody will be able to mint, burn etc'.  ## Proof of Concept Vulnerable line which will divide by 0: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L118 To test this, you can deploy to testnet a contract, then use a time machine to travel to 100 years in the future and try to use mint(). If for some reason you don't want to use your time machine, you may use this function to simulate the passage of time: ``` async function skipTime(seconds) {   let blockNumber = await hre.network.provider.request({     method: "eth_blockNumber",     params: [],   });   let block = await ethers.provider.getBlock(blockNumber["result"]);   await hre.network.provider.request({     method: "evm_mine",     params: [block["timestamp"]+seconds],   }); } ```  ## Tools Used Manual analysis, hardhat, time machine.  ## Recommended Mitigation Steps Tell your grandchildren to call mint(1) in 99 years.  
# Handle  kenzo   # Vulnerability details  The DeletedNewIndex log emits "publisher", but it might be the auction that called the function. Note: the event is defined as: event DeletedNewIndex(address _publisher); So if you wanted to anyway emit just the publisher, this is not a bug. However as this function call be called from both publisher and auction, I have a feeling you wanted to emit the msg.sender.  ## Impact Inaccurate data supplied.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Emit msg.sender instead of publisher.  
# Handle  gpersoon   # Vulnerability details  ## Impact If the functions mintTo and burn of Basket.sol are called twice in the same block then block.timestamp will stay the same and timeDiff ==0. Then it is not necessary to _mint () tokens, as this will be 0 tokens anyway.  So checking for timeDiff ==0 could save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110  function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();              uint256 timeDiff = (block.timestamp - lastFee);             uint256 feePct = timeDiff * licenseFee / ONE_YEAR;             uint256 fee = startSupply * feePct / (BASE - feePct);              _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);             _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);             lastFee = block.timestamp;             uint256 newIbRatio = ibRatio * startSupply / totalSupply();             ibRatio = newIbRatio;              emit NewIBRatio(ibRatio);         }     } ## Tools Used  ## Recommended Mitigation Steps Add an extra if in the following way:   function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();             uint256 timeDiff = (block.timestamp - lastFee);             if (timeDiff !=0) {                                                                      // ===> extra if                 uint256 feePct = timeDiff * licenseFee / ONE_YEAR;                 uint256 fee = startSupply * feePct / (BASE - feePct);                 _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);                 _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);                 lastFee = block.timestamp;                 uint256 newIbRatio = ibRatio * startSupply / totalSupply();                 ibRatio = newIbRatio;                 emit NewIBRatio(ibRatio);            }         }     }     
# Handle  gpersoon   # Vulnerability details  ## Impact When using the Openzeppelin upgradability pattern, the initialize() function should you the modifier initializer. However the initialize() function of Basket.sol doesn't have this modifier.  This won't give problems in practice because __ERC20_init() does have this modifier and prevents initialize() from being called twice. However forks of the projects or future developers might not be aware of this any make risky changes.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36 import { ERC20Upgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";  contract Basket is IBasket, ERC20Upgradeable { ..  function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {        ...          __ERC20_init(proposal.tokenName, proposal.tokenSymbol);     }  ## Tools Used  ## Recommended Mitigation Steps Add the modifier initializer to the function initialize()  
# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondTimestamp, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L89:#L99 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondTimestamp increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ```  
# Handle  kenzo   # Vulnerability details  When using few times an unchanging value from external contract call, the result can be saved and used without recalling the external contract.  ## Impact Some gas can be saved.  ## Proof of Concept In settleAuction, the basket's totalSupply stays constant through the loop's iterations. ``` for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L97  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Save basketAsERC20.totalSupply() to a local variable outside the loop, and use that variable inside the loop.  
# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  There's a chance that `newRatio` would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to [Black Thursday for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)  Given the chance that all user may lose their money, I consider this is a medium-risk issue.   ## Proof of Concept [Black Thursfay for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6) [bug-impacting-over-50-of-ethereum-clients-leads-to-fork](https://www.theblockcrypto.com/post/115822/bug-impacting-over-50-of-ethereum-clients-leads-to-fork)  ## Tools Used None  ## Recommended Mitigation Steps  I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low.  
# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  In this equation, `a` would not always be greater than `b`. The ` auctionBonder` may lock the token in `bondForRebalance()` at a point that `a-b` would always revert.  The contract should not allow users to lock the token at the point that not gonna succeed. Given the possible (huge) loss of the user may suffer, I consider this is a medium-risk issue.   ## Proof of Concept Here's a web3.py script to trigger this bug. ```python basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  for i in range(4 * 60 * 24):     w3.provider.make_request('evm_mine', []) basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  print('auction on going', auction.functions.auctionOngoing().call()) for i in range(20000):     w3.provider.make_request('evm_mine', [])  all_token = basket.functions.balanceOf(user).call() basket.functions.approve(auction.address, all_token).transact() auction.functions.bondForRebalance().transact() # error Log # {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'} auction.functions.settleAuction([], [], [], [], []).transact() ```   ## Tools Used None  ## Recommended Mitigation Steps Recommend to calculate the new irate in `bondForRebalance`. I understand the `auctionBonder` should take the risk to get the profit. However, the contract should protect the user in the first place when this auction is doomed to fail.  
# Handle  kenzo   # Vulnerability details  In some places where data is discarded such as ```bondBurn```, part of the data is set to 0 (```auctionBonder```), and other parts are not (```bondTimestamp```). Setting unnecessary data back to 0 will save gas.  ## Impact Almost 2000 gas saved for each variable reset. In some places, like ```createBasket``` (which only needs to save the proposal's "basket" field after creating the basket), this can save almost 15000 gas.  ## Proof of Concept Places where data is not reset: Factory's createBasket (set all _proposals[idNumber]'s fields to be 0 except basket) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L112 Basket's changePublisher: (set pendingPublisher.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L141 Basket's changeLicenseFee: (set pendingLicenseFee.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L159 Basket's setNewWeights and deleteNewIndex: (set pendingWeights.tokens and pendingWeights.weights to empty arrays) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L200 https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L212 Auction's killAuction: (set auctionStart = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L44 Auction's settleAuction: (set bondTimestamp, auctionBonder = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L107 Auction's bondBurn: (set bondTimestamp = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L120 Auction's withdrawBounty: (set bounty.token, bounty.token = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L148  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Detailed above.  
# Handle  kenzo   # Vulnerability details  The settleAuction() function calls withdrawBounty() before setting auctionOngoing = false, thereby allowing reentrancy.  ## Impact A malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to. At worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.  ## Proof of Concept 1. The publisher (a contract) will propose new valid index and bond the auction. To settle the auction, the publisher will execute the following steps in the same transaction: 2. Add a bounty of an ERC20 contract with a malicious transfer() function. 3. Settle the valid new weights correctly (using settleAuction() with the correct parameters, and passing the malicious bounty id). 4. settleAuction() will call withdrawBounty() which upon transfer will call the publisher's malicious ERC20 contract. 5. The contract will call settleAuction() again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, settleAuction() will finish correctly and call setNewWeights() which will set the new valid weights and set pendingWeights.pending = false. 6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's publishNewIndex(), with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set pendingWeights.pending = false. 7. Now the malicious withdrawBounty() has ended, and the original settleAuction() is resuming, but now with malicious weights in pendingWeights (set in step 6). settleAuction() will now call setNewWeights() which will set the basket's weights to be the malicious pending weights. 8. Now settleAuction has finished, and the publisher (within the same transaction) will burn() all his shares of the basket, thereby transferring all the tokens to himself.  POC exploit: Password to both files: "exploit". AttackPublisher.sol , to be put under contracts/contracts/Exploit: https://pastebin.com/efHZjstS ExploitPublisher.test.js , to be put under contracts/test: https://pastebin.com/knBtcWkk  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps In settleAuction(), move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern.  
# Handle  joeysantoro   # Vulnerability details  ## Impact If any of the timelocked variables of a basket are pending a change, a transaction to change the target will revert during the timelock window.  ## Proof of Concept Publisher wants to change license fee. They submit a change request but fat finger with the wrong value. The only way to change the pending licenseFee is to complete the change to the incorrect value (after timelock period) then resubmit a new request.  In the case of changing index this can be mitigated by using deleteNewIndex(), however changePublisher and changeLicenseFee cannot be mitigated.  ## Recommended Mitigation Steps Introduce a "setPendingX" method for each of  liscenceFee, publisher, and index. This cleanly separates the logic and allows for overwrite of pending during timelock window.  
# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that _bounties variable is global per basket. Also you are allowed to add 0 amount in bounty. This means if user adds uint256 max times bounty with amount 0, no one can add further bounty on this basket  ## Proof of Concept 1. User calls addBounty function with amount 0 uint256 max times  ```     function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {         // add bounty to basket         token.safeTransferFrom(msg.sender, address(this), amount);         _bounties.push(Bounty({             token: address(token),             amount: amount,             active: true         }));          uint256 id = _bounties.length - 1;         emit BountyAdded(token, amount, id);         return id;     } ```  2. Now noone can call bounty on this basket anymore  ## Recommended Mitigation Steps _bounties should be cleared once auction has been settled  
# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc The issue was discovered in validateWeights function of Basket contract   ## Proof of Concept 1. User proposes a new Basket with 0 tokens and weights using proposeBasketLicense function in Factory contract  ```  Proposal memory proposal = Proposal({             licenseFee: 10,             tokenName: abc,             tokenSymbol: aa,             proposer: 0xabc,             tokens: {},             weights: {},             basket: address(0)         }); ```  2. validateWeights function is called and it returns success as the only check performed is _tokens.length == _weights.length (0=0)  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length == _weights.length);         uint256 length = _tokens.length;         address[] memory tokenList = new address[](length);          // check uniqueness of tokens and not token(0)          for (uint i = 0; i < length; i++) {            ...         }     } ```  3. A new proposal gets created  ``` _proposals.push(proposal); ```  4. User creates new Basket with this proposal using createBasket function  ``` function createBasket(uint256 idNumber) external override returns (IBasket) {         Proposal memory bProposal = _proposals[idNumber];         require(bProposal.basket == address(0));          ....          for (uint256 i = 0; i < bProposal.weights.length; i++) {             ...         }   ...         return newBasket;     } ```  5. Since no weights and tokens were in this proposal so no token transfer is required (bProposal.weights.length will be 0 so loop won't run)  6. Basket gets created and user becomes publisher for this basket  ```         newBasket.mintTo(BASE, msg.sender);         _proposals[idNumber].basket = address(newBasket); ```  7. Publisher owned address calls the mint function with say amount 10 on Basket.sol contract  ```     function mint(uint256 amount) public override {         mintTo(amount, msg.sender);     }      function mintTo(uint256 amount, address to) public override {         ...          pullUnderlying(amount, msg.sender);          _mint(to, amount);          ...     } ```  8. Since there is no weights so pullUnderlying function does nothing (weights.length is 0)  ```     function pullUnderlying(uint256 amount, address from) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);         }     } ```  9. Full amount 10 is minted to Publisher owned address setting balanceOf(msg.sender) = 10  ``` _mint(to, amount); ```  10. Now Publisher calls the publishNewIndex to set new weights. Since pendingWeights.pending is false, else condition gets executed  ```     function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {         validateWeights(_tokens, _weights);          if (pendingWeights.pending) {             require(block.number >= pendingWeights.block + TIMELOCK_DURATION);             if (auction.auctionOngoing() == false) {                 auction.startAuction();                  emit PublishedNewIndex(publisher);             } else if (auction.hasBonded()) {              } else {                 auction.killAuction();                  pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.block = block.number;             }         } else {             pendingWeights.pending = true;             pendingWeights.tokens = _tokens;             pendingWeights.weights = _weights;             pendingWeights.block = block.number;         }     } ```   11. Publisher calls the publishNewIndex again which starts the Auction. This auction is later settled using the settleAuction function in Auction contract  12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his balanceOf(msg.sender) = 10 (Step 9)  ```     function burn(uint256 amount) public override {         require(auction.auctionOngoing() == false);         require(amount > 0);         require(balanceOf(msg.sender) >= amount);          handleFees();          pushUnderlying(amount, msg.sender);         _burn(msg.sender, amount);                  emit Burned(msg.sender, amount);     } ```  ## Recommended Mitigation Steps Change validateWeights to check for 0 length token  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length>0);   ...     } ```  
# Handle  bw   # Vulnerability details  ## Impact  A [require](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74) statement in `Factory.sol` could be performed prior to an expensive cross contract call, reducing the amount of gas wasted if the validation fails.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74  ## Tools Used  N/A  ## Recommended Mitigation Steps  Move the require statement before `basketImpl.validateWeights(tokens, weights);`  
# Handle  bw   # Vulnerability details  ## Impact  The implementation contracts that are used by proxies are not initialized by default, this creates the possibility that the contracts will not be initialized after deployment.  Uninitialized implementations could result in Denial of Service exploits. This often involves initializing the contract so that it is possible to `delegatecall` into a contract that has the `selfdestruct` opcode.   The contracts in-scope did not contain any `delegatecalls` that could be exploited. However, it is still regarded as best practice to ensure that the contracts cannot be initialized after deployment.  ## Proof of Concept  As a defence in-depth measure, the implementations should be initialized during deployed by adding the following: ```diff diff --git a/contracts/contracts/Auction.sol b/contracts/contracts/Auction.sol index f07df8b..f7c21eb 100644 --- a/contracts/contracts/Auction.sol +++ b/contracts/contracts/Auction.sol @@ -44,6 +44,10 @@ contract Auction is IAuction {          auctionOngoing = false;      }   +    constructor() { +        initialized = true; +    } +      function initialize(address basket_, address factory_) public override {          require(!initialized);          basket = IBasket(basket_); diff --git a/contracts/contracts/Basket.sol b/contracts/contracts/Basket.sol index 5fef21b..4549365 100644 --- a/contracts/contracts/Basket.sol +++ b/contracts/contracts/Basket.sol @@ -33,6 +33,10 @@ contract Basket is IBasket, ERC20Upgradeable {        uint256 public override lastFee;   +    constructor() { +        __ERC20_init("",  ""); +    } +      function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {          publisher = proposal.proposer;          licenseFee = proposal.licenseFee; ```  * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L9 * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L12  ## Tools Used  N/A  ## Recommended Mitigation Steps  Initialize implementations during deployment by adding a constructor.     
# Handle  bw   # Vulnerability details  ## Impact The [`Factory.sol`](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L19) contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  For more information regarding the `immutable` keyword: https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Proof of Concept  ### Code Diff  ```diff diff --git a/contracts/contracts/Factory.sol b/contracts/contracts/Factory.sol index 271945d..3bbdd4f 100644 --- a/contracts/contracts/Factory.sol +++ b/contracts/contracts/Factory.sol @@ -23,8 +23,8 @@ contract Factory is IFactory, Ownable {        Proposal[] private _proposals;   -    IAuction public override auctionImpl; -    IBasket public override basketImpl; +    IAuction public immutable override auctionImpl; +    IBasket public immutable override basketImpl;        uint256 public override minLicenseFee = 1e15; // 1e15 0.1%      uint256 public override auctionDecrement = 10000; ```  ### Gas Improvement  ```diff diff --git a/base.gas b/factory-immutable.gas index 9d48ade..1447433 100644 --- a/base.gas +++ b/factory-immutable.gas @@ -23,9 +23,9 @@  ·····················|························|·············|·············|···········|···············|··············  |  ERC20Upgradeable  ·  approve               ·          -  ·          -  ·    48900  ·            3  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· -|  Factory           ·  createBasket          ·     880031  ·     908831  ·   882911  ·           10  ·          -  │ +|  Factory           ·  createBasket          ·     875780  ·     904580  ·   878660  ·           10  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· -|  Factory           ·  proposeBasketLicense  ·     335488  ·     335512  ·   335505  ·           12  ·          -  │ +|  Factory           ·  proposeBasketLicense  ·     333388  ·     333412  ·   333405  ·           12  ·          -  │  ·····················|························|·············|·············|···········|···············|··············  |  Factory           ·  setOwnerSplit         ·          -  ·          -  ·    46173  ·            1  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· @@ -39,7 +39,7 @@  ··············································|·············|·············|···········|···············|··············  |  Basket                                     ·          -  ·          -  ·  2390793  ·          8 %  ·          -  │  ··············································|·············|·············|···········|···············|·············· -|  Factory                                    ·          -  ·          -  ·  1706801  ·        5.7 %  ·          -  │ +|  Factory                                    ·          -  ·          -  ·  1684215  ·        5.6 %  ·          -  │  ··············································|·············|·············|···········|···············|··············  |  TestToken                                  ·     653145  ·     653193  ·   653163  ·        2.2 %  ·          -  │  ·---------------------------------------------|-------------|-------------|-----------|---------------|-------------·  ```  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the immutable key word to all variables that are only set during the constructor.   
# Handle  jah   # Vulnerability details  ## Impact the initialize function will not be called from the contract and  it  doesn't require public visibility so the visibility should be changed to external to save gas as  described in https://mudit.blog/solidity-gas-optimization-tips/: “For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from calldata directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”     ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L36  ## Tools Used manual analysis  ## Recommended Mitigation Steps change the visibility to external  
# Handle  tensors   # Vulnerability details  ## Impact In L92 of Basket.sol there is an unnecessary require check that the user balance is greater than or equal to amount. If the amount is larger than user balance then the _burn() method will fail, causing the function to revert anyway.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92  ## Recommended Mitigation Steps Remove the unnecessary check.  
# Handle  tensors   # Vulnerability details  I recommend adding reentrancy checks throughout Basket.sol and Auction.sol using a mutex lock. Many external calls are made to potentially unsafe token contracts. In the case that not all token contracts are properly vetted, this preventative step could be worthwhile.  
# Handle  0xsanson   # Vulnerability details  ## Impact The owner of Factory contract can modify the values of `auctionMultiplier` and `auctionDecrement` at any time. During an auction, these values are used to calculate `newRatio` and thereby `tokensNeeded`: specifically, it's easy to set the factory parameters so that `tokensNeeded = 0` (or close to zero) for every token. This way the owner can participate at an auction, change the parameters, and get the underlying tokens from a Basket without transferring any pending tokens.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a Timelock to these Factory functions. Otherwise a way to not modify them if an auction is ongoing (maybe Auction saves the values it reads when `startAuction` is called).  
# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, `handleFees` computes the following: `uint256 newIbRatio = ibRatio * startSupply / totalSupply()`.  In the case that `totalSupply() = 0` (every holder burned their basket), the function reverts since there's a 0/0. This issue won't let new people mint, since `handleFees` is called before any minting.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L124  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a check before the division. ``` if (startSupply == 0) {  return; } ```  
# Handle  0xsanson   # Vulnerability details  ## Impact The function `Factory.proposeBasketLicense` at the end emits `BasketLicenseProposed(msg.sender, tokenName)` and returns the id of the proposal. This `id` should also be written to the log, since it's needed by the proposer (for createBasket), and they may not see the return value of an external function.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87-L90  ## Tools Used editor  ## Recommended Mitigation Steps Consider redefining the event to contain the id of the proposal.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, there is a function `mintTo(uint256 amount, address to)`. It's best practice to use as first argument `to`, and as second `amount`; see also the order used in L84 (_mint(to, amount)) and L86 (Minted(to, amount)).  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L76  ## Tools Used editor  ## Recommended Mitigation Steps Consider switching the arguments (also don't forget to change the calls to the function).  
# Handle  goatbug   # Vulnerability details  ## Impact Long list of functions should be set from public to external since they are not called anywhere by the contract itself.     ## Proof of Concept  There are too many to list them all from all the contracts.  Just some examples in the Factory contract.  There are lots in every contract that should rather be external.      function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {         minLicenseFee = newMinLicenseFee;     }      function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {         auctionDecrement = newAuctionDecrement;     }      function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {         auctionMultiplier = newAuctionMultiplier;     }      function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {         bondPercentDiv = newBondPercentDiv;     }      function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {         require(newOwnerSplit <= 2e17); // 20%          ownerSplit = newOwnerSplit;     }  ## Tools Used  ## Recommended Mitigation Steps  
# Handle  goatbug   # Vulnerability details  ## Impact Use less storage slots  ## Proof of Concept     struct Proposal {         uint256 licenseFee;         string tokenName;         string tokenSymbol;         address proposer;         address[] tokens;         uint256[] weights;         address basket;     } License fee is a smaller number does not need to be uint256.   Could use an 8 bit value and pack it comfortable with one of the addresses to save a full storage slot.   ## Tools Used  ## Recommended Mitigation Steps  
# Handle  hrkrshnn   # Vulnerability details  ## Replace `tokenList.length` by existing variable `length`  ``` diff modified   contracts/contracts/Basket.sol @@ -61,7 +61,7 @@ contract Basket is IBasket, ERC20Upgradeable {              require(_tokens[i] != address(0));              require(_weights[i] > 0);  -            for (uint256 x = 0; x < tokenList.length; x++) { +            for (uint256 x = 0; x < length; x++) {                  require(_tokens[i] != tokenList[x]);              } ```  Context: <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L64>  The value `tokenList.length` is read from memory and therefore requires a `mload(...)` (6 gas for `push memory_offset` + `mload`). On the other hand, this value is already available in the stack as `length` and could just be `dup-ed` (3 gas). Saves 3 gas for each loop iteration of the interior loop.   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  ### Examples  1.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L65> 2.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69> 3.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L140> 4.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36> 5.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53> 6.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L170>   
# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changeLicenseFee` function ensures that `pendingLicenseFee.licenseFee == newLicenseFee` which means setting `licenseFee = newLicenseFee` is equivalent to `licenseFee = pendingLicenseFee.licenseFee` but the former saves an expensive storage load operation.  
# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changePublisher` function ensures that `pendingPublisher.publisher == newPublisher` which means setting `publisher = newPublisher` is equivalent to `publisher = pendingPublisher.publisher` but the former saves an expensive storage load operation.  
# Handle  cmichel   # Vulnerability details  The `Auction.initialize` function accepts a `factory_` parameter. However, as this contract is always initialized directly from the factory, it can just use `msg.sender`.  ## Recommended Mitigation Steps Removing the additional `factory_` parameter and using `msg.sender` instead will save gas. This is already done for the other `Basket` contract.   
# Handle  cmichel   # Vulnerability details  Note that the `Basket` contract approved the `Auction` contract with all tokens and the `settleAuction` function allows the auction bonder to transfer all funds out of the basket to themselves. The only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:  ``` // this is the safety check if basket still has all the tokens after removing arbitrary amounts for (uint256 i = 0; i < pendingWeights.length; i++) {     uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;     require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded); } ```  The bonder can pass in any `inputTokens`, even malicious ones they created. This allows them to re-enter the `settleAuction` multiple times for the same auction.  Calling this function at the correct time (such that `bondTimestamp - auctionStart` makes `newRatio < basket.ibRatio()`), the attacker can drain more funds each time, eventually draining the entire basket.  ## POC Assume that the current `basket.ibRatio` is `1e18` (the initial value). The basket publisher calls `basket.publishNewIndex` with some tokens and weights. For simplicity, assume that the pending `tokens` are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio. The function call then starts the auction.  The important step to note is that the `tokensNeeded` value in `settleAuction` determines how many tokens need to stay in the `basket`. If we can continuously lower this value, we can keep removing tokens from the `basket` until it is empty.  The `tokensNeeded` variable is computed as `basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. The only variable that changes in the computation when re-entering the function is `newRatio` (no basket tokens are burned, and the pending weights are never cleared).  Thus if we can show that `newRatio` decreases on each re-entrant call, we can move out more and more funds each time.  #### newRatio decreases on each call After some time, the attacker calls `bondForRebalance`. This determines the `bondTimestamp - auctionStart` value in `settleAuction`. The attack is possible as soon as `newRatio < basket.ibRatio()`. For example, using the standard parameters the calculation would be:  ```solidity // a = 2 * ibRatio uint256 a = factory.auctionMultiplier() * basket.ibRatio(); // b = (bondTimestamp - auctionStart) * 1e14 uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); // newRatio = a - b = 2 * ibRatio - (bondTimestamp - auctionStart) * 1e14 uint256 newRatio = a - b; ```  With our initial assumption of `ibRatio = 1e18` and calling `bondForRebalance` after 11,000 seconds (~3 hours) we will get our result that `newRatio` is less than the initial `ibRatio`:  ```python newRatio = a - b = 2 * 1e18 - (11000) * 1e14 = 2e18 - 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio ```  > This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when `newRatio > basket.ibRatio` as they would put in more total value in tokens as they can take out of the basket.  #### re-enter on settleAuction The attacker creates a custom token `attackerToken` that re-enters the `Auction.settleAuction` function on `transferFrom` with parameters we will specify.  They call `settleAuction` with `inputTokens = [attackerToken]` to re-enter several times.  In the inner-most call where `newRatio = 0.9e18`, they choose the `inputTokens`/`outputTokens` parameters in a way to pass the initial `require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);` check - transferring out any other tokens of `basket` with `outputTokens`.  The function will continue to run and call `basket.setNewWeights();` and `basket.updateIBRatio(newRatio);` which will set the new weights (but not clear the pending ones) and set the new `basket.ibRatio`.  Execution then jumps to the 2nd inner call after the `IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...)` and has the chance to transfer out tokens again. It will compute `newRatio` with the new lowered `basket.ibRatio` of `0.9e18`: `newRatio = a - b = 2 * 0.9e18 - 1.1e18 = 0.7e18`. Therefore, `tokensNeeded` is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen `outputWeights`.  This repeats with `newRatio = 0.3`.  The attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the `bondAmount` tokens to the `auction` contract which are then each time transferred back in the function body. But I believe this should work.  ## Impact The basket funds can be stolen.  ## Recommended Mitigation Steps Add re-entrancy checks (for example, OpenZeppelin's "locks") to the `settleAuction` function.    
# Handle  cmichel   # Vulnerability details  The `Basket.changePublisher` function is used for both setting a new pending publisher as well as accepting the publisher transfer **from** the pending publisher.  ## Impact Once a pending publisher has been set, no other publisher can be set and if the pending publisher does not accept it, the contract is locked out of setting any other publishers. Setting a wrong publisher can naturally occur.  ## Recommended Mitigation Steps Add an option to set a new pending publisher even if there already is a pending publisher.   
# Handle  cmichel   # Vulnerability details  A basket creator can specify a custom token that allows them to re-enter in `Factory.createBasket`.  ## Impact As new auction and basket contracts are created every time, no cross-basket issues arise. However, note that the official `BasketCreated` event is emitted for all of them, but only the last basket is stored for the `idNumber`. This could lead to issues for some backend / frontend scripts that use the `BasketCreated` event.  ## Recommended Mitigation Steps Set `_proposals[idNumber].basket = address(newBasket);` immediately after the `newBasket` contract clone has been created to avoid the re-entrancy.   
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why you need this new local variable called newIbRatio if you instantly update and use the storage variable afterwards:   uint256 newIbRatio = ibRatio * startSupply / totalSupply();   ibRatio = newIbRatio;  ## Recommended Mitigation Steps   ibRatio = ibRatio * startSupply / totalSupply();  
# Handle  pauliax   # Vulnerability details  ## Impact This can be refactored to improve precision and gas usage:   _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);   _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);  ## Recommended Mitigation Steps Proposed solution:   uint256 factoryOwnerFee = fee * factory.ownerSplit() / BASE;   uint256 publisherFee = fee - factoryOwnerFee;   _mint(Ownable(address(factory)).owner(), factoryOwnerFee);   _mint(publisher, publisherFee); This will result in fewer math operations and better precision cuz multiplication and division are replaced with subtraction.  
# Handle  pauliax   # Vulnerability details  ## Impact BLOCK_DECREMENT state variable in Auction is not used anywhere.  ## Recommended Mitigation Steps Consider removing unused variables.  
# Handle  pauliax   # Vulnerability details  ## Impact This double division by BASE can be eliminated to improve precision and reduce gas costs:    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps if you introduce a constant variable, e.g.:    uint256 private constant BASE_2X = BASE * 2;    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE_2X;  
# Handle  pauliax   # Vulnerability details  ## Impact I think function initialize should also emit NewIBRatio event as it sets the initial value:  ibRatio = BASE;  ## Recommended Mitigation Steps emit NewIBRatio(ibRatio) in function initialize.  
# Handle  pauliax   # Vulnerability details  ## Impact Hardcoding numbers that depend on other variables is error-prone, e.g.     require(newOwnerSplit <= 2e17); // 20% You must not forget to update this if you decide to change the BASE value.  ## Recommended Mitigation Steps  Better define a separate constant that directly depends on the BASE, e.g.:     uint256 private constant MAX_OWNER_SPLIT = BASE / 5; // 20%     require(newOwnerSplit <= MAX_OWNER_SPLIT);  
# Handle  pauliax   # Vulnerability details  ## Impact In function settleAuction user needs to decide what bounties he/she wants to claim:     function settleAuction(         uint256[] memory bountyIDs     ...     withdrawBounty(bountyIDs); but bounties are stored in a private variable:    Bounty[] private _bounties; and there are no getter (view) functions to view bounties so I think that makes it very inconvenient for the end-user to find the appropriate ids that are relevant, especially considering there could be SPAM bounties as anyone can call addBounty.  ## Recommended Mitigation Steps Consider exposing public view functions to view bounties.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L14  BLOCK_DECREMENT is never used.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L146   `transfer()` might return false instead of reverting, in this case, ignoring return value leads to considering it successful.  use `safeTransfer()` or check the return value if length of returned data is > 0.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  While safeApprove is used in the Factory contract, the use of ERC20 approve in approveUnderlying() (instead of safeApprove) is presumably to handle the reapprovals during changing of index but is susceptible to the historical ERC20 approve() race condition.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L106  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Be aware that this is susceptible to race-condition but this it unlikely a concern because the spender is always the auction contract which is cloned and therefore trusted.  
# Handle  0xRajeev   # Vulnerability details  ## Impact Another big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to generate an event when the new address or license fee is registered for change, pending the timelock duration. This is to warn protocol users that a pending change is upcoming (after the timelock) via offchain signalling so they can monitor/notice and decide to engage/exit based on their perception of the impact from the change.  The current implementation only emits an event when the pending change is enforced but not when it is made pending which does not provide one of the biggest benefits of a 2-step change.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L143-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L161-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add another event when the new publisher or licenseFee is made pending.  
# Handle  0xRajeev   # Vulnerability details  ## Impact A big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to allow any incorrectly used new addresses/values to be changed during the timelock period. This requires allowing the newPublisher or newLicenseFee to be a different value from the one used during the earlier approve and resetting the timelock again.  The current implementation only allows setting it once to a non-zero address/value and prevents any such corrections from being made (by checking that the address/value used is the same as that used during the first approve) which enforces the timelock to prevent surprises to users but does not provide the other accident benefits of using a timelock.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L137  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L155  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Recommend adding "&& pendingPublisher.publisher == newPublisher” and "&& pendingLicenseFee.licenseFee == newLicenseFee" to the if conditional predicate expression along with removing of the require() statement for equality check inside the conditional, to allow resetting the pending address/value to a new one if previously used one was incorrect.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Renouncing ownership is desirable in certain scenarios and is typically allowed by libraries such as Ownable.  The same may be true of the publisher role in this protocol as well to prevent changing the license fee or re-indexing the basket forever.   This is typically done by assigning a zero address to such a role i.e. burning it. However, by requiring any new proposed publisher address to be != zero address, the current implementation does not provide an option to renounce a publisher role by burning it.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L134  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support to renounce the publisher role or specify why this is not a desirable requirement for the protocol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Hardcoded constants in code is risky for auditability/readability/maintainability. The Factory contract uses 2e17 as a threshold check for ownerSplit instead of using a contract constant as done in other places.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L56  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Create a contract constant and use that as done in other places.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  None of the Factory owner setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  The impact of this is that a malicious/compromised/careless owner can intentionally/accidentally changes the minLicenseFee, auctionDecrement, auctionMultiplier, bondPercentDiv or ownerSplit values that significantly change the security/financial posture/perception of the protocol. No events are emitted and users may lose funds/confidence without being a chance to exit/engage protocol. The protocol takes a reputation hit.   See similar high-severity finding in OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and medium-severity finding OpenZeppelin’s Audit of UMA Phase 4: https://blog.openzeppelin.com/uma-audit-phase-4/.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L39-L41  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L47-L49  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L51-L53  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L55-L59   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend to consider emitting events when protocol critical values are updated by owner. This will be more transparent and it will make it easier to keep track of the status of the system.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawBounty() loops through the _bounties array looking for active bounties and transferring amounts from active ones. However, the data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference. So when bounty.active is set to false, this is changing only the memory copy and not the array element of the storage variable. This results in bounties never being set to inactive, keeping them always active forever and every withdrawBounty() will attempt to transfer bounty amount from the Auction contract to the msg.sender.  Therefore, while the transfer will work the first time, subsequent attempts to claim this bounty will revert on transfer (because the Auction contract will not have required amount of bounty tokens) causing withdrawBounty() to always revert and therefore preventing settling of any auction.   A malicious attacker can add a tiny bounty on any/every Auction contract to prevent any reindexing on that contract to happen because it will always revert on auction settling. This can be used to cause DoS on any auctionBonder so as to make them lose their bondAmount because their bonded auction cannot be settled.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143-L147  https://docs.soliditylang.org/en/v0.8.7/types.html#data-location-and-assignment-behaviour  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend changing storage specifier of bounty to "storage" instead of “memory".  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Given that there is no removal of claimed/inactive bounties, the bounty list could grow very long over time requiring a lot of gas for traversal.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L126-L151  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend pruning the claimed bounties by deleting them from the list.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87  ``` emit BasketLicenseProposed(msg.sender, tokenName); ```  same event can be emitted with excat same parameters multiple times causing confusion to actors relying on it.   Mitigation:  Add proposal id or some other parameter  
# Handle  leastwood   # Vulnerability details  ## Impact  The `validateWeights()` function can be better optimised by using a hashmap to measure token uniqueness. Currently, the function utilises an `O(n^2)` solution. By first iterating through each hashmap index for `_tokens`, any previously set tokens can be first cleared . This improves the current solution to `O(n)`.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53-L70  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using a hashmap to measure token uniqueness. However, this hashmap needs to first be cleared out before using it each time in `validateWeights()`.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  killAuction() is missing a require() to check that auctionOngoing == true before setting it to false. While currently, the caller publishNewIndex() in Basket has this condition checked, any other usages may accidentally call this when auction is not ongoing.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L175-L187  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add require(auctionOngoing == true)  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unused constant BLOCK_DECREMENT may be an indication of missing logic or redundant code. In this case, this appears to be a redundant constant same as Factory.auctionDecrement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L14  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Use the constant or remove it.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Choosing either named return or explicit instead of specifying both may reduce gas due to unnecessary bytecode introduced. proposeBasketLicense() uses a named return variable which is never assigned and instead uses an explicit return statement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L71  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L90  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Choose either explicit return or named return, not both  
# Handle  0xRajeev   # Vulnerability details  ## Impact Unnecessary return of argument value via state variable which costs a SLOAD, returns the same value as argument back to caller where the return value is ignored.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L221  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L216-L222  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L104  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove return value for this function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are places across contracts where the same external calls are made multiple times within a function. Caching return values of such calls in local/memory variables avoids CALLs to save gas. CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache factory.ownerSplit() return value to save 2600 gas in this function which gets called at every mint/burn.: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Hoist basketAsERC20.totalSupply() external call out of the loop because it remains the same and each call costs 2600 gas: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L96-L99  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache return values of external calls in local/memory variables  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are numerous places across contracts where the same state variables are read multiple times within a function. Caching state variables in local/memory variables avoids SLOADs to save gas. Warm SLOADs cost 100 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L62-L66  Cache basket, bondTimestamp, factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L78-L99  Cache basket and bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L116-L121  Cache pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L50  Cache lastFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L111-L116  Cache factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Cache pendingPublisher: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L139  Cache pendingLicenseFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L157  Cache auction & pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L173-L182  Cache publisher and auction: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208-L213  Cache proposals: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L62   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache state variables in local/memory variables to save gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L47-L52  `Auction.sol#initialize()` is using the factory_ parameter as the value of `factory`, while `Basket.sol#initialize()` uses `msg.sender`.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L39  Consider changing to `msg.sender` and remove the `factory_` parameter for the purpose of consistency and gas saving.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L143  ```solidity=140 function withdrawBounty(uint256[] memory bountyIds) internal {     // withdraw bounties     for (uint256 i = 0; i < bountyIds.length; i++) {         Bounty memory bounty = _bounties[bountyIds[i]];         require(bounty.active);          IERC20(bounty.token).transfer(msg.sender, bounty.amount);         bounty.active = false;          emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);     } } ```  In the `withdrawBounty` function, `bounty.active` should be set to `false` when the bounty is claimed.  However, since `bounty` is stored in memory, the state update will not succeed.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.   ### Proof of Concept  1. Create an auction; 2. Add a bounty; 3. Auction settled with bounty claimed; 4. Create a new auction; 5. Add a new bounty; 6. Calling `settleAuction()` with the bountyIds of the 2 seemly active bounties always reverts.  ### Recommended Mitigation Steps  Change to:  ```solidity= Bounty storage bounty = _bounties[bountyIds[i]]; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108  Given the `auctionBurn()` function will `_burn()` the auction bond without updating the `ibRatio`. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.bondPercentDiv = 400 basket.totalSupply = 400 basket.tokens = [BTC, ETH] basket.weights = [1, 1]  1. Create an auction; 2. Bond with 1 BASKET TOKEN; 3. Wait for 24 hrs and call `auctionBurn()`;  `basket.ibRatio` remains to be 1e18; basket.totalSupply = 399.  Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.  ### Recommended Mitigation Steps  Change to:  ```solidity= function auctionBurn(uint256 amount) onlyAuction external override {     handleFees();     uint256 startSupply = totalSupply();     _burn(msg.sender, amount);      uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);     ibRatio = newIbRatio;      emit NewIBRatio(newIbRatio);     emit Burned(msg.sender, amount); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact More fees are actually charged than intended   ## Mitigation Steps  [Basket.sol line 118](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118)   Assume that license fee is 10% i.e. 1e17 and time diff = half a year.   When you calculate `feePct`, you expect to get 5e16 since that's 5% and the actual amount of fee to be charged should be totalSupply * feePct (5) / BASE (100) but on line 118, we are actually dividing by BASE - feePct i.e. 95.   5 / 95 = 0.052 instead of the intended 0.05.  Solution is to replace `BASE - feePct` in the denominator with `BASE`.  
# Handle  nikitastupin   # Vulnerability details  Here https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L143-L143 the `bounty` variable is copied from Storage to Memory. Later it's assigned to false https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147. However, this assignment has no effect because `bounty` variable located at Memory so it's basically just thrown away when loop iteration finishes.  I think the intention was to make the `bounty.active` false so the same bounty isn't claimed twice or more times https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L144. However, the `bounty.active` will always be true because it never changes to false except for https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147 (which has no effect).  ## Impact  I don't see the direct impact here, however it may arise with the future changes to the contracts.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Do `_bounties[bountyIds[i]].active = false` instead of `bounty.active = false` if you need this check or just remove `bounty.active = false` and `require(bounty.active)` lines to save a gas otherwise.  
# Handle  nikitastupin   # Vulnerability details  Usually timelock is used in order to give a users of a protocol time to react on protocol changes (e.g. to withdraw their funds). Thus timelock implementations have Proposal and Execution steps. The main way to monitor blockchain changes and react to them is to listen for emitted events. However, none of the timelocked functions (`changePublisher`, `changeLicenseFee`, `publishNewIndex`) emits an event on Proposal step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L144-L147), they emit an event only on Execution step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L143-L143).  ## Impact  Events aren't emitted at critical functions.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Add events after (1) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L145-L146, (2) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L163-L164, (3) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L189-L192 and https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L182-L186.  
# Handle  JMukesh   # Vulnerability details  ## Impact by using approve() , we are not checking the value returned by the approve ,wether it got failed or successfully executed. so it is safe to use safeApproval()  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  ## Tools Used manual review  ## Recommended Mitigation Steps use safeApprove()  
# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking of array parameters in settleAuction()  , these array parameters can have different length which can lead to error.  inputWeight is iterated over the length of inputToken if one of the parameter have less length than other one will become inaccessible   which can lead to error  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  ## Tools Used  manual review  ## Recommended Mitigation Steps  
# Handle  t11s   # Vulnerability details  ## Impact Gas is wasted making `settleAuction` public, and using `memory` Instead of calldata for its arguments.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  If tokensNeeded is 0, it is possible to remove all the funds in the basket since no tokens are required to pass the balanceOf checks. The chances of this happening is very unlikely however it is better to be safe than sorry.   ## Recommended Mitigation Steps  Add a require statement to check that the numerator (`basketAsERC20.totalSupply() * pendingWeights[i] * newRatio`) is greater than or eq to the denominator (`BASE * BASE`). This will ensure that it can never round down i.e. tokensNeeded can never be 0.  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation  ## Recommended Mitigation Steps  The if branch in the handleFee() function is only there to handle the very first time handleFees are called. Thereafter, this condition will always fail so it makes more sense to initialize it with the initialize() function.  ```jsx function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {     publisher = proposal.proposer;     licenseFee = proposal.licenseFee;     factory = IFactory(msg.sender);     auction = auction_;     ibRatio = BASE;     tokens = proposal.tokens;     weights = proposal.weights;   lastFee = block.timestamp;      // updated lastFee here     approveUnderlying(address(auction));      __ERC20_init(proposal.tokenName, proposal.tokenSymbol); } ...  function handleFees() private {     // if (lastFee == 0) {            // delete this     //     lastFee = block.timestamp; // delete this     // } else {                       // delete this     uint256 startSupply = totalSupply();      uint256 timeDiff = (block.timestamp - lastFee);     uint256 feePct = timeDiff * licenseFee / ONE_YEAR;     uint256 fee = startSupply * feePct / (BASE - feePct);      _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);     _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);     lastFee = block.timestamp;      uint256 newIbRatio = ibRatio * startSupply / totalSupply();     ibRatio = newIbRatio;      emit NewIBRatio(ibRatio);     // }                              // delete this } ```  
# Handle  WatchPug   # Vulnerability details  The `newRatio` that determines `tokensNeeded` to settle the auction is calculated based on `auctionMultiplier`, `bondTimestamp - auctionStart` and `auctionDecrement`.  ```solidity= uint256 a = factory.auctionMultiplier() * basket.ibRatio(); uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); uint256 newRatio = a - b; ```  However, if an auction is bonded late (`bondTimestamp - auctionStart` is a large number), and/or the `auctionMultiplier` is small enough, and/or the `auctionDecrement` is small enough, that makes `b` to be greater than `a`, so that `uint256 newRatio = a - b;` will revert on underflow.  This might seem to be an edge case issue, but considering that a rebalance auction of a bag of shitcoin to high-value tokens might just end up being bonded at the last minute, with a `newRatio` near zero. When we take the time between the bonder submits the transaction and it got packed into a block, it's quite possible that the final `bondTimestamp` gets large enough to revet `a - b`.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled, and the user will lose the bond.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.auctionDecrement = 5760 (Blocks per day) factory.auctionMultiplier = 2  1. Create an auction; 2. The auction remain inactive (not get bonded) for more than 2 days (>11,520 blocks); 3. Call `bondForRebalance()` and it will succeed; 4. Calling `settleAuction()` will always revert.  ### Recommended Mitigation Steps  Calculate and require `newRatio > 0` in `bondForRebalance()`, or limit the max value of decrement and make sure newRatio always > 0 in `settleAuction()`.  
# Handle  shenwilly   # Vulnerability details  ## Impact OpenZeppelin ERC20Upgradeable `_burn` already checks for account balance, so another check is unnecessary.   ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92   ## Recommended Mitigation Steps Remove the require statement  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that zero value has not been checked on that "ibRatio" variable. That can cause  miscalculation of the liquidity.   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol" 2. Go to the line #217.  """         ibRatio = newRatio; """  3. Onlyauction modifier can assign ibRation to 0. 4. That can affect tokenAmount on the function.   """     function pushUnderlying(uint256 amount, address to) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransfer(to, tokenAmount);         }     } """  ## Tools Used  None  ## Recommended Mitigation Steps  Validate to ibRatio variable is more than zero.  """ require(ibRation > 0 , "ibRatio should be more than zero"); """  
# Handle  kenzo   # Vulnerability details  If a user is minting small amount of shares (like 1 - amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted. If the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with - although a miniscule amount.  ## Impact User can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.  ## Proof of Concept Add the following test to Basket.test.js. The user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE, and ends with 5e18+4, 1e18+4, 1e18+4. ``` it("should give to user more than he deserves", async () => {         await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            console.log("User balance before minting:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());                   await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));          console.log("\nUser balance after minting 1 share 5 times:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());          await basket.connect(owner).burn(await basket.balanceOf(owner.address));         console.log("\nUser balance after burning all shares:");         console.log("UNI balance: " + (await UNI.balanceOf(owner.address)).toString());         console.log("COMP balance: " + (await COMP.balanceOf(owner.address)).toString());         console.log("AAVE balance: " + (await AAVE.balanceOf(owner.address)).toString());     }); ```  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to ```pullUnderlying```: ``` require(tokenAmount > 0); ``` I think it makes sense that if a user is trying to mint an amount so small that no tokens could be pulled from him, the mint request should be denied. Per my tests, for an initial ibRatio, this number (the minimal amount of shares that can be minted) is 2 for weights in magnitude of 1e18, and if the weights are eg. smaller by 100, this number will be 101.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110-L129  ```solidity= function handleFees() private {     if (lastFee == 0) {         lastFee = block.timestamp;     } else {         uint256 startSupply = totalSupply();          uint256 timeDiff = (block.timestamp - lastFee);         uint256 feePct = timeDiff * licenseFee / ONE_YEAR;         uint256 fee = startSupply * feePct / (BASE - feePct);          _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);         _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);         lastFee = block.timestamp;          uint256 newIbRatio = ibRatio * startSupply / totalSupply();         ibRatio = newIbRatio;          emit NewIBRatio(ibRatio);     } } ```  `timeDiff * licenseFee` can be greater than `ONE_YEAR` when `timeDiff` and/or `licenseFee` is large enough, which makes `feePct` to be greater than `BASE` so that `BASE - feePct` will revert on underflow.   ## Impact  Minting and burning of the basket token are being disrupted until the publisher update the `licenseFee`.  ## Proof of Concept  1. Create a basket with a `licenseFee` of `1e19` or 1000% per year and mint 1 basket token; 2. The basket remain inactive (not being minted or burned) for 2 months; 3. Calling `mint` and `burn` reverts at `handleFees()`.  ## Recommended Mitigation Steps  Limit the max value of `feePct`.  
# Handle  chasemartin01   # Vulnerability details  ## Impact Gas optimisation  ## Example As an example, you can change the declaration of `inputTokens`, `inputWeights`, `outputTokens`, `outputWeights` to be `calldata` as a gas optimisation  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69-L75  There's other instances of this in `Basket.sol` and`Factory.sol` ## Explanation When you specify `memory` for a function param for an external function, the following happens: the compiler copies elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change all instances of `memory` to `calldata` where the function parameter isn't being modified  
# Handle  WatchPug   # Vulnerability details  As defined in the ERC20 Specification, the approve function returns a bool that signals the success of the call. However, in `Basket.sol#approveUnderlying()` the value returned from calls to approve is ignored.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L224-L228  ## Recommended Mitigation Steps  To handle calls to approve safely, consider using the safeApprove function in OpenZeppelin’s SafeERC20 contract for all approvals.  
# Handle  loop   # Vulnerability details  `proposal` is declared as both a function name and the name for a Proposal object.  ## Proof of Concept Factory.sol line 35: `function proposal(uint256 proposalId) external override view returns (Proposal memory) {` Factory.sol line 77: `Proposal memory proposal = Proposal({`  ## Tools Used Remix  ## Recommended Mitigation Steps Change function name to `getProposal` to avoid double naming and be more in line with other getter/setter functions used.  
# Handle  loop   # Vulnerability details  In basket.sol there is one use of `uint` rather than `uint256`, which is used in the rest of the codebase.  ## Impact No real impact considering `uint` functions as a `uint256`.  ## Proof of Concept Basket.sol - line 60: `for (uint i = 0; i < length; i++) {`  
# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts: it("should divide by 0", async () => {       await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));       await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));        await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await basket.connect(addr1).mint(ethers.BigNumber.from(1));   });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  
# Handle  kenzo   # Vulnerability details  The ```handleFees``` function divides by ```(BASE - ((block.timestamp - lastFee)* licenseFee / ONE_YEAR))```. For initial BASE of 1e18 and licenseFee of 1e16, it means that if nobody calls this function in 100 years, the function will divide by 0.  ## Impact After 100 years of no usage, handleFees will always revert and nobody will be able to mint, burn etc'.  ## Proof of Concept Vulnerable line which will divide by 0: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L118 To test this, you can deploy to testnet a contract, then use a time machine to travel to 100 years in the future and try to use mint(). If for some reason you don't want to use your time machine, you may use this function to simulate the passage of time: ``` async function skipTime(seconds) {   let blockNumber = await hre.network.provider.request({     method: "eth_blockNumber",     params: [],   });   let block = await ethers.provider.getBlock(blockNumber["result"]);   await hre.network.provider.request({     method: "evm_mine",     params: [block["timestamp"]+seconds],   }); } ```  ## Tools Used Manual analysis, hardhat, time machine.  ## Recommended Mitigation Steps Tell your grandchildren to call mint(1) in 99 years.  
# Handle  kenzo   # Vulnerability details  The DeletedNewIndex log emits "publisher", but it might be the auction that called the function. Note: the event is defined as: event DeletedNewIndex(address _publisher); So if you wanted to anyway emit just the publisher, this is not a bug. However as this function call be called from both publisher and auction, I have a feeling you wanted to emit the msg.sender.  ## Impact Inaccurate data supplied.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Emit msg.sender instead of publisher.  
# Handle  gpersoon   # Vulnerability details  ## Impact If the functions mintTo and burn of Basket.sol are called twice in the same block then block.timestamp will stay the same and timeDiff ==0. Then it is not necessary to _mint () tokens, as this will be 0 tokens anyway.  So checking for timeDiff ==0 could save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110  function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();              uint256 timeDiff = (block.timestamp - lastFee);             uint256 feePct = timeDiff * licenseFee / ONE_YEAR;             uint256 fee = startSupply * feePct / (BASE - feePct);              _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);             _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);             lastFee = block.timestamp;             uint256 newIbRatio = ibRatio * startSupply / totalSupply();             ibRatio = newIbRatio;              emit NewIBRatio(ibRatio);         }     } ## Tools Used  ## Recommended Mitigation Steps Add an extra if in the following way:   function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();             uint256 timeDiff = (block.timestamp - lastFee);             if (timeDiff !=0) {                                                                      // ===> extra if                 uint256 feePct = timeDiff * licenseFee / ONE_YEAR;                 uint256 fee = startSupply * feePct / (BASE - feePct);                 _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);                 _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);                 lastFee = block.timestamp;                 uint256 newIbRatio = ibRatio * startSupply / totalSupply();                 ibRatio = newIbRatio;                 emit NewIBRatio(ibRatio);            }         }     }     
# Handle  gpersoon   # Vulnerability details  ## Impact When using the Openzeppelin upgradability pattern, the initialize() function should you the modifier initializer. However the initialize() function of Basket.sol doesn't have this modifier.  This won't give problems in practice because __ERC20_init() does have this modifier and prevents initialize() from being called twice. However forks of the projects or future developers might not be aware of this any make risky changes.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36 import { ERC20Upgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";  contract Basket is IBasket, ERC20Upgradeable { ..  function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {        ...          __ERC20_init(proposal.tokenName, proposal.tokenSymbol);     }  ## Tools Used  ## Recommended Mitigation Steps Add the modifier initializer to the function initialize()  
# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondTimestamp, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L89:#L99 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondTimestamp increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ```  
# Handle  kenzo   # Vulnerability details  When using few times an unchanging value from external contract call, the result can be saved and used without recalling the external contract.  ## Impact Some gas can be saved.  ## Proof of Concept In settleAuction, the basket's totalSupply stays constant through the loop's iterations. ``` for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L97  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Save basketAsERC20.totalSupply() to a local variable outside the loop, and use that variable inside the loop.  
# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  There's a chance that `newRatio` would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to [Black Thursday for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)  Given the chance that all user may lose their money, I consider this is a medium-risk issue.   ## Proof of Concept [Black Thursfay for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6) [bug-impacting-over-50-of-ethereum-clients-leads-to-fork](https://www.theblockcrypto.com/post/115822/bug-impacting-over-50-of-ethereum-clients-leads-to-fork)  ## Tools Used None  ## Recommended Mitigation Steps  I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low.  
# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  In this equation, `a` would not always be greater than `b`. The ` auctionBonder` may lock the token in `bondForRebalance()` at a point that `a-b` would always revert.  The contract should not allow users to lock the token at the point that not gonna succeed. Given the possible (huge) loss of the user may suffer, I consider this is a medium-risk issue.   ## Proof of Concept Here's a web3.py script to trigger this bug. ```python basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  for i in range(4 * 60 * 24):     w3.provider.make_request('evm_mine', []) basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  print('auction on going', auction.functions.auctionOngoing().call()) for i in range(20000):     w3.provider.make_request('evm_mine', [])  all_token = basket.functions.balanceOf(user).call() basket.functions.approve(auction.address, all_token).transact() auction.functions.bondForRebalance().transact() # error Log # {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'} auction.functions.settleAuction([], [], [], [], []).transact() ```   ## Tools Used None  ## Recommended Mitigation Steps Recommend to calculate the new irate in `bondForRebalance`. I understand the `auctionBonder` should take the risk to get the profit. However, the contract should protect the user in the first place when this auction is doomed to fail.  
# Handle  kenzo   # Vulnerability details  In some places where data is discarded such as ```bondBurn```, part of the data is set to 0 (```auctionBonder```), and other parts are not (```bondTimestamp```). Setting unnecessary data back to 0 will save gas.  ## Impact Almost 2000 gas saved for each variable reset. In some places, like ```createBasket``` (which only needs to save the proposal's "basket" field after creating the basket), this can save almost 15000 gas.  ## Proof of Concept Places where data is not reset: Factory's createBasket (set all _proposals[idNumber]'s fields to be 0 except basket) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L112 Basket's changePublisher: (set pendingPublisher.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L141 Basket's changeLicenseFee: (set pendingLicenseFee.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L159 Basket's setNewWeights and deleteNewIndex: (set pendingWeights.tokens and pendingWeights.weights to empty arrays) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L200 https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L212 Auction's killAuction: (set auctionStart = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L44 Auction's settleAuction: (set bondTimestamp, auctionBonder = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L107 Auction's bondBurn: (set bondTimestamp = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L120 Auction's withdrawBounty: (set bounty.token, bounty.token = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L148  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Detailed above.  
# Handle  kenzo   # Vulnerability details  The settleAuction() function calls withdrawBounty() before setting auctionOngoing = false, thereby allowing reentrancy.  ## Impact A malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to. At worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.  ## Proof of Concept 1. The publisher (a contract) will propose new valid index and bond the auction. To settle the auction, the publisher will execute the following steps in the same transaction: 2. Add a bounty of an ERC20 contract with a malicious transfer() function. 3. Settle the valid new weights correctly (using settleAuction() with the correct parameters, and passing the malicious bounty id). 4. settleAuction() will call withdrawBounty() which upon transfer will call the publisher's malicious ERC20 contract. 5. The contract will call settleAuction() again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, settleAuction() will finish correctly and call setNewWeights() which will set the new valid weights and set pendingWeights.pending = false. 6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's publishNewIndex(), with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set pendingWeights.pending = false. 7. Now the malicious withdrawBounty() has ended, and the original settleAuction() is resuming, but now with malicious weights in pendingWeights (set in step 6). settleAuction() will now call setNewWeights() which will set the basket's weights to be the malicious pending weights. 8. Now settleAuction has finished, and the publisher (within the same transaction) will burn() all his shares of the basket, thereby transferring all the tokens to himself.  POC exploit: Password to both files: "exploit". AttackPublisher.sol , to be put under contracts/contracts/Exploit: https://pastebin.com/efHZjstS ExploitPublisher.test.js , to be put under contracts/test: https://pastebin.com/knBtcWkk  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps In settleAuction(), move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern.  
# Handle  joeysantoro   # Vulnerability details  ## Impact If any of the timelocked variables of a basket are pending a change, a transaction to change the target will revert during the timelock window.  ## Proof of Concept Publisher wants to change license fee. They submit a change request but fat finger with the wrong value. The only way to change the pending licenseFee is to complete the change to the incorrect value (after timelock period) then resubmit a new request.  In the case of changing index this can be mitigated by using deleteNewIndex(), however changePublisher and changeLicenseFee cannot be mitigated.  ## Recommended Mitigation Steps Introduce a "setPendingX" method for each of  liscenceFee, publisher, and index. This cleanly separates the logic and allows for overwrite of pending during timelock window.  
# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that _bounties variable is global per basket. Also you are allowed to add 0 amount in bounty. This means if user adds uint256 max times bounty with amount 0, no one can add further bounty on this basket  ## Proof of Concept 1. User calls addBounty function with amount 0 uint256 max times  ```     function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {         // add bounty to basket         token.safeTransferFrom(msg.sender, address(this), amount);         _bounties.push(Bounty({             token: address(token),             amount: amount,             active: true         }));          uint256 id = _bounties.length - 1;         emit BountyAdded(token, amount, id);         return id;     } ```  2. Now noone can call bounty on this basket anymore  ## Recommended Mitigation Steps _bounties should be cleared once auction has been settled  
# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc The issue was discovered in validateWeights function of Basket contract   ## Proof of Concept 1. User proposes a new Basket with 0 tokens and weights using proposeBasketLicense function in Factory contract  ```  Proposal memory proposal = Proposal({             licenseFee: 10,             tokenName: abc,             tokenSymbol: aa,             proposer: 0xabc,             tokens: {},             weights: {},             basket: address(0)         }); ```  2. validateWeights function is called and it returns success as the only check performed is _tokens.length == _weights.length (0=0)  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length == _weights.length);         uint256 length = _tokens.length;         address[] memory tokenList = new address[](length);          // check uniqueness of tokens and not token(0)          for (uint i = 0; i < length; i++) {            ...         }     } ```  3. A new proposal gets created  ``` _proposals.push(proposal); ```  4. User creates new Basket with this proposal using createBasket function  ``` function createBasket(uint256 idNumber) external override returns (IBasket) {         Proposal memory bProposal = _proposals[idNumber];         require(bProposal.basket == address(0));          ....          for (uint256 i = 0; i < bProposal.weights.length; i++) {             ...         }   ...         return newBasket;     } ```  5. Since no weights and tokens were in this proposal so no token transfer is required (bProposal.weights.length will be 0 so loop won't run)  6. Basket gets created and user becomes publisher for this basket  ```         newBasket.mintTo(BASE, msg.sender);         _proposals[idNumber].basket = address(newBasket); ```  7. Publisher owned address calls the mint function with say amount 10 on Basket.sol contract  ```     function mint(uint256 amount) public override {         mintTo(amount, msg.sender);     }      function mintTo(uint256 amount, address to) public override {         ...          pullUnderlying(amount, msg.sender);          _mint(to, amount);          ...     } ```  8. Since there is no weights so pullUnderlying function does nothing (weights.length is 0)  ```     function pullUnderlying(uint256 amount, address from) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);         }     } ```  9. Full amount 10 is minted to Publisher owned address setting balanceOf(msg.sender) = 10  ``` _mint(to, amount); ```  10. Now Publisher calls the publishNewIndex to set new weights. Since pendingWeights.pending is false, else condition gets executed  ```     function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {         validateWeights(_tokens, _weights);          if (pendingWeights.pending) {             require(block.number >= pendingWeights.block + TIMELOCK_DURATION);             if (auction.auctionOngoing() == false) {                 auction.startAuction();                  emit PublishedNewIndex(publisher);             } else if (auction.hasBonded()) {              } else {                 auction.killAuction();                  pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.block = block.number;             }         } else {             pendingWeights.pending = true;             pendingWeights.tokens = _tokens;             pendingWeights.weights = _weights;             pendingWeights.block = block.number;         }     } ```   11. Publisher calls the publishNewIndex again which starts the Auction. This auction is later settled using the settleAuction function in Auction contract  12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his balanceOf(msg.sender) = 10 (Step 9)  ```     function burn(uint256 amount) public override {         require(auction.auctionOngoing() == false);         require(amount > 0);         require(balanceOf(msg.sender) >= amount);          handleFees();          pushUnderlying(amount, msg.sender);         _burn(msg.sender, amount);                  emit Burned(msg.sender, amount);     } ```  ## Recommended Mitigation Steps Change validateWeights to check for 0 length token  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length>0);   ...     } ```  
# Handle  bw   # Vulnerability details  ## Impact  A [require](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74) statement in `Factory.sol` could be performed prior to an expensive cross contract call, reducing the amount of gas wasted if the validation fails.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74  ## Tools Used  N/A  ## Recommended Mitigation Steps  Move the require statement before `basketImpl.validateWeights(tokens, weights);`  
# Handle  bw   # Vulnerability details  ## Impact  The implementation contracts that are used by proxies are not initialized by default, this creates the possibility that the contracts will not be initialized after deployment.  Uninitialized implementations could result in Denial of Service exploits. This often involves initializing the contract so that it is possible to `delegatecall` into a contract that has the `selfdestruct` opcode.   The contracts in-scope did not contain any `delegatecalls` that could be exploited. However, it is still regarded as best practice to ensure that the contracts cannot be initialized after deployment.  ## Proof of Concept  As a defence in-depth measure, the implementations should be initialized during deployed by adding the following: ```diff diff --git a/contracts/contracts/Auction.sol b/contracts/contracts/Auction.sol index f07df8b..f7c21eb 100644 --- a/contracts/contracts/Auction.sol +++ b/contracts/contracts/Auction.sol @@ -44,6 +44,10 @@ contract Auction is IAuction {          auctionOngoing = false;      }   +    constructor() { +        initialized = true; +    } +      function initialize(address basket_, address factory_) public override {          require(!initialized);          basket = IBasket(basket_); diff --git a/contracts/contracts/Basket.sol b/contracts/contracts/Basket.sol index 5fef21b..4549365 100644 --- a/contracts/contracts/Basket.sol +++ b/contracts/contracts/Basket.sol @@ -33,6 +33,10 @@ contract Basket is IBasket, ERC20Upgradeable {        uint256 public override lastFee;   +    constructor() { +        __ERC20_init("",  ""); +    } +      function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {          publisher = proposal.proposer;          licenseFee = proposal.licenseFee; ```  * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L9 * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L12  ## Tools Used  N/A  ## Recommended Mitigation Steps  Initialize implementations during deployment by adding a constructor.     
# Handle  bw   # Vulnerability details  ## Impact The [`Factory.sol`](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L19) contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  For more information regarding the `immutable` keyword: https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Proof of Concept  ### Code Diff  ```diff diff --git a/contracts/contracts/Factory.sol b/contracts/contracts/Factory.sol index 271945d..3bbdd4f 100644 --- a/contracts/contracts/Factory.sol +++ b/contracts/contracts/Factory.sol @@ -23,8 +23,8 @@ contract Factory is IFactory, Ownable {        Proposal[] private _proposals;   -    IAuction public override auctionImpl; -    IBasket public override basketImpl; +    IAuction public immutable override auctionImpl; +    IBasket public immutable override basketImpl;        uint256 public override minLicenseFee = 1e15; // 1e15 0.1%      uint256 public override auctionDecrement = 10000; ```  ### Gas Improvement  ```diff diff --git a/base.gas b/factory-immutable.gas index 9d48ade..1447433 100644 --- a/base.gas +++ b/factory-immutable.gas @@ -23,9 +23,9 @@  ·····················|························|·············|·············|···········|···············|··············  |  ERC20Upgradeable  ·  approve               ·          -  ·          -  ·    48900  ·            3  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· -|  Factory           ·  createBasket          ·     880031  ·     908831  ·   882911  ·           10  ·          -  │ +|  Factory           ·  createBasket          ·     875780  ·     904580  ·   878660  ·           10  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· -|  Factory           ·  proposeBasketLicense  ·     335488  ·     335512  ·   335505  ·           12  ·          -  │ +|  Factory           ·  proposeBasketLicense  ·     333388  ·     333412  ·   333405  ·           12  ·          -  │  ·····················|························|·············|·············|···········|···············|··············  |  Factory           ·  setOwnerSplit         ·          -  ·          -  ·    46173  ·            1  ·          -  │  ·····················|························|·············|·············|···········|···············|·············· @@ -39,7 +39,7 @@  ··············································|·············|·············|···········|···············|··············  |  Basket                                     ·          -  ·          -  ·  2390793  ·          8 %  ·          -  │  ··············································|·············|·············|···········|···············|·············· -|  Factory                                    ·          -  ·          -  ·  1706801  ·        5.7 %  ·          -  │ +|  Factory                                    ·          -  ·          -  ·  1684215  ·        5.6 %  ·          -  │  ··············································|·············|·············|···········|···············|··············  |  TestToken                                  ·     653145  ·     653193  ·   653163  ·        2.2 %  ·          -  │  ·---------------------------------------------|-------------|-------------|-----------|---------------|-------------·  ```  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the immutable key word to all variables that are only set during the constructor.   
# Handle  jah   # Vulnerability details  ## Impact the initialize function will not be called from the contract and  it  doesn't require public visibility so the visibility should be changed to external to save gas as  described in https://mudit.blog/solidity-gas-optimization-tips/: “For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from calldata directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”     ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L36  ## Tools Used manual analysis  ## Recommended Mitigation Steps change the visibility to external  
