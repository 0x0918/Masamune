## G01: Redundant variables  The following variables are initialized, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  [`BribeVault.fee`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23)  [`BribeVault.feeDivisor`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26)  ## G02: TokemakBribe: `bribeVault` can be made immutable  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28)  ### Description  `bribeVault` is only set in the constructor, and there are no mutators to modify its value.  ### Recommended Mitigation Steps  `address public immutable bribeVault;`  ## G03: TokemakBribe: Redundant `SetProposals()` event  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154)  ### Description  The setting of multiple proposals does not require the `SetProposals()` event to be emitted because the `SetProposal()` event is emitted for each proposal when `setProposal()` is invoked.  ### Recommended Mitigation Steps  Remove the `SetProposals()` event.  ## G04: ThecosmataETH: Change `BTRFLY` and `CURVEPOOL` types to avoid repeated castings  ### Description  `BTRFLY` and `CURVEPOOL` are repeatedly casted to `IBTRFLY` and `ICurveCryptoPool`. It would be better to declare them as these types instead.  ### Recommended Mitigation Steps  ```jsx IBTRFLY public immutable BTRFLY; ICurveCryptoPool public immutable CURVEPOOL; ```  ## G05: ThecosmataETH: Call `add_liquidity()` with receiver specified  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146)  ### Description  The curve pool tokens can be transferred directly to the treasury by calling a different `add_liquidity` method.  ### Recommended Mitigation Steps  ```jsx interface ICurveCryptoPool {   function add_liquidity(     uint256[2] calldata amounts,     uint256 min_mint_amount,     bool use_eth,     address receiver   )   external   payable;    ... }  // in addLiquidity() ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount, false, TREASURY); ```  ## G06: RewardDistributor: Include updateCount in  `isRewardClaimed()` and `_setClaimed()` functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142)  ### Description  Based on the current tests, the `claim()` function takes an average of 129k gas (82k min, 206k max). By including the `updateCount` parameter in the `isRewardClaimed()` and `_setClaimed()` functions, this can be reduced by about 2k. With the changes, the `claim()` function will take an average of 127k gas (81k min, 202k max).  There is an added benefit to making this change. By taking the `updateCount` as a parameter in `isRewardClaimed()`, it enables the checking of past claims made.  ### Tools Used  `hardhat-gas-reporter`  ### Recommended Mitigation Steps  ```jsx function isRewardClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount)   public   view   returns (bool) {   // Get the group index for the specified index along with the bit index   // and check if the corresponding bit index is flipped   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;   uint256 claimedGroupState = claimed[_identifier][_updateCount][       claimedGroup   ];   uint256 mask = (1 << claimedIndex);   return claimedGroupState & mask == mask; }  function _setClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount) internal {   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;    // Flip the bit state to mark the corresponding index as claimed   claimed[_identifier][_updateCount][claimedGroup] =     claimed[_identifier][_updateCount][claimedGroup] |     (1 << claimedIndex); }  function _claim(..) {   require(     !isRewardClaimed(_rewardIdentifier, _index, reward.updateCount),     "Reward already claimed"   );   ...   _setClaimed(_rewardIdentifier, _index, reward.updateCount); } ```
