# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735  ```solidity function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {     // cannot have an active incentive for the callee     require(incentives[who] == 0, "inc");     ... ```  When an incentiveToken is claimed after `endStream`, `incentives[who]` will be `0` for that `incentiveToken`.  If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as `who` and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.  ### PoC  1. Alice approved `USDC` to the streaming contract; 2. Alice called `createIncentive()` and added `1,000 USDC` of incentive; 3. After the stream is done, the stream creator called `claimIncentive()` and claimed `1,000 USDC`;  The compromised protocol gov can call `arbitraryCall()` and steal all the USDC in Alice's wallet balance.  ### Recommendation  Consider adding a mapping: `isIncentiveToken`, setting `isIncentiveToken[incentiveToken] = true` in `createIncentive()`, and `require(!isIncentiveToken[who], ...)` in `arbitraryCall()`.  
# Handle  WatchPug   # Vulnerability details  `require(newBal <= type(uint112).max ...)` vs `require(newBal < type(uint112).max...)`.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L386-L386 ```solidity=386 require(newBal < type(uint112).max && newBal > prevBal, "erc"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L427-L427 ```solidity=427 require(newBal <= type(uint112).max && newBal > prevBal, "erc"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L506-L506 ```solidity=506 require(newBal <= type(uint112).max && newBal > prevBal, "erc"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens); ```  In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.  As a result:  - When the protocol `governance` calls `claimFees()` and claim accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken. - Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.  ### PoC  Given:  - `feeEnabled`: true - `feePercent`: 10 (0.1%)  1. Alice deposited `1,000,000` depositToken; 2. Bob called `flashloan()` and borrowed `1,000,000` depositToken, then repaid `1,001,000`; 3. Charlie deposited `1,000` depositToken; 4. After `endDepositLock`, Alice called `claimDepositTokens()` and withdrawn `1,000,000` depositToken; 5. `streamCreator` called `recoverTokens(depositToken, recipient)` and retrieved `1,000` depositToken `(2,000 - (1,001,000 - 1,000,000))`; 6. `governance` called `claimFees()` and retrieved another `1,000` depositToken; 7. Charlie tries to `claimDepositTokens()` but since the current balanceOf depositToken is `0`, the transcation always fails, and Charlie loses all the depositToken.  ### Recommendation  Change to:  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - depositTokenFlashloanFeeAmount; ```  
# Handle  hack3r-0m   # Vulnerability details  ## Impact  https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229  reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.  ## Proof of Concept  Attaching diff to modify tests to reproduce behaviour:  ``` diff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol index 2be8db0..aba19ce 100644 --- a/Streaming/src/test/Locke.t.sol +++ b/Streaming/src/test/Locke.t.sol @@ -166,14 +166,14 @@ contract StreamTest is LockeTest {          );            testTokenA.approve(address(stream), type(uint256).max); -        stream.fundStream((10**14)*10**18); +        stream.fundStream(1000);   -        alice.doStake(stream, address(testTokenB), (10**13)*10**18); +        alice.doStake(stream, address(testTokenB), 100);              hevm.warp(startTime + minStreamDuration / 2); // move to half done           -        bob.doStake(stream, address(testTokenB), (10**13)*10**18); +        bob.doStake(stream, address(testTokenB), 100);            hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);   @@ -182,10 +182,10 @@ contract StreamTest is LockeTest {          hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream     -        // alice.doClaimReward(stream); -        // assertEq(testTokenA.balanceOf(address(alice)), 533*(10**15)); -        // bob.doClaimReward(stream); -        // assertEq(testTokenA.balanceOf(address(bob)), 466*(10**15)); +        alice.doClaimReward(stream); +        assertEq(testTokenA.balanceOf(address(alice)), 533); +        bob.doClaimReward(stream); +        assertEq(testTokenA.balanceOf(address(bob)), 466);      }        function test_stake() public { diff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol index eb38060..a479875 100644 --- a/Streaming/src/test/utils/LockeTest.sol +++ b/Streaming/src/test/utils/LockeTest.sol @@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {          testTokenA = ERC20(address(new TestToken("Test Token A", "TTA", 18)));          testTokenB = ERC20(address(new TestToken("Test Token B", "TTB", 18)));          testTokenC = ERC20(address(new TestToken("Test Token C", "TTC", 18))); -        write_balanceOf_ts(address(testTokenA), address(this), (10**14)*10**18); -        write_balanceOf_ts(address(testTokenB), address(this), (10**14)*10**18); -        write_balanceOf_ts(address(testTokenC), address(this), (10**14)*10**18); -        assertEq(testTokenA.balanceOf(address(this)), (10**14)*10**18); -        assertEq(testTokenB.balanceOf(address(this)), (10**14)*10**18); +        write_balanceOf_ts(address(testTokenA), address(this), 100*10**18); +        write_balanceOf_ts(address(testTokenB), address(this), 100*10**18); +        write_balanceOf_ts(address(testTokenC), address(this), 100*10**18); +        assertEq(testTokenA.balanceOf(address(this)), 100*10**18); +        assertEq(testTokenB.balanceOf(address(this)), 100*10**18);            defaultStreamFactory = new StreamFactory(address(this), address(this));   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider doing arithmetic operations in two steps or upcasting to u256 and then downcasting. Alternatively, find a threshold where it breaks and add require condition to not allow total stake per user greater than threshhold.  
# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows the `deposit` and `reward` tokens to be the same token.  > I believe this is intended, think Sushi reward on Sushi as is the case with `xSushi`.  The reward and deposit balances are also correctly tracked independently in `depositTokenAmount` and `rewardTokenAmount`. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:  ```solidity function recoverTokens(address token, address recipient) public lock {     // NOTE: it is the stream creators responsibility to save     // tokens on behalf of their users.     require(msg.sender == streamCreator, "!creator");     if (token == depositToken) {         require(block.timestamp > endDepositLock, "time");         // get the balance of this contract         // check what isnt claimable by either party         // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens         uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);         // allow saving of the token         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }          if (token == rewardToken) {         require(block.timestamp > endRewardLock, "time");         // check current balance vs internal balance         //         // NOTE: if a token rebases, i.e. changes balance out from under us,         // most of this contract breaks and rugs depositors. this isn't exclusive         // to this function but this function would in theory allow someone to rug         // and recover the excess (if it is worth anything)          // check what isnt claimable by depositors and governance         // @audit-info rewardTokenAmount increased on fundStream         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  #### POC Given `recoverTokens == depositToken`, `Stream` creator calls `recoverTokens(token = depositToken, creator)`.  - The `token` balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. `ERC20(token).balanceOf(address(this)) >= (depositTokenAmount - redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)` - `if (token == depositToken)` executes, the `excess` from the deposit amount will be the reward amount (`excess >= rewardTokenAmount + rewardTokenFeeAmount`). This will be transferred. - `if (token == rewardToken)` executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, `ERC20(token).balanceOf(address(this)) >= depositTokenAmount - redeemedDepositTokens`. If this is non-negative, the transaction does not revert and the creator makes a profit.  Example: - outstanding redeemable deposit token amount: `depositTokenAmount - redeemedDepositTokens = 1000` - funded `rewardTokenAmount` (plus `rewardTokenFeeAmount` fees): `rewardTokenAmount + rewardTokenFeeAmount = 500`  Creator receives `1500 - 1000 = 500` excess deposit and `1000 - 500 = 500` excess reward.  ## Impact When using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.  ## Recommended Mitigation Steps One needs to be careful with using `.balanceOf` in this special case as it includes both deposit and reward balances.  Add a special case for `recoverTokens` when `token == depositToken == rewardToken` and then the excess should be `ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount);`  
# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.  However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:  ```solidity function recoverTokens(address token, address recipient) public lock {     if (token == rewardToken) {         require(block.timestamp > endRewardLock, "time");          // check what isnt claimable by depositors and governance         // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  Note that `rewardTokenAmount` only ever _increases_ (when calling `fundStream`) but it never decreases when claiming the rewards through `claimReward`. However, `claimReward` transfers out the reward token.  Therefore, the `rewardTokenAmount` never tracks the contract's reward balance and the excess cannot be computed that way.  #### POC Assume no reward fees for simplicity and only a single user staking.  - Someone funds `1000` reward tokens through `fundStream(1000)`. Then `rewardTokenAmount = 1000`  - The stream and reward lock period is over, i.e. `block.timestamp > endRewardLock` - The user claims their full reward and receives `1000` reward tokens by calling `claimReward()`. The reward contract balance is now `0` but `rewardTokenAmount = 1000` - Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as the `excess = balance - rewardTokenAmount = 0`  ## Impact Reward token recovery does not work.  ## Recommended Mitigation Steps The claimed rewards need to be tracked as well, just like the claimed deposits are tracked. I think you can even decrease `rewardTokenAmount` in `claimReward` because at this point `rewardTokenAmount` is not used to update the `cumulativeRewardPerToken` anymore.  
# Handle  cmichel   # Vulnerability details  The `recoverTokens` function's comment states that the excess deposit tokens are `balance - depositTokenAmount`:  >     *      1. if its deposit token: >     *          - DepositLock is fully done >     *          - There are excess deposit tokens (balance - depositTokenAmount)  But it is `balance - (depositTokenAmount - redeemedDepositTokens)` where `(depositTokenAmount - redeemedDepositTokens)` is the outstanding redeemable amount.  ## Impact The code is correct.  ## Recommended Mitigation Steps Fix the comment.  
# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L553 stated that:  > Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens but the reward is only tracked to the original depositor in both case, see https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L558 ```         TokenStream storage ts = tokensNotYetStreamed[msg.sender]; ``` Transferring the LockeERC20 token does not transfer the TokenStream state.   
# Handle  gzeon   # Vulnerability details  ## Impact The documentation is unclear, but it make little sense that incentives are only paid to the stream creator instead of depositors. This make the incentives more like donation to the creator but not actually incentivizing the stream.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L518  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).   However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().   In summary:  1) If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.  2) Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735  ## Recommended Mitigation Steps  ### Recommendation 1 Limit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall().  ### Recommendation 2 Validate that the allowance of the target contract (if available) has not changed.  
# Handle  bitbopper   # Vulnerability details  ## Impact  `stake` and `withdraws` can generate rewardTokens without streaming depositTokens.  It does not matter whether the stream is a sale or not.  The following lines can increase the reward balance on a `withdraw` some time after `stake`: https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222 ``` // accumulate reward per token info cumulativeRewardPerToken = rewardPerToken();  // update user rewards ts.rewards = earned(ts, cumulativeRewardPerToken); ```   While the following line can be gamed in order to not stream any tokens (same withdraw tx).  Specifically an attacker can arrange to create a fraction less than zero thereby substracting zero. https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229 ``` ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate)); // WARDEN TRANSLATION: (elapsedSecondsSinceStake * stakeAmount) / (endStreamTimestamp - stakeTimestamp) ```  A succesful attack increases the share of rewardTokens of the attacker. The attack can be repeated every block increasing the share further. The attack could be done from multiple EOA increasing the share further. In short: Attackers can create loss of funds for (honest) stakers.  The economic feasability of the attack depends on: - staked amount (times number of attacks) vs total staked amount - relative value of rewardToken to gasprice    ## Proof of Concept  ### code   The following was added to `Locke.t.sol` for the `StreamTest` Contract to simulate the attack from one EOA.  ```     function test_quickDepositAndWithdraw() public {         //// SETUP         // accounting (to proof attack): save the rewardBalance of alice.         uint StartBalanceA = testTokenA.balanceOf(address(alice));         uint112 stakeAmount = 10_000;          // start stream and fill it         (             uint32 maxDepositLockDuration,             uint32 maxRewardLockDuration,             uint32 maxStreamDuration,             uint32 minStreamDuration         ) = defaultStreamFactory.streamParams();          uint64 nextStream = defaultStreamFactory.currStreamId();         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10),              maxStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );                  testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1_000_000_000);          // wait till the stream starts         hevm.warp(block.timestamp + 16);         hevm.roll(block.number + 1);          // just interact with contract to fill "lastUpdate" and "ts.lastUpdate"   // without changing balances inside of Streaming contract         alice.doStake(stream, address(testTokenB), stakeAmount);         alice.doWithdraw(stream, stakeAmount);           ///// ATTACK COMES HERE         // stake         alice.doStake(stream, address(testTokenB), stakeAmount);          // wait a block         hevm.roll(block.number + 1);         hevm.warp(block.timestamp + 16);          // withdraw soon thereafter         alice.doWithdraw(stream, stakeAmount);          // finish the stream         hevm.roll(block.number + 9999);         hevm.warp(block.timestamp + maxDepositLockDuration);          // get reward         alice.doClaimReward(stream);            // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken         uint EndBalanceA = testTokenA.balanceOf(address(alice));         uint EndBalanceB = testTokenB.balanceOf(address(alice));          // Stream returned everything we gave it         // (doStake sets balance of alice out of thin air => we compare end balance against our (thin air) balance)         assert(stakeAmount == EndBalanceB);          // we gained reward token without risk         assert(StartBalanceA == 0);         assert(StartBalanceA < EndBalanceA);         emit log_named_uint("alice gained", EndBalanceA);     } ```  ### commandline  ``` dapp test --verbosity=2 --match "test_quickDepositAndWithdraw" 2> /dev/null Running 1 tests for src/test/Locke.t.sol:StreamTest [PASS] test_quickDepositAndWithdraw() (gas: 4501209)  Success: test_quickDepositAndWithdraw    alice gained: 13227 ```  ## Tools Used  dapptools  ## Recommended Mitigation Steps Ensure staked tokens can not generate reward tokens without streaming deposit tokens. First idea that comes to mind is making following line `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L220` dependable on a positive amount > 0 of: `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229`  
# Handle  jonah1005   # Vulnerability details  ## Impact `rewardPerToken()` is calculated according to `lastApplicableTime`and `lastUpdate`. [Locke.sol#L343-L353](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L343-L353) Since `lastUpdate` is set to `startTime` before the start time. [Locke.sol#L203-L250](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L203-L250), it reverts before the start time.  `lastApplicableTime()) - lastUpdate` would revert when `lastUpdate` is bigger than `lastApplicableTime()`.  ## Proof of Concept This is the web3.py script: ```python     stream.functions.stake(deposit_amount).transact()     stream.functions.rewardPerToken().call() ``` Since `rewardPerToken` returns zero when totalVirtualBalance equals zero, we have to stake a few funds to trigger this bug.  ## Tools Used hardhat ## Recommended Mitigation Steps Recommend to return zero before startTime. ```solidity     function rewardPerToken() public view returns (uint256) {         if (totalVirtualBalance == 0 || lastApplicableTime() < startTime) {             return cumulativeRewardPerToken;         } else {             // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance             return cumulativeRewardPerToken + (                 // NOTE: depositDecimalsOne                 ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration)                  / totalVirtualBalance             );         }     } ```  
# Handle  Omik   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L472 the withdraw and stake function there is unnecessary else statement which didnt have any command inside it, this can lead to gas consumption more expensive then using only if statement for isSale check.  ## Proof of Concept pragma solidity ^0.8.0;   contract testing {      uint public counter;      function test()public {         if(true){             counter += 1;         }else{          }     }//43582 gas      function test2()public {         if(true){             counter += 1;         }     }//26449 gas      }  
# Handle  cyberboy   # Vulnerability details  ## Impact The __abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the "gov" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.  ## Proof of Concept 1. Compile the contract and set the _GOVERNOR and _EMERGENCY_GOVERNOR. 2. Now set a pendingGov but do not call acceptGov()  Bug 1 3. Call the __abdicate() function and we will notice only "gov" is set to zero address while emergency gov remains.  Bug2 4. Now use the address used in "pendingGov" to call acceptGov() function. 5. We will notice the new gov has been updated to the new address from the zero address.   Hence the __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.     ## Tools Used Remix to test the poC  ## Recommended Mitigation Steps The __abdicate() function should set emergency_gov and pendingGov as well to zero address.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.  Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0 ```JS   if (acctTimeDelta > 0 && ts.tokens > 0) { ``` Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens. However it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447  ```JS function stake(uint112 amount) public lock updateStream(msg.sender) {       ...                  uint112 trueDepositAmt = uint112(newBal - prevBal);        ...          ts.tokens += trueDepositAmt; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479  ```JS function withdraw(uint112 amount) public lock updateStream(msg.sender) {         ...         ts.tokens -= amount; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250  ```JS function updateStreamInternal(address who) internal { ...  uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;             if (acctTimeDelta > 0 && ts.tokens > 0) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);             } ```  ## Tools Used  ## Recommended Mitigation Steps Change the code in updateStream()  to:  ```JS     if (acctTimeDelta > 0 ) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 if (ts.tokens > 0)                        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)             } ```  Note: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas   
# Handle  harleythedog   # Vulnerability details  ## Impact The storage variable `unstreamed` keeps track of the global amount of deposit token in the contract that have not been streamed yet. This variable is a public variable, and users that read this variable likely want to use its value to determine whether or not they want to stake in the stream.  The issue here is that `unstreamed` is incremented on calls to `stake`, but it is not being decremented on calls to `withdraw`. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased `unstreamed`. They could do this repeatedly or with large amounts to intentionally inflate `unstreamed` to be as large as they want.  Other users would see this large amount and be deterred to stake in the stream, since they would get very little reward relative to the large amount of unstreamed deposit tokens that *appear* to be in the contract. This benefits the attacker as less users will want to stake in the stream, which leaves more rewards for them.  ## Proof of Concept See `stake` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417  See `withdraw` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455  Notice that `stake` increments `unstreamed` but `withdraw` does not affect `unstreamed` at all, even though `withdraw` is indeed removing unstreamed deposit tokens from the contract.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the following line to `withdraw` to fix this issue: ``` unstreamed -= amount; ```  
# Handle  wuwe1   # Vulnerability details  ```solidity // locke + depositTokenName + streamId = lockeUSD Coin-1 name = string(abi.encodePacked("locke", ERC20(depositToken).name(), ": ", toString(streamId))); ```  As the comment imply, the `": "` should be `"-"`  ## Recommended Mitigation Steps  Consider change the comment or the code.  
# Handle  kenzo   # Vulnerability details  Since `claimReward` can only be called after `endRewardLock`, `lastApplicableTime` will always return `endStream`.  ## Impact Some gas can be saved.  ## Proof of Concept `claimReward` will only run if time > endRewardLock (which is >= endStream): ``` require(block.timestamp > endRewardLock, "lock"); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L556 `claimReward` is calling `lastApplicableTime`: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L567 And this is `lastApplicableTime`: ``` return block.timestamp <= endStream ? uint32(block.timestamp) : endStream; ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 Therefore, it will always return `endStream`.   ## Recommended Mitigation Steps In `claimReward`, change this line: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 To: ``` lastUpdate = endStream; ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept In the method exit of Locke contract, ts.tokens was stored in a local variable, amount, and then this variable was used for call withdraw method, is better to call directly like `withdraw(ts.tokens)`  Source reference: - https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L492-L493  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the amount variable.  
# Handle  pedroais   # Vulnerability details  ## Impact Useless checks that cost gas ## Proof of Concept Since the Flashloan function has the lock modifier reentrancy is not possible so checking both tokens is useless.  ## Recommended Mitigation Steps   Proposed new function with less code :               function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {         require(token == depositToken || token == rewardToken, "erc");          uint256 preTokenBalance = ERC20(token).balanceOf(address(this));          ERC20(token).safeTransfer(to, amount);          // the `to` contract should have a public function with the signature:         // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);         LockeCallee(to).lockeCall(msg.sender, token, amount, data);          uint256 postTokenBalance = ERC20(token).balanceOf(address(this));          uint112 feeAmt = amount * 10 / 10000; // 10bps fee         require(preTokenBalance + feeAmt <= postTokenBalance, "f1");          if (token == depositToken) {             depositTokenFlashloanFeeAmount += feeAmt;         } else {             rewardTokenFeeAmount += feeAmt;         }          emit Flashloaned(token, msg.sender, amount, feeAmt);     }   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Save gas by caching the return value from rewardPerToken() in a local variable and use the local variable L220 and L222. This saves us two storage reads (1 cold = 800 gas, and 1 warm= 100 gas). It is way cheaper to read from a local variable (push/pop operations 2-3 gas each + cheap others)  Note: same for the claimReward() function on L555  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L555 ## Tools Used  ## Recommended Mitigation Steps - cache in a  local variable: uint256 _rewardPerToken = rewardPerToken(); - write the value to the storage variable: cumulativeRewardPerToken =  _rewardPerToken; - replace the occurrences of cumulativeRewardPerToken on L220/222 with _rewardPerToken   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove the unused merkleAccess variable in the TokenStream struct. According to the struct packing it uses a single storage slot.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L106  ## Tools Used  ## Recommended Mitigation Steps - remove the unused merkleAccess variable in the TokenStream struct  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Only ERC20 tokens with a decimals() function can be used as a depositToken. A stream creator maybe not be aware of this restriction and the creation of a stream would revert.  ## Proof of Concept In the constructor of the Stream contract the decimals() (L310) functions of the depositToken is called. But according to EIP20 (https://eips.ethereum.org/EIPS/eip-20) the decimals() function is optional.   https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L310  ## Tools Used  ## Recommended Mitigation Steps - clearly inform the stream creator that the depositToken needs to have the decimals() function implemented  
# Handle  cyberboy   # Vulnerability details  ## Impact Events for critical state changes (e.g., owner and other critical parameters) should be emitted for tracking this off-chain.   ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L41-L43 The function "setEmergencyGov" is missing event emit, and it is a critical function used for setting emergency governer.    ## Tools Used Slither  ## Recommended Mitigation Steps Add an event and emit it as a new emergency governor is set.   
# Handle  wuwe1   # Vulnerability details  excesss at `Streaming/src/Locke.sol:644:18` should be excess  agains at `Streaming/test/utils/HEVMHelpers.sol:28:49` should be against  agains at `Streaming/test/utils/HEVMHelpers.sol:78:49` should be against  
# Handle  cyberboy   # Vulnerability details  ## Impact Performing multiplication before division is generally better to avoid loss of precision because Solidity integer division might truncate  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L237-L238 globalStreamingSpeedPerSecond is later used for unstreamed for multiplication after performing division while calculation of globalStreamingSpeedPerSecond   ## Tools Used Slither   ## Recommended Mitigation Steps The code can be optimized to use uint112((uint256(tdelta) * (uint256(unstreamed) * 10**6) / (endStream - lastUpdate) * 10**6 Or maybe just  (uint112((uint256(tdelta) * (uint256(unstreamed)) / (endStream - lastUpdate)     
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735  ```solidity function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {     // cannot have an active incentive for the callee     require(incentives[who] == 0, "inc");     ... ```  When an incentiveToken is claimed after `endStream`, `incentives[who]` will be `0` for that `incentiveToken`.  If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as `who` and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.  ### PoC  1. Alice approved `USDC` to the streaming contract; 2. Alice called `createIncentive()` and added `1,000 USDC` of incentive; 3. After the stream is done, the stream creator called `claimIncentive()` and claimed `1,000 USDC`;  The compromised protocol gov can call `arbitraryCall()` and steal all the USDC in Alice's wallet balance.  ### Recommendation  Consider adding a mapping: `isIncentiveToken`, setting `isIncentiveToken[incentiveToken] = true` in `createIncentive()`, and `require(!isIncentiveToken[who], ...)` in `arbitraryCall()`.  
# Handle  WatchPug   # Vulnerability details  `require(newBal <= type(uint112).max ...)` vs `require(newBal < type(uint112).max...)`.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L386-L386 ```solidity=386 require(newBal < type(uint112).max && newBal > prevBal, "erc"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L427-L427 ```solidity=427 require(newBal <= type(uint112).max && newBal > prevBal, "erc"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L506-L506 ```solidity=506 require(newBal <= type(uint112).max && newBal > prevBal, "erc"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens); ```  In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.  As a result:  - When the protocol `governance` calls `claimFees()` and claim accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken. - Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.  ### PoC  Given:  - `feeEnabled`: true - `feePercent`: 10 (0.1%)  1. Alice deposited `1,000,000` depositToken; 2. Bob called `flashloan()` and borrowed `1,000,000` depositToken, then repaid `1,001,000`; 3. Charlie deposited `1,000` depositToken; 4. After `endDepositLock`, Alice called `claimDepositTokens()` and withdrawn `1,000,000` depositToken; 5. `streamCreator` called `recoverTokens(depositToken, recipient)` and retrieved `1,000` depositToken `(2,000 - (1,001,000 - 1,000,000))`; 6. `governance` called `claimFees()` and retrieved another `1,000` depositToken; 7. Charlie tries to `claimDepositTokens()` but since the current balanceOf depositToken is `0`, the transcation always fails, and Charlie loses all the depositToken.  ### Recommendation  Change to:  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - depositTokenFlashloanFeeAmount; ```  
# Handle  hack3r-0m   # Vulnerability details  ## Impact  https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229  reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.  ## Proof of Concept  Attaching diff to modify tests to reproduce behaviour:  ``` diff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol index 2be8db0..aba19ce 100644 --- a/Streaming/src/test/Locke.t.sol +++ b/Streaming/src/test/Locke.t.sol @@ -166,14 +166,14 @@ contract StreamTest is LockeTest {          );            testTokenA.approve(address(stream), type(uint256).max); -        stream.fundStream((10**14)*10**18); +        stream.fundStream(1000);   -        alice.doStake(stream, address(testTokenB), (10**13)*10**18); +        alice.doStake(stream, address(testTokenB), 100);              hevm.warp(startTime + minStreamDuration / 2); // move to half done           -        bob.doStake(stream, address(testTokenB), (10**13)*10**18); +        bob.doStake(stream, address(testTokenB), 100);            hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);   @@ -182,10 +182,10 @@ contract StreamTest is LockeTest {          hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream     -        // alice.doClaimReward(stream); -        // assertEq(testTokenA.balanceOf(address(alice)), 533*(10**15)); -        // bob.doClaimReward(stream); -        // assertEq(testTokenA.balanceOf(address(bob)), 466*(10**15)); +        alice.doClaimReward(stream); +        assertEq(testTokenA.balanceOf(address(alice)), 533); +        bob.doClaimReward(stream); +        assertEq(testTokenA.balanceOf(address(bob)), 466);      }        function test_stake() public { diff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol index eb38060..a479875 100644 --- a/Streaming/src/test/utils/LockeTest.sol +++ b/Streaming/src/test/utils/LockeTest.sol @@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {          testTokenA = ERC20(address(new TestToken("Test Token A", "TTA", 18)));          testTokenB = ERC20(address(new TestToken("Test Token B", "TTB", 18)));          testTokenC = ERC20(address(new TestToken("Test Token C", "TTC", 18))); -        write_balanceOf_ts(address(testTokenA), address(this), (10**14)*10**18); -        write_balanceOf_ts(address(testTokenB), address(this), (10**14)*10**18); -        write_balanceOf_ts(address(testTokenC), address(this), (10**14)*10**18); -        assertEq(testTokenA.balanceOf(address(this)), (10**14)*10**18); -        assertEq(testTokenB.balanceOf(address(this)), (10**14)*10**18); +        write_balanceOf_ts(address(testTokenA), address(this), 100*10**18); +        write_balanceOf_ts(address(testTokenB), address(this), 100*10**18); +        write_balanceOf_ts(address(testTokenC), address(this), 100*10**18); +        assertEq(testTokenA.balanceOf(address(this)), 100*10**18); +        assertEq(testTokenB.balanceOf(address(this)), 100*10**18);            defaultStreamFactory = new StreamFactory(address(this), address(this));   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider doing arithmetic operations in two steps or upcasting to u256 and then downcasting. Alternatively, find a threshold where it breaks and add require condition to not allow total stake per user greater than threshhold.  
# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows the `deposit` and `reward` tokens to be the same token.  > I believe this is intended, think Sushi reward on Sushi as is the case with `xSushi`.  The reward and deposit balances are also correctly tracked independently in `depositTokenAmount` and `rewardTokenAmount`. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:  ```solidity function recoverTokens(address token, address recipient) public lock {     // NOTE: it is the stream creators responsibility to save     // tokens on behalf of their users.     require(msg.sender == streamCreator, "!creator");     if (token == depositToken) {         require(block.timestamp > endDepositLock, "time");         // get the balance of this contract         // check what isnt claimable by either party         // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens         uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);         // allow saving of the token         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }          if (token == rewardToken) {         require(block.timestamp > endRewardLock, "time");         // check current balance vs internal balance         //         // NOTE: if a token rebases, i.e. changes balance out from under us,         // most of this contract breaks and rugs depositors. this isn't exclusive         // to this function but this function would in theory allow someone to rug         // and recover the excess (if it is worth anything)          // check what isnt claimable by depositors and governance         // @audit-info rewardTokenAmount increased on fundStream         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  #### POC Given `recoverTokens == depositToken`, `Stream` creator calls `recoverTokens(token = depositToken, creator)`.  - The `token` balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. `ERC20(token).balanceOf(address(this)) >= (depositTokenAmount - redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)` - `if (token == depositToken)` executes, the `excess` from the deposit amount will be the reward amount (`excess >= rewardTokenAmount + rewardTokenFeeAmount`). This will be transferred. - `if (token == rewardToken)` executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, `ERC20(token).balanceOf(address(this)) >= depositTokenAmount - redeemedDepositTokens`. If this is non-negative, the transaction does not revert and the creator makes a profit.  Example: - outstanding redeemable deposit token amount: `depositTokenAmount - redeemedDepositTokens = 1000` - funded `rewardTokenAmount` (plus `rewardTokenFeeAmount` fees): `rewardTokenAmount + rewardTokenFeeAmount = 500`  Creator receives `1500 - 1000 = 500` excess deposit and `1000 - 500 = 500` excess reward.  ## Impact When using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.  ## Recommended Mitigation Steps One needs to be careful with using `.balanceOf` in this special case as it includes both deposit and reward balances.  Add a special case for `recoverTokens` when `token == depositToken == rewardToken` and then the excess should be `ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount);`  
# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.  However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:  ```solidity function recoverTokens(address token, address recipient) public lock {     if (token == rewardToken) {         require(block.timestamp > endRewardLock, "time");          // check what isnt claimable by depositors and governance         // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  Note that `rewardTokenAmount` only ever _increases_ (when calling `fundStream`) but it never decreases when claiming the rewards through `claimReward`. However, `claimReward` transfers out the reward token.  Therefore, the `rewardTokenAmount` never tracks the contract's reward balance and the excess cannot be computed that way.  #### POC Assume no reward fees for simplicity and only a single user staking.  - Someone funds `1000` reward tokens through `fundStream(1000)`. Then `rewardTokenAmount = 1000`  - The stream and reward lock period is over, i.e. `block.timestamp > endRewardLock` - The user claims their full reward and receives `1000` reward tokens by calling `claimReward()`. The reward contract balance is now `0` but `rewardTokenAmount = 1000` - Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as the `excess = balance - rewardTokenAmount = 0`  ## Impact Reward token recovery does not work.  ## Recommended Mitigation Steps The claimed rewards need to be tracked as well, just like the claimed deposits are tracked. I think you can even decrease `rewardTokenAmount` in `claimReward` because at this point `rewardTokenAmount` is not used to update the `cumulativeRewardPerToken` anymore.  
# Handle  cmichel   # Vulnerability details  The `recoverTokens` function's comment states that the excess deposit tokens are `balance - depositTokenAmount`:  >     *      1. if its deposit token: >     *          - DepositLock is fully done >     *          - There are excess deposit tokens (balance - depositTokenAmount)  But it is `balance - (depositTokenAmount - redeemedDepositTokens)` where `(depositTokenAmount - redeemedDepositTokens)` is the outstanding redeemable amount.  ## Impact The code is correct.  ## Recommended Mitigation Steps Fix the comment.  
# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L553 stated that:  > Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens but the reward is only tracked to the original depositor in both case, see https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L558 ```         TokenStream storage ts = tokensNotYetStreamed[msg.sender]; ``` Transferring the LockeERC20 token does not transfer the TokenStream state.   
# Handle  gzeon   # Vulnerability details  ## Impact The documentation is unclear, but it make little sense that incentives are only paid to the stream creator instead of depositors. This make the incentives more like donation to the creator but not actually incentivizing the stream.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L518  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).   However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().   In summary:  1) If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.  2) Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735  ## Recommended Mitigation Steps  ### Recommendation 1 Limit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall().  ### Recommendation 2 Validate that the allowance of the target contract (if available) has not changed.  
# Handle  bitbopper   # Vulnerability details  ## Impact  `stake` and `withdraws` can generate rewardTokens without streaming depositTokens.  It does not matter whether the stream is a sale or not.  The following lines can increase the reward balance on a `withdraw` some time after `stake`: https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222 ``` // accumulate reward per token info cumulativeRewardPerToken = rewardPerToken();  // update user rewards ts.rewards = earned(ts, cumulativeRewardPerToken); ```   While the following line can be gamed in order to not stream any tokens (same withdraw tx).  Specifically an attacker can arrange to create a fraction less than zero thereby substracting zero. https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229 ``` ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate)); // WARDEN TRANSLATION: (elapsedSecondsSinceStake * stakeAmount) / (endStreamTimestamp - stakeTimestamp) ```  A succesful attack increases the share of rewardTokens of the attacker. The attack can be repeated every block increasing the share further. The attack could be done from multiple EOA increasing the share further. In short: Attackers can create loss of funds for (honest) stakers.  The economic feasability of the attack depends on: - staked amount (times number of attacks) vs total staked amount - relative value of rewardToken to gasprice    ## Proof of Concept  ### code   The following was added to `Locke.t.sol` for the `StreamTest` Contract to simulate the attack from one EOA.  ```     function test_quickDepositAndWithdraw() public {         //// SETUP         // accounting (to proof attack): save the rewardBalance of alice.         uint StartBalanceA = testTokenA.balanceOf(address(alice));         uint112 stakeAmount = 10_000;          // start stream and fill it         (             uint32 maxDepositLockDuration,             uint32 maxRewardLockDuration,             uint32 maxStreamDuration,             uint32 minStreamDuration         ) = defaultStreamFactory.streamParams();          uint64 nextStream = defaultStreamFactory.currStreamId();         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10),              maxStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );                  testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1_000_000_000);          // wait till the stream starts         hevm.warp(block.timestamp + 16);         hevm.roll(block.number + 1);          // just interact with contract to fill "lastUpdate" and "ts.lastUpdate"   // without changing balances inside of Streaming contract         alice.doStake(stream, address(testTokenB), stakeAmount);         alice.doWithdraw(stream, stakeAmount);           ///// ATTACK COMES HERE         // stake         alice.doStake(stream, address(testTokenB), stakeAmount);          // wait a block         hevm.roll(block.number + 1);         hevm.warp(block.timestamp + 16);          // withdraw soon thereafter         alice.doWithdraw(stream, stakeAmount);          // finish the stream         hevm.roll(block.number + 9999);         hevm.warp(block.timestamp + maxDepositLockDuration);          // get reward         alice.doClaimReward(stream);            // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken         uint EndBalanceA = testTokenA.balanceOf(address(alice));         uint EndBalanceB = testTokenB.balanceOf(address(alice));          // Stream returned everything we gave it         // (doStake sets balance of alice out of thin air => we compare end balance against our (thin air) balance)         assert(stakeAmount == EndBalanceB);          // we gained reward token without risk         assert(StartBalanceA == 0);         assert(StartBalanceA < EndBalanceA);         emit log_named_uint("alice gained", EndBalanceA);     } ```  ### commandline  ``` dapp test --verbosity=2 --match "test_quickDepositAndWithdraw" 2> /dev/null Running 1 tests for src/test/Locke.t.sol:StreamTest [PASS] test_quickDepositAndWithdraw() (gas: 4501209)  Success: test_quickDepositAndWithdraw    alice gained: 13227 ```  ## Tools Used  dapptools  ## Recommended Mitigation Steps Ensure staked tokens can not generate reward tokens without streaming deposit tokens. First idea that comes to mind is making following line `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L220` dependable on a positive amount > 0 of: `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229`  
# Handle  jonah1005   # Vulnerability details  ## Impact `rewardPerToken()` is calculated according to `lastApplicableTime`and `lastUpdate`. [Locke.sol#L343-L353](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L343-L353) Since `lastUpdate` is set to `startTime` before the start time. [Locke.sol#L203-L250](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L203-L250), it reverts before the start time.  `lastApplicableTime()) - lastUpdate` would revert when `lastUpdate` is bigger than `lastApplicableTime()`.  ## Proof of Concept This is the web3.py script: ```python     stream.functions.stake(deposit_amount).transact()     stream.functions.rewardPerToken().call() ``` Since `rewardPerToken` returns zero when totalVirtualBalance equals zero, we have to stake a few funds to trigger this bug.  ## Tools Used hardhat ## Recommended Mitigation Steps Recommend to return zero before startTime. ```solidity     function rewardPerToken() public view returns (uint256) {         if (totalVirtualBalance == 0 || lastApplicableTime() < startTime) {             return cumulativeRewardPerToken;         } else {             // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance             return cumulativeRewardPerToken + (                 // NOTE: depositDecimalsOne                 ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration)                  / totalVirtualBalance             );         }     } ```  
# Handle  Omik   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L472 the withdraw and stake function there is unnecessary else statement which didnt have any command inside it, this can lead to gas consumption more expensive then using only if statement for isSale check.  ## Proof of Concept pragma solidity ^0.8.0;   contract testing {      uint public counter;      function test()public {         if(true){             counter += 1;         }else{          }     }//43582 gas      function test2()public {         if(true){             counter += 1;         }     }//26449 gas      }  
# Handle  cyberboy   # Vulnerability details  ## Impact The __abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the "gov" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.  ## Proof of Concept 1. Compile the contract and set the _GOVERNOR and _EMERGENCY_GOVERNOR. 2. Now set a pendingGov but do not call acceptGov()  Bug 1 3. Call the __abdicate() function and we will notice only "gov" is set to zero address while emergency gov remains.  Bug2 4. Now use the address used in "pendingGov" to call acceptGov() function. 5. We will notice the new gov has been updated to the new address from the zero address.   Hence the __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.     ## Tools Used Remix to test the poC  ## Recommended Mitigation Steps The __abdicate() function should set emergency_gov and pendingGov as well to zero address.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.  Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0 ```JS   if (acctTimeDelta > 0 && ts.tokens > 0) { ``` Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens. However it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447  ```JS function stake(uint112 amount) public lock updateStream(msg.sender) {       ...                  uint112 trueDepositAmt = uint112(newBal - prevBal);        ...          ts.tokens += trueDepositAmt; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479  ```JS function withdraw(uint112 amount) public lock updateStream(msg.sender) {         ...         ts.tokens -= amount; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250  ```JS function updateStreamInternal(address who) internal { ...  uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;             if (acctTimeDelta > 0 && ts.tokens > 0) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);             } ```  ## Tools Used  ## Recommended Mitigation Steps Change the code in updateStream()  to:  ```JS     if (acctTimeDelta > 0 ) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 if (ts.tokens > 0)                        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)             } ```  Note: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas   
# Handle  harleythedog   # Vulnerability details  ## Impact The storage variable `unstreamed` keeps track of the global amount of deposit token in the contract that have not been streamed yet. This variable is a public variable, and users that read this variable likely want to use its value to determine whether or not they want to stake in the stream.  The issue here is that `unstreamed` is incremented on calls to `stake`, but it is not being decremented on calls to `withdraw`. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased `unstreamed`. They could do this repeatedly or with large amounts to intentionally inflate `unstreamed` to be as large as they want.  Other users would see this large amount and be deterred to stake in the stream, since they would get very little reward relative to the large amount of unstreamed deposit tokens that *appear* to be in the contract. This benefits the attacker as less users will want to stake in the stream, which leaves more rewards for them.  ## Proof of Concept See `stake` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417  See `withdraw` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455  Notice that `stake` increments `unstreamed` but `withdraw` does not affect `unstreamed` at all, even though `withdraw` is indeed removing unstreamed deposit tokens from the contract.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the following line to `withdraw` to fix this issue: ``` unstreamed -= amount; ```  
# Handle  wuwe1   # Vulnerability details  ```solidity // locke + depositTokenName + streamId = lockeUSD Coin-1 name = string(abi.encodePacked("locke", ERC20(depositToken).name(), ": ", toString(streamId))); ```  As the comment imply, the `": "` should be `"-"`  ## Recommended Mitigation Steps  Consider change the comment or the code.  
# Handle  kenzo   # Vulnerability details  Since `claimReward` can only be called after `endRewardLock`, `lastApplicableTime` will always return `endStream`.  ## Impact Some gas can be saved.  ## Proof of Concept `claimReward` will only run if time > endRewardLock (which is >= endStream): ``` require(block.timestamp > endRewardLock, "lock"); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L556 `claimReward` is calling `lastApplicableTime`: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L567 And this is `lastApplicableTime`: ``` return block.timestamp <= endStream ? uint32(block.timestamp) : endStream; ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 Therefore, it will always return `endStream`.   ## Recommended Mitigation Steps In `claimReward`, change this line: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 To: ``` lastUpdate = endStream; ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept In the method exit of Locke contract, ts.tokens was stored in a local variable, amount, and then this variable was used for call withdraw method, is better to call directly like `withdraw(ts.tokens)`  Source reference: - https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L492-L493  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the amount variable.  
# Handle  pedroais   # Vulnerability details  ## Impact Useless checks that cost gas ## Proof of Concept Since the Flashloan function has the lock modifier reentrancy is not possible so checking both tokens is useless.  ## Recommended Mitigation Steps   Proposed new function with less code :               function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {         require(token == depositToken || token == rewardToken, "erc");          uint256 preTokenBalance = ERC20(token).balanceOf(address(this));          ERC20(token).safeTransfer(to, amount);          // the `to` contract should have a public function with the signature:         // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);         LockeCallee(to).lockeCall(msg.sender, token, amount, data);          uint256 postTokenBalance = ERC20(token).balanceOf(address(this));          uint112 feeAmt = amount * 10 / 10000; // 10bps fee         require(preTokenBalance + feeAmt <= postTokenBalance, "f1");          if (token == depositToken) {             depositTokenFlashloanFeeAmount += feeAmt;         } else {             rewardTokenFeeAmount += feeAmt;         }          emit Flashloaned(token, msg.sender, amount, feeAmt);     }   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Save gas by caching the return value from rewardPerToken() in a local variable and use the local variable L220 and L222. This saves us two storage reads (1 cold = 800 gas, and 1 warm= 100 gas). It is way cheaper to read from a local variable (push/pop operations 2-3 gas each + cheap others)  Note: same for the claimReward() function on L555  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L555 ## Tools Used  ## Recommended Mitigation Steps - cache in a  local variable: uint256 _rewardPerToken = rewardPerToken(); - write the value to the storage variable: cumulativeRewardPerToken =  _rewardPerToken; - replace the occurrences of cumulativeRewardPerToken on L220/222 with _rewardPerToken   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove the unused merkleAccess variable in the TokenStream struct. According to the struct packing it uses a single storage slot.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L106  ## Tools Used  ## Recommended Mitigation Steps - remove the unused merkleAccess variable in the TokenStream struct  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Only ERC20 tokens with a decimals() function can be used as a depositToken. A stream creator maybe not be aware of this restriction and the creation of a stream would revert.  ## Proof of Concept In the constructor of the Stream contract the decimals() (L310) functions of the depositToken is called. But according to EIP20 (https://eips.ethereum.org/EIPS/eip-20) the decimals() function is optional.   https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L310  ## Tools Used  ## Recommended Mitigation Steps - clearly inform the stream creator that the depositToken needs to have the decimals() function implemented  
# Handle  cyberboy   # Vulnerability details  ## Impact Events for critical state changes (e.g., owner and other critical parameters) should be emitted for tracking this off-chain.   ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L41-L43 The function "setEmergencyGov" is missing event emit, and it is a critical function used for setting emergency governer.    ## Tools Used Slither  ## Recommended Mitigation Steps Add an event and emit it as a new emergency governor is set.   
# Handle  wuwe1   # Vulnerability details  excesss at `Streaming/src/Locke.sol:644:18` should be excess  agains at `Streaming/test/utils/HEVMHelpers.sol:28:49` should be against  agains at `Streaming/test/utils/HEVMHelpers.sol:78:49` should be against  
# Handle  cyberboy   # Vulnerability details  ## Impact Performing multiplication before division is generally better to avoid loss of precision because Solidity integer division might truncate  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L237-L238 globalStreamingSpeedPerSecond is later used for unstreamed for multiplication after performing division while calculation of globalStreamingSpeedPerSecond   ## Tools Used Slither   ## Recommended Mitigation Steps The code can be optimized to use uint112((uint256(tdelta) * (uint256(unstreamed) * 10**6) / (endStream - lastUpdate) * 10**6 Or maybe just  (uint112((uint256(tdelta) * (uint256(unstreamed)) / (endStream - lastUpdate)     
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735  ```solidity function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {     // cannot have an active incentive for the callee     require(incentives[who] == 0, "inc");     ... ```  When an incentiveToken is claimed after `endStream`, `incentives[who]` will be `0` for that `incentiveToken`.  If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as `who` and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.  ### PoC  1. Alice approved `USDC` to the streaming contract; 2. Alice called `createIncentive()` and added `1,000 USDC` of incentive; 3. After the stream is done, the stream creator called `claimIncentive()` and claimed `1,000 USDC`;  The compromised protocol gov can call `arbitraryCall()` and steal all the USDC in Alice's wallet balance.  ### Recommendation  Consider adding a mapping: `isIncentiveToken`, setting `isIncentiveToken[incentiveToken] = true` in `createIncentive()`, and `require(!isIncentiveToken[who], ...)` in `arbitraryCall()`.  
# Handle  WatchPug   # Vulnerability details  `require(newBal <= type(uint112).max ...)` vs `require(newBal < type(uint112).max...)`.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L386-L386 ```solidity=386 require(newBal < type(uint112).max && newBal > prevBal, "erc"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L427-L427 ```solidity=427 require(newBal <= type(uint112).max && newBal > prevBal, "erc"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L506-L506 ```solidity=506 require(newBal <= type(uint112).max && newBal > prevBal, "erc"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens); ```  In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.  As a result:  - When the protocol `governance` calls `claimFees()` and claim accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken. - Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.  ### PoC  Given:  - `feeEnabled`: true - `feePercent`: 10 (0.1%)  1. Alice deposited `1,000,000` depositToken; 2. Bob called `flashloan()` and borrowed `1,000,000` depositToken, then repaid `1,001,000`; 3. Charlie deposited `1,000` depositToken; 4. After `endDepositLock`, Alice called `claimDepositTokens()` and withdrawn `1,000,000` depositToken; 5. `streamCreator` called `recoverTokens(depositToken, recipient)` and retrieved `1,000` depositToken `(2,000 - (1,001,000 - 1,000,000))`; 6. `governance` called `claimFees()` and retrieved another `1,000` depositToken; 7. Charlie tries to `claimDepositTokens()` but since the current balanceOf depositToken is `0`, the transcation always fails, and Charlie loses all the depositToken.  ### Recommendation  Change to:  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - depositTokenFlashloanFeeAmount; ```  
# Handle  hack3r-0m   # Vulnerability details  ## Impact  https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229  reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.  ## Proof of Concept  Attaching diff to modify tests to reproduce behaviour:  ``` diff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol index 2be8db0..aba19ce 100644 --- a/Streaming/src/test/Locke.t.sol +++ b/Streaming/src/test/Locke.t.sol @@ -166,14 +166,14 @@ contract StreamTest is LockeTest {          );            testTokenA.approve(address(stream), type(uint256).max); -        stream.fundStream((10**14)*10**18); +        stream.fundStream(1000);   -        alice.doStake(stream, address(testTokenB), (10**13)*10**18); +        alice.doStake(stream, address(testTokenB), 100);              hevm.warp(startTime + minStreamDuration / 2); // move to half done           -        bob.doStake(stream, address(testTokenB), (10**13)*10**18); +        bob.doStake(stream, address(testTokenB), 100);            hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);   @@ -182,10 +182,10 @@ contract StreamTest is LockeTest {          hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream     -        // alice.doClaimReward(stream); -        // assertEq(testTokenA.balanceOf(address(alice)), 533*(10**15)); -        // bob.doClaimReward(stream); -        // assertEq(testTokenA.balanceOf(address(bob)), 466*(10**15)); +        alice.doClaimReward(stream); +        assertEq(testTokenA.balanceOf(address(alice)), 533); +        bob.doClaimReward(stream); +        assertEq(testTokenA.balanceOf(address(bob)), 466);      }        function test_stake() public { diff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol index eb38060..a479875 100644 --- a/Streaming/src/test/utils/LockeTest.sol +++ b/Streaming/src/test/utils/LockeTest.sol @@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {          testTokenA = ERC20(address(new TestToken("Test Token A", "TTA", 18)));          testTokenB = ERC20(address(new TestToken("Test Token B", "TTB", 18)));          testTokenC = ERC20(address(new TestToken("Test Token C", "TTC", 18))); -        write_balanceOf_ts(address(testTokenA), address(this), (10**14)*10**18); -        write_balanceOf_ts(address(testTokenB), address(this), (10**14)*10**18); -        write_balanceOf_ts(address(testTokenC), address(this), (10**14)*10**18); -        assertEq(testTokenA.balanceOf(address(this)), (10**14)*10**18); -        assertEq(testTokenB.balanceOf(address(this)), (10**14)*10**18); +        write_balanceOf_ts(address(testTokenA), address(this), 100*10**18); +        write_balanceOf_ts(address(testTokenB), address(this), 100*10**18); +        write_balanceOf_ts(address(testTokenC), address(this), 100*10**18); +        assertEq(testTokenA.balanceOf(address(this)), 100*10**18); +        assertEq(testTokenB.balanceOf(address(this)), 100*10**18);            defaultStreamFactory = new StreamFactory(address(this), address(this));   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider doing arithmetic operations in two steps or upcasting to u256 and then downcasting. Alternatively, find a threshold where it breaks and add require condition to not allow total stake per user greater than threshhold.  
# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows the `deposit` and `reward` tokens to be the same token.  > I believe this is intended, think Sushi reward on Sushi as is the case with `xSushi`.  The reward and deposit balances are also correctly tracked independently in `depositTokenAmount` and `rewardTokenAmount`. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:  ```solidity function recoverTokens(address token, address recipient) public lock {     // NOTE: it is the stream creators responsibility to save     // tokens on behalf of their users.     require(msg.sender == streamCreator, "!creator");     if (token == depositToken) {         require(block.timestamp > endDepositLock, "time");         // get the balance of this contract         // check what isnt claimable by either party         // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens         uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);         // allow saving of the token         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }          if (token == rewardToken) {         require(block.timestamp > endRewardLock, "time");         // check current balance vs internal balance         //         // NOTE: if a token rebases, i.e. changes balance out from under us,         // most of this contract breaks and rugs depositors. this isn't exclusive         // to this function but this function would in theory allow someone to rug         // and recover the excess (if it is worth anything)          // check what isnt claimable by depositors and governance         // @audit-info rewardTokenAmount increased on fundStream         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  #### POC Given `recoverTokens == depositToken`, `Stream` creator calls `recoverTokens(token = depositToken, creator)`.  - The `token` balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. `ERC20(token).balanceOf(address(this)) >= (depositTokenAmount - redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)` - `if (token == depositToken)` executes, the `excess` from the deposit amount will be the reward amount (`excess >= rewardTokenAmount + rewardTokenFeeAmount`). This will be transferred. - `if (token == rewardToken)` executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, `ERC20(token).balanceOf(address(this)) >= depositTokenAmount - redeemedDepositTokens`. If this is non-negative, the transaction does not revert and the creator makes a profit.  Example: - outstanding redeemable deposit token amount: `depositTokenAmount - redeemedDepositTokens = 1000` - funded `rewardTokenAmount` (plus `rewardTokenFeeAmount` fees): `rewardTokenAmount + rewardTokenFeeAmount = 500`  Creator receives `1500 - 1000 = 500` excess deposit and `1000 - 500 = 500` excess reward.  ## Impact When using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.  ## Recommended Mitigation Steps One needs to be careful with using `.balanceOf` in this special case as it includes both deposit and reward balances.  Add a special case for `recoverTokens` when `token == depositToken == rewardToken` and then the excess should be `ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount);`  
# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.  However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:  ```solidity function recoverTokens(address token, address recipient) public lock {     if (token == rewardToken) {         require(block.timestamp > endRewardLock, "time");          // check what isnt claimable by depositors and governance         // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  Note that `rewardTokenAmount` only ever _increases_ (when calling `fundStream`) but it never decreases when claiming the rewards through `claimReward`. However, `claimReward` transfers out the reward token.  Therefore, the `rewardTokenAmount` never tracks the contract's reward balance and the excess cannot be computed that way.  #### POC Assume no reward fees for simplicity and only a single user staking.  - Someone funds `1000` reward tokens through `fundStream(1000)`. Then `rewardTokenAmount = 1000`  - The stream and reward lock period is over, i.e. `block.timestamp > endRewardLock` - The user claims their full reward and receives `1000` reward tokens by calling `claimReward()`. The reward contract balance is now `0` but `rewardTokenAmount = 1000` - Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as the `excess = balance - rewardTokenAmount = 0`  ## Impact Reward token recovery does not work.  ## Recommended Mitigation Steps The claimed rewards need to be tracked as well, just like the claimed deposits are tracked. I think you can even decrease `rewardTokenAmount` in `claimReward` because at this point `rewardTokenAmount` is not used to update the `cumulativeRewardPerToken` anymore.  
# Handle  cmichel   # Vulnerability details  The `recoverTokens` function's comment states that the excess deposit tokens are `balance - depositTokenAmount`:  >     *      1. if its deposit token: >     *          - DepositLock is fully done >     *          - There are excess deposit tokens (balance - depositTokenAmount)  But it is `balance - (depositTokenAmount - redeemedDepositTokens)` where `(depositTokenAmount - redeemedDepositTokens)` is the outstanding redeemable amount.  ## Impact The code is correct.  ## Recommended Mitigation Steps Fix the comment.  
# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L553 stated that:  > Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens but the reward is only tracked to the original depositor in both case, see https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L558 ```         TokenStream storage ts = tokensNotYetStreamed[msg.sender]; ``` Transferring the LockeERC20 token does not transfer the TokenStream state.   
# Handle  gzeon   # Vulnerability details  ## Impact The documentation is unclear, but it make little sense that incentives are only paid to the stream creator instead of depositors. This make the incentives more like donation to the creator but not actually incentivizing the stream.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L518  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).   However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().   In summary:  1) If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.  2) Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735  ## Recommended Mitigation Steps  ### Recommendation 1 Limit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall().  ### Recommendation 2 Validate that the allowance of the target contract (if available) has not changed.  
# Handle  bitbopper   # Vulnerability details  ## Impact  `stake` and `withdraws` can generate rewardTokens without streaming depositTokens.  It does not matter whether the stream is a sale or not.  The following lines can increase the reward balance on a `withdraw` some time after `stake`: https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222 ``` // accumulate reward per token info cumulativeRewardPerToken = rewardPerToken();  // update user rewards ts.rewards = earned(ts, cumulativeRewardPerToken); ```   While the following line can be gamed in order to not stream any tokens (same withdraw tx).  Specifically an attacker can arrange to create a fraction less than zero thereby substracting zero. https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229 ``` ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate)); // WARDEN TRANSLATION: (elapsedSecondsSinceStake * stakeAmount) / (endStreamTimestamp - stakeTimestamp) ```  A succesful attack increases the share of rewardTokens of the attacker. The attack can be repeated every block increasing the share further. The attack could be done from multiple EOA increasing the share further. In short: Attackers can create loss of funds for (honest) stakers.  The economic feasability of the attack depends on: - staked amount (times number of attacks) vs total staked amount - relative value of rewardToken to gasprice    ## Proof of Concept  ### code   The following was added to `Locke.t.sol` for the `StreamTest` Contract to simulate the attack from one EOA.  ```     function test_quickDepositAndWithdraw() public {         //// SETUP         // accounting (to proof attack): save the rewardBalance of alice.         uint StartBalanceA = testTokenA.balanceOf(address(alice));         uint112 stakeAmount = 10_000;          // start stream and fill it         (             uint32 maxDepositLockDuration,             uint32 maxRewardLockDuration,             uint32 maxStreamDuration,             uint32 minStreamDuration         ) = defaultStreamFactory.streamParams();          uint64 nextStream = defaultStreamFactory.currStreamId();         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10),              maxStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );                  testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1_000_000_000);          // wait till the stream starts         hevm.warp(block.timestamp + 16);         hevm.roll(block.number + 1);          // just interact with contract to fill "lastUpdate" and "ts.lastUpdate"   // without changing balances inside of Streaming contract         alice.doStake(stream, address(testTokenB), stakeAmount);         alice.doWithdraw(stream, stakeAmount);           ///// ATTACK COMES HERE         // stake         alice.doStake(stream, address(testTokenB), stakeAmount);          // wait a block         hevm.roll(block.number + 1);         hevm.warp(block.timestamp + 16);          // withdraw soon thereafter         alice.doWithdraw(stream, stakeAmount);          // finish the stream         hevm.roll(block.number + 9999);         hevm.warp(block.timestamp + maxDepositLockDuration);          // get reward         alice.doClaimReward(stream);            // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken         uint EndBalanceA = testTokenA.balanceOf(address(alice));         uint EndBalanceB = testTokenB.balanceOf(address(alice));          // Stream returned everything we gave it         // (doStake sets balance of alice out of thin air => we compare end balance against our (thin air) balance)         assert(stakeAmount == EndBalanceB);          // we gained reward token without risk         assert(StartBalanceA == 0);         assert(StartBalanceA < EndBalanceA);         emit log_named_uint("alice gained", EndBalanceA);     } ```  ### commandline  ``` dapp test --verbosity=2 --match "test_quickDepositAndWithdraw" 2> /dev/null Running 1 tests for src/test/Locke.t.sol:StreamTest [PASS] test_quickDepositAndWithdraw() (gas: 4501209)  Success: test_quickDepositAndWithdraw    alice gained: 13227 ```  ## Tools Used  dapptools  ## Recommended Mitigation Steps Ensure staked tokens can not generate reward tokens without streaming deposit tokens. First idea that comes to mind is making following line `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L220` dependable on a positive amount > 0 of: `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229`  
# Handle  jonah1005   # Vulnerability details  ## Impact `rewardPerToken()` is calculated according to `lastApplicableTime`and `lastUpdate`. [Locke.sol#L343-L353](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L343-L353) Since `lastUpdate` is set to `startTime` before the start time. [Locke.sol#L203-L250](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L203-L250), it reverts before the start time.  `lastApplicableTime()) - lastUpdate` would revert when `lastUpdate` is bigger than `lastApplicableTime()`.  ## Proof of Concept This is the web3.py script: ```python     stream.functions.stake(deposit_amount).transact()     stream.functions.rewardPerToken().call() ``` Since `rewardPerToken` returns zero when totalVirtualBalance equals zero, we have to stake a few funds to trigger this bug.  ## Tools Used hardhat ## Recommended Mitigation Steps Recommend to return zero before startTime. ```solidity     function rewardPerToken() public view returns (uint256) {         if (totalVirtualBalance == 0 || lastApplicableTime() < startTime) {             return cumulativeRewardPerToken;         } else {             // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance             return cumulativeRewardPerToken + (                 // NOTE: depositDecimalsOne                 ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration)                  / totalVirtualBalance             );         }     } ```  
# Handle  Omik   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L472 the withdraw and stake function there is unnecessary else statement which didnt have any command inside it, this can lead to gas consumption more expensive then using only if statement for isSale check.  ## Proof of Concept pragma solidity ^0.8.0;   contract testing {      uint public counter;      function test()public {         if(true){             counter += 1;         }else{          }     }//43582 gas      function test2()public {         if(true){             counter += 1;         }     }//26449 gas      }  
# Handle  cyberboy   # Vulnerability details  ## Impact The __abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the "gov" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.  ## Proof of Concept 1. Compile the contract and set the _GOVERNOR and _EMERGENCY_GOVERNOR. 2. Now set a pendingGov but do not call acceptGov()  Bug 1 3. Call the __abdicate() function and we will notice only "gov" is set to zero address while emergency gov remains.  Bug2 4. Now use the address used in "pendingGov" to call acceptGov() function. 5. We will notice the new gov has been updated to the new address from the zero address.   Hence the __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.     ## Tools Used Remix to test the poC  ## Recommended Mitigation Steps The __abdicate() function should set emergency_gov and pendingGov as well to zero address.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.  Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0 ```JS   if (acctTimeDelta > 0 && ts.tokens > 0) { ``` Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens. However it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447  ```JS function stake(uint112 amount) public lock updateStream(msg.sender) {       ...                  uint112 trueDepositAmt = uint112(newBal - prevBal);        ...          ts.tokens += trueDepositAmt; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479  ```JS function withdraw(uint112 amount) public lock updateStream(msg.sender) {         ...         ts.tokens -= amount; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250  ```JS function updateStreamInternal(address who) internal { ...  uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;             if (acctTimeDelta > 0 && ts.tokens > 0) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);             } ```  ## Tools Used  ## Recommended Mitigation Steps Change the code in updateStream()  to:  ```JS     if (acctTimeDelta > 0 ) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 if (ts.tokens > 0)                        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)             } ```  Note: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas   
# Handle  harleythedog   # Vulnerability details  ## Impact The storage variable `unstreamed` keeps track of the global amount of deposit token in the contract that have not been streamed yet. This variable is a public variable, and users that read this variable likely want to use its value to determine whether or not they want to stake in the stream.  The issue here is that `unstreamed` is incremented on calls to `stake`, but it is not being decremented on calls to `withdraw`. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased `unstreamed`. They could do this repeatedly or with large amounts to intentionally inflate `unstreamed` to be as large as they want.  Other users would see this large amount and be deterred to stake in the stream, since they would get very little reward relative to the large amount of unstreamed deposit tokens that *appear* to be in the contract. This benefits the attacker as less users will want to stake in the stream, which leaves more rewards for them.  ## Proof of Concept See `stake` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417  See `withdraw` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455  Notice that `stake` increments `unstreamed` but `withdraw` does not affect `unstreamed` at all, even though `withdraw` is indeed removing unstreamed deposit tokens from the contract.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the following line to `withdraw` to fix this issue: ``` unstreamed -= amount; ```  
# Handle  wuwe1   # Vulnerability details  ```solidity // locke + depositTokenName + streamId = lockeUSD Coin-1 name = string(abi.encodePacked("locke", ERC20(depositToken).name(), ": ", toString(streamId))); ```  As the comment imply, the `": "` should be `"-"`  ## Recommended Mitigation Steps  Consider change the comment or the code.  
# Handle  kenzo   # Vulnerability details  Since `claimReward` can only be called after `endRewardLock`, `lastApplicableTime` will always return `endStream`.  ## Impact Some gas can be saved.  ## Proof of Concept `claimReward` will only run if time > endRewardLock (which is >= endStream): ``` require(block.timestamp > endRewardLock, "lock"); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L556 `claimReward` is calling `lastApplicableTime`: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L567 And this is `lastApplicableTime`: ``` return block.timestamp <= endStream ? uint32(block.timestamp) : endStream; ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 Therefore, it will always return `endStream`.   ## Recommended Mitigation Steps In `claimReward`, change this line: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 To: ``` lastUpdate = endStream; ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept In the method exit of Locke contract, ts.tokens was stored in a local variable, amount, and then this variable was used for call withdraw method, is better to call directly like `withdraw(ts.tokens)`  Source reference: - https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L492-L493  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the amount variable.  
# Handle  pedroais   # Vulnerability details  ## Impact Useless checks that cost gas ## Proof of Concept Since the Flashloan function has the lock modifier reentrancy is not possible so checking both tokens is useless.  ## Recommended Mitigation Steps   Proposed new function with less code :               function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {         require(token == depositToken || token == rewardToken, "erc");          uint256 preTokenBalance = ERC20(token).balanceOf(address(this));          ERC20(token).safeTransfer(to, amount);          // the `to` contract should have a public function with the signature:         // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);         LockeCallee(to).lockeCall(msg.sender, token, amount, data);          uint256 postTokenBalance = ERC20(token).balanceOf(address(this));          uint112 feeAmt = amount * 10 / 10000; // 10bps fee         require(preTokenBalance + feeAmt <= postTokenBalance, "f1");          if (token == depositToken) {             depositTokenFlashloanFeeAmount += feeAmt;         } else {             rewardTokenFeeAmount += feeAmt;         }          emit Flashloaned(token, msg.sender, amount, feeAmt);     }   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Save gas by caching the return value from rewardPerToken() in a local variable and use the local variable L220 and L222. This saves us two storage reads (1 cold = 800 gas, and 1 warm= 100 gas). It is way cheaper to read from a local variable (push/pop operations 2-3 gas each + cheap others)  Note: same for the claimReward() function on L555  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L555 ## Tools Used  ## Recommended Mitigation Steps - cache in a  local variable: uint256 _rewardPerToken = rewardPerToken(); - write the value to the storage variable: cumulativeRewardPerToken =  _rewardPerToken; - replace the occurrences of cumulativeRewardPerToken on L220/222 with _rewardPerToken   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove the unused merkleAccess variable in the TokenStream struct. According to the struct packing it uses a single storage slot.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L106  ## Tools Used  ## Recommended Mitigation Steps - remove the unused merkleAccess variable in the TokenStream struct  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Only ERC20 tokens with a decimals() function can be used as a depositToken. A stream creator maybe not be aware of this restriction and the creation of a stream would revert.  ## Proof of Concept In the constructor of the Stream contract the decimals() (L310) functions of the depositToken is called. But according to EIP20 (https://eips.ethereum.org/EIPS/eip-20) the decimals() function is optional.   https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L310  ## Tools Used  ## Recommended Mitigation Steps - clearly inform the stream creator that the depositToken needs to have the decimals() function implemented  
# Handle  cyberboy   # Vulnerability details  ## Impact Events for critical state changes (e.g., owner and other critical parameters) should be emitted for tracking this off-chain.   ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L41-L43 The function "setEmergencyGov" is missing event emit, and it is a critical function used for setting emergency governer.    ## Tools Used Slither  ## Recommended Mitigation Steps Add an event and emit it as a new emergency governor is set.   
# Handle  wuwe1   # Vulnerability details  excesss at `Streaming/src/Locke.sol:644:18` should be excess  agains at `Streaming/test/utils/HEVMHelpers.sol:28:49` should be against  agains at `Streaming/test/utils/HEVMHelpers.sol:78:49` should be against  
# Handle  cyberboy   # Vulnerability details  ## Impact Performing multiplication before division is generally better to avoid loss of precision because Solidity integer division might truncate  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L237-L238 globalStreamingSpeedPerSecond is later used for unstreamed for multiplication after performing division while calculation of globalStreamingSpeedPerSecond   ## Tools Used Slither   ## Recommended Mitigation Steps The code can be optimized to use uint112((uint256(tdelta) * (uint256(unstreamed) * 10**6) / (endStream - lastUpdate) * 10**6 Or maybe just  (uint112((uint256(tdelta) * (uint256(unstreamed)) / (endStream - lastUpdate)     
