# Handle  shw   # Vulnerability details  ** Editing on a previous submission to clarify more details **  ## Impact  In `Pool.sol`, the lockup restriction of withdrawal (`Pool.sol#396`) can be bypassed or reduced if new liquidity providers cooperate with existing ones.  ## Proof of Concept  1. A liquidity provider, Alice, deposits liquidity assets into the pool and minted some FDTs. She then waits for `lockupPeriod` days and calls `intendToWithdraw` to pass her withdrawal window. Now she is available to receive FDTs from others. 2. A new liquidity provider, Bob, deposits liquidity assets into the pool and minted some FDTs. Currently, he is not allowed to withdraw his funds by protocol design. 3. Bob and Alice agree to cooperate with each other to reduce Bob's waiting time for withdrawal. Bob transfers his FDT to Alice via the `_transfer` function. 4. Alice calls `intendToWithdraw` and waits for the `withdrawCooldown` period. Notice that Alice's `depositDate` is updated after the transfer; however, since it is calculated using a weighted timestamp, the increased amount of lockup time should be less than `lockupPeriod`. In situations where the deposit from Alice is much larger than that from Bob, Alice could only even need to wait for the `withdrawCooldown` period before she could withdraw any funds. 5. Alice then withdraws the amount of FDT that Bob transferred to her and transfers the funds (liquidity assets) to Bob. Bob successfully reduces (or bypasses) the lockup period of withdrawal.  ## Tools Used  None  ## Recommended Mitigation Steps  Force users to wait for the lockup period when transferring FDT to others. Or let the `depositDate` variable record the timestamp of the last operation instead of a weighted timestamp.  
# Handle  shw   # Vulnerability details  ## Impact  In `library/PoolLib.sol`, the return value of functions `BPTVal` and `getPoolSharesRequired` are vulnerable by flash-loan attacks. The attacker can inflate the results of these two functions by swapping a large amount of `liquidityAsset` into the pool and swaps back after the functions are called to deceive the pool contract that BPT has a relatively high price.  Although currently `BPTVal` is not used and `getPoolSharesRequired` only affects the required staking amounts of token for a pool delegate, the code is vulnerable and could be misused by anyone in the future.  ## Proof of Concept  In the function `BPTVal`, the value of BPT in units of liquidityAsset is calculated directly from the balance of `liquidityAsset` in the Balancer pool (`PoolLib.sol#331`). For function `getPoolSharesRequired`, the required BPT to be burned also depends on the current balance of `liquidityAsset` in the pool.  ## Tools Used  None  ## Recommended Mitigation Steps  Use the balance of `liquidityAsset` in the previous block to eliminate the possibility of suffering from a flash-loan attack. A time-weight average price can also mitigate the problem.  
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  Every loan has its own fundingPeriod which is set once in the constructor: fundingPeriod          = globals.fundingPeriod(); fundingPeriod in globals can change. It does not effect already deployed Loans. However, in Loan contract function unwind() calls LoanLib.unwind which checks against globals.fundingPeriod():         IGlobals globals = _globals(superFactory);         // Only callable if time has passed drawdown grace period, set in MapleGlobals         require(block.timestamp > createdAt.add(globals.fundingPeriod()), "Loan:FUNDING_PERIOD_NOT_FINISHED"); at this time, globals.fundingPeriod() could be different than this specific Loan's fundingPeriod.  ## Recommended Mitigation Steps  Check expiration against local fundingPeriod.   
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker to emit event as the balance of CollateralLocker changes after calling LoanLib.liquidateCollateral.   
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  ILoan.sol: function getNextPayment() external view returns (uint256, uint256, uint256, uint256) Loan.sol: function getNextPayment() public view returns(uint256, uint256, uint256, uint256, bool) Such discrepencies appear because implementation contracts do not inherit the interface explicitly (Loan is ILoan), so it does not give compilation errors if the declaration changes.  ## Recommended Mitigation Steps  Unify the declarations or even better, make the contract inherit from the interface so you can always be sure that these functions are present.  
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  A comment says: "It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0." However, actually, this event is always emitted (no check against 0).   ## Recommended Mitigation Steps Either emit this event if _withdrawableDividend > 0 or remove the comment.    
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  Some events have no index: - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.LossesCorrectionUpdated` - `ExtendedFDT.LossesCorrectionUpdated` - `StakeLocker.StakeDateUpdated` - `MapleTreasury.FundsTokenModified` is never used   ## Impact  Off-chain scripts that rely on these events are unable to filter them efficiently.  ## Recommended Mitigation Steps  Add the missing indexes on the events or remove the events if they are not needed on the backend.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `ChainlinkOracle.setManualPrice` function specifies that it can only be called "if manualOverride == true".  This is not the case.   ## Impact  Assume an oracle failure happened, and the oracle needs to be manually set to prevent losses. The `setManualPrice` function succeeds and the owner might think that the oracle price is overwritten as the function would fail when `manualOverride` is not `true` according to specification. The protocol would still use the broken chainlink price feed and suffer losses.  ## Recommended Mitigation Steps  Add the missing `require(manualOverride == true, "manual override not set")` check.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `UsdOracle.sol` contract states:  > UsdOracle is a constant price oracle feed that always returns 1 USD in USDC precision.  The USDC precision is 6, but the oracle returns a precision of 8, so the comment does not match the code.   ## Impact  A wrong precision on the oracle contract could lead to inflated/deflated prices.  ## Recommended Mitigation Steps  It seems that the current contract code assumes a precision of 8 instead of 6 and works correctly. Clarify if the documentation is wrong or the code needs to be updated. If further development is done and the comment is assumed to be correct, one might use 100 times the actual USDC token balance.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  There is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:   * ["if answeredInRound < roundId could indicate stale data."](https://docs.chain.link/docs/developer-communications#current-notifications)   * ["A timestamp with zero value means the round is not complete and should not be used."](https://docs.chain.link/docs/historical-price-data#solidity)   ## Impact  The price oracle might return unreliable price data which can lead to a variety of different issues in the protocol, for example, for liquidating more staker & lender tokens than required at fair market price.  ## Recommended Mitigation Steps  Add missing checks for stale data. See example [here](https://github.com/cryptexfinance/contracts/blob/master/contracts/oracles/ChainlinkOracle.sol#L58-L65).   
# Handle  a_delamo   # Vulnerability details  ## Impact  Low  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/7b51e901ac50e524369549af70ca9eeb   
# Handle  a_delamo   # Vulnerability details  ## Impact  Low, just gas optimizations  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/60973d61b49ff1f5ec83b121b33b30b1  ## Tools Used  Remix  ## Recommended Mitigation Steps  Use constant for unchanging values  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The isValidDelegateorAdmin() is used for access control on both setLiquidityCap() and claim() but the @dev Natspec comment only specifies setLiquidityCap() which is misleading.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L597  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add claim() as well to @dev on L597.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers/requires/checks is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the setAdmin() function which is accessible only by Pool Delegate.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Can only called by the pool delegate.” to @dev on L330.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Pool can call claim() and setLiquidytCap() along with the Pool Delegate. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L167 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.   require(!globals.protocolPaused(), "PoolFactory:PROTOCOL_PAUSED");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(!globals.protocolPaused(), “LoanFactory:PROTOCOL_PAUSED");   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L163-L168  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L160 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor() || admins[msg.sender], “PoolFactory:UNAUTHORIZED");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L160  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor() || admins[msg.sender], “LoanFactory:UNAUTHORIZED");  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L153 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor(), "PoolFactory:INVALID_GOVERNOR");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L153  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor(), “LoanFactory:INVALID_GOVERNOR");   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L156-L161  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L149-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in LoanFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L133-L139  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L152-L157  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L145-L150  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L138-L143  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function unpause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers unpaused state. Returns functionality for certain functions. Only Governor can call this function.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L130-L136  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L122-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidPoolDelegate() is not about pause/unpause but about msg.sender being a valid Pool Delegate, which is used to check if msg.sender can set lockup period and open staking to public in StakeLocker.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L302-L307  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidPoolDelegate().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the pull() function of StakeLocker.sol which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L125-L132  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Only Pool can call this function.” to @dev on L126.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Pool delegates are trusted actors (see https://github.com/maple-labs/maple-core/wiki/Security#trust-assumptions) and so any change (additions/removals) in their validity should be recorded for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L232-L239  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log pool delegate validity change in setPoolDelegateAllowlist function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol admin defined in MapleGlobals can pause/unpause all important functionalities of the protocol. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L148-L156  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The access control model for the different contracts and how they interact is confusing and may cause issues during deployment and maintenance. Multiple contracts have the notion of admin(s), all of which use setAdmin function to update admin status. This mirroring and reuse of the admin variable is susceptible to accidents.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L20 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L55 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L19 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L58 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L27  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Rename the different admin variables e.g. adminGlobal, adminPool, adminLoan. Document the access control roles, hierarchy and interactions explicitly.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the claim() function which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLocker.sol#L44-L54  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Only called by the pool contract.” to @dev on L45.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Loan can pause/unpause the fundLoan operation along with the borrower. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L409-L413  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LiquidityLockerFactory.sol#L19-L24  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/FundingLockerFactory.sol#L21-L26  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLockerFactory.sol#L19-L23  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  gpersoon   # Vulnerability details  ## Impact  A require statement in the function transfer in LiquidityLocker.sol contains a typo. TRASNFER should be TRANSFER  ## Proof of Concept  LiquidityLocker.sol: function transfer(address dst, uint256 amt) external isPool { LiquidityLocker.sol:    require(dst != address(0), "LiquidityLocker:NULL_TRASNFER_DST");  ## Tools Used  Editor  ## Recommended Mitigation Steps  Fix typo   
# Handle  gpersoon   # Vulnerability details  ## Impact  LoanLib.sol has a definition of enum State and Loan.sol has the same definition. The LoanLib.sol does not seem to be used This means dead code and could be confusing.  ## Proof of Concept  Loan.sol:       enum State { Ready, Active, Matured, Expired, Liquidated } LoanLib.sol:    enum State { Ready, Active, Matured, Expired, Liquidated }  ## Tools Used  grep "enum" *.sol -S  ## Recommended Mitigation Steps  Remove the unused definition from LoanLib.sol (or make sure there is just one definition for the enum and include that elsewhere)  
# Handle  JMukesh   # Vulnerability details  // All these function described should be declared  external, as functions that are never called by the contract should be declared external to save gas.                 In fundingLockerFactory.sol --> newLocker(){} In LatefeeCalc.sol          --> getlateFee(){] In Loan.sol                 --> MakeFullPayment(){} In library/Loanlib.sol      --> getNextPayment(){} In library/Util.sol         --> calcMinAmount(){} In token/BasicFDT.sol       --> withdrawnFundsOf(){} In MapleTreasury.sol        --> reclaimERC20(){}                                distributeToHolder(){}                                convertERC20(){}  In Pool.sol                 --> claimablefunds(){}                             --> BPTval(){} In Poollib,sol              --> validateDeactivation(){}                                isWithdrawAllowed(){}                                getInitialStakeRequirements(){}                                ecognizedLossesOf(){} In Premiumcal.sol            --> getPremium(){} In Repayment.sol            -->  getNextPayment(){}     
# Handle  JMukesh   # Vulnerability details  ## Impact Its impact will be limited since we will not able tract the change of address off-chain but on-chain we can which will consume gas  ## Proof of Concept In file MapleTreasury.sol has no event, so it is difficult to track off-chain changes of  Address of new MapleGlobals contract     ## Tools Used  slither  ## Recommended Mitigation Steps  add event for setting global address  
# Handle  shw   # Vulnerability details  ** Editing on a previous submission to clarify more details **  ## Impact  In `Pool.sol`, the lockup restriction of withdrawal (`Pool.sol#396`) can be bypassed or reduced if new liquidity providers cooperate with existing ones.  ## Proof of Concept  1. A liquidity provider, Alice, deposits liquidity assets into the pool and minted some FDTs. She then waits for `lockupPeriod` days and calls `intendToWithdraw` to pass her withdrawal window. Now she is available to receive FDTs from others. 2. A new liquidity provider, Bob, deposits liquidity assets into the pool and minted some FDTs. Currently, he is not allowed to withdraw his funds by protocol design. 3. Bob and Alice agree to cooperate with each other to reduce Bob's waiting time for withdrawal. Bob transfers his FDT to Alice via the `_transfer` function. 4. Alice calls `intendToWithdraw` and waits for the `withdrawCooldown` period. Notice that Alice's `depositDate` is updated after the transfer; however, since it is calculated using a weighted timestamp, the increased amount of lockup time should be less than `lockupPeriod`. In situations where the deposit from Alice is much larger than that from Bob, Alice could only even need to wait for the `withdrawCooldown` period before she could withdraw any funds. 5. Alice then withdraws the amount of FDT that Bob transferred to her and transfers the funds (liquidity assets) to Bob. Bob successfully reduces (or bypasses) the lockup period of withdrawal.  ## Tools Used  None  ## Recommended Mitigation Steps  Force users to wait for the lockup period when transferring FDT to others. Or let the `depositDate` variable record the timestamp of the last operation instead of a weighted timestamp.  
# Handle  shw   # Vulnerability details  ## Impact  In `library/PoolLib.sol`, the return value of functions `BPTVal` and `getPoolSharesRequired` are vulnerable by flash-loan attacks. The attacker can inflate the results of these two functions by swapping a large amount of `liquidityAsset` into the pool and swaps back after the functions are called to deceive the pool contract that BPT has a relatively high price.  Although currently `BPTVal` is not used and `getPoolSharesRequired` only affects the required staking amounts of token for a pool delegate, the code is vulnerable and could be misused by anyone in the future.  ## Proof of Concept  In the function `BPTVal`, the value of BPT in units of liquidityAsset is calculated directly from the balance of `liquidityAsset` in the Balancer pool (`PoolLib.sol#331`). For function `getPoolSharesRequired`, the required BPT to be burned also depends on the current balance of `liquidityAsset` in the pool.  ## Tools Used  None  ## Recommended Mitigation Steps  Use the balance of `liquidityAsset` in the previous block to eliminate the possibility of suffering from a flash-loan attack. A time-weight average price can also mitigate the problem.  
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  Every loan has its own fundingPeriod which is set once in the constructor: fundingPeriod          = globals.fundingPeriod(); fundingPeriod in globals can change. It does not effect already deployed Loans. However, in Loan contract function unwind() calls LoanLib.unwind which checks against globals.fundingPeriod():         IGlobals globals = _globals(superFactory);         // Only callable if time has passed drawdown grace period, set in MapleGlobals         require(block.timestamp > createdAt.add(globals.fundingPeriod()), "Loan:FUNDING_PERIOD_NOT_FINISHED"); at this time, globals.fundingPeriod() could be different than this specific Loan's fundingPeriod.  ## Recommended Mitigation Steps  Check expiration against local fundingPeriod.   
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker to emit event as the balance of CollateralLocker changes after calling LoanLib.liquidateCollateral.   
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  ILoan.sol: function getNextPayment() external view returns (uint256, uint256, uint256, uint256) Loan.sol: function getNextPayment() public view returns(uint256, uint256, uint256, uint256, bool) Such discrepencies appear because implementation contracts do not inherit the interface explicitly (Loan is ILoan), so it does not give compilation errors if the declaration changes.  ## Recommended Mitigation Steps  Unify the declarations or even better, make the contract inherit from the interface so you can always be sure that these functions are present.  
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  A comment says: "It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0." However, actually, this event is always emitted (no check against 0).   ## Recommended Mitigation Steps Either emit this event if _withdrawableDividend > 0 or remove the comment.    
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  Some events have no index: - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.LossesCorrectionUpdated` - `ExtendedFDT.LossesCorrectionUpdated` - `StakeLocker.StakeDateUpdated` - `MapleTreasury.FundsTokenModified` is never used   ## Impact  Off-chain scripts that rely on these events are unable to filter them efficiently.  ## Recommended Mitigation Steps  Add the missing indexes on the events or remove the events if they are not needed on the backend.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `ChainlinkOracle.setManualPrice` function specifies that it can only be called "if manualOverride == true".  This is not the case.   ## Impact  Assume an oracle failure happened, and the oracle needs to be manually set to prevent losses. The `setManualPrice` function succeeds and the owner might think that the oracle price is overwritten as the function would fail when `manualOverride` is not `true` according to specification. The protocol would still use the broken chainlink price feed and suffer losses.  ## Recommended Mitigation Steps  Add the missing `require(manualOverride == true, "manual override not set")` check.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `UsdOracle.sol` contract states:  > UsdOracle is a constant price oracle feed that always returns 1 USD in USDC precision.  The USDC precision is 6, but the oracle returns a precision of 8, so the comment does not match the code.   ## Impact  A wrong precision on the oracle contract could lead to inflated/deflated prices.  ## Recommended Mitigation Steps  It seems that the current contract code assumes a precision of 8 instead of 6 and works correctly. Clarify if the documentation is wrong or the code needs to be updated. If further development is done and the comment is assumed to be correct, one might use 100 times the actual USDC token balance.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  There is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:   * ["if answeredInRound < roundId could indicate stale data."](https://docs.chain.link/docs/developer-communications#current-notifications)   * ["A timestamp with zero value means the round is not complete and should not be used."](https://docs.chain.link/docs/historical-price-data#solidity)   ## Impact  The price oracle might return unreliable price data which can lead to a variety of different issues in the protocol, for example, for liquidating more staker & lender tokens than required at fair market price.  ## Recommended Mitigation Steps  Add missing checks for stale data. See example [here](https://github.com/cryptexfinance/contracts/blob/master/contracts/oracles/ChainlinkOracle.sol#L58-L65).   
# Handle  a_delamo   # Vulnerability details  ## Impact  Low  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/7b51e901ac50e524369549af70ca9eeb   
# Handle  a_delamo   # Vulnerability details  ## Impact  Low, just gas optimizations  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/60973d61b49ff1f5ec83b121b33b30b1  ## Tools Used  Remix  ## Recommended Mitigation Steps  Use constant for unchanging values  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The isValidDelegateorAdmin() is used for access control on both setLiquidityCap() and claim() but the @dev Natspec comment only specifies setLiquidityCap() which is misleading.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L597  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add claim() as well to @dev on L597.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers/requires/checks is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the setAdmin() function which is accessible only by Pool Delegate.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Can only called by the pool delegate.” to @dev on L330.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Pool can call claim() and setLiquidytCap() along with the Pool Delegate. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L167 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.   require(!globals.protocolPaused(), "PoolFactory:PROTOCOL_PAUSED");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(!globals.protocolPaused(), “LoanFactory:PROTOCOL_PAUSED");   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L163-L168  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L160 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor() || admins[msg.sender], “PoolFactory:UNAUTHORIZED");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L160  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor() || admins[msg.sender], “LoanFactory:UNAUTHORIZED");  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L153 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor(), "PoolFactory:INVALID_GOVERNOR");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L153  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor(), “LoanFactory:INVALID_GOVERNOR");   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L156-L161  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L149-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in LoanFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L133-L139  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L152-L157  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L145-L150  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L138-L143  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function unpause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers unpaused state. Returns functionality for certain functions. Only Governor can call this function.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L130-L136  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L122-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidPoolDelegate() is not about pause/unpause but about msg.sender being a valid Pool Delegate, which is used to check if msg.sender can set lockup period and open staking to public in StakeLocker.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L302-L307  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidPoolDelegate().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the pull() function of StakeLocker.sol which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L125-L132  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Only Pool can call this function.” to @dev on L126.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Pool delegates are trusted actors (see https://github.com/maple-labs/maple-core/wiki/Security#trust-assumptions) and so any change (additions/removals) in their validity should be recorded for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L232-L239  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log pool delegate validity change in setPoolDelegateAllowlist function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol admin defined in MapleGlobals can pause/unpause all important functionalities of the protocol. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L148-L156  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The access control model for the different contracts and how they interact is confusing and may cause issues during deployment and maintenance. Multiple contracts have the notion of admin(s), all of which use setAdmin function to update admin status. This mirroring and reuse of the admin variable is susceptible to accidents.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L20 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L55 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L19 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L58 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L27  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Rename the different admin variables e.g. adminGlobal, adminPool, adminLoan. Document the access control roles, hierarchy and interactions explicitly.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the claim() function which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLocker.sol#L44-L54  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Only called by the pool contract.” to @dev on L45.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Loan can pause/unpause the fundLoan operation along with the borrower. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L409-L413  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LiquidityLockerFactory.sol#L19-L24  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/FundingLockerFactory.sol#L21-L26  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLockerFactory.sol#L19-L23  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  gpersoon   # Vulnerability details  ## Impact  A require statement in the function transfer in LiquidityLocker.sol contains a typo. TRASNFER should be TRANSFER  ## Proof of Concept  LiquidityLocker.sol: function transfer(address dst, uint256 amt) external isPool { LiquidityLocker.sol:    require(dst != address(0), "LiquidityLocker:NULL_TRASNFER_DST");  ## Tools Used  Editor  ## Recommended Mitigation Steps  Fix typo   
# Handle  gpersoon   # Vulnerability details  ## Impact  LoanLib.sol has a definition of enum State and Loan.sol has the same definition. The LoanLib.sol does not seem to be used This means dead code and could be confusing.  ## Proof of Concept  Loan.sol:       enum State { Ready, Active, Matured, Expired, Liquidated } LoanLib.sol:    enum State { Ready, Active, Matured, Expired, Liquidated }  ## Tools Used  grep "enum" *.sol -S  ## Recommended Mitigation Steps  Remove the unused definition from LoanLib.sol (or make sure there is just one definition for the enum and include that elsewhere)  
# Handle  JMukesh   # Vulnerability details  // All these function described should be declared  external, as functions that are never called by the contract should be declared external to save gas.                 In fundingLockerFactory.sol --> newLocker(){} In LatefeeCalc.sol          --> getlateFee(){] In Loan.sol                 --> MakeFullPayment(){} In library/Loanlib.sol      --> getNextPayment(){} In library/Util.sol         --> calcMinAmount(){} In token/BasicFDT.sol       --> withdrawnFundsOf(){} In MapleTreasury.sol        --> reclaimERC20(){}                                distributeToHolder(){}                                convertERC20(){}  In Pool.sol                 --> claimablefunds(){}                             --> BPTval(){} In Poollib,sol              --> validateDeactivation(){}                                isWithdrawAllowed(){}                                getInitialStakeRequirements(){}                                ecognizedLossesOf(){} In Premiumcal.sol            --> getPremium(){} In Repayment.sol            -->  getNextPayment(){}     
# Handle  JMukesh   # Vulnerability details  ## Impact Its impact will be limited since we will not able tract the change of address off-chain but on-chain we can which will consume gas  ## Proof of Concept In file MapleTreasury.sol has no event, so it is difficult to track off-chain changes of  Address of new MapleGlobals contract     ## Tools Used  slither  ## Recommended Mitigation Steps  add event for setting global address  
# Handle  shw   # Vulnerability details  ** Editing on a previous submission to clarify more details **  ## Impact  In `Pool.sol`, the lockup restriction of withdrawal (`Pool.sol#396`) can be bypassed or reduced if new liquidity providers cooperate with existing ones.  ## Proof of Concept  1. A liquidity provider, Alice, deposits liquidity assets into the pool and minted some FDTs. She then waits for `lockupPeriod` days and calls `intendToWithdraw` to pass her withdrawal window. Now she is available to receive FDTs from others. 2. A new liquidity provider, Bob, deposits liquidity assets into the pool and minted some FDTs. Currently, he is not allowed to withdraw his funds by protocol design. 3. Bob and Alice agree to cooperate with each other to reduce Bob's waiting time for withdrawal. Bob transfers his FDT to Alice via the `_transfer` function. 4. Alice calls `intendToWithdraw` and waits for the `withdrawCooldown` period. Notice that Alice's `depositDate` is updated after the transfer; however, since it is calculated using a weighted timestamp, the increased amount of lockup time should be less than `lockupPeriod`. In situations where the deposit from Alice is much larger than that from Bob, Alice could only even need to wait for the `withdrawCooldown` period before she could withdraw any funds. 5. Alice then withdraws the amount of FDT that Bob transferred to her and transfers the funds (liquidity assets) to Bob. Bob successfully reduces (or bypasses) the lockup period of withdrawal.  ## Tools Used  None  ## Recommended Mitigation Steps  Force users to wait for the lockup period when transferring FDT to others. Or let the `depositDate` variable record the timestamp of the last operation instead of a weighted timestamp.  
# Handle  shw   # Vulnerability details  ## Impact  In `library/PoolLib.sol`, the return value of functions `BPTVal` and `getPoolSharesRequired` are vulnerable by flash-loan attacks. The attacker can inflate the results of these two functions by swapping a large amount of `liquidityAsset` into the pool and swaps back after the functions are called to deceive the pool contract that BPT has a relatively high price.  Although currently `BPTVal` is not used and `getPoolSharesRequired` only affects the required staking amounts of token for a pool delegate, the code is vulnerable and could be misused by anyone in the future.  ## Proof of Concept  In the function `BPTVal`, the value of BPT in units of liquidityAsset is calculated directly from the balance of `liquidityAsset` in the Balancer pool (`PoolLib.sol#331`). For function `getPoolSharesRequired`, the required BPT to be burned also depends on the current balance of `liquidityAsset` in the pool.  ## Tools Used  None  ## Recommended Mitigation Steps  Use the balance of `liquidityAsset` in the previous block to eliminate the possibility of suffering from a flash-loan attack. A time-weight average price can also mitigate the problem.  
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  Every loan has its own fundingPeriod which is set once in the constructor: fundingPeriod          = globals.fundingPeriod(); fundingPeriod in globals can change. It does not effect already deployed Loans. However, in Loan contract function unwind() calls LoanLib.unwind which checks against globals.fundingPeriod():         IGlobals globals = _globals(superFactory);         // Only callable if time has passed drawdown grace period, set in MapleGlobals         require(block.timestamp > createdAt.add(globals.fundingPeriod()), "Loan:FUNDING_PERIOD_NOT_FINISHED"); at this time, globals.fundingPeriod() could be different than this specific Loan's fundingPeriod.  ## Recommended Mitigation Steps  Check expiration against local fundingPeriod.   
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker to emit event as the balance of CollateralLocker changes after calling LoanLib.liquidateCollateral.   
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  ILoan.sol: function getNextPayment() external view returns (uint256, uint256, uint256, uint256) Loan.sol: function getNextPayment() public view returns(uint256, uint256, uint256, uint256, bool) Such discrepencies appear because implementation contracts do not inherit the interface explicitly (Loan is ILoan), so it does not give compilation errors if the declaration changes.  ## Recommended Mitigation Steps  Unify the declarations or even better, make the contract inherit from the interface so you can always be sure that these functions are present.  
# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  A comment says: "It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0." However, actually, this event is always emitted (no check against 0).   ## Recommended Mitigation Steps Either emit this event if _withdrawableDividend > 0 or remove the comment.    
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  Some events have no index: - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.LossesCorrectionUpdated` - `ExtendedFDT.LossesCorrectionUpdated` - `StakeLocker.StakeDateUpdated` - `MapleTreasury.FundsTokenModified` is never used   ## Impact  Off-chain scripts that rely on these events are unable to filter them efficiently.  ## Recommended Mitigation Steps  Add the missing indexes on the events or remove the events if they are not needed on the backend.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `ChainlinkOracle.setManualPrice` function specifies that it can only be called "if manualOverride == true".  This is not the case.   ## Impact  Assume an oracle failure happened, and the oracle needs to be manually set to prevent losses. The `setManualPrice` function succeeds and the owner might think that the oracle price is overwritten as the function would fail when `manualOverride` is not `true` according to specification. The protocol would still use the broken chainlink price feed and suffer losses.  ## Recommended Mitigation Steps  Add the missing `require(manualOverride == true, "manual override not set")` check.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `UsdOracle.sol` contract states:  > UsdOracle is a constant price oracle feed that always returns 1 USD in USDC precision.  The USDC precision is 6, but the oracle returns a precision of 8, so the comment does not match the code.   ## Impact  A wrong precision on the oracle contract could lead to inflated/deflated prices.  ## Recommended Mitigation Steps  It seems that the current contract code assumes a precision of 8 instead of 6 and works correctly. Clarify if the documentation is wrong or the code needs to be updated. If further development is done and the comment is assumed to be correct, one might use 100 times the actual USDC token balance.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  There is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:   * ["if answeredInRound < roundId could indicate stale data."](https://docs.chain.link/docs/developer-communications#current-notifications)   * ["A timestamp with zero value means the round is not complete and should not be used."](https://docs.chain.link/docs/historical-price-data#solidity)   ## Impact  The price oracle might return unreliable price data which can lead to a variety of different issues in the protocol, for example, for liquidating more staker & lender tokens than required at fair market price.  ## Recommended Mitigation Steps  Add missing checks for stale data. See example [here](https://github.com/cryptexfinance/contracts/blob/master/contracts/oracles/ChainlinkOracle.sol#L58-L65).   
# Handle  a_delamo   # Vulnerability details  ## Impact  Low  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/7b51e901ac50e524369549af70ca9eeb   
# Handle  a_delamo   # Vulnerability details  ## Impact  Low, just gas optimizations  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/60973d61b49ff1f5ec83b121b33b30b1  ## Tools Used  Remix  ## Recommended Mitigation Steps  Use constant for unchanging values  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The isValidDelegateorAdmin() is used for access control on both setLiquidityCap() and claim() but the @dev Natspec comment only specifies setLiquidityCap() which is misleading.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L597  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add claim() as well to @dev on L597.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers/requires/checks is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the setAdmin() function which is accessible only by Pool Delegate.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Can only called by the pool delegate.” to @dev on L330.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Pool can call claim() and setLiquidytCap() along with the Pool Delegate. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L167 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.   require(!globals.protocolPaused(), "PoolFactory:PROTOCOL_PAUSED");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(!globals.protocolPaused(), “LoanFactory:PROTOCOL_PAUSED");   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L163-L168  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L160 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor() || admins[msg.sender], “PoolFactory:UNAUTHORIZED");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L160  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor() || admins[msg.sender], “LoanFactory:UNAUTHORIZED");  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L153 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor(), "PoolFactory:INVALID_GOVERNOR");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L153  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor(), “LoanFactory:INVALID_GOVERNOR");   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L156-L161  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in LoanFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L149-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in LoanFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L133-L139  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function whenProtocolNotPaused() is not about msg.sender eligibility to pause/unpause but about checking if protocol is unpaused or not in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L152-L157  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _whenProtocolNotPaused().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernorOrAdmin() is not about pause/unpause but about msg.sender being valid Governor or Admin, which is used by pause()/unpause() in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L145-L150  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernororAdmin().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidGovernor() is not about pause/unpause but about msg.sender being valid Governor, which is used by setAdmin/setGlobals in PoolFactory.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L138-L143  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidGovernor().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function unpause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers unpaused state. Returns functionality for certain functions. Only Governor can call this function.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L130-L136  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L122-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function _isValidPoolDelegate() is not about pause/unpause but about msg.sender being a valid Pool Delegate, which is used to check if msg.sender can set lockup period and open staking to public in StakeLocker.sol.  Therefore, the Natspec comment for this function is incorrect: @dev Function to determine if msg.sender is eligible to trigger pause/unpause.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L302-L307  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate the functionality of _isValidPoolDelegate().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the pull() function of StakeLocker.sol which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L125-L132  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Only Pool can call this function.” to @dev on L126.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Pool delegates are trusted actors (see https://github.com/maple-labs/maple-core/wiki/Security#trust-assumptions) and so any change (additions/removals) in their validity should be recorded for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L232-L239  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log pool delegate validity change in setPoolDelegateAllowlist function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol admin defined in MapleGlobals can pause/unpause all important functionalities of the protocol. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L148-L156  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The access control model for the different contracts and how they interact is confusing and may cause issues during deployment and maintenance. Multiple contracts have the notion of admin(s), all of which use setAdmin function to update admin status. This mirroring and reuse of the admin variable is susceptible to accidents.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L20 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L55 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L19 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L58 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L27  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Rename the different admin variables e.g. adminGlobal, adminPool, adminLoan. Document the access control roles, hierarchy and interactions explicitly.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the claim() function which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLocker.sol#L44-L54  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add “Only called by the pool contract.” to @dev on L45.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Loan can pause/unpause the fundLoan operation along with the borrower. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L409-L413  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LiquidityLockerFactory.sol#L19-L24  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/FundingLockerFactory.sol#L21-L26  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLockerFactory.sol#L19-L23  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   
# Handle  gpersoon   # Vulnerability details  ## Impact  A require statement in the function transfer in LiquidityLocker.sol contains a typo. TRASNFER should be TRANSFER  ## Proof of Concept  LiquidityLocker.sol: function transfer(address dst, uint256 amt) external isPool { LiquidityLocker.sol:    require(dst != address(0), "LiquidityLocker:NULL_TRASNFER_DST");  ## Tools Used  Editor  ## Recommended Mitigation Steps  Fix typo   
# Handle  gpersoon   # Vulnerability details  ## Impact  LoanLib.sol has a definition of enum State and Loan.sol has the same definition. The LoanLib.sol does not seem to be used This means dead code and could be confusing.  ## Proof of Concept  Loan.sol:       enum State { Ready, Active, Matured, Expired, Liquidated } LoanLib.sol:    enum State { Ready, Active, Matured, Expired, Liquidated }  ## Tools Used  grep "enum" *.sol -S  ## Recommended Mitigation Steps  Remove the unused definition from LoanLib.sol (or make sure there is just one definition for the enum and include that elsewhere)  
# Handle  JMukesh   # Vulnerability details  // All these function described should be declared  external, as functions that are never called by the contract should be declared external to save gas.                 In fundingLockerFactory.sol --> newLocker(){} In LatefeeCalc.sol          --> getlateFee(){] In Loan.sol                 --> MakeFullPayment(){} In library/Loanlib.sol      --> getNextPayment(){} In library/Util.sol         --> calcMinAmount(){} In token/BasicFDT.sol       --> withdrawnFundsOf(){} In MapleTreasury.sol        --> reclaimERC20(){}                                distributeToHolder(){}                                convertERC20(){}  In Pool.sol                 --> claimablefunds(){}                             --> BPTval(){} In Poollib,sol              --> validateDeactivation(){}                                isWithdrawAllowed(){}                                getInitialStakeRequirements(){}                                ecognizedLossesOf(){} In Premiumcal.sol            --> getPremium(){} In Repayment.sol            -->  getNextPayment(){}     
# Handle  JMukesh   # Vulnerability details  ## Impact Its impact will be limited since we will not able tract the change of address off-chain but on-chain we can which will consume gas  ## Proof of Concept In file MapleTreasury.sol has no event, so it is difficult to track off-chain changes of  Address of new MapleGlobals contract     ## Tools Used  slither  ## Recommended Mitigation Steps  add event for setting global address  
