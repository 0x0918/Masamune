**Redundant greater than 0 checks for uint** When executing pool weight changes in `InflationManager.sol` ([_executeKeeperPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575), [_executeLpPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589), [_executeAmmTokenWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)), corresponding total pool weights `x` are `unsigned int`. As they can't only be `x >= 0`, the expression `x>0 ? x : 0` does nothing.   **Sensible changes, such as adding a Governor should be a two-step process** [`addGovernance`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L41) directly grants `Roles.GOVERNANCE` to the `newGovernor`. It should be a two-step process (*e.g. [setGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#setgovernance)-[acceptGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#acceptgovernance)*) to ensure the input address is correct. Whilst `renounceGovernance` checks that there is at least one Governor left, in a single-Governor scenario, back to back execution of `addGovernance` with an incorrect address followed by `renounceGovernance` will render the protocol ungovernable. Additionally, as there is no way to revoke this role, granting governance to an address means that address will have complete control over the protocol forever after.  **Requirement uses external call to user-controlled address in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** `require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0");` makes an external call to `oldPoolAddress_`, which is a user-controlled address. It could be a malicious contract, thus reporting any result needed to bypass the guard.  **Erring on the safe side for reentrancy in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** While I did not manage to exploit it in any way - I'd recommend against not including a `nonReentrant` guard in this function. `oldPoolAddress_` could be a malicious contract thus enabling multiple calls to `migrate` spanning from the external calls to `oldPool` or `lpToken_`.   **Recommended missing events** Modifying key protocol variables or triggering key events should always emit events accordingly to ensure transparency and proper traceability.  - [`Minter.sol`]( https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol): *setToken, startInflation,  executeInflationRateUpdate* - [`BkdLocker.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol): *migrate* - [`Controller.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol): *setInflationManager* - [`AmmGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol): *kill* - [`KeeperGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol): *kill, advanceEpoch, reportFees, poolCheckpoint* - [`InflationManager.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol): *deactivateWeightBasedKeeperDistribution, checkpointAllGauges* - [`VestedEscrow.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol): *setAdmin, setFundAdmin, initializeUnallocatedSupply*
