# Handle  hyh   # Vulnerability details   ## Impact  Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.  ## Proof of Concept  3 types of mint/burn: NFT, Fungible and Synths. Synths are most vilnerable as they do not have share: LP own the pool, so Synth's funds are lost in scenarios similar to: 1. LP deposit both sides to a pool 2. Synth deposit and mint a Synth 3. LP withdraws all as she owns all the pool liquidity, even when provided only part of it 4. Synth can't withdraw as no assets left  burn NFT LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L270  burn fungible LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L374  ## Recommended Mitigation Steps  Take into account liquidity that was provided by Synth minting.  
# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter.calculateOutGivenIn` is supposed to first swap **foreign** assets to native assets **in pool0**, and then the received native assets to different foreign assets again **in pool1**.  The first argument of `VaderMath.calculateSwap(amountIn, reserveIn, reserveOut)` must refer to the same token as the second argument `reserveIn`. The code however mixes these positions up and first performs a swap in `pool1` instead of `pool0`:  ```solidity function calculateOutGivenIn(uint256 amountIn, address[] calldata path)     external     view     returns (uint256 amountOut) {   if(...) {   } else {     return         VaderMath.calculateSwap(             VaderMath.calculateSwap(                 // @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0                 amountIn,                 nativeReserve1,                 foreignReserve1             ),             foreignReserve0,             nativeReserve0         );   }   /** @audit instead should first be trading in pool0!     VaderMath.calculateSwap(         VaderMath.calculateSwap(             amountIn,             foreignReserve0,             nativeReserve0         ),         nativeReserve1,         foreignReserve1     );   */ ```  ## Impact All 3-path swaps computations through `VaderRouter.calculateOutGivenIn` will return the wrong result. Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.  ## Recommended Mitigation Steps Return the following code instead which first trades in pool0 and then in pool1:  ```solidity return   VaderMath.calculateSwap(       VaderMath.calculateSwap(           amountIn,           foreignReserve0,           nativeReserve0       ),       nativeReserve1,       foreignReserve1   ); ```   
# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter._swap` is supposed to first swap **foreign** assets to native assets, and then the received native assets to different foreign assets again.  The `pool.swap(nativeAmountIn, foreignAmountIn)` accepts the foreign amount as the **second** argument. The code however mixes these positional arguments up and tries to perform a `pool0` foreign -> native swap by using the **foreign** amount as the **native amount**:  ```solidity function _swap(     uint256 amountIn,     address[] calldata path,     address to ) private returns (uint256 amountOut) {     if (path.length == 3) {       // ...       // @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)       return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);     } }  // @audit should be this instead return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to); ```  ## Impact All 3-path swaps through the `VaderRouter` fail in the pool check when `require(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)` is checked, as foreign amount is sent but _native_ amount is specified.  ## Recommended Mitigation Steps Use `return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);` instead.  
# Handle  hyh   # Vulnerability details   ## Impact  Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.  ## Proof of Concept  3 types of mint/burn: NFT, Fungible and Synths. Synths are most vilnerable as they do not have share: LP own the pool, so Synth's funds are lost in scenarios similar to: 1. LP deposit both sides to a pool 2. Synth deposit and mint a Synth 3. LP withdraws all as she owns all the pool liquidity, even when provided only part of it 4. Synth can't withdraw as no assets left  burn NFT LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L270  burn fungible LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L374  ## Recommended Mitigation Steps  Take into account liquidity that was provided by Synth minting.  
# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter.calculateOutGivenIn` is supposed to first swap **foreign** assets to native assets **in pool0**, and then the received native assets to different foreign assets again **in pool1**.  The first argument of `VaderMath.calculateSwap(amountIn, reserveIn, reserveOut)` must refer to the same token as the second argument `reserveIn`. The code however mixes these positions up and first performs a swap in `pool1` instead of `pool0`:  ```solidity function calculateOutGivenIn(uint256 amountIn, address[] calldata path)     external     view     returns (uint256 amountOut) {   if(...) {   } else {     return         VaderMath.calculateSwap(             VaderMath.calculateSwap(                 // @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0                 amountIn,                 nativeReserve1,                 foreignReserve1             ),             foreignReserve0,             nativeReserve0         );   }   /** @audit instead should first be trading in pool0!     VaderMath.calculateSwap(         VaderMath.calculateSwap(             amountIn,             foreignReserve0,             nativeReserve0         ),         nativeReserve1,         foreignReserve1     );   */ ```  ## Impact All 3-path swaps computations through `VaderRouter.calculateOutGivenIn` will return the wrong result. Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.  ## Recommended Mitigation Steps Return the following code instead which first trades in pool0 and then in pool1:  ```solidity return   VaderMath.calculateSwap(       VaderMath.calculateSwap(           amountIn,           foreignReserve0,           nativeReserve0       ),       nativeReserve1,       foreignReserve1   ); ```   
# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter._swap` is supposed to first swap **foreign** assets to native assets, and then the received native assets to different foreign assets again.  The `pool.swap(nativeAmountIn, foreignAmountIn)` accepts the foreign amount as the **second** argument. The code however mixes these positional arguments up and tries to perform a `pool0` foreign -> native swap by using the **foreign** amount as the **native amount**:  ```solidity function _swap(     uint256 amountIn,     address[] calldata path,     address to ) private returns (uint256 amountOut) {     if (path.length == 3) {       // ...       // @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)       return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);     } }  // @audit should be this instead return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to); ```  ## Impact All 3-path swaps through the `VaderRouter` fail in the pool check when `require(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)` is checked, as foreign amount is sent but _native_ amount is specified.  ## Recommended Mitigation Steps Use `return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);` instead.  
# Handle  hyh   # Vulnerability details   ## Impact  Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.  ## Proof of Concept  3 types of mint/burn: NFT, Fungible and Synths. Synths are most vilnerable as they do not have share: LP own the pool, so Synth's funds are lost in scenarios similar to: 1. LP deposit both sides to a pool 2. Synth deposit and mint a Synth 3. LP withdraws all as she owns all the pool liquidity, even when provided only part of it 4. Synth can't withdraw as no assets left  burn NFT LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L270  burn fungible LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L374  ## Recommended Mitigation Steps  Take into account liquidity that was provided by Synth minting.  
# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter.calculateOutGivenIn` is supposed to first swap **foreign** assets to native assets **in pool0**, and then the received native assets to different foreign assets again **in pool1**.  The first argument of `VaderMath.calculateSwap(amountIn, reserveIn, reserveOut)` must refer to the same token as the second argument `reserveIn`. The code however mixes these positions up and first performs a swap in `pool1` instead of `pool0`:  ```solidity function calculateOutGivenIn(uint256 amountIn, address[] calldata path)     external     view     returns (uint256 amountOut) {   if(...) {   } else {     return         VaderMath.calculateSwap(             VaderMath.calculateSwap(                 // @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0                 amountIn,                 nativeReserve1,                 foreignReserve1             ),             foreignReserve0,             nativeReserve0         );   }   /** @audit instead should first be trading in pool0!     VaderMath.calculateSwap(         VaderMath.calculateSwap(             amountIn,             foreignReserve0,             nativeReserve0         ),         nativeReserve1,         foreignReserve1     );   */ ```  ## Impact All 3-path swaps computations through `VaderRouter.calculateOutGivenIn` will return the wrong result. Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.  ## Recommended Mitigation Steps Return the following code instead which first trades in pool0 and then in pool1:  ```solidity return   VaderMath.calculateSwap(       VaderMath.calculateSwap(           amountIn,           foreignReserve0,           nativeReserve0       ),       nativeReserve1,       foreignReserve1   ); ```   
# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter._swap` is supposed to first swap **foreign** assets to native assets, and then the received native assets to different foreign assets again.  The `pool.swap(nativeAmountIn, foreignAmountIn)` accepts the foreign amount as the **second** argument. The code however mixes these positional arguments up and tries to perform a `pool0` foreign -> native swap by using the **foreign** amount as the **native amount**:  ```solidity function _swap(     uint256 amountIn,     address[] calldata path,     address to ) private returns (uint256 amountOut) {     if (path.length == 3) {       // ...       // @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)       return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);     } }  // @audit should be this instead return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to); ```  ## Impact All 3-path swaps through the `VaderRouter` fail in the pool check when `require(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)` is checked, as foreign amount is sent but _native_ amount is specified.  ## Recommended Mitigation Steps Use `return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);` instead.  
