# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134   # Vulnerability details  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTime = unlockInWeeks; } ```  In `_lockCurve()`, `unlockInWeeks - unlockTime` is being used as a number in weeks, while it actually is a number in seconds.  Thus, comparing it with `2` actually means a 2 seconds buffer instead of a 2 weeks buffer.  The intention is to wait for 2 weeks before extending the lock time again, but the current implementation allows the extension of the lock once a new week begins.  ### Recommendation  Consider changing the name of `unlockTime` to `unlockTimeInWeeks`, and:  1. Change L94-102 to:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L94-L102  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //release old lock if exists IStaker(staker).release(); //create new lock uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker); IStaker(staker).createLock(crvBalanceStaker, unlockAt); unlockTimeInWeeks = unlockInWeeks; ```  2. Change L127-L134 to:  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTimeInWeeks = unlockInWeeks; } ```  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250   # Vulnerability details  Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.  Setting the severity to medium as this is conditional to transfer flow control assumption, but the impact is the full loss of contract reward token holdings.  ## Proof of Concept  Both withdraw() and deposit() have the issue, performing late accounting update and not controlling for reentrancy:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221  ```solidity     function deposit(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         updatePool(_pid);         if (user.amount > 0) {             uint256 pending = user                 .amount                 .mul(pool.accCvxPerShare)                 .div(1e12)                 .sub(user.rewardDebt);             safeRewardTransfer(msg.sender, pending);         }         pool.lpToken.safeTransferFrom( ```  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250  ```solidity     function withdraw(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         require(user.amount >= _amount, "withdraw: not good");         updatePool(_pid);         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(             user.rewardDebt         );         safeRewardTransfer(msg.sender, pending);         user.amount = user.amount.sub(_amount);         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);         pool.lpToken.safeTransfer(address(msg.sender), _amount); ```  ## Recommended Mitigation Steps  Consider adding a direct reentrancy control, e.g. nonReentrant modifier:  https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard  Also, consider finishing all internal state updates prior to external calls:  https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/#pitfalls-in-reentrancy-solutions  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L176-L177 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L802-L814 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L864   # Vulnerability details  ## Impact  There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.  The impact of this overflow is that all reward tokens will be permanently locked in the contract. User's will be unable to call any of the functions which have the `updateReward()` modifier, that is:  - `lock()` - `getReward()` - `_processExpiredLocks()` - `_notifyReward()`  As a result the contract will need to call `shutdown()` and the users will only be able to receive their staked tokens via `emergencyWithdraw()`, which does not transfer the users the reward tokens.  Note that if one reward token overflows this will cause a revert on all reward tokens due to the loop over reward tokens.  ## Proof of Concept  The overflow may occur due to the base of values in `_rewardPerToken()`.   ```solidity     function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {         if (lockedSupply == 0) {             return rewardData[_rewardsToken].rewardPerTokenStored;         }         return             uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(                 _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)                     .sub(rewardData[_rewardsToken].lastUpdateTime)                     .mul(rewardData[_rewardsToken].rewardRate)                     .mul(1e18)                     .div(lockedSupply)             );     } ```  The return value of `_rewardPerToken()` is in terms of  ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply ```  Here `(now - lastUpdateTime)` has a maximum value of `rewardDuration = 6 * 10**5`.  Now `rewardRate` is the `_reward.div(rewardsDuration)` as seen in `_notifyRewardAmount()` on line #864. Note that `rewardDuration` is a constant 604,800.  `rewardDuration = 6 * 10**5`   Thus, if we have a rewards such as AURA or WETH (or most ERC20 tokens) which have units 10**18 we can transfer 1 WETH to the reward distributor which calls `_notifyRewardAmount()` and  sets the reward rate to,  `rewardRate = 10**18 / (6 * 10**5) ~= 10**12`  Finally, if this attack is run either by the first depositor they may `lock()` a single token which would set `totalSupply = 1`.  Therefore our equation in terms of units will become, ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply => 10**5 * 10**12 * 10**18 / 1 = 10**35 ```  In since `rewardPerTokenStored` is a `uint96` it has a maximum value of `2**96 ~= 7.9 * 10**28`. Hence there will be an overflow in `newRewardPerToken.to96()`. Since we are unable to add more total supply due to `lock()` reverting there will be no way to circumvent this revert except to `shutdown()`.  ```solidity                 uint256 newRewardPerToken = _rewardPerToken(token);                 rewardData[token].rewardPerTokenStored = newRewardPerToken.to96(); ```  Note this attack is described when we have a low `totalSupply`. However it is also possible to apply this attack on a larger `totalSupply` when there are reward tokens which have decimal places larger than 18 or tokens which such as SHIB which have small token value and so many of the tokens can be bought for cheap.   ## Recommended Mitigation Steps  To mitigation this issue it is recommended to increase the size of the `rewardPerTokenStored`. Since updating this value will require another slot to be used we recommend updating this to either `uint256` or to update both `rewardRate` and `rewardPerTokenStored` to be `uint224`.  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/convex-platform/contracts/contracts/ConvexMasterChef.sol#L178-L183   # Vulnerability details  ## Impact massUpdatePools() is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.  ## Proof of Concept https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-block-gas-limit  ## Tools Used Manual analysis  ## Recommended Mitigation Steps I suggest to limit the max number of loop iterations to prevent hitting block gas limit.   
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L404   # Vulnerability details  The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch. A comment in this section mentions `"wont have the exact reward rate that you would get if looped through"`. However, there's no reason not to multiply *user's whole locked balance* by the number of epochs since the *last lock's* unlock time, *instead of only the last locked amount*. While this will still not be as accurate as looping through, this will give a more accurate kick reward result, which is still bounded by the full amount that would have been calculated if we had looped through.  ## Impact The reward calculation is inaccurate and lacking for no reason. Kickers receive less rewards than they should. Giving them a bigger, more accurate reward, will incentivize them better.  ## Proof of Concept [This](https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L396:#L405) is the section that calculates the kick reward if all locks have expired: ```             //check for kick reward             //this wont have the exact reward rate that you would get if looped through             //but this section is supposed to be for quick and easy low gas processing of all locks             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch             if (_checkDelay > 0) {                 uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                 uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);                 uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                 reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);             } ``` This flow is for low gas processing, so the function is not looping through all the locks (unlike the flow where some locks have not expired yet). In this flow, the function is just calculating the reward for the last lock.  Instead of doing this, it can multiply the *total amount locked by the user* (`locked`, already saved) by the *number of epochs between the last unlock time and current epoch*. The reward will still be smaller than if we had looped through all the rewards (since then each lock amount would be multiplied by more than just the last lock's number of expired epochs). But it would be more accurate and give better incentive for kicking.   ## Recommended Mitigation Steps Change the last line in the code above to: ```                 reward = uint256(locked).mul(rRate).div(denominator); ``` This will keep the low gas consumption of this flow, while giving a more accurate result.  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118   # Vulnerability details  ## Impact In the ConvexMasterChef contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (cvx) or not. ```   function add(       uint256 _allocPoint,       IERC20 _lpToken,       IRewarder _rewarder,       bool _withUpdate   ) public onlyOwner {       if (_withUpdate) {           massUpdatePools();       }       uint256 lastRewardBlock = block.number > startBlock           ? block.number           : startBlock;       totalAllocPoint = totalAllocPoint.add(_allocPoint);       poolInfo.push(           PoolInfo({               lpToken: _lpToken,               allocPoint: _allocPoint,               lastRewardBlock: lastRewardBlock,               accCvxPerShare: 0,               rewarder: _rewarder           })       );   } ``` When the _lpToken is the same token as cvx, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```   function updatePool(uint256 _pid) public {       PoolInfo storage pool = poolInfo[_pid];       if (block.number <= pool.lastRewardBlock) {           return;       }       uint256 lpSupply = pool.lpToken.balanceOf(address(this));       if (lpSupply == 0) {           pool.lastRewardBlock = block.number;           return;       }       uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);       uint256 cvxReward = multiplier           .mul(rewardPerBlock)           .mul(pool.allocPoint)           .div(totalAllocPoint);       //cvx.mint(address(this), cvxReward);       pool.accCvxPerShare = pool.accCvxPerShare.add(           cvxReward.mul(1e12).div(lpSupply)       );       pool.lastRewardBlock = block.number;   } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L186-L206 ## Tools Used None ## Recommended Mitigation Steps Add a check that _lpToken is not cvx in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138   # Vulnerability details  ## Impact Same as IDX-003 in https://public-stg.inspex.co/report/Inspex_AUDIT2021024_LuckyLion_Farm_FullReport_v2.0.pdf The totalAllocPoint variable is used to determine the portion that each pool would get from the total reward, so it is one of the main factors used in the rewards calculation. Therefore, whenever the totalAllocPoint variable is modified without updating the pending reward first, the reward of each pool will be incorrectly calculated. For example, when  _withUpdate is false, in the add() shown below, the totalAllocPoint variable will be modified without updating the rewards (massUpdatePools()). ```     function add(         uint256 _allocPoint,         IERC20 _lpToken,         IRewarder _rewarder,         bool _withUpdate     ) public onlyOwner {         if (_withUpdate) {             massUpdatePools();         }         uint256 lastRewardBlock = block.number > startBlock             ? block.number             : startBlock;         totalAllocPoint = totalAllocPoint.add(_allocPoint);         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accCvxPerShare: 0,                 rewarder: _rewarder             })         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138 ## Tools Used None ## Recommended Mitigation Steps Removing the _withUpdate variable in the add() and set() functions and always calling the massUpdatePools() function before updating totalAllocPoint variable  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L56-L65   # Vulnerability details  ## Impact Unpredictable slippage, sandwich vulnerability or frequent failed transactions  ## Proof of Concept CrvDepostiorWrapper uses the TWAP provided by the 20/80 WETH/BAL. The issue is that this pool has only handled ~15 transactions per day in the last 30 days, which means that the oracle frequently goes more than an hour without updating. Each time a state changing operation is called, the following code in the balancer pool takes a snapshot of the pool state BEFORE any operation changes it:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/80e1a5db7439069e2cb53e228bce0a8a51f5b23e/pkg/pool-weighted/contracts/oracle/OracleWeightedPool.sol#L156-L161  This could result in the price of the oracle frequently not reflecting the true value of the assets due to infrequency of update. Now also consider that the pool has a trading fee of 2%. Combine an inaccurate oracle with a high fee pool and trades can exhibit high levels of "slippage". To account for this outputBps in AuraStakingProxy needs to be set relatively low or risks frequent failed transactions when calling distribute due to slippage conditions not being met. The lower outputBps is set the more vulnerable distribute becomes to sandwich attacks.   ## Tools Used  ## Recommended Mitigation Steps Consider using chainlink oracles for both BAL and ETH to a realtime estimate of the LP value. A chainlink LP oracle implementation can be found in the link below: https://blog.alphaventuredao.io/fair-lp-token-pricing/  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraClaimZap.sol#L224-L226   # Vulnerability details  ## Impact It was observed that User will lose funds due to missing else condition  ## Proof of Concept  1. User call claimRewards at ClaimZap.sol#L103 with Options.LockCvx as false 2. claimRewards internally calls _claimExtras 3. Everything goes good until AuraClaimZap.sol#L218  ``` if (depositCvxMaxAmount > 0) {             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);             if (cvxBalance > 0) {                 //pull cvx                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                 if (_checkOption(options, uint256(Options.LockCvx))) {                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                 }             }         } ```  4. Since user cvxBalance>0 so cvxBalance is transferred from user to the contract. 5. Now since Options.LockCvx was set to false in options so if (_checkOption(options, uint256(Options.LockCvx))) does not evaluate to true and does not execute 6. This means User cvx funds are stuck in contract  ## Recommended Mitigation Steps The condition should check if user has enabled lock for cvx, otherwise cvx should not be transferred from user  ``` if (depositCvxMaxAmount > 0 && _checkOption(options, uint256(Options.LockCvx))) {           uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);           cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);           if (cvxBalance > 0) {               //pull cvx               IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                    IAuraLocker(locker).lock(msg.sender, cvxBalance);           }       } ```  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/ExtraRewardsDistributor.sol#L127   # Vulnerability details  ## Impact User can forfeit other user rewards by giving a higher _startIndex in getReward function  ## Proof of Concept 1. Assume User B has not received any reward yet so that his userClaims[_token][User B]=0 2. User A calls getReward function with _account as User B and _startIndex as 5 3. This eventually calls _allClaimableRewards at ExtraRewardsDistributor.sol#L213 which computes epochIndex =5>0?5:0 = 5 4. Assuming tokenEpochs is 10 and latestEpoch is 8, so reward will computed from epoch 5 till epoch index 7 and _allClaimableRewards will return index as 7 5. _getReward will simply update userClaims[_token][User B] with 7  6. This is incorrect because as per contract User B has received reward from epoch 0-7 even though he only received reward for epoch 5-7   ## Recommended Mitigation Steps Do not allow users to call getReward function for other users  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82   # Vulnerability details  ## Impact In `Aura.sol` the `updateOperator()` function can be called by anyone and it sets a new `operator` based on the address returned from `IStaker(vecrvProxy).operator()`.  The problem is that anyone can call this function even if the operator on `vecrvProxy` is not yet set.  If this is the case the operator in `Aura.sol` would be set to a zero address breaking the contract since functions like `init()` and `mint()` rely on the `msg.sender` being the `operator`. Even the `minterMint()` function relies on the `operator` since only the operator can set the `minter` which is the only one who can call `minterMinter()`.   ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `updateOperator()` function should not be a public function and should only be callable by an admin or the `operator` inside `Aura.sol`.  Also in the `updateOperator()` function,  there should be a check ensuring that the `newOperator` address is not a zero address to prevent breaking the contract by setting the `operator` to a zero address.   
# Lines of code  https://github.com/aurafinance/convex-platform/blob/9cae5eb5a77e73bbc1378ef213740c1889e2e8a3/contracts/contracts/BaseRewardPool4626.sol   # Vulnerability details  ## Impact   BaseRewardPool4626 is not IERC4626 compliant. This makes the BaseRewardPool4626 contract irrelevant as it is for now since projects won't be able to integrate with BaseRewardPool4626 using the[eip-4626](https://eips.ethereum.org/EIPS/eip-4626) standard.   ## Suggestion  You can choose to remove the BaseRewardPool4626 and save on some deployment gas or review the necessary` functions` and `emits` required on [eip-4626](https://eips.ethereum.org/EIPS/eip-4626)  and add it to BaseRewardPool4626.   
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/CrvDepositorWrapper.sol#L9 https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraStakingProxy.sol#L10   # Vulnerability details  ## Impact If a codebase has two contracts with the same names, the compilation artifacts will not contain one of the contracts.  `ICrvDepositor` exists in both `AuraStakingProxy` and `CrvDepositorWrapper`  ## Tools Manual Review   ## Recommended Mitigation Steps Move the contract to an interface file and import it or if the interface differs rename one of the contracts.  
The `amount should be greater than 0` is not checked by the `_addReward` function.  ## Permalink: https://github.com/code-423n4/2022-05-aura/blob/c332f8c23e12b3bb678f018682c7609df9c77ed9/contracts/ExtraRewardsDistributor.sol#L87  ## Recommendation: Can Add Require Statement to check _amount is greater than 0.
# Lines of code  https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848   # Vulnerability details    Rewards distribution can be delayed/never distributed on [AuraLocker.sol#L848 ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848)   ### Issue  Someone malicious can delay the rewards distribution for non `cvxCrv` tokens distributed on AuraLocker.sol.   1: Attacker will send one wei of token that are distributed on the [AuraLocker.sol ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol) to [AuraStakingProxy](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol).  2: Attacker will call [distributeOther](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol#L203). The function will call notifyRewardAmount that calls [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860)   When calling [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860) the rewards left to distribute over the 7 days are redistributed throughout a new period starting immediately.  ``` uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp); uint256 leftover = remaining.mul(rdata.rewardRate); rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96(); ```  _Example:_ If the reward rate is 1 token (10**18) per second and 3.5 days are left (302400 seconds), we get a leftover of 302400 tokens. this is then divided by 604800, the reward rate is now 0.5 and the user of the protocol will have to wait one week for tokens that were supposed to be distributed over 3.5 days. This can be repeated again and again so that some rewards are never distributed.    ### Suggestion I can see that [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820) has some protective mechanism. A new period is started only if the token that is added on top of the already distributed tokens during the duration is over 120%.  I suggest adding a similar check to [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820)   
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134   # Vulnerability details  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTime = unlockInWeeks; } ```  In `_lockCurve()`, `unlockInWeeks - unlockTime` is being used as a number in weeks, while it actually is a number in seconds.  Thus, comparing it with `2` actually means a 2 seconds buffer instead of a 2 weeks buffer.  The intention is to wait for 2 weeks before extending the lock time again, but the current implementation allows the extension of the lock once a new week begins.  ### Recommendation  Consider changing the name of `unlockTime` to `unlockTimeInWeeks`, and:  1. Change L94-102 to:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L94-L102  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //release old lock if exists IStaker(staker).release(); //create new lock uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker); IStaker(staker).createLock(crvBalanceStaker, unlockAt); unlockTimeInWeeks = unlockInWeeks; ```  2. Change L127-L134 to:  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTimeInWeeks = unlockInWeeks; } ```  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250   # Vulnerability details  Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.  Setting the severity to medium as this is conditional to transfer flow control assumption, but the impact is the full loss of contract reward token holdings.  ## Proof of Concept  Both withdraw() and deposit() have the issue, performing late accounting update and not controlling for reentrancy:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221  ```solidity     function deposit(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         updatePool(_pid);         if (user.amount > 0) {             uint256 pending = user                 .amount                 .mul(pool.accCvxPerShare)                 .div(1e12)                 .sub(user.rewardDebt);             safeRewardTransfer(msg.sender, pending);         }         pool.lpToken.safeTransferFrom( ```  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250  ```solidity     function withdraw(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         require(user.amount >= _amount, "withdraw: not good");         updatePool(_pid);         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(             user.rewardDebt         );         safeRewardTransfer(msg.sender, pending);         user.amount = user.amount.sub(_amount);         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);         pool.lpToken.safeTransfer(address(msg.sender), _amount); ```  ## Recommended Mitigation Steps  Consider adding a direct reentrancy control, e.g. nonReentrant modifier:  https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard  Also, consider finishing all internal state updates prior to external calls:  https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/#pitfalls-in-reentrancy-solutions  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L176-L177 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L802-L814 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L864   # Vulnerability details  ## Impact  There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.  The impact of this overflow is that all reward tokens will be permanently locked in the contract. User's will be unable to call any of the functions which have the `updateReward()` modifier, that is:  - `lock()` - `getReward()` - `_processExpiredLocks()` - `_notifyReward()`  As a result the contract will need to call `shutdown()` and the users will only be able to receive their staked tokens via `emergencyWithdraw()`, which does not transfer the users the reward tokens.  Note that if one reward token overflows this will cause a revert on all reward tokens due to the loop over reward tokens.  ## Proof of Concept  The overflow may occur due to the base of values in `_rewardPerToken()`.   ```solidity     function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {         if (lockedSupply == 0) {             return rewardData[_rewardsToken].rewardPerTokenStored;         }         return             uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(                 _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)                     .sub(rewardData[_rewardsToken].lastUpdateTime)                     .mul(rewardData[_rewardsToken].rewardRate)                     .mul(1e18)                     .div(lockedSupply)             );     } ```  The return value of `_rewardPerToken()` is in terms of  ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply ```  Here `(now - lastUpdateTime)` has a maximum value of `rewardDuration = 6 * 10**5`.  Now `rewardRate` is the `_reward.div(rewardsDuration)` as seen in `_notifyRewardAmount()` on line #864. Note that `rewardDuration` is a constant 604,800.  `rewardDuration = 6 * 10**5`   Thus, if we have a rewards such as AURA or WETH (or most ERC20 tokens) which have units 10**18 we can transfer 1 WETH to the reward distributor which calls `_notifyRewardAmount()` and  sets the reward rate to,  `rewardRate = 10**18 / (6 * 10**5) ~= 10**12`  Finally, if this attack is run either by the first depositor they may `lock()` a single token which would set `totalSupply = 1`.  Therefore our equation in terms of units will become, ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply => 10**5 * 10**12 * 10**18 / 1 = 10**35 ```  In since `rewardPerTokenStored` is a `uint96` it has a maximum value of `2**96 ~= 7.9 * 10**28`. Hence there will be an overflow in `newRewardPerToken.to96()`. Since we are unable to add more total supply due to `lock()` reverting there will be no way to circumvent this revert except to `shutdown()`.  ```solidity                 uint256 newRewardPerToken = _rewardPerToken(token);                 rewardData[token].rewardPerTokenStored = newRewardPerToken.to96(); ```  Note this attack is described when we have a low `totalSupply`. However it is also possible to apply this attack on a larger `totalSupply` when there are reward tokens which have decimal places larger than 18 or tokens which such as SHIB which have small token value and so many of the tokens can be bought for cheap.   ## Recommended Mitigation Steps  To mitigation this issue it is recommended to increase the size of the `rewardPerTokenStored`. Since updating this value will require another slot to be used we recommend updating this to either `uint256` or to update both `rewardRate` and `rewardPerTokenStored` to be `uint224`.  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/convex-platform/contracts/contracts/ConvexMasterChef.sol#L178-L183   # Vulnerability details  ## Impact massUpdatePools() is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.  ## Proof of Concept https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-block-gas-limit  ## Tools Used Manual analysis  ## Recommended Mitigation Steps I suggest to limit the max number of loop iterations to prevent hitting block gas limit.   
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L404   # Vulnerability details  The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch. A comment in this section mentions `"wont have the exact reward rate that you would get if looped through"`. However, there's no reason not to multiply *user's whole locked balance* by the number of epochs since the *last lock's* unlock time, *instead of only the last locked amount*. While this will still not be as accurate as looping through, this will give a more accurate kick reward result, which is still bounded by the full amount that would have been calculated if we had looped through.  ## Impact The reward calculation is inaccurate and lacking for no reason. Kickers receive less rewards than they should. Giving them a bigger, more accurate reward, will incentivize them better.  ## Proof of Concept [This](https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L396:#L405) is the section that calculates the kick reward if all locks have expired: ```             //check for kick reward             //this wont have the exact reward rate that you would get if looped through             //but this section is supposed to be for quick and easy low gas processing of all locks             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch             if (_checkDelay > 0) {                 uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                 uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);                 uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                 reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);             } ``` This flow is for low gas processing, so the function is not looping through all the locks (unlike the flow where some locks have not expired yet). In this flow, the function is just calculating the reward for the last lock.  Instead of doing this, it can multiply the *total amount locked by the user* (`locked`, already saved) by the *number of epochs between the last unlock time and current epoch*. The reward will still be smaller than if we had looped through all the rewards (since then each lock amount would be multiplied by more than just the last lock's number of expired epochs). But it would be more accurate and give better incentive for kicking.   ## Recommended Mitigation Steps Change the last line in the code above to: ```                 reward = uint256(locked).mul(rRate).div(denominator); ``` This will keep the low gas consumption of this flow, while giving a more accurate result.  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118   # Vulnerability details  ## Impact In the ConvexMasterChef contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (cvx) or not. ```   function add(       uint256 _allocPoint,       IERC20 _lpToken,       IRewarder _rewarder,       bool _withUpdate   ) public onlyOwner {       if (_withUpdate) {           massUpdatePools();       }       uint256 lastRewardBlock = block.number > startBlock           ? block.number           : startBlock;       totalAllocPoint = totalAllocPoint.add(_allocPoint);       poolInfo.push(           PoolInfo({               lpToken: _lpToken,               allocPoint: _allocPoint,               lastRewardBlock: lastRewardBlock,               accCvxPerShare: 0,               rewarder: _rewarder           })       );   } ``` When the _lpToken is the same token as cvx, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```   function updatePool(uint256 _pid) public {       PoolInfo storage pool = poolInfo[_pid];       if (block.number <= pool.lastRewardBlock) {           return;       }       uint256 lpSupply = pool.lpToken.balanceOf(address(this));       if (lpSupply == 0) {           pool.lastRewardBlock = block.number;           return;       }       uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);       uint256 cvxReward = multiplier           .mul(rewardPerBlock)           .mul(pool.allocPoint)           .div(totalAllocPoint);       //cvx.mint(address(this), cvxReward);       pool.accCvxPerShare = pool.accCvxPerShare.add(           cvxReward.mul(1e12).div(lpSupply)       );       pool.lastRewardBlock = block.number;   } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L186-L206 ## Tools Used None ## Recommended Mitigation Steps Add a check that _lpToken is not cvx in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138   # Vulnerability details  ## Impact Same as IDX-003 in https://public-stg.inspex.co/report/Inspex_AUDIT2021024_LuckyLion_Farm_FullReport_v2.0.pdf The totalAllocPoint variable is used to determine the portion that each pool would get from the total reward, so it is one of the main factors used in the rewards calculation. Therefore, whenever the totalAllocPoint variable is modified without updating the pending reward first, the reward of each pool will be incorrectly calculated. For example, when  _withUpdate is false, in the add() shown below, the totalAllocPoint variable will be modified without updating the rewards (massUpdatePools()). ```     function add(         uint256 _allocPoint,         IERC20 _lpToken,         IRewarder _rewarder,         bool _withUpdate     ) public onlyOwner {         if (_withUpdate) {             massUpdatePools();         }         uint256 lastRewardBlock = block.number > startBlock             ? block.number             : startBlock;         totalAllocPoint = totalAllocPoint.add(_allocPoint);         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accCvxPerShare: 0,                 rewarder: _rewarder             })         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138 ## Tools Used None ## Recommended Mitigation Steps Removing the _withUpdate variable in the add() and set() functions and always calling the massUpdatePools() function before updating totalAllocPoint variable  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L56-L65   # Vulnerability details  ## Impact Unpredictable slippage, sandwich vulnerability or frequent failed transactions  ## Proof of Concept CrvDepostiorWrapper uses the TWAP provided by the 20/80 WETH/BAL. The issue is that this pool has only handled ~15 transactions per day in the last 30 days, which means that the oracle frequently goes more than an hour without updating. Each time a state changing operation is called, the following code in the balancer pool takes a snapshot of the pool state BEFORE any operation changes it:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/80e1a5db7439069e2cb53e228bce0a8a51f5b23e/pkg/pool-weighted/contracts/oracle/OracleWeightedPool.sol#L156-L161  This could result in the price of the oracle frequently not reflecting the true value of the assets due to infrequency of update. Now also consider that the pool has a trading fee of 2%. Combine an inaccurate oracle with a high fee pool and trades can exhibit high levels of "slippage". To account for this outputBps in AuraStakingProxy needs to be set relatively low or risks frequent failed transactions when calling distribute due to slippage conditions not being met. The lower outputBps is set the more vulnerable distribute becomes to sandwich attacks.   ## Tools Used  ## Recommended Mitigation Steps Consider using chainlink oracles for both BAL and ETH to a realtime estimate of the LP value. A chainlink LP oracle implementation can be found in the link below: https://blog.alphaventuredao.io/fair-lp-token-pricing/  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraClaimZap.sol#L224-L226   # Vulnerability details  ## Impact It was observed that User will lose funds due to missing else condition  ## Proof of Concept  1. User call claimRewards at ClaimZap.sol#L103 with Options.LockCvx as false 2. claimRewards internally calls _claimExtras 3. Everything goes good until AuraClaimZap.sol#L218  ``` if (depositCvxMaxAmount > 0) {             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);             if (cvxBalance > 0) {                 //pull cvx                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                 if (_checkOption(options, uint256(Options.LockCvx))) {                     IAuraLocker(locker).lock(msg.sender, cvxBalance);                 }             }         } ```  4. Since user cvxBalance>0 so cvxBalance is transferred from user to the contract. 5. Now since Options.LockCvx was set to false in options so if (_checkOption(options, uint256(Options.LockCvx))) does not evaluate to true and does not execute 6. This means User cvx funds are stuck in contract  ## Recommended Mitigation Steps The condition should check if user has enabled lock for cvx, otherwise cvx should not be transferred from user  ``` if (depositCvxMaxAmount > 0 && _checkOption(options, uint256(Options.LockCvx))) {           uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);           cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);           if (cvxBalance > 0) {               //pull cvx               IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);                    IAuraLocker(locker).lock(msg.sender, cvxBalance);           }       } ```  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/ExtraRewardsDistributor.sol#L127   # Vulnerability details  ## Impact User can forfeit other user rewards by giving a higher _startIndex in getReward function  ## Proof of Concept 1. Assume User B has not received any reward yet so that his userClaims[_token][User B]=0 2. User A calls getReward function with _account as User B and _startIndex as 5 3. This eventually calls _allClaimableRewards at ExtraRewardsDistributor.sol#L213 which computes epochIndex =5>0?5:0 = 5 4. Assuming tokenEpochs is 10 and latestEpoch is 8, so reward will computed from epoch 5 till epoch index 7 and _allClaimableRewards will return index as 7 5. _getReward will simply update userClaims[_token][User B] with 7  6. This is incorrect because as per contract User B has received reward from epoch 0-7 even though he only received reward for epoch 5-7   ## Recommended Mitigation Steps Do not allow users to call getReward function for other users  
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82   # Vulnerability details  ## Impact In `Aura.sol` the `updateOperator()` function can be called by anyone and it sets a new `operator` based on the address returned from `IStaker(vecrvProxy).operator()`.  The problem is that anyone can call this function even if the operator on `vecrvProxy` is not yet set.  If this is the case the operator in `Aura.sol` would be set to a zero address breaking the contract since functions like `init()` and `mint()` rely on the `msg.sender` being the `operator`. Even the `minterMint()` function relies on the `operator` since only the operator can set the `minter` which is the only one who can call `minterMinter()`.   ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `updateOperator()` function should not be a public function and should only be callable by an admin or the `operator` inside `Aura.sol`.  Also in the `updateOperator()` function,  there should be a check ensuring that the `newOperator` address is not a zero address to prevent breaking the contract by setting the `operator` to a zero address.   
# Lines of code  https://github.com/aurafinance/convex-platform/blob/9cae5eb5a77e73bbc1378ef213740c1889e2e8a3/contracts/contracts/BaseRewardPool4626.sol   # Vulnerability details  ## Impact   BaseRewardPool4626 is not IERC4626 compliant. This makes the BaseRewardPool4626 contract irrelevant as it is for now since projects won't be able to integrate with BaseRewardPool4626 using the[eip-4626](https://eips.ethereum.org/EIPS/eip-4626) standard.   ## Suggestion  You can choose to remove the BaseRewardPool4626 and save on some deployment gas or review the necessary` functions` and `emits` required on [eip-4626](https://eips.ethereum.org/EIPS/eip-4626)  and add it to BaseRewardPool4626.   
# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/CrvDepositorWrapper.sol#L9 https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraStakingProxy.sol#L10   # Vulnerability details  ## Impact If a codebase has two contracts with the same names, the compilation artifacts will not contain one of the contracts.  `ICrvDepositor` exists in both `AuraStakingProxy` and `CrvDepositorWrapper`  ## Tools Manual Review   ## Recommended Mitigation Steps Move the contract to an interface file and import it or if the interface differs rename one of the contracts.  
The `amount should be greater than 0` is not checked by the `_addReward` function.  ## Permalink: https://github.com/code-423n4/2022-05-aura/blob/c332f8c23e12b3bb678f018682c7609df9c77ed9/contracts/ExtraRewardsDistributor.sol#L87  ## Recommendation: Can Add Require Statement to check _amount is greater than 0.
# Lines of code  https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848   # Vulnerability details    Rewards distribution can be delayed/never distributed on [AuraLocker.sol#L848 ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848)   ### Issue  Someone malicious can delay the rewards distribution for non `cvxCrv` tokens distributed on AuraLocker.sol.   1: Attacker will send one wei of token that are distributed on the [AuraLocker.sol ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol) to [AuraStakingProxy](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol).  2: Attacker will call [distributeOther](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol#L203). The function will call notifyRewardAmount that calls [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860)   When calling [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860) the rewards left to distribute over the 7 days are redistributed throughout a new period starting immediately.  ``` uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp); uint256 leftover = remaining.mul(rdata.rewardRate); rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96(); ```  _Example:_ If the reward rate is 1 token (10**18) per second and 3.5 days are left (302400 seconds), we get a leftover of 302400 tokens. this is then divided by 604800, the reward rate is now 0.5 and the user of the protocol will have to wait one week for tokens that were supposed to be distributed over 3.5 days. This can be repeated again and again so that some rewards are never distributed.    ### Suggestion I can see that [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820) has some protective mechanism. A new period is started only if the token that is added on top of the already distributed tokens during the duration is over 120%.  I suggest adding a similar check to [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820)   
