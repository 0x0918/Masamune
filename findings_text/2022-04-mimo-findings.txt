# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L159-L165 https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/GenericMinerV2.sol#L88-L94   # Vulnerability details  ## Impact Users aware of this vulnerability could effectively steal a portion of liquidity mining rewards from honest users.  Affected contracts are: `SupplyMinerV2`, ` DemandMinerV2`, ` PARMinerV2`   `VotingMinerV2` is less affected because locking veMIMO in `votingEscrow`  triggers a call to `releaseMIMO` of this miner contract (which in turn updates user's boost multiplier).   ## Proof of Concept Let's focus here on `SupplyMinerV2`. The exploits for other liquidity mining contracts are analogous.  ### Scenario 1:  Both Alice and Bob deposit 1 WETH to `coreVaults`  and borrow 100 PAR from `coreVaults`. They both have no locked veMIMO.   Now they wait for a month without interacting with the protocol. In the meantime, `SupplyMinerV2` accumulated 100 MIMO for rewards.  Alice locks huge amount of veMIMO in `votingEscrow`, so now her `boostMultiplier`  is 4.  Let's assume that Alice and Bob are the only users of the protocol. Because they borrowed the same amounts of PAR, they should have the same stakes for past month, so a fair reward for each of them (for this past month) should be 50 MIMO. If they simply repay their debts now, 50 MIMO is indeed what they get.  However if Alice calls `supplyMiner.updateBoost(alice)` before repaying her debt, she can claim 80 MIMO and leave only 20 MIMO for Bob. She can basically apply the multiplier 4 to her past stake.  ### Scenario 2:  Both Alice and Bob deposit 1 WETH to `coreVaults`  and borrow 100 PAR from `coreVaults`. Bob locks huge amount of veMIMO in `votingEscrow` for 4 years, so now his `boostMultiplier` is 4.   Alice and Bob wait for 4 years without interacting with the protocol.  `SupplyMinerV2` accumulated 1000 MIMO rewards.   Because of his locked veMIMO, Bob should be able to claim larger reward than Alice. Maybe not 4 times larger but definitely larger.  However, if Alice includes  a transaction with call `supplyMiner.updateBoost(bob)` before Bob's `vaultsCore.repay()` , then she can claim 500 MIMO. She can effectively set Bob's `boostMultiplier` for past 4 years to 1.  ## Tools Used Tested in Foundry  ## Recommended Mitigation Steps I have 2 ideas: 1. Remove `updateBoost` function. There shouldn't be a way to update boost multiplier without claiming rewards and updating `_userInfo.accAmountPerShare` .  So `releaseRewards`  should be sufficient. 2. A better, but also much more difficult solution, would be to redesign boost updates in such a way that distribution of rewards no longer depends on when and how often boost multiplier is updated. If the formula for boost multiplier stays the same, this approach might require calculating integrals of the multiplier as a function of time.  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L76-L99   # Vulnerability details  ## Impact According to Aave documentation, when requesting flash-loan, it's possible to specify a `receiver`, so function `executeOperation()` of that `receiver` will be called by `lendingPool`. https://docs.aave.com/developers/v/2.0/guides/flash-loans In the `SuperVault` there is no check to prevent this attack so attacker can use this and perform  `griefing attack` and make miner contract lose all its funds. or he can create specifically crafted `params` so when `executeOperation()` is called by `lendingPool`, attacker could steal vault's user funds.   ## Proof of Concept To exploit this attacker will do this steps: 1. will call `Aave lendingPool` to get a flash-loan and specify `SuperVault` as `receiver` of flash-loan. and also create a specific `params` that invoke `Operation.REBALANCE` action to change user vault's collateral. 2. `lendingPool` will call `executeOperation()` of `SuperVault` with attacker specified data. 3. `executeOperation()` will check `msg.sender` and will process the function call which will cause some dummy exchanges that will cost user exchange fee and flash-loan fee. 4. attacker will repeat this attack until user losses all his funds. ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address,     bytes calldata params   ) external returns (bool) {     require(msg.sender == address(lendingPool), "SV002");     (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));     IERC20 asset = IERC20(assets[0]);     uint256 flashloanRepayAmount = amounts[0] + premiums[0];     if (operation == Operation.LEVERAGE) {       leverageOperation(asset, flashloanRepayAmount, operationParams);     }     if (operation == Operation.REBALANCE) {       rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);     }     if (operation == Operation.EMPTY) {       emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);     }      asset.approve(address(lendingPool), flashloanRepayAmount);     return true;   } ```  To steal user fund in `SupperVault` attacker needs more steps. in all these actions (`Operation.REBALANCE`, `Operation.LEVERAGE`, `Operation.EMPTY`) contract will call `aggregatorSwap()` with data that are controlled by attacker. ```   function aggregatorSwap(     uint256 dexIndex,     IERC20 token,     uint256 amount,     bytes memory dexTxData   ) internal {     (address proxy, address router) = _dexAP.dexMapping(dexIndex);     require(proxy != address(0) && router != address(0), "SV201");      token.approve(proxy, amount);     router.call(dexTxData);   } ```  Attacker can put special data in `dexTxData` that make contract to do an exchange with bad price. To do this, attacker will create a smart contract that will do this steps: 1. manipulate price in exchange with flash loan. 2. make a call to `executeOperation()` by `Aave flash-loan` with `receiver` and specific `params` so that `SuperVault` will make calls to manipulated exchange for exchanging. 3. do the reverse of #1 and pay the flash-loan and steal the user fund. The details are: Attacker can manipulate swapping pool price with flash-loan, then Attacker will create specific `params` and perform steps 1 to 4. so contract will try to exchange tokens and because of attacker price manipulation and specific `dexTxData`, contract will have bad deals. After that, attacker can reverse the process of swap manipulation and get his  flash-loan tokens and some of `SuperVault` funds and. then pay the flash-loan.  ## Tools Used VIM  ## Recommended Mitigation Steps There should be some state variable which stores the fact that `SuperVault` imitated flash-loan. When contract tries to start flash-loan, it sets the `isFlash` to `True` and `executeOperation()` only accepts calls if `isFlash` is `True`. and after the flash loan code will set `isFlash` to `False.`  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L126 https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L299 https://github.com/Uniswap/solidity-lib/blob/c01640b0f0f1d8a85cba8de378cc48469fcfd9a6/contracts/libraries/TransferHelper.sol#L47-L50   # Vulnerability details  ## Impact A malicious user is able to steal all collateral of an unhealthy position in `PARMinerV2.sol`. The code for the `liquidate()` function is written so that the following steps are followed:  - User calls `PARMinerV2.liquidate()` - PARMinerV2 performs the liquidation with `_a.parallel().core().liquidatePartial()` - PARMinerV2 receives the liquidated collateral - An arbitrary router function is called to swap the collateral to PAR - Finally, `PARMinerV2.liquidate()` checks that PARMinerV2's PAR balance is higher than the balance at the beginning of the function call.  The exploit occurs with the arbitrary router call. The malicious user is able to supply the `dexTxnData` parameter which dictates the function call to the router. If the user supplied a function such as UniswapV2Router's `swapExactTokenForETH()`, then control flow will be given to the user, allowing them to perform the exploit.  Note: The Mimo developers have stated that the routers used by the protocol will be DEX Aggregators such as 1inch and Paraswap, but this submission will be referring to UniswapV2Router for simplicity. It can be assumed that the dex aggregators currently allow swapping tokens for ETH.  Continuing the exploit, once the attacker has gained control due to the ETH transfer, they are able to swap the ETH for PAR. Finally, they deposit the PAR with `PARMinerV2.deposit()`. This will cause the final check of `liquidate()` to pass because PARMinerV2's PAR balance will be larger than the start of the liquidation call.  The attacker is able to steal all collateral from every unhealthy position that they liquidate. In the most extreme case, the attacker is able to open their own risky positions with the hope that the position becomes unhealthy. They will borrow the PAR and then liquidate themselves to take back the collateral. Thus effectively stealing PAR.  ## Proof of Concept Steps for exploit:  - Attacker monitors unhealthy positions. Finds a position to liquidate. - Attacker calls `PARMinerV2.liquidate()` - Position liquidated. Collateral transferred back to `PARMinerV2` - In the `liquidate()` function, attacker supplies bytes for `UniswapV2Router.swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)`. For `to`, they supply the attacker contract. - `swapExactTokensForETH()` firstly swaps the collateral for ETH and then transfers the ETH to the user with `TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);` - `TransferHelper.safeTransferETH()` contains a call to the receiver via `(bool success, ) = to.call{value: value}(new bytes(0));` - Therefore, the attacker contract will indeed gain control of execution.  The attacker contract will then perform the following steps:  - Swap the received ETH to PAR. - Deposit the PAR in `PARMinerV2` - Withdraw the deposited PAR.  ## Tools Used Static review.  ## Recommended Mitigation Steps The arbitrary call to the router contracts is risky because of the various functions that they can contain. Perhaps a solution is to only allow certain calls such as swapping tokens to tokens, not ETH. This would require frequently updated knowledge of the router's functions, though would be beneficial for security.   Also, adding a check that the `_totalStake` variable has not increased during the liquidation call will mitigate the risk of the attacker depositing the PAR to increase the contract's balance. The attacker would have no option but to transfer the PAR to PARMinerV2 as is intended.  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L47 https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L51   # Vulnerability details  ## Impact It is possible to produce underflows with specific tokens which can cause errors when calculating prices.  ## Proof of Concept The pragma is `pragma solidity 0.6.12;` therefore, integer overflows must be protected with safe math. But in the case of [GUniLPOracle](https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L51), there is a decimal subtraction that could underflow if any token in the pool has more than 18 decimals. this could cause an error when calculating price values.  ## Recommended Mitigation Steps Ensure that tokens have less than 18 decimals.  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L159-L165 https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/GenericMinerV2.sol#L88-L94   # Vulnerability details  ## Impact Users aware of this vulnerability could effectively steal a portion of liquidity mining rewards from honest users.  Affected contracts are: `SupplyMinerV2`, ` DemandMinerV2`, ` PARMinerV2`   `VotingMinerV2` is less affected because locking veMIMO in `votingEscrow`  triggers a call to `releaseMIMO` of this miner contract (which in turn updates user's boost multiplier).   ## Proof of Concept Let's focus here on `SupplyMinerV2`. The exploits for other liquidity mining contracts are analogous.  ### Scenario 1:  Both Alice and Bob deposit 1 WETH to `coreVaults`  and borrow 100 PAR from `coreVaults`. They both have no locked veMIMO.   Now they wait for a month without interacting with the protocol. In the meantime, `SupplyMinerV2` accumulated 100 MIMO for rewards.  Alice locks huge amount of veMIMO in `votingEscrow`, so now her `boostMultiplier`  is 4.  Let's assume that Alice and Bob are the only users of the protocol. Because they borrowed the same amounts of PAR, they should have the same stakes for past month, so a fair reward for each of them (for this past month) should be 50 MIMO. If they simply repay their debts now, 50 MIMO is indeed what they get.  However if Alice calls `supplyMiner.updateBoost(alice)` before repaying her debt, she can claim 80 MIMO and leave only 20 MIMO for Bob. She can basically apply the multiplier 4 to her past stake.  ### Scenario 2:  Both Alice and Bob deposit 1 WETH to `coreVaults`  and borrow 100 PAR from `coreVaults`. Bob locks huge amount of veMIMO in `votingEscrow` for 4 years, so now his `boostMultiplier` is 4.   Alice and Bob wait for 4 years without interacting with the protocol.  `SupplyMinerV2` accumulated 1000 MIMO rewards.   Because of his locked veMIMO, Bob should be able to claim larger reward than Alice. Maybe not 4 times larger but definitely larger.  However, if Alice includes  a transaction with call `supplyMiner.updateBoost(bob)` before Bob's `vaultsCore.repay()` , then she can claim 500 MIMO. She can effectively set Bob's `boostMultiplier` for past 4 years to 1.  ## Tools Used Tested in Foundry  ## Recommended Mitigation Steps I have 2 ideas: 1. Remove `updateBoost` function. There shouldn't be a way to update boost multiplier without claiming rewards and updating `_userInfo.accAmountPerShare` .  So `releaseRewards`  should be sufficient. 2. A better, but also much more difficult solution, would be to redesign boost updates in such a way that distribution of rewards no longer depends on when and how often boost multiplier is updated. If the formula for boost multiplier stays the same, this approach might require calculating integrals of the multiplier as a function of time.  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L76-L99   # Vulnerability details  ## Impact According to Aave documentation, when requesting flash-loan, it's possible to specify a `receiver`, so function `executeOperation()` of that `receiver` will be called by `lendingPool`. https://docs.aave.com/developers/v/2.0/guides/flash-loans In the `SuperVault` there is no check to prevent this attack so attacker can use this and perform  `griefing attack` and make miner contract lose all its funds. or he can create specifically crafted `params` so when `executeOperation()` is called by `lendingPool`, attacker could steal vault's user funds.   ## Proof of Concept To exploit this attacker will do this steps: 1. will call `Aave lendingPool` to get a flash-loan and specify `SuperVault` as `receiver` of flash-loan. and also create a specific `params` that invoke `Operation.REBALANCE` action to change user vault's collateral. 2. `lendingPool` will call `executeOperation()` of `SuperVault` with attacker specified data. 3. `executeOperation()` will check `msg.sender` and will process the function call which will cause some dummy exchanges that will cost user exchange fee and flash-loan fee. 4. attacker will repeat this attack until user losses all his funds. ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address,     bytes calldata params   ) external returns (bool) {     require(msg.sender == address(lendingPool), "SV002");     (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));     IERC20 asset = IERC20(assets[0]);     uint256 flashloanRepayAmount = amounts[0] + premiums[0];     if (operation == Operation.LEVERAGE) {       leverageOperation(asset, flashloanRepayAmount, operationParams);     }     if (operation == Operation.REBALANCE) {       rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);     }     if (operation == Operation.EMPTY) {       emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);     }      asset.approve(address(lendingPool), flashloanRepayAmount);     return true;   } ```  To steal user fund in `SupperVault` attacker needs more steps. in all these actions (`Operation.REBALANCE`, `Operation.LEVERAGE`, `Operation.EMPTY`) contract will call `aggregatorSwap()` with data that are controlled by attacker. ```   function aggregatorSwap(     uint256 dexIndex,     IERC20 token,     uint256 amount,     bytes memory dexTxData   ) internal {     (address proxy, address router) = _dexAP.dexMapping(dexIndex);     require(proxy != address(0) && router != address(0), "SV201");      token.approve(proxy, amount);     router.call(dexTxData);   } ```  Attacker can put special data in `dexTxData` that make contract to do an exchange with bad price. To do this, attacker will create a smart contract that will do this steps: 1. manipulate price in exchange with flash loan. 2. make a call to `executeOperation()` by `Aave flash-loan` with `receiver` and specific `params` so that `SuperVault` will make calls to manipulated exchange for exchanging. 3. do the reverse of #1 and pay the flash-loan and steal the user fund. The details are: Attacker can manipulate swapping pool price with flash-loan, then Attacker will create specific `params` and perform steps 1 to 4. so contract will try to exchange tokens and because of attacker price manipulation and specific `dexTxData`, contract will have bad deals. After that, attacker can reverse the process of swap manipulation and get his  flash-loan tokens and some of `SuperVault` funds and. then pay the flash-loan.  ## Tools Used VIM  ## Recommended Mitigation Steps There should be some state variable which stores the fact that `SuperVault` imitated flash-loan. When contract tries to start flash-loan, it sets the `isFlash` to `True` and `executeOperation()` only accepts calls if `isFlash` is `True`. and after the flash loan code will set `isFlash` to `False.`  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L126 https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L299 https://github.com/Uniswap/solidity-lib/blob/c01640b0f0f1d8a85cba8de378cc48469fcfd9a6/contracts/libraries/TransferHelper.sol#L47-L50   # Vulnerability details  ## Impact A malicious user is able to steal all collateral of an unhealthy position in `PARMinerV2.sol`. The code for the `liquidate()` function is written so that the following steps are followed:  - User calls `PARMinerV2.liquidate()` - PARMinerV2 performs the liquidation with `_a.parallel().core().liquidatePartial()` - PARMinerV2 receives the liquidated collateral - An arbitrary router function is called to swap the collateral to PAR - Finally, `PARMinerV2.liquidate()` checks that PARMinerV2's PAR balance is higher than the balance at the beginning of the function call.  The exploit occurs with the arbitrary router call. The malicious user is able to supply the `dexTxnData` parameter which dictates the function call to the router. If the user supplied a function such as UniswapV2Router's `swapExactTokenForETH()`, then control flow will be given to the user, allowing them to perform the exploit.  Note: The Mimo developers have stated that the routers used by the protocol will be DEX Aggregators such as 1inch and Paraswap, but this submission will be referring to UniswapV2Router for simplicity. It can be assumed that the dex aggregators currently allow swapping tokens for ETH.  Continuing the exploit, once the attacker has gained control due to the ETH transfer, they are able to swap the ETH for PAR. Finally, they deposit the PAR with `PARMinerV2.deposit()`. This will cause the final check of `liquidate()` to pass because PARMinerV2's PAR balance will be larger than the start of the liquidation call.  The attacker is able to steal all collateral from every unhealthy position that they liquidate. In the most extreme case, the attacker is able to open their own risky positions with the hope that the position becomes unhealthy. They will borrow the PAR and then liquidate themselves to take back the collateral. Thus effectively stealing PAR.  ## Proof of Concept Steps for exploit:  - Attacker monitors unhealthy positions. Finds a position to liquidate. - Attacker calls `PARMinerV2.liquidate()` - Position liquidated. Collateral transferred back to `PARMinerV2` - In the `liquidate()` function, attacker supplies bytes for `UniswapV2Router.swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)`. For `to`, they supply the attacker contract. - `swapExactTokensForETH()` firstly swaps the collateral for ETH and then transfers the ETH to the user with `TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);` - `TransferHelper.safeTransferETH()` contains a call to the receiver via `(bool success, ) = to.call{value: value}(new bytes(0));` - Therefore, the attacker contract will indeed gain control of execution.  The attacker contract will then perform the following steps:  - Swap the received ETH to PAR. - Deposit the PAR in `PARMinerV2` - Withdraw the deposited PAR.  ## Tools Used Static review.  ## Recommended Mitigation Steps The arbitrary call to the router contracts is risky because of the various functions that they can contain. Perhaps a solution is to only allow certain calls such as swapping tokens to tokens, not ETH. This would require frequently updated knowledge of the router's functions, though would be beneficial for security.   Also, adding a check that the `_totalStake` variable has not increased during the liquidation call will mitigate the risk of the attacker depositing the PAR to increase the contract's balance. The attacker would have no option but to transfer the PAR to PARMinerV2 as is intended.  
# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L47 https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L51   # Vulnerability details  ## Impact It is possible to produce underflows with specific tokens which can cause errors when calculating prices.  ## Proof of Concept The pragma is `pragma solidity 0.6.12;` therefore, integer overflows must be protected with safe math. But in the case of [GUniLPOracle](https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L51), there is a decimal subtraction that could underflow if any token in the pool has more than 18 decimals. this could cause an error when calculating price values.  ## Recommended Mitigation Steps Ensure that tokens have less than 18 decimals.  
