- [Gas](#gas)     - [**1. constants expressions are expressions, not constants**](#1-constants-expressions-are-expressions-not-constants)     - [**2. Reorder structure layout**](#2-reorder-structure-layout)     - [**3. Use calldata instead of memory**](#3-use-calldata-instead-of-memory)     - [**4. There's no need to set default values for variables**](#4-theres-no-need-to-set-default-values-for-variables)     - [**5. Don't use the length of an array for loops condition**](#5-dont-use-the-length-of-an-array-for-loops-condition)     - [**6. ++i costs less gas compared to i++ or i += 1**](#6-i-costs-less-gas-compared-to-i-or-i--1)     - [**7. Reduce the size of error messages Long revert Strings**](#7-reduce-the-size-of-error-messages-long-revert-strings)         - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)     - [**8. Use library instead of abstract contract**](#8-use-library-instead-of-abstract-contract)     - [**9. Use inline methods**](#9-use-inline-methods)     - [**10. Gas saving using immutable**](#10-gas-saving-using-immutable)     - [**11. Improved migrateFractions logic**](#11-improved-migratefractions-logic)  -----  # Gas  ## **1. `constants` expressions are expressions, not `constants`**  Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was immutable instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  Reference:  - https://github.com/ethereum/solidity/issues/9232  Consequences: each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )  Affected source code:  - [Permit.sol#L5-L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Permit.sol#L5-L17)  ## **2. Reorder structure layout**  The following structs could be optimized moving the position of certains values in order to save slot storages:  Put booleans types together on [IMigration.sol#L8-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L8-L33)  ```diff struct Proposal {     // Start time of the migration proposal     uint256 startTime;     // Target buyout price for the migration     uint256 targetPrice;     // Total ether contributed to the migration     uint256 totalEth;     // Total fractions contributed to the migration     uint256 totalFractions;     // Module contract addresses proposed for the migration     address[] modules;     // Plugin contract addresses proposed for the migration     address[] plugins;     // Function selectors for the proposed plugins     bytes4[] selectors; +   // Old fraction supply for a given vault +   uint256 oldFractionSupply; +   // New fraction supply for a given vault that has succesfully migrated +   uint256 newFractionSupply;     // Address for the new vault to migrate to (if buyout is succesful)     address newVault;     // Boolean status to check if the propoal is active     bool isCommited; -   // Old fraction supply for a given vault -   uint256 oldFractionSupply; -   // New fraction supply for a given vault that has succesfully migrated -   uint256 newFractionSupply;     // Boolean status to check that the fractions have already been migrated     bool fractionsMigrated; } ```  ## **3. Use `calldata` instead of `memory`**  The following methods are `external` but `memory` is used for arguments.  - [IMigration.sol#L89-L162](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L89-L162) - [IModule.sol#L8-L13](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IModule.sol#L8-L13) - [IVault.sol#L43-L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L43-L64) - [IVaultRegistry.sol#L43-L71](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVaultRegistry.sol#L43-L71)   These one require to change the visibility to `external`:  - [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) - [MerkleBase.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73)  ## **4. There's no need to set default values for variables**  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **5. Don't use the length of an array for loops condition**  It's cheaper to store the length of the array inside a local variable and iterate over it.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [MerkleBase.sol#L110](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [BaseVault.sol#L130-L132](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130-L132) - [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454)  ## **6. `++i` costs less gas compared to `i++` or `i += 1`**  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  Affected source code:  - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **7. Reduce the size of error messages (Long revert Strings)**  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) - [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)  ## **8. Use `library` instead of `abstract` contract**  If the following contracts were libraries, they could save gas thanks to compiler optimizations since there are functions that are not called and being an abstract contract implies publishing all the code marked as public, such as library, the compiler can choose which functions to eliminate by not be used.  Smaller contracts would be produced, with less inheritance and therefore more auditable and readable.  Affected source code:  - [MerkleBase.sol](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L7)  ## **9. Use inline methods**  The following methods can be moved to inline calls without greatly affecting readability, this will increase the performance of the contract.  Affected source code:  - [Multicall.sol#L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Multicall.sol#L39)  ## **10. Gas saving using `immutable`**  It's possible to avoid storage access a save gas using `immutable` keyword for the following variables:  It's also better to remove the initial values, because they will be set during the constructor.  Affected source code:  - [BaseVault.sol#L19](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L19) - [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39)  ## **11. Improved `migrateFractions` logic**  [migrateFractions](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438-L449) method could be optimized as follows:  ```diff -       (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo( +       (, address proposer, State current, , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(             _vault         );         State required = State.SUCCESS;         if (current != required) revert IBuyout.InvalidState(required, current);         // Reverts if proposer of buyout is not this contract         if (proposer != address(this)) revert NotProposalBuyout(); - -       // Gets the last total supply of fractions for the vault -       (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( -           _vault -       ); ```  **There is no need to duplicate the call of `buyoutInfo(_vault)`** 
