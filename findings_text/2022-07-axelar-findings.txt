## [NAZ-L1] `receive()` Function Should Emit An Event **Severity**: Low **Context**: [`DepositReceiver.sol#L29`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29), [`AxelarDepositServiceProxy.sol#L13`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13)  **Description**: Consider emitting an event inside this function with `msg.sender` and `msg.value` as the parameters. This would make it easier to track incoming ether transfers.  **Recommendation**: Add events to the `receive()` functions.    ## [NAZ-L2] Local Variable Shadowing **Severity**: Low **Context**: [`AxelarDepositService.sol#L19 (both gateway && wrappedSymbol)`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L19)  **Description**: These Variables shadow state variables. As a result, the use of them locally might be incorrect.  **Recommendation**: Rename the local variables that shadow another component.   ## [NAZ-N1] Code Contains Empty Blocks **Severity** Informational **Context**: [`AxelarDepositServiceProxy.sol#L13`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13), [`AxelarAuthWeighted.sol#L101`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101)  **Description**: It's best practice that when there is an empty block, to add a comment in the block exmplaining why it's empty.  **Recommendation**: Consider adding `/* Comment on why */` to the empty block.   ## [NAZ-N2] Variable Naming Convention **Severity** Informational **Context**: [`AxelarGateway.sol#L45-L46`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L45-L46)  **Description**: The linked variables do not conform to the standard naming convention of Solidity whereby functions and variable names(local, state and immutable) utilize the `mixedCase` format unless variables are declared as `constant` in which case they utilize the `UPPER_CASE_WITH_UNDERSCORES` format.  **Recommendation**: Naming conventions utilized by the linked statements are adjusted to reflect the correcttype of declaration according to the Solidity style guide.   ## [NAZ-N3] Missing Use of `solhint-disable-next-line` **Severity**: Informational **Context**:[`AxelarGateway.sol#L157`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L157), [`AxelarGateway.sol#L229`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L229), [`AxelarGateway.sol#L320`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L320), [`AxelarGateway.sol#L344`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L344), [`AxelarGateway.sol#L461`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L461), [`AxelarGateway.sol#L615`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L615), [`AxelarAuthWeighted.sol#L101`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101)  **Description**: `solhint-disable-next-line` is used elsewhere for small linter errors and can be used here to disable these errors.  **Recommendation**: Consider adding `solhint-disable-next-line`.   ## [NAZ-N4] Commented Out Code **Severity**: Informational **Context**: [`AxelarGateway.sol#L22-L24`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L22-L24)  **Description**: There is commented code that makes the code messy and unneeded.   **Recommendation**: Remove the commented out code.   ## [NAZ-N5] Floating Pragma **Severity**: Informational **Context**: [`IAxelarGasService.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol), [`IAxelarDepositService.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol), [`IAxelarAuthWeighted.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol), [`IDepositBase.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol)  **Description**: Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  **Recommendation**:  Lock the pragma version.   ## [NAZ-N6] Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-07-axelar)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.
#  [L-01] Unused `receive()` function will lock Ether in contract :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29 :      `receive() external payable {}`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13 :      `receive() external payable override {}`           #  [L-02] Missing checks for `address(0x0)` when assigning values to address state variables :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L37 :        `xc20Codehash = codehash_;`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L45 :        `xc20Codehash = newCodehash;`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L52 :         'AUTH_MODULE = authModule;'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L53 :        `TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L24 :        `gateway = gateway_;`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L27 :        `gatewayAddress = gatewayAddress_;`        #  [L-03] address.call{value:x}() should be used instead of payable.transfer() :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L63 :        `payable(msg.sender).transfer(address(this).balance);`          #  [L-04] approve should be replaced with safeApprove or safeIncreaseAllowance() / safeDecreaseAllowance() :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L30 :        `IERC20(wrappedTokenAddress).approve(gateway, amount);`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L38 :        `IERC20(tokenAddress).approve(gateway, amount);`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L64 :         'IERC20(wrappedTokenAddress).approve(gateway, amount);'                #  [L-05] Low level calls donâ€™t check for contract existence :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L320 :        `(bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L460#L463 :        `function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {         (bool success, bytes memory returnData) = tokenAddress.call(callData);         return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));     }`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L158 :         '(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L172#L174 :        `(bool success, bytes memory returnData) = tokenAddress.call(             abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)         );`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L71 :        `(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L95 :        `(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));`    7. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L106#L108 :        `(bool success, bytes memory returnData) = tokenAddress.call(             abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)         );`               #  [L-06] an unbounded loop on array can lead to DoS :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123L#124 :        `for (uint256 i; i < tokens.length; i++) {             address token = tokens[i];`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168#L169 :        `for (uint256 i; i < refundTokens.length; i++) {             refundToken = refundTokens[i];`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116#L120 :         'for (uint256 i; i < accounts.length - 1; ++i) {             if (accounts[i] >= accounts[i + 1]) {                 return false;             }         }'                 #  [N-01] Adding a return statement when the function defines a named return variable, is redundant:-   1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L182 :      `return _adminEpoch();`          #  [N-02] require()/revert() statements should have descriptive reason strings :-   1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L55#L58 :      ` revert('NotAxelarToken()');       revert('NotXc20Token()');       revert('AlreadyWrappingAxelarToken()');       revert('AlreadyWrappingXC20Token()');`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L60#L61 :      `revert('NotOwner()');      revert('CannotSetMetadata()');`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L68 :       'revert('NotAxelarToken()');'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L70 :      `revert('NotWrappingToken()');`  1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L78#L79 :      `revert('NotAxelarToken()');      revert('CannotMint()');`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L84#L86 :      `revert('NotXc20Token()');      revert('InsufficientBalance()');      revert('CannotBurn()');`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L98 :       'revert('TransferFailed()');'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L111 :      `revert('TransferFailed()');`         #  [N-03] Use a more recent version of solidity (Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`) :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L3 :      `pragma solidity 0.8.9;`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L3 :      `pragma solidity 0.8.9;`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L3 :       'pragma solidity 0.8.9;'                #  [N-04] Event is missing indexed fields (Each `event` should use three `indexed` fields if there are three or more fields) :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L13#L57 :      `    event GasPaidForContractCall(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         address gasToken,         uint256 gasFeeAmount,         address refundAddress     );      event GasPaidForContractCallWithToken(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         string symbol,         uint256 amount,         address gasToken,         uint256 gasFeeAmount,         address refundAddress     );      event NativeGasPaidForContractCall(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         uint256 gasFeeAmount,         address refundAddress     );      event NativeGasPaidForContractCallWithToken(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         string symbol,         uint256 amount,         uint256 gasFeeAmount,         address refundAddress     );      event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);      event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L14 :      `event OperatorshipTransferred(address[] newOperators, uint256[] newWeights, uint256 newThreshold);`        #  [N-05] Use of sensitive/non-inclusive terms :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L496 :      `bool burnSuccess;`                   #  [N-06] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L152#L178 :      `    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {         return getUint(_getTokenDailyMintLimitKey(symbol));     }      function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {         return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));     }      function allTokensFrozen() external pure override returns (bool) {         return false;     }      function implementation() public view override returns (address) {         return getAddress(KEY_IMPLEMENTATION);     }      function tokenAddresses(string memory symbol) public view override returns (address) {         return getAddress(_getTokenAddressKey(symbol));     }      function tokenFrozen(string memory) external pure override returns (bool) {         return false;     }      function isCommandExecuted(bytes32 commandId) public view override returns (bool) {         return getBool(_getIsCommandExecutedKey(commandId));     }`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L56#L61 :      `  function addressForNativeDeposit(         bytes32 salt,         address refundAddress,         string calldata destinationChain,         string calldata destinationAddress     ) public view returns (address) {`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L241 :       'function contractId() public pure returns (bytes32) {'  4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L41#L47 :      `    function wrappedToken() public view returns (address) {         return IAxelarGateway(gateway).tokenAddresses(wrappedSymbol());     }      // @dev Converts bytes32 from immutable storage into a string     function wrappedSymbol() public view returns (string memory symbol) {         bytes32 symbolData = wrappedSymbolBytes;`  5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L30#L32 :       'function gateway() public view override returns (IAxelarGateway) {         return IAxelarGateway(gatewayAddress);     }'  6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L40#L42 :       '   function contractId() public pure returns (bytes32) {         return keccak256('xc20-wrapper');     }'               #  [N-07] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L5 :      `interface IDepositBase {`                   #  [N-08] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L4 :      ` uint8 internal constant OLD_KEY_RETENTION = 16;`             #  [N-09] Use a more recent version of solidity :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L1 :      `// SPDX-License-Identifier: MIT`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L1 :      `// SPDX-License-Identifier: MIT`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L1 :       '// SPDX-License-Identifier: MIT'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasServiceProxy.sol#L1 :      `// SPDX-License-Identifier: MIT`  5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuth.sol#L1 :      `// SPDX-License-Identifier: MIT`       6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L1 :      `// SPDX-License-Identifier: MIT`  7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol#L1 :       '// SPDX-License-Identifier: MIT'       8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L1 :      `// SPDX-License-Identifier: MIT`             9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L1 :      `// SPDX-License-Identifier: MIT`       10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L1 :      `// SPDX-License-Identifier: MIT`  11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L1 :       '// SPDX-License-Identifier: MIT'       12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L1 :      `// SPDX-License-Identifier: MIT`  13. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L1 :      `// SPDX-License-Identifier: MIT`       14. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L1 :      `// SPDX-License-Identifier: MIT`  15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L1 :       '// SPDX-License-Identifier: MIT' 
**AxelarGasServiceProxy** - L6 - The IUpgradable interface is imported but is never used.  **DepositBase** - L7 - The IWETH9 interface is imported but is never used.  
# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/a1205d2ba78e0db583d136f8563e8097860a110f/xc20/contracts/XC20Wrapper.sol#L66   # Vulnerability details  ## Impact An owner can call `removeWrapping`, even if there are still circulating wrapped tokens. This will cause the unwrapping of those tokens to fail, as `unwrapped[wrappedToken]` will be `addres(0)`.  ## Recommended Mitigation Steps Track how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap.
# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L268 https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L311   # Vulnerability details  ## Impact According to the specifications, only the current operators should be able to transfer operatorship. However, there is one way to circumvent this. Because currentOperators is not updated in the loop, when multiple `transferOperatorship` commands are submitted in the same `execute` call, all will succeed. After the first one, the operators that signed these commands are no longer the current operators, but the call will still succeed.  This also means that one set of operators could submit so many `transferOperatorship` commands in one `execute` call that `OLD_KEY_RETENTION` is reached for all other ones, meaning they would control complete set of currently valid operators.  ## Recommended Mitigation Steps Set `currentOperators` to `false` when the operators were changed.
- In `refundTokenDeposit` within `AxelarDepositService`, the address of the `gatewayToken` is retrieved in every loop iteration (https://github.com/code-423n4/2022-07-axelar/blob/a46fa61e73dd0f3469c0263bc6818e682d62fb5f/contracts/deposit-service/AxelarDepositService.sol#L115). However, as this address does not change, the retrieval can be moved outside of the loop to save a lot of gas when the number of tokens is large. - In multiple for loops, the loop iteration can be marked as `unchecked` because an overflow is not possible (as the iterator is bounded): ``` ./auth/AxelarAuthWeighted.sol:        for (uint256 i; i < recentOperators.length; ++i) { ./auth/AxelarAuthWeighted.sol:        for (uint256 i = 0; i < weightsLength; ++i) { ./auth/AxelarAuthWeighted.sol:        for (uint256 i = 0; i < signatures.length; ++i) { ./auth/AxelarAuthWeighted.sol:            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {} ./auth/AxelarAuthWeighted.sol:        for (uint256 i; i < accounts.length - 1; ++i) { ./gas-service/AxelarGasService.sol:        for (uint256 i; i < tokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ```
 ## Change if -> revert pattern to require  Change if -> revert pattern to 'require' to save gas and improve code quality, if (some_condition) {          revert(revert_message)  }  to: require(!some_condition, revert_message)  In the following locations:  ### Code instance:          DepositReceiver.sol, 17    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-07-axelar/tree/main/contracts/Ownable.sol#L12    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          AdminMultisigBase.sol, _adminEpoch         AxelarGateway.sol, _setTokenDailyMintAmount         AdminMultisigBase.sol, _getVoteCount         AdminMultisigBase.sol, _hasVoted   ## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instances:          gateway in IAxelarExecutable.sol         DOMAIN_SEPARATOR in ERC20Permit.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instance:          DepositBase.sol, refundToken    ## Unnecessary array boundaries check when loading an array element twice       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:       ### Code instance:          AxelarAuthWeighted.sol._isSortedAscAndContainsNoDuplicate - double load of accounts[i]    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          AxelarAuthWeighted.sol, recentOperators, 17         AxelarDepositService.sol, refundTokens, 168         AxelarDepositService.sol, refundTokens, 204         AxelarGasService.sol, tokens, 123         AxelarAuthWeighted.sol, signatures, 98         AxelarGateway.sol, symbols, 207         AxelarDepositService.sol, refundTokens, 114    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instances:          change to prefix increment and unchecked: AxelarGasService.sol, i, 123         change to prefix increment and unchecked: AxelarGateway.sol, i, 207         just change to unchecked: AxelarAuthWeighted.sol, i, 69         just change to unchecked: AxelarAuthWeighted.sol, i, 98         just change to unchecked: AxelarAuthWeighted.sol, i, 17         just change to unchecked: AxelarGateway.sol, i, 195         change to prefix increment and unchecked: AxelarDepositService.sol, i, 114         just change to unchecked: AxelarAuthWeighted.sol, i, 116         just change to unchecked: AxelarGateway.sol, i, 292         just change to unchecked: AdminMultisigBase.sol, i, 158         change to prefix increment and unchecked: AxelarDepositService.sol, i, 168         change to prefix increment and unchecked: AxelarDepositService.sol, i, 204         just change to unchecked: AdminMultisigBase.sol, i, 51    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instances:          AxelarAuthWeighted.sol, 98         AxelarGateway.sol, 207         AxelarAuthWeighted.sol, 69    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          AxelarDepositService.sol, 165: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 71: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 23: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 51: change 'balance > 0' to 'balance != 0' 
#  [G-01] State variables only set in the constructor should be declared immutable:-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L23 :        `bytes32 public xc20Codehash;`                  #  [G-02] `x = x + y` is cheaper than `x += y` :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L70 :        `totalWeight += newWeights[i];`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L105:        `weight += weights[operatorIndex];`     #  [G-03] <array>.length should not be looked up in every loop of a for-loop :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123 :        `for (uint256 i; i < tokens.length; i++) {`          3. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L114 :        `for (uint256 i; i < refundTokens.length; i++) {`    4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168 :        `for (uint256 i; i < refundTokens.length; i++) {`    5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L204 :        `for (uint256 i; i < refundTokens.length; i++) {`    6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L17 :        `for (uint256 i; i < recentOperators.length; ++i) {`          7. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :        ` for (uint256 i; i < accounts.length - 1; ++i) {`      #  [G-04] Use prefix not postfix in loops (Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.) :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123 :        `for (uint256 i; i < tokens.length; i++) {`          3. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L114 :        `for (uint256 i; i < refundTokens.length; i++) {`    4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168 :        `for (uint256 i; i < refundTokens.length; i++) {`    5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L204 :        `for (uint256 i; i < refundTokens.length; i++) {`    6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L17 :        `for (uint256 i; i < recentOperators.length; ++i) {`          7. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :        ` for (uint256 i; i < accounts.length - 1; ++i) {`          9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L195 :        `for (uint256 i; i < adminCount; ++i) {`    10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L292 :        `ffor (uint256 i; i < commandsLength; ++i) {`          11. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L69 :        `for (uint256 i = 0; i < weightsLength; ++i) {`                   #  [G-05] Not using the named return variables when a function returns, wastes deployment gas :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L182 :        `return _adminEpoch();`               #  [G-06] It costs more gas to initialize variables to zero than to let the default of zero be applied :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :         4. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L69 :        `for (uint256 i = 0; i < weightsLength; ++i) {`                        #  [G-07] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L14 :        `uint8 internal constant OLD_KEY_RETENTION = 16;`                #  [G-08] Expressions for constant values such as a call to keccak256(), should use immutable rather than constant :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L30#L43 :        `bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');     bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');     bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');     bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');     bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');     bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');     bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');      bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');     bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');     bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');     bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');     bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');     bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');`              #  [G-09] Use custom errors rather than revert()/require() strings to save deployment gas :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L55#L58 :        ` revert('NotAxelarToken()');         revert('NotXc20Token()');         revert('AlreadyWrappingAxelarToken()');         revert('AlreadyWrappingXC20Token()');`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L60#L61 :        `revert('NotOwner()');        revert('CannotSetMetadata()');`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L68 :         'revert('NotAxelarToken()');'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L70 :        `revert('NotWrappingToken()');`    1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L78#L79 :        `revert('NotAxelarToken()');        revert('CannotMint()');`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L84#L86 :        `revert('NotXc20Token()');        revert('InsufficientBalance()');        revert('CannotBurn()');`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L98 :         'revert('TransferFailed()');'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L111 :        `revert('TransferFailed()');`         #  [G-09] Functions guaranteed to revert when called by normal users can be marked payable (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.) :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L204 :        ` function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L217#L221 :        `function upgrade(         address newImplementation,         bytes32 newImplementationCodeHash,         bytes calldata setupParams     ) external override onlyAdmin {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L331 :         'function deployToken(bytes calldata params, bytes32) external onlySelf {'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L367 :        `function mintToken(bytes calldata params, bytes32) external onlySelf {`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L373 :        `function burnToken(bytes calldata params, bytes32) external onlySelf {`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L397 :        `function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L411 :         'function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {'         8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L437 :        `function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {`               9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L120 :        `function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {`          10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L136#L140 :        `function refund(         address payable receiver,         address token,         uint256 amount     ) external onlyOwner {`    11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L47 :         'function transferOperatorship(bytes calldata params) external onlyOwner {'         12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L44 :        `function setXc20Codehash(bytes32 newCodehash) external onlyOwner {`    13. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L48#L53 :        ` function addWrapping(         string calldata symbol,         address xc20Token,         string memory newName,         string memory newSymbol     ) external payable onlyOwner {`          14. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L66 :        `function removeWrapping(string calldata symbol) external onlyOwner {`    15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L411 :         'function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {'         16. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L437 :        `function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {`             #  [G-10] Use a more recent version of solidity :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L3 :        `pragma solidity 0.8.9;`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L3 :        `pragma solidity 0.8.9;`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L3 :         'pragma solidity 0.8.9;'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasServiceProxy.sol#L3 :        `pragma solidity 0.8.9;`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuth.sol#L3 :        `pragma solidity 0.8.9;`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L3 :        `pragma solidity 0.8.9;`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol#L3 :         'pragma solidity 0.8.9;'         8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L3 :        `pragma solidity 0.8.9;`               9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L3 :        `pragma solidity 0.8.9;`          10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L3 :        `pragma solidity 0.8.9;`    11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L3 :         'pragma solidity 0.8.9;'         12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L3 :        `pragma solidity 0.8.9;`    13. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L3 :        `pragma solidity 0.8.9;`          14. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L3 :        `pragma solidity 0.8.9;`    15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L3 :         'pragma solidity 0.8.9;'          #  [G-11]  `internal` functions only called once can be inlined to save gas :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L460 :        `function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L465#L469 :        `function _mintToken(         string memory symbol,         address account,         uint256 amount     ) internal {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L485#L489 :         'function _burnTokenFrom(         address sender,         string memory symbol,         uint256 amount     ) internal {'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L539#L557 :        `function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));     }      function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));     }      function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));     }      function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));     }      function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));     }`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L559#L658 :        ` function _getIsContractCallApprovedKey(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash     ) internal pure returns (bytes32) {         return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));     }      function _getIsContractCallApprovedWithMintKey(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash,         string memory symbol,         uint256 amount     ) internal pure returns (bytes32) {         return             keccak256(                 abi.encode(                     PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,                     commandId,                     sourceChain,                     sourceAddress,                     contractAddress,                     payloadHash,                     symbol,                     amount                 )             );     }      /********************\     |* Internal Getters *|     \********************/      function _getTokenType(string memory symbol) internal view returns (TokenType) {         return TokenType(getUint(_getTokenTypeKey(symbol)));     }      /********************\     |* Internal Setters *|     \********************/      function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {         _setUint(_getTokenDailyMintLimitKey(symbol), limit);          emit TokenDailyMintLimitUpdated(symbol, limit);     }      function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {         uint256 limit = tokenDailyMintLimit(symbol);         if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);          _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);     }      function _setTokenType(string memory symbol, TokenType tokenType) internal {         _setUint(_getTokenTypeKey(symbol), uint256(tokenType));     }      function _setTokenAddress(string memory symbol, address tokenAddress) internal {         _setAddress(_getTokenAddressKey(symbol), tokenAddress);     }      function _setCommandExecuted(bytes32 commandId, bool executed) internal {         _setBool(_getIsCommandExecutedKey(commandId), executed);     }      function _setContractCallApproved(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash     ) internal {         _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);     }      function _setContractCallApprovedWithMint(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash,         string memory symbol,         uint256 amount     ) internal {         _setBool(             _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),             true         );     }      function _setImplementation(address newImplementation) internal {         _setAddress(KEY_IMPLEMENTATION, newImplementation);     } }`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L150#L154 :        `function _safeTransfer(         address tokenAddress,         address receiver,         uint256 amount     ) internal {`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L164#L168 :         'function _safeTransferFrom(         address tokenAddress,         address from,         uint256 amount     ) internal {'             #  [G-12]  Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L20#L21 :        `mapping(address => address) public wrapped;        mapping(address => address) public unwrapped;`           #  [G-13] Empty blocks should be removed or emit something :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29 :        `receive() external payable {}`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13 :        `receive() external payable override {}`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L12 :         'constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {}'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101 :        `for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}`       
# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L128 https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L144 https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L158   # Vulnerability details   # Vulnerability details   ## Impact The use of the deprecated transfer() function for an address will inevitably make the transaction fail when:  The claimer smart contract does not implement a payable function. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the callâ€™s gas usage above 2300. Additionally, using higher than 2300 gas might be mandatory for some multisig wallets. Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time. The impact would mean that any contracts receiving funds would potentially be unable to retrieve funds from the swap.  ## Recommended Mitigation Steps use call() to send eth , re-entrancy has been accounted for in all functions that reference Solidity's transfer() . This has been done by using a re-entrancy guard, therefore, we can rely on msg.sender.call.value(amount)` or using the OpenZeppelin Address.sendValue library   Relevant links: https://github.com/code-423n4/2021-04-meebits-findings/issues/2 https://twitter.com/hacxyk/status/1520715516490379264?s=21&t=fnhDkcC3KpE_kJE8eLiE2A https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/
## [NAZ-L1] `receive()` Function Should Emit An Event **Severity**: Low **Context**: [`DepositReceiver.sol#L29`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29), [`AxelarDepositServiceProxy.sol#L13`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13)  **Description**: Consider emitting an event inside this function with `msg.sender` and `msg.value` as the parameters. This would make it easier to track incoming ether transfers.  **Recommendation**: Add events to the `receive()` functions.    ## [NAZ-L2] Local Variable Shadowing **Severity**: Low **Context**: [`AxelarDepositService.sol#L19 (both gateway && wrappedSymbol)`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L19)  **Description**: These Variables shadow state variables. As a result, the use of them locally might be incorrect.  **Recommendation**: Rename the local variables that shadow another component.   ## [NAZ-N1] Code Contains Empty Blocks **Severity** Informational **Context**: [`AxelarDepositServiceProxy.sol#L13`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13), [`AxelarAuthWeighted.sol#L101`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101)  **Description**: It's best practice that when there is an empty block, to add a comment in the block exmplaining why it's empty.  **Recommendation**: Consider adding `/* Comment on why */` to the empty block.   ## [NAZ-N2] Variable Naming Convention **Severity** Informational **Context**: [`AxelarGateway.sol#L45-L46`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L45-L46)  **Description**: The linked variables do not conform to the standard naming convention of Solidity whereby functions and variable names(local, state and immutable) utilize the `mixedCase` format unless variables are declared as `constant` in which case they utilize the `UPPER_CASE_WITH_UNDERSCORES` format.  **Recommendation**: Naming conventions utilized by the linked statements are adjusted to reflect the correcttype of declaration according to the Solidity style guide.   ## [NAZ-N3] Missing Use of `solhint-disable-next-line` **Severity**: Informational **Context**:[`AxelarGateway.sol#L157`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L157), [`AxelarGateway.sol#L229`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L229), [`AxelarGateway.sol#L320`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L320), [`AxelarGateway.sol#L344`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L344), [`AxelarGateway.sol#L461`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L461), [`AxelarGateway.sol#L615`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L615), [`AxelarAuthWeighted.sol#L101`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101)  **Description**: `solhint-disable-next-line` is used elsewhere for small linter errors and can be used here to disable these errors.  **Recommendation**: Consider adding `solhint-disable-next-line`.   ## [NAZ-N4] Commented Out Code **Severity**: Informational **Context**: [`AxelarGateway.sol#L22-L24`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L22-L24)  **Description**: There is commented code that makes the code messy and unneeded.   **Recommendation**: Remove the commented out code.   ## [NAZ-N5] Floating Pragma **Severity**: Informational **Context**: [`IAxelarGasService.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol), [`IAxelarDepositService.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol), [`IAxelarAuthWeighted.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol), [`IDepositBase.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol)  **Description**: Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  **Recommendation**:  Lock the pragma version.   ## [NAZ-N6] Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-07-axelar)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.
#  [L-01] Unused `receive()` function will lock Ether in contract :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29 :      `receive() external payable {}`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13 :      `receive() external payable override {}`           #  [L-02] Missing checks for `address(0x0)` when assigning values to address state variables :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L37 :        `xc20Codehash = codehash_;`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L45 :        `xc20Codehash = newCodehash;`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L52 :         'AUTH_MODULE = authModule;'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L53 :        `TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L24 :        `gateway = gateway_;`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L27 :        `gatewayAddress = gatewayAddress_;`        #  [L-03] address.call{value:x}() should be used instead of payable.transfer() :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L63 :        `payable(msg.sender).transfer(address(this).balance);`          #  [L-04] approve should be replaced with safeApprove or safeIncreaseAllowance() / safeDecreaseAllowance() :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L30 :        `IERC20(wrappedTokenAddress).approve(gateway, amount);`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L38 :        `IERC20(tokenAddress).approve(gateway, amount);`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L64 :         'IERC20(wrappedTokenAddress).approve(gateway, amount);'                #  [L-05] Low level calls donâ€™t check for contract existence :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L320 :        `(bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L460#L463 :        `function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {         (bool success, bytes memory returnData) = tokenAddress.call(callData);         return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));     }`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L158 :         '(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L172#L174 :        `(bool success, bytes memory returnData) = tokenAddress.call(             abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)         );`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L71 :        `(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L95 :        `(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));`    7. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L106#L108 :        `(bool success, bytes memory returnData) = tokenAddress.call(             abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)         );`               #  [L-06] an unbounded loop on array can lead to DoS :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123L#124 :        `for (uint256 i; i < tokens.length; i++) {             address token = tokens[i];`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168#L169 :        `for (uint256 i; i < refundTokens.length; i++) {             refundToken = refundTokens[i];`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116#L120 :         'for (uint256 i; i < accounts.length - 1; ++i) {             if (accounts[i] >= accounts[i + 1]) {                 return false;             }         }'                 #  [N-01] Adding a return statement when the function defines a named return variable, is redundant:-   1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L182 :      `return _adminEpoch();`          #  [N-02] require()/revert() statements should have descriptive reason strings :-   1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L55#L58 :      ` revert('NotAxelarToken()');       revert('NotXc20Token()');       revert('AlreadyWrappingAxelarToken()');       revert('AlreadyWrappingXC20Token()');`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L60#L61 :      `revert('NotOwner()');      revert('CannotSetMetadata()');`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L68 :       'revert('NotAxelarToken()');'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L70 :      `revert('NotWrappingToken()');`  1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L78#L79 :      `revert('NotAxelarToken()');      revert('CannotMint()');`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L84#L86 :      `revert('NotXc20Token()');      revert('InsufficientBalance()');      revert('CannotBurn()');`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L98 :       'revert('TransferFailed()');'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L111 :      `revert('TransferFailed()');`         #  [N-03] Use a more recent version of solidity (Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`) :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L3 :      `pragma solidity 0.8.9;`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L3 :      `pragma solidity 0.8.9;`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L3 :       'pragma solidity 0.8.9;'                #  [N-04] Event is missing indexed fields (Each `event` should use three `indexed` fields if there are three or more fields) :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L13#L57 :      `    event GasPaidForContractCall(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         address gasToken,         uint256 gasFeeAmount,         address refundAddress     );      event GasPaidForContractCallWithToken(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         string symbol,         uint256 amount,         address gasToken,         uint256 gasFeeAmount,         address refundAddress     );      event NativeGasPaidForContractCall(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         uint256 gasFeeAmount,         address refundAddress     );      event NativeGasPaidForContractCallWithToken(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         string symbol,         uint256 amount,         uint256 gasFeeAmount,         address refundAddress     );      event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);      event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L14 :      `event OperatorshipTransferred(address[] newOperators, uint256[] newWeights, uint256 newThreshold);`        #  [N-05] Use of sensitive/non-inclusive terms :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L496 :      `bool burnSuccess;`                   #  [N-06] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L152#L178 :      `    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {         return getUint(_getTokenDailyMintLimitKey(symbol));     }      function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {         return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));     }      function allTokensFrozen() external pure override returns (bool) {         return false;     }      function implementation() public view override returns (address) {         return getAddress(KEY_IMPLEMENTATION);     }      function tokenAddresses(string memory symbol) public view override returns (address) {         return getAddress(_getTokenAddressKey(symbol));     }      function tokenFrozen(string memory) external pure override returns (bool) {         return false;     }      function isCommandExecuted(bytes32 commandId) public view override returns (bool) {         return getBool(_getIsCommandExecutedKey(commandId));     }`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L56#L61 :      `  function addressForNativeDeposit(         bytes32 salt,         address refundAddress,         string calldata destinationChain,         string calldata destinationAddress     ) public view returns (address) {`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L241 :       'function contractId() public pure returns (bytes32) {'  4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L41#L47 :      `    function wrappedToken() public view returns (address) {         return IAxelarGateway(gateway).tokenAddresses(wrappedSymbol());     }      // @dev Converts bytes32 from immutable storage into a string     function wrappedSymbol() public view returns (string memory symbol) {         bytes32 symbolData = wrappedSymbolBytes;`  5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L30#L32 :       'function gateway() public view override returns (IAxelarGateway) {         return IAxelarGateway(gatewayAddress);     }'  6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L40#L42 :       '   function contractId() public pure returns (bytes32) {         return keccak256('xc20-wrapper');     }'               #  [N-07] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L5 :      `interface IDepositBase {`                   #  [N-08] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L4 :      ` uint8 internal constant OLD_KEY_RETENTION = 16;`             #  [N-09] Use a more recent version of solidity :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L1 :      `// SPDX-License-Identifier: MIT`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L1 :      `// SPDX-License-Identifier: MIT`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L1 :       '// SPDX-License-Identifier: MIT'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasServiceProxy.sol#L1 :      `// SPDX-License-Identifier: MIT`  5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuth.sol#L1 :      `// SPDX-License-Identifier: MIT`       6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L1 :      `// SPDX-License-Identifier: MIT`  7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol#L1 :       '// SPDX-License-Identifier: MIT'       8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L1 :      `// SPDX-License-Identifier: MIT`             9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L1 :      `// SPDX-License-Identifier: MIT`       10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L1 :      `// SPDX-License-Identifier: MIT`  11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L1 :       '// SPDX-License-Identifier: MIT'       12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L1 :      `// SPDX-License-Identifier: MIT`  13. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L1 :      `// SPDX-License-Identifier: MIT`       14. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L1 :      `// SPDX-License-Identifier: MIT`  15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L1 :       '// SPDX-License-Identifier: MIT' 
**AxelarGasServiceProxy** - L6 - The IUpgradable interface is imported but is never used.  **DepositBase** - L7 - The IWETH9 interface is imported but is never used.  
# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/a1205d2ba78e0db583d136f8563e8097860a110f/xc20/contracts/XC20Wrapper.sol#L66   # Vulnerability details  ## Impact An owner can call `removeWrapping`, even if there are still circulating wrapped tokens. This will cause the unwrapping of those tokens to fail, as `unwrapped[wrappedToken]` will be `addres(0)`.  ## Recommended Mitigation Steps Track how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap.
# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L268 https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L311   # Vulnerability details  ## Impact According to the specifications, only the current operators should be able to transfer operatorship. However, there is one way to circumvent this. Because currentOperators is not updated in the loop, when multiple `transferOperatorship` commands are submitted in the same `execute` call, all will succeed. After the first one, the operators that signed these commands are no longer the current operators, but the call will still succeed.  This also means that one set of operators could submit so many `transferOperatorship` commands in one `execute` call that `OLD_KEY_RETENTION` is reached for all other ones, meaning they would control complete set of currently valid operators.  ## Recommended Mitigation Steps Set `currentOperators` to `false` when the operators were changed.
- In `refundTokenDeposit` within `AxelarDepositService`, the address of the `gatewayToken` is retrieved in every loop iteration (https://github.com/code-423n4/2022-07-axelar/blob/a46fa61e73dd0f3469c0263bc6818e682d62fb5f/contracts/deposit-service/AxelarDepositService.sol#L115). However, as this address does not change, the retrieval can be moved outside of the loop to save a lot of gas when the number of tokens is large. - In multiple for loops, the loop iteration can be marked as `unchecked` because an overflow is not possible (as the iterator is bounded): ``` ./auth/AxelarAuthWeighted.sol:        for (uint256 i; i < recentOperators.length; ++i) { ./auth/AxelarAuthWeighted.sol:        for (uint256 i = 0; i < weightsLength; ++i) { ./auth/AxelarAuthWeighted.sol:        for (uint256 i = 0; i < signatures.length; ++i) { ./auth/AxelarAuthWeighted.sol:            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {} ./auth/AxelarAuthWeighted.sol:        for (uint256 i; i < accounts.length - 1; ++i) { ./gas-service/AxelarGasService.sol:        for (uint256 i; i < tokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ```
 ## Change if -> revert pattern to require  Change if -> revert pattern to 'require' to save gas and improve code quality, if (some_condition) {          revert(revert_message)  }  to: require(!some_condition, revert_message)  In the following locations:  ### Code instance:          DepositReceiver.sol, 17    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-07-axelar/tree/main/contracts/Ownable.sol#L12    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          AdminMultisigBase.sol, _adminEpoch         AxelarGateway.sol, _setTokenDailyMintAmount         AdminMultisigBase.sol, _getVoteCount         AdminMultisigBase.sol, _hasVoted   ## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instances:          gateway in IAxelarExecutable.sol         DOMAIN_SEPARATOR in ERC20Permit.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instance:          DepositBase.sol, refundToken    ## Unnecessary array boundaries check when loading an array element twice       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:       ### Code instance:          AxelarAuthWeighted.sol._isSortedAscAndContainsNoDuplicate - double load of accounts[i]    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          AxelarAuthWeighted.sol, recentOperators, 17         AxelarDepositService.sol, refundTokens, 168         AxelarDepositService.sol, refundTokens, 204         AxelarGasService.sol, tokens, 123         AxelarAuthWeighted.sol, signatures, 98         AxelarGateway.sol, symbols, 207         AxelarDepositService.sol, refundTokens, 114    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instances:          change to prefix increment and unchecked: AxelarGasService.sol, i, 123         change to prefix increment and unchecked: AxelarGateway.sol, i, 207         just change to unchecked: AxelarAuthWeighted.sol, i, 69         just change to unchecked: AxelarAuthWeighted.sol, i, 98         just change to unchecked: AxelarAuthWeighted.sol, i, 17         just change to unchecked: AxelarGateway.sol, i, 195         change to prefix increment and unchecked: AxelarDepositService.sol, i, 114         just change to unchecked: AxelarAuthWeighted.sol, i, 116         just change to unchecked: AxelarGateway.sol, i, 292         just change to unchecked: AdminMultisigBase.sol, i, 158         change to prefix increment and unchecked: AxelarDepositService.sol, i, 168         change to prefix increment and unchecked: AxelarDepositService.sol, i, 204         just change to unchecked: AdminMultisigBase.sol, i, 51    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instances:          AxelarAuthWeighted.sol, 98         AxelarGateway.sol, 207         AxelarAuthWeighted.sol, 69    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          AxelarDepositService.sol, 165: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 71: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 23: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 51: change 'balance > 0' to 'balance != 0' 
#  [G-01] State variables only set in the constructor should be declared immutable:-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L23 :        `bytes32 public xc20Codehash;`                  #  [G-02] `x = x + y` is cheaper than `x += y` :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L70 :        `totalWeight += newWeights[i];`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L105:        `weight += weights[operatorIndex];`     #  [G-03] <array>.length should not be looked up in every loop of a for-loop :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123 :        `for (uint256 i; i < tokens.length; i++) {`          3. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L114 :        `for (uint256 i; i < refundTokens.length; i++) {`    4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168 :        `for (uint256 i; i < refundTokens.length; i++) {`    5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L204 :        `for (uint256 i; i < refundTokens.length; i++) {`    6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L17 :        `for (uint256 i; i < recentOperators.length; ++i) {`          7. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :        ` for (uint256 i; i < accounts.length - 1; ++i) {`      #  [G-04] Use prefix not postfix in loops (Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.) :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123 :        `for (uint256 i; i < tokens.length; i++) {`          3. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L114 :        `for (uint256 i; i < refundTokens.length; i++) {`    4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168 :        `for (uint256 i; i < refundTokens.length; i++) {`    5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L204 :        `for (uint256 i; i < refundTokens.length; i++) {`    6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L17 :        `for (uint256 i; i < recentOperators.length; ++i) {`          7. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :        ` for (uint256 i; i < accounts.length - 1; ++i) {`          9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L195 :        `for (uint256 i; i < adminCount; ++i) {`    10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L292 :        `ffor (uint256 i; i < commandsLength; ++i) {`          11. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L69 :        `for (uint256 i = 0; i < weightsLength; ++i) {`                   #  [G-05] Not using the named return variables when a function returns, wastes deployment gas :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L182 :        `return _adminEpoch();`               #  [G-06] It costs more gas to initialize variables to zero than to let the default of zero be applied :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :         4. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L69 :        `for (uint256 i = 0; i < weightsLength; ++i) {`                        #  [G-07] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L14 :        `uint8 internal constant OLD_KEY_RETENTION = 16;`                #  [G-08] Expressions for constant values such as a call to keccak256(), should use immutable rather than constant :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L30#L43 :        `bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');     bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');     bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');     bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');     bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');     bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');     bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');      bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');     bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');     bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');     bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');     bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');     bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');`              #  [G-09] Use custom errors rather than revert()/require() strings to save deployment gas :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L55#L58 :        ` revert('NotAxelarToken()');         revert('NotXc20Token()');         revert('AlreadyWrappingAxelarToken()');         revert('AlreadyWrappingXC20Token()');`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L60#L61 :        `revert('NotOwner()');        revert('CannotSetMetadata()');`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L68 :         'revert('NotAxelarToken()');'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L70 :        `revert('NotWrappingToken()');`    1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L78#L79 :        `revert('NotAxelarToken()');        revert('CannotMint()');`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L84#L86 :        `revert('NotXc20Token()');        revert('InsufficientBalance()');        revert('CannotBurn()');`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L98 :         'revert('TransferFailed()');'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L111 :        `revert('TransferFailed()');`         #  [G-09] Functions guaranteed to revert when called by normal users can be marked payable (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.) :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L204 :        ` function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L217#L221 :        `function upgrade(         address newImplementation,         bytes32 newImplementationCodeHash,         bytes calldata setupParams     ) external override onlyAdmin {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L331 :         'function deployToken(bytes calldata params, bytes32) external onlySelf {'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L367 :        `function mintToken(bytes calldata params, bytes32) external onlySelf {`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L373 :        `function burnToken(bytes calldata params, bytes32) external onlySelf {`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L397 :        `function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L411 :         'function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {'         8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L437 :        `function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {`               9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L120 :        `function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {`          10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L136#L140 :        `function refund(         address payable receiver,         address token,         uint256 amount     ) external onlyOwner {`    11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L47 :         'function transferOperatorship(bytes calldata params) external onlyOwner {'         12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L44 :        `function setXc20Codehash(bytes32 newCodehash) external onlyOwner {`    13. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L48#L53 :        ` function addWrapping(         string calldata symbol,         address xc20Token,         string memory newName,         string memory newSymbol     ) external payable onlyOwner {`          14. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L66 :        `function removeWrapping(string calldata symbol) external onlyOwner {`    15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L411 :         'function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {'         16. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L437 :        `function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {`             #  [G-10] Use a more recent version of solidity :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L3 :        `pragma solidity 0.8.9;`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L3 :        `pragma solidity 0.8.9;`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L3 :         'pragma solidity 0.8.9;'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasServiceProxy.sol#L3 :        `pragma solidity 0.8.9;`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuth.sol#L3 :        `pragma solidity 0.8.9;`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L3 :        `pragma solidity 0.8.9;`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol#L3 :         'pragma solidity 0.8.9;'         8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L3 :        `pragma solidity 0.8.9;`               9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L3 :        `pragma solidity 0.8.9;`          10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L3 :        `pragma solidity 0.8.9;`    11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L3 :         'pragma solidity 0.8.9;'         12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L3 :        `pragma solidity 0.8.9;`    13. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L3 :        `pragma solidity 0.8.9;`          14. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L3 :        `pragma solidity 0.8.9;`    15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L3 :         'pragma solidity 0.8.9;'          #  [G-11]  `internal` functions only called once can be inlined to save gas :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L460 :        `function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L465#L469 :        `function _mintToken(         string memory symbol,         address account,         uint256 amount     ) internal {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L485#L489 :         'function _burnTokenFrom(         address sender,         string memory symbol,         uint256 amount     ) internal {'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L539#L557 :        `function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));     }      function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));     }      function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));     }      function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));     }      function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));     }`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L559#L658 :        ` function _getIsContractCallApprovedKey(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash     ) internal pure returns (bytes32) {         return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));     }      function _getIsContractCallApprovedWithMintKey(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash,         string memory symbol,         uint256 amount     ) internal pure returns (bytes32) {         return             keccak256(                 abi.encode(                     PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,                     commandId,                     sourceChain,                     sourceAddress,                     contractAddress,                     payloadHash,                     symbol,                     amount                 )             );     }      /********************\     |* Internal Getters *|     \********************/      function _getTokenType(string memory symbol) internal view returns (TokenType) {         return TokenType(getUint(_getTokenTypeKey(symbol)));     }      /********************\     |* Internal Setters *|     \********************/      function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {         _setUint(_getTokenDailyMintLimitKey(symbol), limit);          emit TokenDailyMintLimitUpdated(symbol, limit);     }      function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {         uint256 limit = tokenDailyMintLimit(symbol);         if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);          _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);     }      function _setTokenType(string memory symbol, TokenType tokenType) internal {         _setUint(_getTokenTypeKey(symbol), uint256(tokenType));     }      function _setTokenAddress(string memory symbol, address tokenAddress) internal {         _setAddress(_getTokenAddressKey(symbol), tokenAddress);     }      function _setCommandExecuted(bytes32 commandId, bool executed) internal {         _setBool(_getIsCommandExecutedKey(commandId), executed);     }      function _setContractCallApproved(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash     ) internal {         _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);     }      function _setContractCallApprovedWithMint(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash,         string memory symbol,         uint256 amount     ) internal {         _setBool(             _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),             true         );     }      function _setImplementation(address newImplementation) internal {         _setAddress(KEY_IMPLEMENTATION, newImplementation);     } }`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L150#L154 :        `function _safeTransfer(         address tokenAddress,         address receiver,         uint256 amount     ) internal {`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L164#L168 :         'function _safeTransferFrom(         address tokenAddress,         address from,         uint256 amount     ) internal {'             #  [G-12]  Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L20#L21 :        `mapping(address => address) public wrapped;        mapping(address => address) public unwrapped;`           #  [G-13] Empty blocks should be removed or emit something :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29 :        `receive() external payable {}`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13 :        `receive() external payable override {}`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L12 :         'constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {}'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101 :        `for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {}`       
# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L128 https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L144 https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L158   # Vulnerability details   # Vulnerability details   ## Impact The use of the deprecated transfer() function for an address will inevitably make the transaction fail when:  The claimer smart contract does not implement a payable function. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the callâ€™s gas usage above 2300. Additionally, using higher than 2300 gas might be mandatory for some multisig wallets. Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time. The impact would mean that any contracts receiving funds would potentially be unable to retrieve funds from the swap.  ## Recommended Mitigation Steps use call() to send eth , re-entrancy has been accounted for in all functions that reference Solidity's transfer() . This has been done by using a re-entrancy guard, therefore, we can rely on msg.sender.call.value(amount)` or using the OpenZeppelin Address.sendValue library   Relevant links: https://github.com/code-423n4/2021-04-meebits-findings/issues/2 https://twitter.com/hacxyk/status/1520715516490379264?s=21&t=fnhDkcC3KpE_kJE8eLiE2A https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/
