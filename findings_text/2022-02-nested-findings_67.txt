* function transfer in NestedReserve is never used and can only be called by the factory (onlyFactory), so consider removing it because I think the factory uses a withdraw function from the Reserve.  * Currently never used: ```solidity   function setReserve onlyFactory ``` You can remove it to save some gas, or leave it if it was intended for future use with other factories.  * functions that add or remove operators or shareholders iterate over the whole array, so you can consider using EnumerableSet to store them: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol  * Could just use msg.sender and do not call an owner() function here: ```solidity     function unlockTokens(IERC20 _token) external override onlyOwner {         ...         _token.safeTransfer(owner(), amount); ```  * There are several functions that call _checkMsgValue. This function is quite expensive as it iterates over all the _batchedOrders and is only relevant when the inputToken is ETH. Later the callers will have to iterate over all the _batchedOrders again anyway, so I think this function should be refactored to significantly reduce gas. My suggestion: because processInputOrders and processInputAndOutputOrders both call _processInputOrders, the logic from _checkMsgValue could be moved to _processInputOrders. function create then can be refactored to re-use _processInputOrders. I see 2 discrepancies here: _fromReserve is always false when _submitInOrders is called from create (could be solved if _processInputOrders takes extra parameter), and _processInputOrders has this extra line: ```solidity   require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); ``` but this could be solved if you first mint the NFT and then invoke _processInputOrders from create.  * function withdraw calls nestedRecords twice: ```solidity  uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);  ...   address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];  ```  I think it could just substitute these links by first fetching all the tokens, and then calculating the length itself instead of making 2 external calls for pretty much the same data.    * Could use 'unchecked' maths here, as underflow is not possible: ```solidity    if (_amountToSpend > amounts[1]) {       IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);     } ```
