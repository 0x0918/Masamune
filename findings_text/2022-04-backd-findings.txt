# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729   # Vulnerability details  ## Impact  A Staker -- that has their top-up position removed after `execute` is called by a Keeper -- can always cause the transaction to revert. They can do this by deploying a smart contract to the `payer` address that has implemented a `receive()` function that calls `revert()`. The revert will be triggered by the following [lines](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729) in `execute`  ```sol if (vars.removePosition) {     gasBank.withdrawUnused(payer); } ```  This will consume some gas from the keeper while preventing them accruing any rewards for performing the top-up action.  ## Proof of Concept  I have implemented a [PoC](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/tests/top_up_action/sseefried_test_staker_grief.py) in a fork of the contest repo. The attacker's contract can be found [here](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/contracts/AliceAttacker.sol).  ## Tools Used Manual inspection  ## Recommend Mitigation Steps  To prevent this denial of service attack some way of blacklisting badly behaved Stakers should be added.   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L50 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L721   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             "SafeERC20: approve from non-zero to non-zero allowance"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers can be prevented from `register()`ing the same `token`/`stakerVaultAddress` as another customer; and once changed away from, stakers and lptokens can't be used in the future.  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first.  `register()` calls `lockFunds()` for each user registration, and since users will use the same tokens and staker vaults, the second user's `register()` call will fail: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #1  36       function lockFunds( 37           address stakerVaultAddress, 38           address payer, 39           address token, 40           uint256 lockAmount, 41           uint256 depositAmount 42       ) external { 43           uint256 amountLeft = lockAmount; 44           IStakerVault stakerVault = IStakerVault(stakerVaultAddress); 45    46           // stake deposit amount 47           if (depositAmount > 0) { 48               depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount; 49               IERC20(token).safeTransferFrom(payer, address(this), depositAmount); 50               IERC20(token).safeApprove(stakerVaultAddress, depositAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L36-L50  The changing of either the staker or an lp token is behind a time-lock, and once the time has passed, the changed variables rely on this function: ```solidity File: backd/contracts/pool/LiquidityPool.sol   #2  717       function _approveStakerVaultSpendingLpTokens() internal { 718           address staker_ = address(staker); 719           address lpToken_ = address(lpToken); 720           if (staker_ == address(0) || lpToken_ == address(0)) return; 721           IERC20(lpToken_).safeApprove(staker_, type(uint256).max); 722       } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L717-L722  If a bug is found in a new `staker` or `lpToken` and the governor wishes to change back to the old one(s), the governor will have to wait for the time-lock delay only to find out that the old value(s) cause the code to revert.  I've filed the other more-severe instances as a separate high-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L71 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L120 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L53 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L847   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             "SafeERC20: approve from non-zero to non-zero allowance"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first. The instances below are all related to topping up.  Compound-specific top-ups will fail the second time around when approving the `ctoken` again: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1  50       function topUp( 51           bytes32 account, 52           address underlying, 53           uint256 amount, 54           bytes memory extra 55       ) external override returns (bool) { 56           bool repayDebt = abi.decode(extra, (bool)); 57           CToken ctoken = cTokenRegistry.fetchCToken(underlying); 58           uint256 initialTokens = ctoken.balanceOf(address(this)); 59    60           address addr = account.addr(); 61    62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } 66    67           uint256 err; 68           if (underlying == address(0)) { 69               err = ctoken.mint{value: amount}(amount); 70           } else { 71               IERC20(underlying).safeApprove(address(ctoken), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L50-L71  Compound-specific top-ups will also fail when trying to repay debt: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2  62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L62-L65  Aave-specific top-ups will fail for the `lendingPool`: ```solidity File: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3  36       function topUp( 37           bytes32 account, 38           address underlying, 39           uint256 amount, 40           bytes memory extra 41       ) external override returns (bool) { 42           bool repayDebt = abi.decode(extra, (bool)); 43           if (underlying == address(0)) { 44               weth.deposit{value: amount}(); 45               underlying = address(weth); 46           } 47    48           address addr = account.addr(); 49    50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying); 51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED); 52    53           IERC20(underlying).safeApprove(address(lendingPool), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L36-L53  The `TopUpAction` itself fails for the `feeHandler`: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #4  840       function _payFees( 841           address payer, 842           address beneficiary, 843           uint256 feeAmount, 844           address depositToken 845       ) internal { 846           address feeHandler = getFeeHandler(); 847           IERC20(depositToken).safeApprove(feeHandler, feeAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L840-L847  I've filed the other less-severe instances as a separate medium-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L56   # Vulnerability details  ## Impact The current code returns the following: ``` return (roundId_, (answer_ * _ethPrice()) / 1e8, startedAt_, updatedAt_, answeredInRound_); ``` If we're wrapping an asset that's relatively stable to eth price, the `answer` here might not be updated constantly. By returning the startedAt of the last answer update, it's possible that this answer be considered "stale" from the protocol.  ## Recommended Mitigation Steps  It's better to return the new `updatedAt_ ` at the greater of the two:   * `updatedAt_ ` from eth oracle,  * `updatedAt_ ` from the asset oracle  This way, if asset/eth is unchanged for a while, but there's a eth price move, we capture the correct `updatedAt` timestamp  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/access/RoleManager.sol#L155   # Vulnerability details  ## Impact The function doesn't remove the address from _roleMembers[role] set, which will mess up with the roleCount  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps ``` _roles[role].members[account] = false; _roleMembers[role].remove(account); ```  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252   # Vulnerability details  ## Impact The CvxCrvRewardsLocker contract swaps tokens through the CRV cvxCRV pool. But, it doesn't use any slippage checks. The swap is at risk of being frontrun / sandwiched which will result in a loss of funds.  Since MEV is very prominent I think the chance of that happening is pretty high.  ## Proof of Concept Here's the swap: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252  ## Tools Used none  ## Recommended Mitigation Steps Use a proper value for `minOut` instead of `0`.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345  ```solidity  function mint() external payable returns (uint256); ```  `mint()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  In the current implementation, the interface for `CToken` is used for both `CEther` and `CErc20`.  As a result, the transaction will revert with the error: `function returned an unexpected amount of data` when `topUp()` with the native token (ETH).  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint - Compound CEther.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L46 - Compound CErc20.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L46  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358  ```solidity function repayBorrowBehalf(address borrower, uint256 repayAmount)         external         payable         returns (uint256); ```  `repayBorrowBehalf()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  As a result, `ether.repayBorrowBehalf()` will always revert  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L117-L118  ```solidity     CEther cether = CEther(address(ctoken));     err = cether.repayBorrowBehalf{value: debt}(account); ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound cToken Repay Borrow Behalf doc: https://compound.finance/docs/ctokens#repay-borrow-behalf - Compound CEther.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L92-L95 - Compound CErc20.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L94-L97  
# Lines of code  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47   # Vulnerability details  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47  ```solidity function mint() external payable {     (uint err,) = mintInternal(msg.value);     requireNoError(err, "mint failed"); } ```  `mint()` for native cToken (`CEther`) does not have any parameters, as the `Function Selector` is based on `the function name with the parenthesised list of parameter types`, when you add a nonexisting `parameter`, the `Function Selector` will be incorrect.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L316  ```solidity     function mint(uint256 mintAmount) external payable virtual returns (uint256); ```  The current implementation uses the same `CToken` interface for both `CEther` and `CErc20` in `topUp()`, and `function mint(uint256 mintAmount)` is a nonexisting function for `CEther`.  As a result, the native token `topUp()` always revert.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  See also:  - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L38-L43 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L109-L114   # Vulnerability details  ## Impact in the setSlippageTolerance(L119) method you have certain requirements to set slippageTolerance, but in the constructor you don't.    ## Recommended Mitigation Steps I would add the corresponding validations to the constructor   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L154 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L187   # Vulnerability details  ## Impact The default swap slippage of 5% allows malicious keepers to sandwich attack topup. Additionally, up to 40% (_MIN_SWAPPER_SLIPPAGE) slippage allows malicious owner to sandwich huge amounts from topup  ## Proof of Concept Keeper can bundle swaps before and after topup to sandwich topup action, in fact it's actually in their best interest to do so.  ## Tools Used  ## Recommended Mitigation Steps Allow user to specify max swap slippage when creating topup similar to how it's specified on uniswap or sushiswap to block attacks from both keepers and owners  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L57-L65   # Vulnerability details  ## Impact In function TopUpActionLibrary.lockFunds when transfers stakes from payer it doesn't call stakerVault.increaseActionLockedBalance for that payer so stakerVault.actionLockedBalances[payer] is not get updated for payer and stakerVault.stakedAndActionLockedBalanceOf(payer) is going to show wrong value and any calculation based on this function is gonna be wrong which will cause fund lose and theft and some restriction bypasses.  ## Proof of Concept When user wants to create a TopUpAction. so he seposit his funds to Pool and get LP token. then stake the LP token in StakerVault and use that stakes to create a TopUp position with function TopUpAction.register. This function transfer user stakes (locks user staks) and create his position. for transferring and locking user stakes it uses TopUpActionLibrary.lockFunds. function lockFunds transfers user stakes but don't call stakerVault.increaseActionLockedBalance for the payer which cause that stakerVault.actionLockedBalances[payer] to get different values(not equal to position.depositTokenBalance). function StakerVault.stakedAndActionLockedBalanceOf(account) uses stakerVault.actionLockedBalances[account] so it will return wrong value and any where in code that uses stakedAndActionLockedBalanceOf() is going to cause problems. three part of the codes uses stakerVault.stakedAndActionLockedBalanceOf(): 1- LiqudityPool.depositFor() for checking user total deposits to be less than depositCap. 2- LiqudityPool._updateUserFeesOnDeposit() for updating user fee on new deposits. 3- userCheckpoint() for calculating user rewards. attacker can use #1 and #2 to bypass high fee payment and max depositCap and #3 will cause users to lose  rewards.  The detail steps: 1- user deposit fund to Pool and get LP token. 2- user stakes LP token in StakerVault. 3- user approve TopUpAction address to transfer his staks in StakerVault. 3- user use all his stakes to create a position with TopUpAction.register() function. 3.1- register() will call lockFunds to transfer and lock user stakes. 3.2- lockFunds() will transfer user stakes with stakerVault.transferFrom() but don't call stakerVault.increaseActionLockedBalance() so StakerVault.actionLockedBalances[user] will be zero. 3.3- StakerVault.balance[useer] will be zero too because his stakes get transfers in 3.2 4- StakerVault.stakedAndActionLockedBalanceOf(user) will return zero (user has some locked stakes in TopUpAction but because of the bug calculation get out of sync)  In this moment user will lose all the rewards that are minted in LpGauge. becasue userCheckpoint() use stakerVault.stakedAndActionLockedBalanceOf(user) for calculating rewards which is zero  and new rewards will be zero too.  Attacker can use this process to bypass "max deposit Cap" and deposit any amount of assets he wants. because LiqudityPool.depositFor(address,uint256,uint256) uses stakedAndActionLockedBalanceOf to check user deposits which is zero so Attacker can deposit & stake & register to make his balance zero and repeat this and in the end reset his TopUp positions to get back his large stakes which are multiple time bigger than "max deposit Cap"  Attacker can also use this process to bypass fee penalties for early withdraw. because LiqudityPool._updateUserFeesOnDeposit() to get user current balance use stakedAndActionLockedBalanceOf() which is zero. so the value of shareExisting variable become zero and newFeeRatio will be calculated based on feeOnDeposit which can be minFee if asset is already in wallet for some time.   ## Tools Used VIM  ## Recommended Mitigation Steps add this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():  stakerVault.increaseActionLockedBalance(payer, amountLeft);  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L790-L792   # Vulnerability details  ## Impact The `_updateUserFeesOnDeposit()` function in `LiquidityPool.sol` is used to update a user's withdrawal fees after an action such as deposit, transfer in, etc. The withdrawal fee decays toward a minimum withdrawal fee over a period of 1 or 2 weeks (discussed with developer). Since anyone can transfer lp tokens to any user, a griefer can transfer 1 wei of lp tokens to another user to reset their `lastActionTimestamp` used in the withdrawal fee calculation.  The developers nicely weight the updated withdrawal fee by taking the original balance/original fee vs the added balance/added fee. The attacker will only be able to extend the runway of the withdrawal fee cooldown by resetting the `lastActionTimestamp` for future calculations. Example below:  ## Proof of Concept Assumptions: - MinWithdrawalFee = 0% //For easy math - MaxWithdrawalFee = 10% - timeToWait = 2 weeks  ### Steps - User A has `100 wei` of shares - User A waits 1 week (Current withdrawal fee = 5%) - User B deposits, receives `1 wei` of shares, current withdrawal fee = 10% - User B immediately transfers `1 wei` of shares to User A  Based on the formula to calculated User A's new feeRatio:  ```         uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +             shareAdded.scaledMul(feeOnDeposit); ```  In reality, User A's withdrawal fee will only increase by a negligible amount since the shares added were very small in proportion to the original shares. We can assume user A's current withdrawal fee is still 5%.  The issue is that the function then reset's User A's `lastActionTimestamp` to the current time. This means that User A will have to wait the maximum 2 weeks for the withdrawal fee to reduce from 5% to 0%. Effectively the cooldown runway is the same length as the original runway length, so the decay down to 0% will take twice as long.  `meta.lastActionTimestamp = uint64(_getTime());`  ## Tools Used Manual Review  ## Recommended Mitigation Steps Instead of resetting `lastActionTimestamp` to the current time, scale it the same way the `feeRatio` is scaled. I understand that this would technically not be the timestamp of the last action, so the variable would probably need to be renamed.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/actions/topup/TopUpAction.sol#L291 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/pool/EthPool.sol#L30 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L77 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L93 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L117 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L29 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L37 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/VaultReserve.sol#L81   # Vulnerability details  This is a classic Code4rena issue:  - https://github.com/code-423n4/2021-04-meebits-findings/issues/2 - https://github.com/code-423n4/2021-10-tally-findings/issues/20 - https://github.com/code-423n4/2022-01-openleverage-findings/issues/75  ## Impact The use of the deprecated `transfer()` function for an address will inevitably make the transaction fail when:  1. The claimer smart contract does not implement a payable function. 2. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. 3. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.  Additionally, using higher than 2300 gas might be mandatory for some multisig wallets.  ## Impacted lines:  ```solidity backd/contracts/pool/EthPool.sol:   30:         to.transfer(amount);  backd/contracts/strategies/BkdEthCvx.sol:    77:             payable(vault).transfer(amount);    93:         payable(vault).transfer(amount);   117:         payable(vault).transfer(underlyingBalance);  backd/contracts/vault/EthVault.sol:   29:         payable(to).transfer(amount);    37:         payable(addressProvider.getTreasury()).transfer(amount);    backd/contracts/vault/VaultReserve.sol:   81:             payable(msg.sender).transfer(amount); ```  ## Recommended Mitigation  I recommend using `call()` instead of `transfer()`  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L694   # Vulnerability details  ## Impact Depositors won't be able to transfer or redeem funds temporarily.   The problem is caused by the implementation of `LiquidityPool.getNewCurrentFees`:  ``` function getNewCurrentFees(     uint256 timeToWait,     uint256 lastActionTimestamp,     uint256 feeRatio ) public view returns (uint256) {     uint256 timeElapsed = _getTime() - lastActionTimestamp;     uint256 minFeePercentage = getMinWithdrawalFee();     if (timeElapsed >= timeToWait) {         return minFeePercentage;     }     uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);     return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare); } ``` The last line requires the current `feeRatio` to be higher than `minFeePercentage` or the function will revert. When this condition is broken, some critical functions such as transferring tokens and redeeming will be unusable. Affected users need to wait until enough time has elapsed and `getNewCurrentFees` returns `minFeePercentage` on [L691](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L691).  This could happen if governance changes the `MinWithdrawalFee` to be higher than a user's feeRatio.  ## Proof of Concept - Initial `MinWithdrawalFee` is set to 0, `MaxWithdrawalFee` is set to 0.03e18. - Alice deposits fund and receives LP token. Alice's `feeRatio` is now set to 0.03e18 (the current `MaxWithdrawalFee`). - Governance changes `MaxWithdrawalFee` to `0.05e18` and `MinWithdrawalFee` to `0.04e18`. - `minFeePercentage` is now higher than Alice's `feeRatio` and she can't transfer nor redeem the LP token until `timeElapsed >= timeToWait`.  ## Recommended Mitigation Steps Add a new condition in `getNewCurrentFees` [L690](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L690) to account for this case: ``` if (timeElapsed >= timeToWait || minFeePercentage > feeRatio) {     return minFeePercentage; } ```   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L287-L289 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L318-L320 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L335-L337   # Vulnerability details  ## Impact In `StrategySwapper`, swapping from or to tokens with decimals higher than 18 will always revert. This will cause inabilities for strategies to harvest rewards.  ## Proof of Concept [L288](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L288) will revert when `token_` has higher than 18 decimals. ```  return 10**(18 - IERC20Full(token_).decimals()); ```   ## Recommended Mitigation Steps Consider modifying how `_decimalMultiplier` works so it could handle tokens with higher than 18 decimals.   Update the calculation of `_minTokenAmountOut` and `_minWethAmountOut` to account when decimals are higher/lower than `18`.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L523   # Vulnerability details  ## Impact When ERC777 token is used as the underlying token for a `LiquidityPool`, a depositor can reenter `depositFor` and bypass the `depositCap` requirement check, resulting in higher total deposit than intended by governance.  ## Proof of Concept - An empty ERC777 liquidity pool is capped at 1.000 token. - Alice deposits 1.000 token. Before the token is actually sent to the contract, `tokensToSend` ERC777 hook is called and Alice reenters `depositFor`. - As the previous deposit hasn't been taken into account, the reentrancy passes the `depositCap` check. - Pool has 2.000 token now, despite the 1.000 deposit cap.  ## Recommended Mitigation Steps Add reentrancy guards to `depositFor`.   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L112-L119   # Vulnerability details  ## Impact I believe this to be a high severity vulnerability that is potentially included in the currently deployed `StakerVault.sol` contract also. The team will be contacted immediately following the submission of this report.  In `StakerVault.sol`, the user checkpoints occur AFTER the balances are updated in the `transfer()` function. The user checkpoints update the amount of rewards claimable by the user. Since their rewards will be updated after transfer, a user can send funds between their own accounts and repeatedly claim maximum rewards since the pool's inception.  In every actionable function except `transfer()` of `StakerVault.sol`, a call to `ILpGauge(lpGauge).userCheckpoint()` is correctly made BEFORE the action effects.  ## Proof of Concept Assume a certain period of time has passed since the pool's inception. For easy accounting, assume `poolStakedIntegral` of `LpGauge.sol` equals `1`. The `poolStakedIntegral` is used to keep track of the current reward rate.  Steps: - Account A stakes 1000 LP tokens. `balances[A] += 1000`  - In the same `stakeFor()` function, `userCheckpoint()` was already called so A will already have `perUserShare[A]` set correctly based on their previously 0 balance and the current `poolStakedIntegral`. - Account A can immediately send all balance to Account B via `transfer()`. - Since the checkpoint occurs after the transfer, B's balance will increase and then `perUserShare[B]` will be updated. The calculation for `perUserShare` looks as follows.  ``` perUserShare[user] += (             (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(                 (poolStakedIntegral_ - perUserStakedIntegral[user])             )         ); ```  Assuming Account B is new to the protocol, their `perUserStakedIntegral[user]` will default to `0`.  `perUserShare[B] += 1000 * (1 - 0) = 1000`  - B is able to call `claimRewards()` and mint all 1000 reward tokens. - B then calls `transfer()` and sends all 1000 staked tokens to Account C. - Same calculation occurs, and C can claim all 1000 reward tokens. - This process can be repeated until the contract is drained of reward tokens.  ## Tools Used Static review.  ## Recommended Mitigation Steps In `StakerVault.transfer()`, move the call to `ILpGauge(lpGauge).userCheckpoint()` to before the balances are updated.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55   # Vulnerability details  ## Impact On ChainlinkOracleProvider.sol and ChainlinkUsdWrapper.sol , we are using latestRoundData, but there is no check if the return value indicates stale data. ```     function _ethPrice() private view returns (int256) {         (, int256 answer, , , ) = _ethOracle.latestRoundData();         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);          (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();          require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);         require(answer >= 0, Error.NEGATIVE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     } ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L64 ## Tools Used None ## Recommended Mitigation Steps ```     function _ethPrice() private view returns (int256) {         (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = _ethOracle.latestRoundData();         require(answeredInRound >= roundID, "Stale price");         require(timestamp != 0,"Round not complete");         require(answer > 0,"Chainlink answer reporting 0");         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);         (uint80 roundID, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = AggregatorV2V3Interface(feed).latestRoundData();         require(answeredInRound >= roundID, "Stale price");         require(answer > 0," Error.NEGATIVE_PRICE");         require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     }  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729   # Vulnerability details  ## Impact  A Staker -- that has their top-up position removed after `execute` is called by a Keeper -- can always cause the transaction to revert. They can do this by deploying a smart contract to the `payer` address that has implemented a `receive()` function that calls `revert()`. The revert will be triggered by the following [lines](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729) in `execute`  ```sol if (vars.removePosition) {     gasBank.withdrawUnused(payer); } ```  This will consume some gas from the keeper while preventing them accruing any rewards for performing the top-up action.  ## Proof of Concept  I have implemented a [PoC](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/tests/top_up_action/sseefried_test_staker_grief.py) in a fork of the contest repo. The attacker's contract can be found [here](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/contracts/AliceAttacker.sol).  ## Tools Used Manual inspection  ## Recommend Mitigation Steps  To prevent this denial of service attack some way of blacklisting badly behaved Stakers should be added.   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L50 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L721   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             "SafeERC20: approve from non-zero to non-zero allowance"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers can be prevented from `register()`ing the same `token`/`stakerVaultAddress` as another customer; and once changed away from, stakers and lptokens can't be used in the future.  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first.  `register()` calls `lockFunds()` for each user registration, and since users will use the same tokens and staker vaults, the second user's `register()` call will fail: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #1  36       function lockFunds( 37           address stakerVaultAddress, 38           address payer, 39           address token, 40           uint256 lockAmount, 41           uint256 depositAmount 42       ) external { 43           uint256 amountLeft = lockAmount; 44           IStakerVault stakerVault = IStakerVault(stakerVaultAddress); 45    46           // stake deposit amount 47           if (depositAmount > 0) { 48               depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount; 49               IERC20(token).safeTransferFrom(payer, address(this), depositAmount); 50               IERC20(token).safeApprove(stakerVaultAddress, depositAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L36-L50  The changing of either the staker or an lp token is behind a time-lock, and once the time has passed, the changed variables rely on this function: ```solidity File: backd/contracts/pool/LiquidityPool.sol   #2  717       function _approveStakerVaultSpendingLpTokens() internal { 718           address staker_ = address(staker); 719           address lpToken_ = address(lpToken); 720           if (staker_ == address(0) || lpToken_ == address(0)) return; 721           IERC20(lpToken_).safeApprove(staker_, type(uint256).max); 722       } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L717-L722  If a bug is found in a new `staker` or `lpToken` and the governor wishes to change back to the old one(s), the governor will have to wait for the time-lock delay only to find out that the old value(s) cause the code to revert.  I've filed the other more-severe instances as a separate high-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L71 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L120 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L53 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L847   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             "SafeERC20: approve from non-zero to non-zero allowance"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first. The instances below are all related to topping up.  Compound-specific top-ups will fail the second time around when approving the `ctoken` again: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1  50       function topUp( 51           bytes32 account, 52           address underlying, 53           uint256 amount, 54           bytes memory extra 55       ) external override returns (bool) { 56           bool repayDebt = abi.decode(extra, (bool)); 57           CToken ctoken = cTokenRegistry.fetchCToken(underlying); 58           uint256 initialTokens = ctoken.balanceOf(address(this)); 59    60           address addr = account.addr(); 61    62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } 66    67           uint256 err; 68           if (underlying == address(0)) { 69               err = ctoken.mint{value: amount}(amount); 70           } else { 71               IERC20(underlying).safeApprove(address(ctoken), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L50-L71  Compound-specific top-ups will also fail when trying to repay debt: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2  62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L62-L65  Aave-specific top-ups will fail for the `lendingPool`: ```solidity File: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3  36       function topUp( 37           bytes32 account, 38           address underlying, 39           uint256 amount, 40           bytes memory extra 41       ) external override returns (bool) { 42           bool repayDebt = abi.decode(extra, (bool)); 43           if (underlying == address(0)) { 44               weth.deposit{value: amount}(); 45               underlying = address(weth); 46           } 47    48           address addr = account.addr(); 49    50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying); 51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED); 52    53           IERC20(underlying).safeApprove(address(lendingPool), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L36-L53  The `TopUpAction` itself fails for the `feeHandler`: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #4  840       function _payFees( 841           address payer, 842           address beneficiary, 843           uint256 feeAmount, 844           address depositToken 845       ) internal { 846           address feeHandler = getFeeHandler(); 847           IERC20(depositToken).safeApprove(feeHandler, feeAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L840-L847  I've filed the other less-severe instances as a separate medium-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L56   # Vulnerability details  ## Impact The current code returns the following: ``` return (roundId_, (answer_ * _ethPrice()) / 1e8, startedAt_, updatedAt_, answeredInRound_); ``` If we're wrapping an asset that's relatively stable to eth price, the `answer` here might not be updated constantly. By returning the startedAt of the last answer update, it's possible that this answer be considered "stale" from the protocol.  ## Recommended Mitigation Steps  It's better to return the new `updatedAt_ ` at the greater of the two:   * `updatedAt_ ` from eth oracle,  * `updatedAt_ ` from the asset oracle  This way, if asset/eth is unchanged for a while, but there's a eth price move, we capture the correct `updatedAt` timestamp  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/access/RoleManager.sol#L155   # Vulnerability details  ## Impact The function doesn't remove the address from _roleMembers[role] set, which will mess up with the roleCount  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps ``` _roles[role].members[account] = false; _roleMembers[role].remove(account); ```  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252   # Vulnerability details  ## Impact The CvxCrvRewardsLocker contract swaps tokens through the CRV cvxCRV pool. But, it doesn't use any slippage checks. The swap is at risk of being frontrun / sandwiched which will result in a loss of funds.  Since MEV is very prominent I think the chance of that happening is pretty high.  ## Proof of Concept Here's the swap: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252  ## Tools Used none  ## Recommended Mitigation Steps Use a proper value for `minOut` instead of `0`.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345  ```solidity  function mint() external payable returns (uint256); ```  `mint()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  In the current implementation, the interface for `CToken` is used for both `CEther` and `CErc20`.  As a result, the transaction will revert with the error: `function returned an unexpected amount of data` when `topUp()` with the native token (ETH).  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint - Compound CEther.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L46 - Compound CErc20.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L46  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358  ```solidity function repayBorrowBehalf(address borrower, uint256 repayAmount)         external         payable         returns (uint256); ```  `repayBorrowBehalf()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  As a result, `ether.repayBorrowBehalf()` will always revert  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L117-L118  ```solidity     CEther cether = CEther(address(ctoken));     err = cether.repayBorrowBehalf{value: debt}(account); ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound cToken Repay Borrow Behalf doc: https://compound.finance/docs/ctokens#repay-borrow-behalf - Compound CEther.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L92-L95 - Compound CErc20.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L94-L97  
# Lines of code  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47   # Vulnerability details  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47  ```solidity function mint() external payable {     (uint err,) = mintInternal(msg.value);     requireNoError(err, "mint failed"); } ```  `mint()` for native cToken (`CEther`) does not have any parameters, as the `Function Selector` is based on `the function name with the parenthesised list of parameter types`, when you add a nonexisting `parameter`, the `Function Selector` will be incorrect.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L316  ```solidity     function mint(uint256 mintAmount) external payable virtual returns (uint256); ```  The current implementation uses the same `CToken` interface for both `CEther` and `CErc20` in `topUp()`, and `function mint(uint256 mintAmount)` is a nonexisting function for `CEther`.  As a result, the native token `topUp()` always revert.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  See also:  - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L38-L43 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L109-L114   # Vulnerability details  ## Impact in the setSlippageTolerance(L119) method you have certain requirements to set slippageTolerance, but in the constructor you don't.    ## Recommended Mitigation Steps I would add the corresponding validations to the constructor   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L154 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L187   # Vulnerability details  ## Impact The default swap slippage of 5% allows malicious keepers to sandwich attack topup. Additionally, up to 40% (_MIN_SWAPPER_SLIPPAGE) slippage allows malicious owner to sandwich huge amounts from topup  ## Proof of Concept Keeper can bundle swaps before and after topup to sandwich topup action, in fact it's actually in their best interest to do so.  ## Tools Used  ## Recommended Mitigation Steps Allow user to specify max swap slippage when creating topup similar to how it's specified on uniswap or sushiswap to block attacks from both keepers and owners  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L57-L65   # Vulnerability details  ## Impact In function TopUpActionLibrary.lockFunds when transfers stakes from payer it doesn't call stakerVault.increaseActionLockedBalance for that payer so stakerVault.actionLockedBalances[payer] is not get updated for payer and stakerVault.stakedAndActionLockedBalanceOf(payer) is going to show wrong value and any calculation based on this function is gonna be wrong which will cause fund lose and theft and some restriction bypasses.  ## Proof of Concept When user wants to create a TopUpAction. so he seposit his funds to Pool and get LP token. then stake the LP token in StakerVault and use that stakes to create a TopUp position with function TopUpAction.register. This function transfer user stakes (locks user staks) and create his position. for transferring and locking user stakes it uses TopUpActionLibrary.lockFunds. function lockFunds transfers user stakes but don't call stakerVault.increaseActionLockedBalance for the payer which cause that stakerVault.actionLockedBalances[payer] to get different values(not equal to position.depositTokenBalance). function StakerVault.stakedAndActionLockedBalanceOf(account) uses stakerVault.actionLockedBalances[account] so it will return wrong value and any where in code that uses stakedAndActionLockedBalanceOf() is going to cause problems. three part of the codes uses stakerVault.stakedAndActionLockedBalanceOf(): 1- LiqudityPool.depositFor() for checking user total deposits to be less than depositCap. 2- LiqudityPool._updateUserFeesOnDeposit() for updating user fee on new deposits. 3- userCheckpoint() for calculating user rewards. attacker can use #1 and #2 to bypass high fee payment and max depositCap and #3 will cause users to lose  rewards.  The detail steps: 1- user deposit fund to Pool and get LP token. 2- user stakes LP token in StakerVault. 3- user approve TopUpAction address to transfer his staks in StakerVault. 3- user use all his stakes to create a position with TopUpAction.register() function. 3.1- register() will call lockFunds to transfer and lock user stakes. 3.2- lockFunds() will transfer user stakes with stakerVault.transferFrom() but don't call stakerVault.increaseActionLockedBalance() so StakerVault.actionLockedBalances[user] will be zero. 3.3- StakerVault.balance[useer] will be zero too because his stakes get transfers in 3.2 4- StakerVault.stakedAndActionLockedBalanceOf(user) will return zero (user has some locked stakes in TopUpAction but because of the bug calculation get out of sync)  In this moment user will lose all the rewards that are minted in LpGauge. becasue userCheckpoint() use stakerVault.stakedAndActionLockedBalanceOf(user) for calculating rewards which is zero  and new rewards will be zero too.  Attacker can use this process to bypass "max deposit Cap" and deposit any amount of assets he wants. because LiqudityPool.depositFor(address,uint256,uint256) uses stakedAndActionLockedBalanceOf to check user deposits which is zero so Attacker can deposit & stake & register to make his balance zero and repeat this and in the end reset his TopUp positions to get back his large stakes which are multiple time bigger than "max deposit Cap"  Attacker can also use this process to bypass fee penalties for early withdraw. because LiqudityPool._updateUserFeesOnDeposit() to get user current balance use stakedAndActionLockedBalanceOf() which is zero. so the value of shareExisting variable become zero and newFeeRatio will be calculated based on feeOnDeposit which can be minFee if asset is already in wallet for some time.   ## Tools Used VIM  ## Recommended Mitigation Steps add this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():  stakerVault.increaseActionLockedBalance(payer, amountLeft);  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L790-L792   # Vulnerability details  ## Impact The `_updateUserFeesOnDeposit()` function in `LiquidityPool.sol` is used to update a user's withdrawal fees after an action such as deposit, transfer in, etc. The withdrawal fee decays toward a minimum withdrawal fee over a period of 1 or 2 weeks (discussed with developer). Since anyone can transfer lp tokens to any user, a griefer can transfer 1 wei of lp tokens to another user to reset their `lastActionTimestamp` used in the withdrawal fee calculation.  The developers nicely weight the updated withdrawal fee by taking the original balance/original fee vs the added balance/added fee. The attacker will only be able to extend the runway of the withdrawal fee cooldown by resetting the `lastActionTimestamp` for future calculations. Example below:  ## Proof of Concept Assumptions: - MinWithdrawalFee = 0% //For easy math - MaxWithdrawalFee = 10% - timeToWait = 2 weeks  ### Steps - User A has `100 wei` of shares - User A waits 1 week (Current withdrawal fee = 5%) - User B deposits, receives `1 wei` of shares, current withdrawal fee = 10% - User B immediately transfers `1 wei` of shares to User A  Based on the formula to calculated User A's new feeRatio:  ```         uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +             shareAdded.scaledMul(feeOnDeposit); ```  In reality, User A's withdrawal fee will only increase by a negligible amount since the shares added were very small in proportion to the original shares. We can assume user A's current withdrawal fee is still 5%.  The issue is that the function then reset's User A's `lastActionTimestamp` to the current time. This means that User A will have to wait the maximum 2 weeks for the withdrawal fee to reduce from 5% to 0%. Effectively the cooldown runway is the same length as the original runway length, so the decay down to 0% will take twice as long.  `meta.lastActionTimestamp = uint64(_getTime());`  ## Tools Used Manual Review  ## Recommended Mitigation Steps Instead of resetting `lastActionTimestamp` to the current time, scale it the same way the `feeRatio` is scaled. I understand that this would technically not be the timestamp of the last action, so the variable would probably need to be renamed.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/actions/topup/TopUpAction.sol#L291 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/pool/EthPool.sol#L30 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L77 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L93 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L117 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L29 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L37 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/VaultReserve.sol#L81   # Vulnerability details  This is a classic Code4rena issue:  - https://github.com/code-423n4/2021-04-meebits-findings/issues/2 - https://github.com/code-423n4/2021-10-tally-findings/issues/20 - https://github.com/code-423n4/2022-01-openleverage-findings/issues/75  ## Impact The use of the deprecated `transfer()` function for an address will inevitably make the transaction fail when:  1. The claimer smart contract does not implement a payable function. 2. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. 3. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.  Additionally, using higher than 2300 gas might be mandatory for some multisig wallets.  ## Impacted lines:  ```solidity backd/contracts/pool/EthPool.sol:   30:         to.transfer(amount);  backd/contracts/strategies/BkdEthCvx.sol:    77:             payable(vault).transfer(amount);    93:         payable(vault).transfer(amount);   117:         payable(vault).transfer(underlyingBalance);  backd/contracts/vault/EthVault.sol:   29:         payable(to).transfer(amount);    37:         payable(addressProvider.getTreasury()).transfer(amount);    backd/contracts/vault/VaultReserve.sol:   81:             payable(msg.sender).transfer(amount); ```  ## Recommended Mitigation  I recommend using `call()` instead of `transfer()`  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L694   # Vulnerability details  ## Impact Depositors won't be able to transfer or redeem funds temporarily.   The problem is caused by the implementation of `LiquidityPool.getNewCurrentFees`:  ``` function getNewCurrentFees(     uint256 timeToWait,     uint256 lastActionTimestamp,     uint256 feeRatio ) public view returns (uint256) {     uint256 timeElapsed = _getTime() - lastActionTimestamp;     uint256 minFeePercentage = getMinWithdrawalFee();     if (timeElapsed >= timeToWait) {         return minFeePercentage;     }     uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);     return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare); } ``` The last line requires the current `feeRatio` to be higher than `minFeePercentage` or the function will revert. When this condition is broken, some critical functions such as transferring tokens and redeeming will be unusable. Affected users need to wait until enough time has elapsed and `getNewCurrentFees` returns `minFeePercentage` on [L691](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L691).  This could happen if governance changes the `MinWithdrawalFee` to be higher than a user's feeRatio.  ## Proof of Concept - Initial `MinWithdrawalFee` is set to 0, `MaxWithdrawalFee` is set to 0.03e18. - Alice deposits fund and receives LP token. Alice's `feeRatio` is now set to 0.03e18 (the current `MaxWithdrawalFee`). - Governance changes `MaxWithdrawalFee` to `0.05e18` and `MinWithdrawalFee` to `0.04e18`. - `minFeePercentage` is now higher than Alice's `feeRatio` and she can't transfer nor redeem the LP token until `timeElapsed >= timeToWait`.  ## Recommended Mitigation Steps Add a new condition in `getNewCurrentFees` [L690](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L690) to account for this case: ``` if (timeElapsed >= timeToWait || minFeePercentage > feeRatio) {     return minFeePercentage; } ```   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L287-L289 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L318-L320 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L335-L337   # Vulnerability details  ## Impact In `StrategySwapper`, swapping from or to tokens with decimals higher than 18 will always revert. This will cause inabilities for strategies to harvest rewards.  ## Proof of Concept [L288](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L288) will revert when `token_` has higher than 18 decimals. ```  return 10**(18 - IERC20Full(token_).decimals()); ```   ## Recommended Mitigation Steps Consider modifying how `_decimalMultiplier` works so it could handle tokens with higher than 18 decimals.   Update the calculation of `_minTokenAmountOut` and `_minWethAmountOut` to account when decimals are higher/lower than `18`.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L523   # Vulnerability details  ## Impact When ERC777 token is used as the underlying token for a `LiquidityPool`, a depositor can reenter `depositFor` and bypass the `depositCap` requirement check, resulting in higher total deposit than intended by governance.  ## Proof of Concept - An empty ERC777 liquidity pool is capped at 1.000 token. - Alice deposits 1.000 token. Before the token is actually sent to the contract, `tokensToSend` ERC777 hook is called and Alice reenters `depositFor`. - As the previous deposit hasn't been taken into account, the reentrancy passes the `depositCap` check. - Pool has 2.000 token now, despite the 1.000 deposit cap.  ## Recommended Mitigation Steps Add reentrancy guards to `depositFor`.   
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L112-L119   # Vulnerability details  ## Impact I believe this to be a high severity vulnerability that is potentially included in the currently deployed `StakerVault.sol` contract also. The team will be contacted immediately following the submission of this report.  In `StakerVault.sol`, the user checkpoints occur AFTER the balances are updated in the `transfer()` function. The user checkpoints update the amount of rewards claimable by the user. Since their rewards will be updated after transfer, a user can send funds between their own accounts and repeatedly claim maximum rewards since the pool's inception.  In every actionable function except `transfer()` of `StakerVault.sol`, a call to `ILpGauge(lpGauge).userCheckpoint()` is correctly made BEFORE the action effects.  ## Proof of Concept Assume a certain period of time has passed since the pool's inception. For easy accounting, assume `poolStakedIntegral` of `LpGauge.sol` equals `1`. The `poolStakedIntegral` is used to keep track of the current reward rate.  Steps: - Account A stakes 1000 LP tokens. `balances[A] += 1000`  - In the same `stakeFor()` function, `userCheckpoint()` was already called so A will already have `perUserShare[A]` set correctly based on their previously 0 balance and the current `poolStakedIntegral`. - Account A can immediately send all balance to Account B via `transfer()`. - Since the checkpoint occurs after the transfer, B's balance will increase and then `perUserShare[B]` will be updated. The calculation for `perUserShare` looks as follows.  ``` perUserShare[user] += (             (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(                 (poolStakedIntegral_ - perUserStakedIntegral[user])             )         ); ```  Assuming Account B is new to the protocol, their `perUserStakedIntegral[user]` will default to `0`.  `perUserShare[B] += 1000 * (1 - 0) = 1000`  - B is able to call `claimRewards()` and mint all 1000 reward tokens. - B then calls `transfer()` and sends all 1000 staked tokens to Account C. - Same calculation occurs, and C can claim all 1000 reward tokens. - This process can be repeated until the contract is drained of reward tokens.  ## Tools Used Static review.  ## Recommended Mitigation Steps In `StakerVault.transfer()`, move the call to `ILpGauge(lpGauge).userCheckpoint()` to before the balances are updated.  
# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55   # Vulnerability details  ## Impact On ChainlinkOracleProvider.sol and ChainlinkUsdWrapper.sol , we are using latestRoundData, but there is no check if the return value indicates stale data. ```     function _ethPrice() private view returns (int256) {         (, int256 answer, , , ) = _ethOracle.latestRoundData();         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);          (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();          require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);         require(answer >= 0, Error.NEGATIVE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     } ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L64 ## Tools Used None ## Recommended Mitigation Steps ```     function _ethPrice() private view returns (int256) {         (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = _ethOracle.latestRoundData();         require(answeredInRound >= roundID, "Stale price");         require(timestamp != 0,"Round not complete");         require(answer > 0,"Chainlink answer reporting 0");         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);         (uint80 roundID, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = AggregatorV2V3Interface(feed).latestRoundData();         require(answeredInRound >= roundID, "Stale price");         require(answer > 0," Error.NEGATIVE_PRICE");         require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     }  
