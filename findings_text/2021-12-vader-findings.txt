# Handle  pauliax   # Vulnerability details  ## Impact function _addUSDVPair does not check if the foreignAsset does not exist yet, thus it is possible to override it.   ## Recommended Mitigation Steps Make sure this is the intended behavior or else add validations, e.g. ```solidity   require(pairData.updatePeriod == 0, "..."); ```  
# Handle  gzeon   # Vulnerability details  ## Impact Oracles are mapped to the `foreignAsset` but not to the specific pair. Pairs with the same `foreignAsset` (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly.  ## Proof of Concept https://github.com/code-423n4/2021-12-vader/blob/9fb7f206eaff1863aeeb8f997e0f21ea74e78b49/contracts/lbt/LiquidityBasedTWAP.sol#L271 ```         oracles[foreignAsset] = oracle; ```  ## Recommended Mitigation Steps Bind the oracle to pair instead  
# Handle  cmichel   # Vulnerability details  The vader price in `LiquidityBasedTWAP.getVaderPrice` is computed using the `pastLiquidityWeights` and `pastTotalLiquidityWeight` return values of the `syncVaderPrice`.  The `syncVaderPrice` function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:  ```solidity function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;         // @audit-info update period depends on pair         // @audit-issue if update period not reached => does not initialize pastLiquidityWeights[i]         if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  #### POC This bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert. Observe what happens if an attacker calls `syncVaderPrice` twice in the same block:  - The first time any pairs that need to be updated are updated - On the second call `_totalLiquidityWeight` is initialized to zero and all pairs have already been updated and thus skipped. `_totalLiquidityWeight` never increases and the storage variable `totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0;` is set to zero. - DoS because calls to `getStaleVaderPrice` / `getVaderPrice` will revert in `_calculateVaderPrice` which divides by `totalLiquidityWeight = 0`.  Attacker keeps double-calling `syncVaderPrice` every time an update window of one of the pairs becomes eligible to be updated.   ## Impact This bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met. This in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.  It's also possible to always set the `totalLiquidityWeight` to zero by calling `syncVaderPrice` twice which in turn reverts all transactions making use of the price because of a division by zero in `_caluclateVaderPrice`. An attacker can break the `USDV.mint` minting forever and any router calls to `VaderReserve.reimburseImpermanentLoss` also fail as they perform a call to the reverting price function.  ## Recommended Mitigation Steps Even if `timeElapsed < pairData.updatePeriod`, the old pair weight should still contribute to the total liquidity weight and be set in `pastLiquidityWeights`. Move the `_totalLiquidityWeight += currentLiquidityEvaluation` and the `pastLiquidityWeights[i] = pastLiquidityEvaluation` assignments before the `continue`.   
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221 vader can be initialized twice if in the first call to `setupVader`, `vaderPrice == 0`.  ## Recommended Mitigation Steps add: ``` require(vaderPrice > 0); ``` in `setupVader`.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `_addVaderPair` function is called by the `onlyOwner` role. The relevant data in the `twapData` mapping is set by querying the respective liquidity pool and Chainlink oracle. `totalLiquidityWeight` for the `VADER` path is also incremented by the `pairLiquidityEvaluation` amount (calculated within `_addVaderPair`). If a user then calls `syncVaderPrice`, the recently updated `totalLiquidityWeight` will be taken into consideration when iterating through all token pairs eligible for price updates to calculate the liquidity weight for each token pair. This data is stored in `pastTotalLiquidityWeight` and `pastLiquidityWeights` respectively.  As a result, newly added token pairs will increase `pastTotalLiquidityWeight` while leaving `pastLiquidityWeights` underrepresented. This only occurs if `syncVaderPrice` is called before the update period for the new token has not been passed.  This issue also affects how the price for `USDV` is synced.  ## Proof of Concept  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L299 ``` function _addVaderPair(     IUniswapV2Pair pair,     IAggregatorV3 oracle,     uint256 updatePeriod ) internal {     require(         updatePeriod != 0,         "LBTWAP::addVaderPair: Incorrect Update Period"     );      require(oracle.decimals() == 8, "LBTWAP::addVaderPair: Non-USD Oracle");      ExchangePair storage pairData = twapData[address(pair)];      bool isFirst = pair.token0() == vader;      (address nativeAsset, address foreignAsset) = isFirst         ? (pair.token0(), pair.token1())         : (pair.token1(), pair.token0());      oracles[foreignAsset] = oracle;      require(nativeAsset == vader, "LBTWAP::addVaderPair: Unsupported Pair");      pairData.foreignAsset = foreignAsset;     pairData.foreignUnit = uint96(         10**uint256(IERC20Metadata(foreignAsset).decimals())     );      pairData.updatePeriod = updatePeriod;     pairData.lastMeasurement = block.timestamp;      pairData.nativeTokenPriceCumulative = isFirst         ? pair.price0CumulativeLast()         : pair.price1CumulativeLast();      (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();      (uint256 reserveNative, uint256 reserveForeign) = isFirst         ? (reserve0, reserve1)         : (reserve1, reserve0);      uint256 pairLiquidityEvaluation = (reserveNative *         previousPrices[uint256(Paths.VADER)]) +         (reserveForeign * getChainlinkPrice(foreignAsset));      pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;      totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;      vaderPairs.push(pair);      if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod; } ```  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L113-L148 ``` function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;          if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  As shown above, `pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)]` loads in the total liquidity weight which is updated when `_addVaderPair` is called. However, `pastLiquidityWeights` is calculated by iterating through each token pair that is eligible to be updated.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing the line `totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;` in `_addVaderPair` so that newly added tokens do not impact upcoming queries for `VADER/USDV` price data. This should ensure `syncVaderPrice` and `syncUSDVPrice` cannot be manipulated when adding new tokens.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Invalid values returned from oracle in vast majority of situations  ## Proof of Concept  The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.  Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409  For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy. ``` foreignPrice = getChainlinkPrice(address(foreignAsset)); foreignPrice = 1e8 ```  We can set `liquidityWeights[i]` and `totalUSDVLiquidityWeight` both to 1 as we only consider a single pair so L399-401 becomes ``` totalUSD = foreignPrice; totalUSD = 1e8; ```  L403-408 is slightly more complex but from looking at the links below we can calculate `totalUSDV` as shown https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160  ``` totalUSDV = pairData     .nativeTokenPriceAverage     .mul(pairData.foreignUnit)     .decode144() // pairData.nativeTokenPriceAverage == 2**112 // pairData.foreignUnit = 10**18 // decode144(x) = x >> 112 totalUSDV = (2**112).mul(10**18).decode144() totalUSDV = 10**18 ```  Using `totalUSD` and `totalUSDV` we can then calculate the return value of `_calculateUSDVPrice`  ``` returnValue = (totalUSD * 1 ether) / totalUSDV;  returnValue = 1e8 * 1e18 / 1e18  returnValue = 1e8 ```  For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent $1 rather than 1e8.  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109  High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.  ## Recommended Mitigation Steps  Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.  Build a test suite to ensure that the oracle returns the expected values for simple situations.  
# Handle  pauliax   # Vulnerability details  ## Impact function _addUSDVPair does not check if the foreignAsset does not exist yet, thus it is possible to override it.   ## Recommended Mitigation Steps Make sure this is the intended behavior or else add validations, e.g. ```solidity   require(pairData.updatePeriod == 0, "..."); ```  
# Handle  gzeon   # Vulnerability details  ## Impact Oracles are mapped to the `foreignAsset` but not to the specific pair. Pairs with the same `foreignAsset` (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly.  ## Proof of Concept https://github.com/code-423n4/2021-12-vader/blob/9fb7f206eaff1863aeeb8f997e0f21ea74e78b49/contracts/lbt/LiquidityBasedTWAP.sol#L271 ```         oracles[foreignAsset] = oracle; ```  ## Recommended Mitigation Steps Bind the oracle to pair instead  
# Handle  cmichel   # Vulnerability details  The vader price in `LiquidityBasedTWAP.getVaderPrice` is computed using the `pastLiquidityWeights` and `pastTotalLiquidityWeight` return values of the `syncVaderPrice`.  The `syncVaderPrice` function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:  ```solidity function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;         // @audit-info update period depends on pair         // @audit-issue if update period not reached => does not initialize pastLiquidityWeights[i]         if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  #### POC This bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert. Observe what happens if an attacker calls `syncVaderPrice` twice in the same block:  - The first time any pairs that need to be updated are updated - On the second call `_totalLiquidityWeight` is initialized to zero and all pairs have already been updated and thus skipped. `_totalLiquidityWeight` never increases and the storage variable `totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0;` is set to zero. - DoS because calls to `getStaleVaderPrice` / `getVaderPrice` will revert in `_calculateVaderPrice` which divides by `totalLiquidityWeight = 0`.  Attacker keeps double-calling `syncVaderPrice` every time an update window of one of the pairs becomes eligible to be updated.   ## Impact This bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met. This in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.  It's also possible to always set the `totalLiquidityWeight` to zero by calling `syncVaderPrice` twice which in turn reverts all transactions making use of the price because of a division by zero in `_caluclateVaderPrice`. An attacker can break the `USDV.mint` minting forever and any router calls to `VaderReserve.reimburseImpermanentLoss` also fail as they perform a call to the reverting price function.  ## Recommended Mitigation Steps Even if `timeElapsed < pairData.updatePeriod`, the old pair weight should still contribute to the total liquidity weight and be set in `pastLiquidityWeights`. Move the `_totalLiquidityWeight += currentLiquidityEvaluation` and the `pastLiquidityWeights[i] = pastLiquidityEvaluation` assignments before the `continue`.   
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221 vader can be initialized twice if in the first call to `setupVader`, `vaderPrice == 0`.  ## Recommended Mitigation Steps add: ``` require(vaderPrice > 0); ``` in `setupVader`.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `_addVaderPair` function is called by the `onlyOwner` role. The relevant data in the `twapData` mapping is set by querying the respective liquidity pool and Chainlink oracle. `totalLiquidityWeight` for the `VADER` path is also incremented by the `pairLiquidityEvaluation` amount (calculated within `_addVaderPair`). If a user then calls `syncVaderPrice`, the recently updated `totalLiquidityWeight` will be taken into consideration when iterating through all token pairs eligible for price updates to calculate the liquidity weight for each token pair. This data is stored in `pastTotalLiquidityWeight` and `pastLiquidityWeights` respectively.  As a result, newly added token pairs will increase `pastTotalLiquidityWeight` while leaving `pastLiquidityWeights` underrepresented. This only occurs if `syncVaderPrice` is called before the update period for the new token has not been passed.  This issue also affects how the price for `USDV` is synced.  ## Proof of Concept  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L299 ``` function _addVaderPair(     IUniswapV2Pair pair,     IAggregatorV3 oracle,     uint256 updatePeriod ) internal {     require(         updatePeriod != 0,         "LBTWAP::addVaderPair: Incorrect Update Period"     );      require(oracle.decimals() == 8, "LBTWAP::addVaderPair: Non-USD Oracle");      ExchangePair storage pairData = twapData[address(pair)];      bool isFirst = pair.token0() == vader;      (address nativeAsset, address foreignAsset) = isFirst         ? (pair.token0(), pair.token1())         : (pair.token1(), pair.token0());      oracles[foreignAsset] = oracle;      require(nativeAsset == vader, "LBTWAP::addVaderPair: Unsupported Pair");      pairData.foreignAsset = foreignAsset;     pairData.foreignUnit = uint96(         10**uint256(IERC20Metadata(foreignAsset).decimals())     );      pairData.updatePeriod = updatePeriod;     pairData.lastMeasurement = block.timestamp;      pairData.nativeTokenPriceCumulative = isFirst         ? pair.price0CumulativeLast()         : pair.price1CumulativeLast();      (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();      (uint256 reserveNative, uint256 reserveForeign) = isFirst         ? (reserve0, reserve1)         : (reserve1, reserve0);      uint256 pairLiquidityEvaluation = (reserveNative *         previousPrices[uint256(Paths.VADER)]) +         (reserveForeign * getChainlinkPrice(foreignAsset));      pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;      totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;      vaderPairs.push(pair);      if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod; } ```  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L113-L148 ``` function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;          if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  As shown above, `pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)]` loads in the total liquidity weight which is updated when `_addVaderPair` is called. However, `pastLiquidityWeights` is calculated by iterating through each token pair that is eligible to be updated.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing the line `totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;` in `_addVaderPair` so that newly added tokens do not impact upcoming queries for `VADER/USDV` price data. This should ensure `syncVaderPrice` and `syncUSDVPrice` cannot be manipulated when adding new tokens.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Invalid values returned from oracle in vast majority of situations  ## Proof of Concept  The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.  Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409  For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy. ``` foreignPrice = getChainlinkPrice(address(foreignAsset)); foreignPrice = 1e8 ```  We can set `liquidityWeights[i]` and `totalUSDVLiquidityWeight` both to 1 as we only consider a single pair so L399-401 becomes ``` totalUSD = foreignPrice; totalUSD = 1e8; ```  L403-408 is slightly more complex but from looking at the links below we can calculate `totalUSDV` as shown https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160  ``` totalUSDV = pairData     .nativeTokenPriceAverage     .mul(pairData.foreignUnit)     .decode144() // pairData.nativeTokenPriceAverage == 2**112 // pairData.foreignUnit = 10**18 // decode144(x) = x >> 112 totalUSDV = (2**112).mul(10**18).decode144() totalUSDV = 10**18 ```  Using `totalUSD` and `totalUSDV` we can then calculate the return value of `_calculateUSDVPrice`  ``` returnValue = (totalUSD * 1 ether) / totalUSDV;  returnValue = 1e8 * 1e18 / 1e18  returnValue = 1e8 ```  For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent $1 rather than 1e8.  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109  High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.  ## Recommended Mitigation Steps  Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.  Build a test suite to ensure that the oracle returns the expected values for simple situations.  
# Handle  pauliax   # Vulnerability details  ## Impact function _addUSDVPair does not check if the foreignAsset does not exist yet, thus it is possible to override it.   ## Recommended Mitigation Steps Make sure this is the intended behavior or else add validations, e.g. ```solidity   require(pairData.updatePeriod == 0, "..."); ```  
# Handle  gzeon   # Vulnerability details  ## Impact Oracles are mapped to the `foreignAsset` but not to the specific pair. Pairs with the same `foreignAsset` (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly.  ## Proof of Concept https://github.com/code-423n4/2021-12-vader/blob/9fb7f206eaff1863aeeb8f997e0f21ea74e78b49/contracts/lbt/LiquidityBasedTWAP.sol#L271 ```         oracles[foreignAsset] = oracle; ```  ## Recommended Mitigation Steps Bind the oracle to pair instead  
# Handle  cmichel   # Vulnerability details  The vader price in `LiquidityBasedTWAP.getVaderPrice` is computed using the `pastLiquidityWeights` and `pastTotalLiquidityWeight` return values of the `syncVaderPrice`.  The `syncVaderPrice` function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:  ```solidity function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;         // @audit-info update period depends on pair         // @audit-issue if update period not reached => does not initialize pastLiquidityWeights[i]         if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  #### POC This bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert. Observe what happens if an attacker calls `syncVaderPrice` twice in the same block:  - The first time any pairs that need to be updated are updated - On the second call `_totalLiquidityWeight` is initialized to zero and all pairs have already been updated and thus skipped. `_totalLiquidityWeight` never increases and the storage variable `totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0;` is set to zero. - DoS because calls to `getStaleVaderPrice` / `getVaderPrice` will revert in `_calculateVaderPrice` which divides by `totalLiquidityWeight = 0`.  Attacker keeps double-calling `syncVaderPrice` every time an update window of one of the pairs becomes eligible to be updated.   ## Impact This bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met. This in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.  It's also possible to always set the `totalLiquidityWeight` to zero by calling `syncVaderPrice` twice which in turn reverts all transactions making use of the price because of a division by zero in `_caluclateVaderPrice`. An attacker can break the `USDV.mint` minting forever and any router calls to `VaderReserve.reimburseImpermanentLoss` also fail as they perform a call to the reverting price function.  ## Recommended Mitigation Steps Even if `timeElapsed < pairData.updatePeriod`, the old pair weight should still contribute to the total liquidity weight and be set in `pastLiquidityWeights`. Move the `_totalLiquidityWeight += currentLiquidityEvaluation` and the `pastLiquidityWeights[i] = pastLiquidityEvaluation` assignments before the `continue`.   
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221 vader can be initialized twice if in the first call to `setupVader`, `vaderPrice == 0`.  ## Recommended Mitigation Steps add: ``` require(vaderPrice > 0); ``` in `setupVader`.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `_addVaderPair` function is called by the `onlyOwner` role. The relevant data in the `twapData` mapping is set by querying the respective liquidity pool and Chainlink oracle. `totalLiquidityWeight` for the `VADER` path is also incremented by the `pairLiquidityEvaluation` amount (calculated within `_addVaderPair`). If a user then calls `syncVaderPrice`, the recently updated `totalLiquidityWeight` will be taken into consideration when iterating through all token pairs eligible for price updates to calculate the liquidity weight for each token pair. This data is stored in `pastTotalLiquidityWeight` and `pastLiquidityWeights` respectively.  As a result, newly added token pairs will increase `pastTotalLiquidityWeight` while leaving `pastLiquidityWeights` underrepresented. This only occurs if `syncVaderPrice` is called before the update period for the new token has not been passed.  This issue also affects how the price for `USDV` is synced.  ## Proof of Concept  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L299 ``` function _addVaderPair(     IUniswapV2Pair pair,     IAggregatorV3 oracle,     uint256 updatePeriod ) internal {     require(         updatePeriod != 0,         "LBTWAP::addVaderPair: Incorrect Update Period"     );      require(oracle.decimals() == 8, "LBTWAP::addVaderPair: Non-USD Oracle");      ExchangePair storage pairData = twapData[address(pair)];      bool isFirst = pair.token0() == vader;      (address nativeAsset, address foreignAsset) = isFirst         ? (pair.token0(), pair.token1())         : (pair.token1(), pair.token0());      oracles[foreignAsset] = oracle;      require(nativeAsset == vader, "LBTWAP::addVaderPair: Unsupported Pair");      pairData.foreignAsset = foreignAsset;     pairData.foreignUnit = uint96(         10**uint256(IERC20Metadata(foreignAsset).decimals())     );      pairData.updatePeriod = updatePeriod;     pairData.lastMeasurement = block.timestamp;      pairData.nativeTokenPriceCumulative = isFirst         ? pair.price0CumulativeLast()         : pair.price1CumulativeLast();      (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();      (uint256 reserveNative, uint256 reserveForeign) = isFirst         ? (reserve0, reserve1)         : (reserve1, reserve0);      uint256 pairLiquidityEvaluation = (reserveNative *         previousPrices[uint256(Paths.VADER)]) +         (reserveForeign * getChainlinkPrice(foreignAsset));      pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;      totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;      vaderPairs.push(pair);      if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod; } ```  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L113-L148 ``` function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;          if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  As shown above, `pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)]` loads in the total liquidity weight which is updated when `_addVaderPair` is called. However, `pastLiquidityWeights` is calculated by iterating through each token pair that is eligible to be updated.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing the line `totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;` in `_addVaderPair` so that newly added tokens do not impact upcoming queries for `VADER/USDV` price data. This should ensure `syncVaderPrice` and `syncUSDVPrice` cannot be manipulated when adding new tokens.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Invalid values returned from oracle in vast majority of situations  ## Proof of Concept  The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.  Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409  For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy. ``` foreignPrice = getChainlinkPrice(address(foreignAsset)); foreignPrice = 1e8 ```  We can set `liquidityWeights[i]` and `totalUSDVLiquidityWeight` both to 1 as we only consider a single pair so L399-401 becomes ``` totalUSD = foreignPrice; totalUSD = 1e8; ```  L403-408 is slightly more complex but from looking at the links below we can calculate `totalUSDV` as shown https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160  ``` totalUSDV = pairData     .nativeTokenPriceAverage     .mul(pairData.foreignUnit)     .decode144() // pairData.nativeTokenPriceAverage == 2**112 // pairData.foreignUnit = 10**18 // decode144(x) = x >> 112 totalUSDV = (2**112).mul(10**18).decode144() totalUSDV = 10**18 ```  Using `totalUSD` and `totalUSDV` we can then calculate the return value of `_calculateUSDVPrice`  ``` returnValue = (totalUSD * 1 ether) / totalUSDV;  returnValue = 1e8 * 1e18 / 1e18  returnValue = 1e8 ```  For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent $1 rather than 1e8.  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109  High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.  ## Recommended Mitigation Steps  Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.  Build a test suite to ensure that the oracle returns the expected values for simple situations.  
