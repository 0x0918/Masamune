# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59   # Vulnerability details  When deploying a new `MIMOProxy`, the `MIMOProxyRegistry` first checks whether a proxy exists with the same owner for the given address. If an existing proxy is found, the deployment reverts:  [`MIMOProxyRegistry#deployFor`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59)  ```solidity   function deployFor(address owner) public override returns (IMIMOProxy proxy) {     IMIMOProxy currentProxy = _currentProxies[owner];      // Do not deploy if the proxy already exists and the owner is the same.     if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {       revert CustomErrors.PROXY_ALREADY_EXISTS(owner);     }      // Deploy the proxy via the factory.     proxy = factory.deployFor(owner);      // Set or override the current proxy for the owner.     _currentProxies[owner] = IMIMOProxy(proxy);   } } ```  However, if a `MIMOProxy` owner intentionally or accidentally destroys their proxy by `delegatecall`ing a target that calls `selfdestruct`, the address of their destroyed proxy will remain in the `_currentProxies` mapping, but the static call to `currentProxy.owner()` on L49 will revert. The caller will be blocked from deploying a new proxy from the same address that created their original `MIMOProxy.  **Impact:** If a user accidentally destroys their MIMOProxy, they must use a new EOA address to deploy another.  ### Recommendation  Check whether the proxy has been destroyed as part of the "proxy already exists" conditions. If the proxy address has a codesize of zero, it has been destroyed:  ```solidity     // Do not deploy if the proxy already exists and the owner is the same.     if (address(currentProxy) != address(0) && currentProxy.code.length > 0 && currentProxy.owner() == owner) {       revert CustomErrors.PROXY_ALREADY_EXISTS(owner);     }  ```  ### Test cases  We'll use this `ProxyAttacks` helper contract to manipulate proxy storage. Note that it has the same storage layout as `MIMOProxy`.  ```solidity contract ProxyAttacks {     address public owner;    uint256 public minGasReserve;    mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;     // Selector 0x9cb8a26a    function selfDestruct() external {      selfdestruct(payable(address(0)));    } } ```  Then deploy the `ProxyAttacks` helper in a test environment and use `MIMOProxy` to `delegatecall` into it:  ```typescript import chai, { expect } from 'chai'; import { solidity } from 'ethereum-waffle'; import { deployments, ethers } from 'hardhat';  import { MIMOProxy, MIMOProxyFactory, MIMOProxyRegistry, ProxyAttacks } from '../../typechain';  chai.use(solidity);  const setup = deployments.createFixture(async () => {   const { deploy } = deployments;   const [owner, attacker] = await ethers.getSigners();    await deploy("MIMOProxy", {     from: owner.address,     args: [],   });   const mimoProxyBase: MIMOProxy = await ethers.getContract("MIMOProxy");    await deploy("MIMOProxyFactory", {     from: owner.address,     args: [mimoProxyBase.address],   });   const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract("MIMOProxyFactory");    await deploy("MIMOProxyRegistry", {     from: owner.address,     args: [mimoProxyFactory.address],   });   const mimoProxyRegistry: MIMOProxyRegistry = await ethers.getContract("MIMOProxyRegistry");    await deploy("ProxyAttacks", {     from: owner.address,     args: [],   });   const proxyAttacks: ProxyAttacks = await ethers.getContract("ProxyAttacks");    return {     owner,     attacker,     mimoProxyBase,     mimoProxyFactory,     mimoProxyRegistry,     proxyAttacks,   }; });  describe("Proxy attack tests", () => {   it("Proxy instance self destruct + recreation", async () => {     const { owner, mimoProxyRegistry, proxyAttacks } = await setup();     await mimoProxyRegistry.deploy();     const currentProxy = await mimoProxyRegistry.getCurrentProxy(owner.address);     const proxy = await ethers.getContractAt("MIMOProxy", currentProxy);      // Delegatecall to selfDestruct on ProxyAttacks contract     await proxy.execute(proxyAttacks.address, "0x9cb8a26a");      // Owner's existing proxy is destroyed     expect(proxy.owner()).to.be.revertedWith("call revert exception");      // Cannot deploy another proxy for this address through the registry     await expect(mimoProxyRegistry.deploy()).to.be.revertedWith("function returned an unexpected amount of data");   }); }); ```
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L54 https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104   # Vulnerability details  ## Description  There is a function `execute` in `MIMOProxy` smart contract. The function performs a delegate call to the user-specified address with the specified data. As an access control, the function checks that either it was called by the owner or the owner has previously approved that the sender can call a specified target with specified calldata. See https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104.   The check itself:   ```     if (owner != msg.sender) {       bytes4 selector;       assembly {         selector := calldataload(data.offset)       }       if (!_permissions[msg.sender][target][selector]) {         revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);       }     } ```  The problem is how the `selector` is calculated. Specifically, `calldataload(data.offset)` - reads first 4 bytes of `data`.  Imagine `data.length == 0`, does it mean that `calldataload(data.offset)` will return `bytes4(0)`? No.  Let's see how calldata are accepted by functions in Solidity. The solidity function checks that the calldata length is less than needed, but does NOT check that there is no redundant data in calldata. That means, the function `execute(address target, bytes calldata data)` will definitely accept data that have `target` and `data`, but also in calldata can be other user-provided bytes. As a result,  `calldataload(data.offset)` can read trash, but not the `data` bytes.  And in the case of `execute` function, an attacker can affect the execution by providing `trash` data at the end of the function. Namely, if the attacker has permission to call the function with some `signature`, the attacker can call proxy contract bypass check for signature and make delegate call directly with zero calldata.  Please see proof-of-concept (PoC), `getAttackerCalldata` returns a calldata with which it is possible to bypass check permission for signature. Function `execute` from PoC simulate check for permission to call `signatureWithPermision`, and enforce that `data.length == 0`. With calldata from `getAttackerCalldata` it works.  ## Impact  Any account that have permission to call at least one function (signature) to the contract can call fallback function without without permission to do so.  ## Proof of Concept  ``` // SPDX-License-Identifier: MIT OR Apache-2.0  pragma solidity ^0.8.0;  interface IMIMOProxy {   event Execute(address indexed target, bytes data, bytes response);    event TransferOwnership(address indexed oldOwner, address indexed newOwner);    function initialize() external;    function getPermission(     address envoy,     address target,     bytes4 selector   ) external view returns (bool);    function owner() external view returns (address);    function minGasReserve() external view returns (uint256);    function execute(address target, bytes calldata data) external payable returns (bytes memory response);    function setPermission(     address envoy,     address target,     bytes4 selector,     bool permission   ) external;    function transferOwnership(address newOwner) external;    function multicall(address[] calldata targets, bytes[] calldata data) external returns (bytes[] memory); }  contract PoC {     bytes4 public signatureWithPermision = bytes4(0xffffffff);      // Call this function with calldata that can be prepared in `getAttackerCalldata`     function execute(address target, bytes calldata data) external {         bytes4 selector;         assembly {             selector := calldataload(data.offset)         }          require(selector == signatureWithPermision);          require(data.length == 0);     }      // Function that prepare attacker calldata     function getAttackerCalldata() public view returns(bytes memory)  {         bytes memory usualCalldata = abi.encodeWithSelector(IMIMOProxy.execute.selector, msg.sender, new bytes(0));         return abi.encodePacked(usualCalldata, bytes32(signatureWithPermision));     } } ```  ## Recommended Mitigation Steps  Add `require(data.length >= 4);`
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/actions/automated/MIMOAutoAction.sol#L32 https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/actions/automated/MIMOAutoRebalance.sol#L54   # Vulnerability details  ## Impact A `vaultOwner` who is "not confident enough in ourselves to stay up-to-date with market conditions to know when we should move to less volatile collateral to avoid liquidations." They can open their vault to other users who pay attention to the markets and would call `rebalance` to recieve the insentivized fees. The `vaultOwner` who doesn't want to pay the baiting high fees instead front-runs the `autoRebalance()` with `setAutomation()` to lower incentives.  ## Proof of Concept 1. A Mallory a `vaultOwner` isn't confident in staying up-to-date with market conditions. She has her vault setup to be automated and has high fee incentives.  2. Alice a user who is confident in staying up-to-date with market conditions see's a profitable opportunity and calls `rebalance()`. 3. Mallory is confident in her programing and watching mempools for when `rebalance()` is called. See's that Alice just called `rebalance()` and calls `setAutomation()` to lower the incentives.  4. Alice's call to `rebalance()` then goes through getting lower incentives and Mallory then calls `setAutomation()` to set the incentives back to normal.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add a time-lock to `setAutomation` so that the `vaultOwner` can't front-run users.
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L45   # Vulnerability details  ## Impact The `deployFor()` function in `MIMOProxyFactory.sol` can be called directly instead of being called within `MIMOProxyRegistry.sol`. This results in the ability to create many MIMOProxies that are not registered within the registry. The proxies deployed directly through the factory will lack the ability to call certain actions such as leveraging and emptying the vault, but will be able to call all functions in `MIMOVaultAction.sol`.  This inconsistency doesn't feel natural and would be remedied by adding an `onlyRegistry` modifier to the `ProxyFactory.deployFor()` function.  ## Proof of Concept `MIMOProxyFactory.deployFor()` lacking any access control: ```   function deployFor(address owner) public override returns (IMIMOProxy proxy) {     proxy = IMIMOProxy(mimoProxyBase.clone());     proxy.initialize();       // Transfer the ownership from this factory contract to the specified owner.     proxy.transferOwnership(owner);       // Mark the proxy as deployed.     _proxies[address(proxy)] = true;       // Log the proxy via en event.     emit DeployProxy(msg.sender, owner, address(proxy));   } } ```  Example of reduced functionality: `MIMOEmptyVault.executeOperation()` checks proxy existence in the proxy registry therefore can't be called. ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {     (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));     IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner)); ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Adding access control to ensure that the factory deployFor function is called from the proxy registry would mitigate this issue.
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58 https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59   # Vulnerability details  ## Impact The description of Registry.sol is following: /// Deploys new proxies via the factory and keeps a registry of owners to proxies. Owners can only /// have one proxy at a time. But it is not. There are multiple problems: 1) Proxy owner can change and will not be registered 2) There many ways for an owner to have many proxies: - a few other proxy owners transfeOwnership() to one address - Registry tracks last deployments and does not guarantee ownership - Factory.sol allows calling deployFor() to anyone, without any checks and registrations  ## Proof of Concept https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58 https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59  ## Tools Used Hardhat  ## Recommended Mitigation Steps Delete Proxy.transfetOwnership() Disallow anyone to call deploy() and deployFor() in Factory()
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/automated/MIMOAutoAction.sol#L33 https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/managed/MIMOManagedAction.sol#L35   # Vulnerability details  ## Impact & Proof Of Concept `vaultOwner` returns zero for a non-existing `vaultId`. Similarly, `proxyRegistry.getCurrentProxy(msg.sender)` returns zero when `msg.sender` has not deployed a proxy yet. Those two facts can be combined to set automation for a vault ID that does not exist yet. When this is done by a user without a proxy, it will succeed, as both `vaultOwner` and `mimoProxy` are `address(0)`, i.e. we have `vaultOwner == mimoProxy`.  The consequences of this are quite severe. As soon as the vault is created, it will be an automated vault (with potentially very high fees). An attacker can exploit this by setting very high fees before the creation of the vault and then performing actions for the automated vault, which leads to a loss of funds for the user.  The same attack is possible for `setManagement`.  ## Recommended Mitigation Steps Do not allow setting automation parameters for non-existing vaults, i.e. check that `vaultOwner != address(0)`.
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/managed/MIMOManagedRebalance.sol#L50-L80   # Vulnerability details  ## Impact Inconsistent manager fees could lead to lack of incentivization to rebalance and unexpected liquidation.  ## Proof of Concept      uint256 managerFee = managedVault.fixedFee + flData.amount.wadMul(managedVault.varFee);      IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);  The variable portion of the fee is calculated using the amount of the flashloan but pays out in PAR. This is problematic because the value of the flashloan asset is constantly fluctuating in value against PAR. This results in an unpredictable fee for both the user and the manager. If the asset drops in price then the user will pay more than they intended. If the asset increases in price then the fee may not be enough to incentivize the manager to call them. The purpose of the managed rebalance is limit user interaction. If the manager isn't incentivized to call the vault then the user may be unexpectedly liquidated, resulting in loss of user funds.    ## Tools Used  ## Recommended Mitigation Steps  varFee should be calculated against the PAR of the rebalance like it is in MIMOAutoRebalance.sol:      IPriceFeed priceFeed = a.priceFeed();     address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);      uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, flData.amount);     uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/MIMOEmptyVault.sol#L96-L100   # Vulnerability details  ## Impact MIMOEmptyVault.sol executeAction() is supposed to pay off the debt and return the leftover assets to the owner of the Vault But In fact the emptyVault contract, after executing the executionOperation(), only pays back the flash loan, and does not transfer the leftover assets to the owner, and locked in the emptyVault contract  ## Proof of Concept ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {      ....     ....      require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);      vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);      //****Paid off the flash loan but did not transfer the remaining balance back to mimoProxy or owner ***//      return true;   }  ```  Add logs to test case   test/02_integration/MIMOEmtpyVault.test.ts  ```   it("should be able to empty vault with 1inch", async () => {   ...   ...   ...   ++++ console.log("before emptyVault balance:--->", (await wmatic.balanceOf(emptyVault.address)) + "");     const tx = await mimoProxy.execute(emptyVault.address, MIMOProxyData);     const receipt = await tx.wait(1);   ++++ console.log("after emptyVault balance: --->", (await wmatic.balanceOf(emptyVault.address)) + "");    ```  print: ``` before emptyVault balance:---> 0 after emptyVault balance: ---> 44383268870065355782  ```  ## Tools Used  ## Recommended Mitigation Steps  ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {      ....     ....      require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);      vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);      //****transfer the remaining balance back to mimoProxy or owner ***//     ++++ vaultCollateral.safeTransfer(address(mimoProxy), vaultCollateral.balanceOf(address(this)) - flashloanRepayAmount);      return true;   }  ``` 
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59   # Vulnerability details  When deploying a new `MIMOProxy`, the `MIMOProxyRegistry` first checks whether a proxy exists with the same owner for the given address. If an existing proxy is found, the deployment reverts:  [`MIMOProxyRegistry#deployFor`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59)  ```solidity   function deployFor(address owner) public override returns (IMIMOProxy proxy) {     IMIMOProxy currentProxy = _currentProxies[owner];      // Do not deploy if the proxy already exists and the owner is the same.     if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {       revert CustomErrors.PROXY_ALREADY_EXISTS(owner);     }      // Deploy the proxy via the factory.     proxy = factory.deployFor(owner);      // Set or override the current proxy for the owner.     _currentProxies[owner] = IMIMOProxy(proxy);   } } ```  However, if a `MIMOProxy` owner intentionally or accidentally destroys their proxy by `delegatecall`ing a target that calls `selfdestruct`, the address of their destroyed proxy will remain in the `_currentProxies` mapping, but the static call to `currentProxy.owner()` on L49 will revert. The caller will be blocked from deploying a new proxy from the same address that created their original `MIMOProxy.  **Impact:** If a user accidentally destroys their MIMOProxy, they must use a new EOA address to deploy another.  ### Recommendation  Check whether the proxy has been destroyed as part of the "proxy already exists" conditions. If the proxy address has a codesize of zero, it has been destroyed:  ```solidity     // Do not deploy if the proxy already exists and the owner is the same.     if (address(currentProxy) != address(0) && currentProxy.code.length > 0 && currentProxy.owner() == owner) {       revert CustomErrors.PROXY_ALREADY_EXISTS(owner);     }  ```  ### Test cases  We'll use this `ProxyAttacks` helper contract to manipulate proxy storage. Note that it has the same storage layout as `MIMOProxy`.  ```solidity contract ProxyAttacks {     address public owner;    uint256 public minGasReserve;    mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;     // Selector 0x9cb8a26a    function selfDestruct() external {      selfdestruct(payable(address(0)));    } } ```  Then deploy the `ProxyAttacks` helper in a test environment and use `MIMOProxy` to `delegatecall` into it:  ```typescript import chai, { expect } from 'chai'; import { solidity } from 'ethereum-waffle'; import { deployments, ethers } from 'hardhat';  import { MIMOProxy, MIMOProxyFactory, MIMOProxyRegistry, ProxyAttacks } from '../../typechain';  chai.use(solidity);  const setup = deployments.createFixture(async () => {   const { deploy } = deployments;   const [owner, attacker] = await ethers.getSigners();    await deploy("MIMOProxy", {     from: owner.address,     args: [],   });   const mimoProxyBase: MIMOProxy = await ethers.getContract("MIMOProxy");    await deploy("MIMOProxyFactory", {     from: owner.address,     args: [mimoProxyBase.address],   });   const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract("MIMOProxyFactory");    await deploy("MIMOProxyRegistry", {     from: owner.address,     args: [mimoProxyFactory.address],   });   const mimoProxyRegistry: MIMOProxyRegistry = await ethers.getContract("MIMOProxyRegistry");    await deploy("ProxyAttacks", {     from: owner.address,     args: [],   });   const proxyAttacks: ProxyAttacks = await ethers.getContract("ProxyAttacks");    return {     owner,     attacker,     mimoProxyBase,     mimoProxyFactory,     mimoProxyRegistry,     proxyAttacks,   }; });  describe("Proxy attack tests", () => {   it("Proxy instance self destruct + recreation", async () => {     const { owner, mimoProxyRegistry, proxyAttacks } = await setup();     await mimoProxyRegistry.deploy();     const currentProxy = await mimoProxyRegistry.getCurrentProxy(owner.address);     const proxy = await ethers.getContractAt("MIMOProxy", currentProxy);      // Delegatecall to selfDestruct on ProxyAttacks contract     await proxy.execute(proxyAttacks.address, "0x9cb8a26a");      // Owner's existing proxy is destroyed     expect(proxy.owner()).to.be.revertedWith("call revert exception");      // Cannot deploy another proxy for this address through the registry     await expect(mimoProxyRegistry.deploy()).to.be.revertedWith("function returned an unexpected amount of data");   }); }); ```
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L54 https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104   # Vulnerability details  ## Description  There is a function `execute` in `MIMOProxy` smart contract. The function performs a delegate call to the user-specified address with the specified data. As an access control, the function checks that either it was called by the owner or the owner has previously approved that the sender can call a specified target with specified calldata. See https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104.   The check itself:   ```     if (owner != msg.sender) {       bytes4 selector;       assembly {         selector := calldataload(data.offset)       }       if (!_permissions[msg.sender][target][selector]) {         revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);       }     } ```  The problem is how the `selector` is calculated. Specifically, `calldataload(data.offset)` - reads first 4 bytes of `data`.  Imagine `data.length == 0`, does it mean that `calldataload(data.offset)` will return `bytes4(0)`? No.  Let's see how calldata are accepted by functions in Solidity. The solidity function checks that the calldata length is less than needed, but does NOT check that there is no redundant data in calldata. That means, the function `execute(address target, bytes calldata data)` will definitely accept data that have `target` and `data`, but also in calldata can be other user-provided bytes. As a result,  `calldataload(data.offset)` can read trash, but not the `data` bytes.  And in the case of `execute` function, an attacker can affect the execution by providing `trash` data at the end of the function. Namely, if the attacker has permission to call the function with some `signature`, the attacker can call proxy contract bypass check for signature and make delegate call directly with zero calldata.  Please see proof-of-concept (PoC), `getAttackerCalldata` returns a calldata with which it is possible to bypass check permission for signature. Function `execute` from PoC simulate check for permission to call `signatureWithPermision`, and enforce that `data.length == 0`. With calldata from `getAttackerCalldata` it works.  ## Impact  Any account that have permission to call at least one function (signature) to the contract can call fallback function without without permission to do so.  ## Proof of Concept  ``` // SPDX-License-Identifier: MIT OR Apache-2.0  pragma solidity ^0.8.0;  interface IMIMOProxy {   event Execute(address indexed target, bytes data, bytes response);    event TransferOwnership(address indexed oldOwner, address indexed newOwner);    function initialize() external;    function getPermission(     address envoy,     address target,     bytes4 selector   ) external view returns (bool);    function owner() external view returns (address);    function minGasReserve() external view returns (uint256);    function execute(address target, bytes calldata data) external payable returns (bytes memory response);    function setPermission(     address envoy,     address target,     bytes4 selector,     bool permission   ) external;    function transferOwnership(address newOwner) external;    function multicall(address[] calldata targets, bytes[] calldata data) external returns (bytes[] memory); }  contract PoC {     bytes4 public signatureWithPermision = bytes4(0xffffffff);      // Call this function with calldata that can be prepared in `getAttackerCalldata`     function execute(address target, bytes calldata data) external {         bytes4 selector;         assembly {             selector := calldataload(data.offset)         }          require(selector == signatureWithPermision);          require(data.length == 0);     }      // Function that prepare attacker calldata     function getAttackerCalldata() public view returns(bytes memory)  {         bytes memory usualCalldata = abi.encodeWithSelector(IMIMOProxy.execute.selector, msg.sender, new bytes(0));         return abi.encodePacked(usualCalldata, bytes32(signatureWithPermision));     } } ```  ## Recommended Mitigation Steps  Add `require(data.length >= 4);`
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/actions/automated/MIMOAutoAction.sol#L32 https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/actions/automated/MIMOAutoRebalance.sol#L54   # Vulnerability details  ## Impact A `vaultOwner` who is "not confident enough in ourselves to stay up-to-date with market conditions to know when we should move to less volatile collateral to avoid liquidations." They can open their vault to other users who pay attention to the markets and would call `rebalance` to recieve the insentivized fees. The `vaultOwner` who doesn't want to pay the baiting high fees instead front-runs the `autoRebalance()` with `setAutomation()` to lower incentives.  ## Proof of Concept 1. A Mallory a `vaultOwner` isn't confident in staying up-to-date with market conditions. She has her vault setup to be automated and has high fee incentives.  2. Alice a user who is confident in staying up-to-date with market conditions see's a profitable opportunity and calls `rebalance()`. 3. Mallory is confident in her programing and watching mempools for when `rebalance()` is called. See's that Alice just called `rebalance()` and calls `setAutomation()` to lower the incentives.  4. Alice's call to `rebalance()` then goes through getting lower incentives and Mallory then calls `setAutomation()` to set the incentives back to normal.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add a time-lock to `setAutomation` so that the `vaultOwner` can't front-run users.
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L45   # Vulnerability details  ## Impact The `deployFor()` function in `MIMOProxyFactory.sol` can be called directly instead of being called within `MIMOProxyRegistry.sol`. This results in the ability to create many MIMOProxies that are not registered within the registry. The proxies deployed directly through the factory will lack the ability to call certain actions such as leveraging and emptying the vault, but will be able to call all functions in `MIMOVaultAction.sol`.  This inconsistency doesn't feel natural and would be remedied by adding an `onlyRegistry` modifier to the `ProxyFactory.deployFor()` function.  ## Proof of Concept `MIMOProxyFactory.deployFor()` lacking any access control: ```   function deployFor(address owner) public override returns (IMIMOProxy proxy) {     proxy = IMIMOProxy(mimoProxyBase.clone());     proxy.initialize();       // Transfer the ownership from this factory contract to the specified owner.     proxy.transferOwnership(owner);       // Mark the proxy as deployed.     _proxies[address(proxy)] = true;       // Log the proxy via en event.     emit DeployProxy(msg.sender, owner, address(proxy));   } } ```  Example of reduced functionality: `MIMOEmptyVault.executeOperation()` checks proxy existence in the proxy registry therefore can't be called. ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {     (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));     IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner)); ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Adding access control to ensure that the factory deployFor function is called from the proxy registry would mitigate this issue.
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58 https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59   # Vulnerability details  ## Impact The description of Registry.sol is following: /// Deploys new proxies via the factory and keeps a registry of owners to proxies. Owners can only /// have one proxy at a time. But it is not. There are multiple problems: 1) Proxy owner can change and will not be registered 2) There many ways for an owner to have many proxies: - a few other proxy owners transfeOwnership() to one address - Registry tracks last deployments and does not guarantee ownership - Factory.sol allows calling deployFor() to anyone, without any checks and registrations  ## Proof of Concept https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58 https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59  ## Tools Used Hardhat  ## Recommended Mitigation Steps Delete Proxy.transfetOwnership() Disallow anyone to call deploy() and deployFor() in Factory()
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/automated/MIMOAutoAction.sol#L33 https://github.com/code-423n4/2022-08-mimo/blob/9adf46f2efc61898247c719f2f948b41d5d62bbe/contracts/actions/managed/MIMOManagedAction.sol#L35   # Vulnerability details  ## Impact & Proof Of Concept `vaultOwner` returns zero for a non-existing `vaultId`. Similarly, `proxyRegistry.getCurrentProxy(msg.sender)` returns zero when `msg.sender` has not deployed a proxy yet. Those two facts can be combined to set automation for a vault ID that does not exist yet. When this is done by a user without a proxy, it will succeed, as both `vaultOwner` and `mimoProxy` are `address(0)`, i.e. we have `vaultOwner == mimoProxy`.  The consequences of this are quite severe. As soon as the vault is created, it will be an automated vault (with potentially very high fees). An attacker can exploit this by setting very high fees before the creation of the vault and then performing actions for the automated vault, which leads to a loss of funds for the user.  The same attack is possible for `setManagement`.  ## Recommended Mitigation Steps Do not allow setting automation parameters for non-existing vaults, i.e. check that `vaultOwner != address(0)`.
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/managed/MIMOManagedRebalance.sol#L50-L80   # Vulnerability details  ## Impact Inconsistent manager fees could lead to lack of incentivization to rebalance and unexpected liquidation.  ## Proof of Concept      uint256 managerFee = managedVault.fixedFee + flData.amount.wadMul(managedVault.varFee);      IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);  The variable portion of the fee is calculated using the amount of the flashloan but pays out in PAR. This is problematic because the value of the flashloan asset is constantly fluctuating in value against PAR. This results in an unpredictable fee for both the user and the manager. If the asset drops in price then the user will pay more than they intended. If the asset increases in price then the fee may not be enough to incentivize the manager to call them. The purpose of the managed rebalance is limit user interaction. If the manager isn't incentivized to call the vault then the user may be unexpectedly liquidated, resulting in loss of user funds.    ## Tools Used  ## Recommended Mitigation Steps  varFee should be calculated against the PAR of the rebalance like it is in MIMOAutoRebalance.sol:      IPriceFeed priceFeed = a.priceFeed();     address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);      uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, flData.amount);     uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);
# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/MIMOEmptyVault.sol#L96-L100   # Vulnerability details  ## Impact MIMOEmptyVault.sol executeAction() is supposed to pay off the debt and return the leftover assets to the owner of the Vault But In fact the emptyVault contract, after executing the executionOperation(), only pays back the flash loan, and does not transfer the leftover assets to the owner, and locked in the emptyVault contract  ## Proof of Concept ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {      ....     ....      require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);      vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);      //****Paid off the flash loan but did not transfer the remaining balance back to mimoProxy or owner ***//      return true;   }  ```  Add logs to test case   test/02_integration/MIMOEmtpyVault.test.ts  ```   it("should be able to empty vault with 1inch", async () => {   ...   ...   ...   ++++ console.log("before emptyVault balance:--->", (await wmatic.balanceOf(emptyVault.address)) + "");     const tx = await mimoProxy.execute(emptyVault.address, MIMOProxyData);     const receipt = await tx.wait(1);   ++++ console.log("after emptyVault balance: --->", (await wmatic.balanceOf(emptyVault.address)) + "");    ```  print: ``` before emptyVault balance:---> 0 after emptyVault balance: ---> 44383268870065355782  ```  ## Tools Used  ## Recommended Mitigation Steps  ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address initiator,     bytes calldata params   ) external override returns (bool) {      ....     ....      require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);      vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);      //****transfer the remaining balance back to mimoProxy or owner ***//     ++++ vaultCollateral.safeTransfer(address(mimoProxy), vaultCollateral.balanceOf(address(this)) - flashloanRepayAmount);      return true;   }  ``` 
