See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Udsen-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/joestakey-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/nadin-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Deathstore-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/leopoldjoy-G.md).
# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1386-L1393   # Vulnerability details  ## Impact  Staking rewards are calculated based on the user's share of total points in the corresponding asset pool, this is the sum of the points associated to the staker's positions divided by the total points from all positions in the pool. We can see this calculation in the `getPoolReward` function:  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1386-L1393  ```solidity // Return final shares. unchecked {     uint256 share = points * _PRECISION / pool.totalPoints * totalReward;     uint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);     share /= _PRECISION;     daoShare /= _PRECISION;     return ((share - daoShare), daoShare); } ```  However, note that `pool.totalPoints` is the current value of the pool's total point at the time the function `getPoolReward` is called. It isn't related to the time the user staked their position, or isn't affected in any way by other stake/unstake actions from potentially other users.  This means that any action that modifies the pool's total points (stake or unstake) won't affect current staking positions, as previously opened staking positions won't accrue their rewards correctly. For stake actions, it will cause rewards from existing staking positions to be reduced, as their calculation of the shares now divided by a higher `pool.totalPoints` value. From unstake actions, it will cause rewards from existing staking positions to be incorrectly increased, as the calculation of the shares is now divided by a lower `pool.totalPoints` value. See section "Proof of Concept" for a more detailed walkthrough.  In a similar way, this could also be used by a griefer to intentionally harm another user. As the `getReward` function present in the `BYTES2` contract is permissionless (anyone can call this on behalf of an arbitrary account), a bad actor can call this when the pool's total points is high, which will have the effect of reducing the user rewards.  ## Proof of Concept  Let's assume the pool is empty. Alice stakes at `t1` an asset worth 100 points and Bob stakes at `t2` another asset worth 100 points. In order to simplify the examples, let's also consider that all periods fall in the same window, thus having a constant reward rate.  ### Alice claims after Bob stakes  In this scenario, Alice claims her rewards in `t3` after Bob stakes. She will get less rewards from the `[t1, t2]` period, as the calculation will consider the entire period `[t1, t3]` and calculate the shares using 200 points. Here the correct way would be to calculate the period `[t1, t2]` using 100 total points, and the period `[t2, t3]` using 100 total points.  1. Alice stakes at `t1` and gets 100 points. Total points is 100. 2. Bob stakes at `t2` and gets 100 points. Total points is 200. 3. Alice claims rewards at `t3`. She will get less rewards since the calculation will be done using 200 points.  ### Alice and Bob stake at same time  Here, `t1 == t2` and Bob and Alice stake at the same time. Alice unstakes at `t3` and Bob claims rewards at `t4`. In this case, Bob will get more rewards, as the calculation will consider the entire period `[t1, t4]` and calculate the shares using 100 points. Here the correct way would be to calculate the period `[t1, t3]` using 200 total points, and the period `[t3, t4]` using 100 total points.  1. Alice and Bob stake at `t1 == t2` and each one gets 100 points. Total points is 200. 2. Alice unstakes at `t3`. Total points is 100. 3. Bob claims rewards at `t4`. He will get more rewards since the calculation will be done using 100 points.  ### Griefer intentionally claims rewards of Alice  As described in the previous section, a bad actor can intentionally claim the rewards of another user at a time the pool has a high value for total points, since this call as this is a permissionless action.  1. Alice stakes at `t1` and gets 100 points. Total points is 100. 2. Bob stakes at `t2` and gets 100 points. Total points is 200. 3. Bad actor claims rewards of Alice at `t3`. She will get less rewards since the calculation will be done using 200 points.  ## Recommendation  Rewards calculation should track reward rate according to modifications in the pool's total points caused by stake or unstake actions.   My recommendation for a performant solution would be to follow [this staking example](https://solidity-by-example.org/defi/staking-rewards/) or [the full Staking contract from Synthetix](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol). The principal idea here is that every action that affects rewards triggers the `updateReward` modifier, which updates the `rewardPerTokenStored` variable that tracks the reward amount per staked token. A similar idea could be adapted to track the reward per point for the current contract. Stake and unstake actions should update this variable before modifying the pool's total points. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Aymen0909-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/0x1f8b-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/hunter_w3b-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/c3phas-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/carlitox477-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/ulqiorra-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/atharvasama-G.md).
# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L203 https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L10617-L1080 https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1085-L1101   # Vulnerability details  ## Impact  A magnitude of 100 times will completely break the balance on the rewards system calculation, as staking S1 Citizens, S2 Citizens and LP tokens will accrue 100 times less in comparison, and ultimately those users will only be able to claim a fraction of the rewards compared to the ones staking BYTES.  This will break the rewards system, and greatly discourage users from staking LP tokens, or from staking their Citizens without staking BYTES.  ## Proof of Concept  The `_stakeBytes()` function for staking BYTES with S1 and S2 Citizens has an error when calculating the `bonusPoints`.  As per the [documentation](https://github.com/code-423n4/2023-03-neotokyo/tree/main#overview): "Staking participants may also stake BYTES 2.0 tokens into their S1 or S2 Citizens in order to boost the points weight of those Citizens at a rate of 200 BYTES per point."  This means `200 BYTES per point`.  The code defines it as: `bonusPoints = (amount * 100 / _BYTES_PER_POINT)`  Which translates to: `bonusPoints = amount * 100 / (200 * 1e18)`  This results in the miscalculation that it only needs: `2 BYTES per point`, which is 100 times lower than expected.  This may be due to some confusion between "base points" and "basis points". [1 base point = 100 basis points](https://discord.com/channels/810916927919620096/1082395240566104216/1084307565145509980).  `bonusPoints` are added to both `citizenStatus.points` and `pool.totalPoints`. So they must be expressed in base points.  Examples:  ```solidity     // For 200 BYTES `amount == 200 * 1e18`     // Expected: 1 point     // Result: 100 points     bonusPoints = (amount * 100 / _BYTES_PER_POINT);     bonusPoints = amount * 100 / (200 * 1e18);     bonusPoints = (200 * 1e18) * 100 / (200 * 1e18);     bonusPoints = 100; ```  ```solidity     // For 2 BYTES: `amount == 2 * 1e18`     // Expected: 0 points     // Result: 1 point     bonusPoints = (amount * 100 / _BYTES_PER_POINT);     bonusPoints = amount * 100 / (200 * 1e18);     bonusPoints = (2 * 1e18) * 100 / (200 * 1e18);     bonusPoints = 1; ```  References:  The definition of `_BYTES_PER_POINT`:  ```solidity // File: NeoTokyoStaker.sol  202: /// The number of BYTES needed to get one point in BYTES staking calculations. 203: uint256 constant private _BYTES_PER_POINT = 200 * 1e18; ```  [Link to Code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L203)  `bonusPoints` are miscalculated in `_stakeBytes()` and added to the user and the S1 and S2 pool:  ```solidity // File: NeoTokyoStaker.sol // Function: _stakeBytes() // S1 Citizen  L1061:           StakedS1Citizen storage citizenStatus = stakedS1[msg.sender][citizenId];  L1075:                              PoolData storage pool = _pools[AssetType.S1_CITIZEN];  L1077:    uint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT); // @audit wrong calculation L1078:    citizenStatus.stakedBytes += amount; L1079:    citizenStatus.points += bonusPoints; // @audit accrued more points than expected L1080:    pool.totalPoints += bonusPoints; // @audit imbalance in the pool total points ```  [Link to Code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L10617-L1080)  ```solidity // File: NeoTokyoStaker.sol // Function: _stakeBytes() // S2 Citizen  L1085:               StakedS2Citizen storage citizenStatus = stakedS2[msg.sender][citizenId];  L1096:                              PoolData storage pool = _pools[AssetType.S2_CITIZEN];  L1098:    uint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT); // @audit wrong calculation L1099:    citizenStatus.stakedBytes += amount; L1100:    citizenStatus.points += bonusPoints; // @audit accrued more points than expected L1101:    pool.totalPoints += bonusPoints; // @audit imbalance in the pool total points ```  [Link to Code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1085-L1101)  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Fix the calculation by removing the `* 100`:  ```diff // File: NeoTokyoStaker.sol // Function: _stakeBytes()  -    uint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT); +    uint256 bonusPoints = amount / _BYTES_PER_POINT; ```  Check that the calculation for LP tokens is done correctly:  ```solidity 1155:   uint256 points = amount * 100 / 1e18 * timelockMultiplier / _DIVISOR; ```  [Link to code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1155)  ```solidity 1623:   uint256 points = amount * 100 / 1e18 * lpPosition.multiplier / _DIVISOR; ```  [Link to code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1623)  Fix the corresponding tests, and replace with exact calculations, as the use broad ranges make it difficult to spot these issues:  ```javascript // Confirm Bob and the DAO received their proper share. let bobBalance = await NTBytes2_0.balanceOf(bob.address); bobBalance.sub(bobBalanceInitial).should.be.closeTo(   ethers.BigNumber.from("8919540229885057471"), // @audit broad range   ethers.BigNumber.from("1000000000") // @audit broad range ); ``` 
# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/dfa5887062e47e2d0c801ef33062d44c09f6f36e/contracts/staking/NeoTokyoStaker.sol#L1378   # Vulnerability details  ## Impact one of the main features that the staking contract that should always and carefully operate is the reward calculation, there is a miscalculation on every time the getPoolReward is being called on first time staking with a pool of a single window reward count, where lastPoolRewardTime is initially equal to 0, that leads that the timeSinceReward is equal to block timestamp, which massively inflate totalReward. but since the points initially are 0, it gets multiplied by 0 so it would lead to a share of 0. It is advised that the internal calculations are correct at all times.  ## Proof of Concept To help on illustrating the miscalculation, we would apply it on LP, but it's also applicable to S1 and S2.   - We import hardhat console in `NeoTokyoStaker.sol`: ```solidity import "hardhat/console.sol"; ``` - we add the following test case to `NeoTokyoStaker.test.js` within `with example configuration` describe test suite:  ```js   describe('internal miscalculation', function () {    it("internally calculates an inflatable LP totalReward", async function () {     // Configure the LP token contract address on the staker.     await NTStaking.connect(owner.signer).configureLP(LPToken.address);      // Stake Alice's LP tokens to have a non zero pool total points     await NTStaking.connect(alice.signer).stake(      ASSETS.LP.id,      TIMELOCK_OPTION_IDS['30'],      ethers.utils.parseEther('40'),      0,      0     );      // Stake Bob's LP tokens     await NTStaking.connect(bob.signer).stake(      ASSETS.LP.id,      TIMELOCK_OPTION_IDS['1080'],      ethers.utils.parseEther('10'),      0,      0     );    })   }) ``` - we finally add the debugging console.log within the `NeoTokyoStaker.sol` contract: ```solidity     function getPoolReward(AssetType _assetType, address _recipient) public view returns (uint256, uint256) {     // ...                 } else if (i == windowCount - 1) {                     unchecked {                         uint256 timeSinceReward = block.timestamp - lastPoolRewardTime;                         console.log("last pool reward time", lastPoolRewardTime); // +                         console.log("time passed", timeSinceReward); // +                         totalReward = window.reward * timeSinceReward;                     }                     break;                 }    // ...    // Return final shares.             unchecked {                 uint256 share = points * _PRECISION / pool.totalPoints * totalReward;                 uint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);                 share /= _PRECISION;                 daoShare /= _PRECISION;                  console.log("points", points); // +                 console.log("pool total points", pool.totalPoints); // +                 console.log("total reward", totalReward); // +                 return ((share - daoShare), daoShare);             }         }         return (0, 0);     } ``` - after running the test case, we would have the following output:  ```sh       internal miscalculation last pool reward time 0 time passed 2678881252 points 0 pool total points 4000 total reward 1550278502314812929676156         √ internally calculates an inflateable LP totalReward ```  - We can see clearly that initially the total reward is directly correlated with the block timestamp, which would lead to the total reward to be internally calculated in an inflated manner. on the mainnet at block.timestamp of 1678881350, we have in the test case a time passed of 2678881252, so it would result in:  - totalReward = 1550278502314812929676156 / 2678881252 * 1678881350 / 10**18 = 971574.855324 BYTES2.0  ## Tools Used Vs code  ## Recommended Mitigation Steps  - for a safer internal reward calculation, we may simply add a check that ensure that the user's getPoolReward call is not the first time call:  ```solidity     function getPoolReward(AssetType _assetType, address _recipient) public view returns (uint256, uint256) {         /*     During the very first stake, there will not be any points in the pool. In      this case, do not attempt to grant any rewards so as to prevent reversion.         */         PoolData storage pool = _pools[_assetType];         uint256 lastPoolRewardTime = lastRewardTime[_recipient][_assetType];         if (pool.totalPoints != 0 && lastPoolRewardTime != 0) {              // ...         }         return (0, 0);    }  ```
# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1622-L1631   # Vulnerability details  ## Impact NeoTokyoStaking allows to stake and withdraw LPs. User can stake multiple times on same position which simply results in extended lock time and user can withdraw all of these LPs once lock time is passed.  There is a scenario when withdrawing LPs results in overflow of [lpPosition.points](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1627). After withdraw if attacker calls `getRewards()` then attacker will get more than 1e64 BYTES tokens as reward.  ## Proof of Concept Affected code block: [NeoTokyoStaker.sol#L1622-L1631]( https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1622-L1631)  Affected line: [L1627](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1627)  From below POC you can see that Alice is staking twice and some specific amounts which will trigger underflow when Alice withdraw LP. Once staked LPs are unlocked, Alice can withdraw her LPs and call `getReward()` to trigger minting of more than 1e64 BYTES tokens.  Below test can be added in `NeoTokyoStaker.test.js` test file. ```js   it('Unexpected rewards minting due to underflow of "points"', async function () {    // Configure the LP token contract address on the staker.    await NTStaking.connect(owner.signer).configureLP(LPToken.address);    const amount1 = ethers.utils.parseEther('10.009')    const amount2 = ethers.utils.parseEther('11.009')    const lockingDays = 30        // Alice stake amount1 LPs for 30 days.    await NTStaking.connect(alice.signer).stake(     ASSETS.LP.id,     TIMELOCK_OPTION_IDS[lockingDays],     amount1,     0,     0    );     // Alice stake amount2 LPs for 30 days.    await NTStaking.connect(alice.signer).stake(     ASSETS.LP.id,     TIMELOCK_OPTION_IDS[lockingDays],     amount2,     0,     0    );     const priorBlockNumber = await ethers.provider.getBlockNumber();    const priorBlock = await ethers.provider.getBlock(priorBlockNumber);    let aliceStakeTime = priorBlock.timestamp;        // Bob stake 10 LPs for 30 days    await NTStaking.connect(bob.signer).stake(     ASSETS.LP.id,     TIMELOCK_OPTION_IDS[lockingDays],     ethers.utils.parseEther('10'),     0,     0    );     // Set time to unlock staked lp    await ethers.provider.send('evm_setNextBlockTimestamp', [     aliceStakeTime + (60 * 60 * 24 * lockingDays)    ]);        // Alice withdraw LP                         // This transaction will cause underflow of `lpPosition.points`    await NTStaking.connect(alice.signer).withdraw(     ASSETS.LP.id,     amount1.add(amount2)    );     // Before exploit:: Verify Alice's Bytes balance is less than 10000 BYTES    expect(await NTBytes2_0.balanceOf(alice.address)).lt(ethers.utils.parseUnits('10000', 18))        // Get rewards for Alice. It will mint HUGE rewards due to underflow happened on withdraw transaction.    await NTBytes2_0.getReward(alice.address)     // After exploit:: Verify Alice's Bytes balance is greater than 3e64    expect(await NTBytes2_0.balanceOf(alice.address)).gt(ethers.utils.parseUnits('3', 64))   }); ```  ## Tools Used Manual  ## Recommended Mitigation Steps Consider adding proper precision for `points` and `totalPoints` and also consider checking for under/overflows.
