# Gas Optimizations ## Loop in `Delegation` and `PermitAndMulticall` contracts Loops can be optimized in several ways. Let's take for example the loop in the `executeCalls` function of the `Delegation` contract. ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   for (uint256 i = 0; i < calls.length; i++) {     response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);   }   return response; } ``` To optimize this loop and make it consume less gas, we can do the foloowing things: 1. Use ++i instead of i++, which is a cheaper operation (in this case there is no difference between i++ and ++i because we dont use the return value of this expression, which is the only difference between these two expression). 2. Save the `calls` array length in a local variable instead of accessing it in every iteration. 3. Save `calls[i]` in a local variable instead of accessing it 3 times in every iteration. This will save accssing the array's ith element 3 times in every iteration ,which requires an address calculation. 4. There's no need to initialize i to its default value, it will be done automatically and it will consume more gas if it will be done (I know, sounds stupid, but trust me - it works). So after applying all these changes, the loop will look something like this: ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   uint256 length = calls.length;   Call memory call;   for (uint256 i; i < length; ++i) {     call = calls[i];     response[i] = _executeCall(call.to, call.value, call.data);   }   return response; } ```  ## Inline all these little functions Defining all these little functions cause 2 things: 1. contract's code size gets bigger 2. the function calls consumes more gas than exectuing it as an inlined function (part of the code, without the function call) So in order to save gas, I would reccomend to inline these functions.  ```sol   function _computeAddress(address _delegator, uint256 _slot) internal view returns (address) {     return _computeAddress(_computeSalt(_delegator, bytes32(_slot)));   }    function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {     return uint96(block.timestamp) + _lockDuration;   }    function _requireDelegatorOrRepresentative(address _delegator) internal view {     require(       _delegator == msg.sender || representatives[_delegator][msg.sender] == true,       "TWABDelegator/not-delegator-or-rep"     );   }    function _requireDelegateeNotZeroAddress(address _delegatee) internal pure {     require(_delegatee != address(0), "TWABDelegator/dlgt-not-zero-adr");   }    function _requireAmountGtZero(uint256 _amount) internal pure {     require(_amount > 0, "TWABDelegator/amount-gt-zero");   }    function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), "TWABDelegator/dlgtr-not-zero-adr");   }    function _requireRecipientNotZeroAddress(address _to) internal pure {     require(_to != address(0), "TWABDelegator/to-not-zero-addr");   }    function _requireDelegationUnlocked(Delegation _delegation) internal view {     require(block.timestamp >= _delegation.lockUntil(), "TWABDelegator/delegation-locked");   }    function _requireContract(address _address) internal view {     require(_address.isContract(), "TWABDelegator/not-a-contract");   }    function _requireLockDuration(uint256 _lockDuration) internal pure {     require(_lockDuration <= MAX_LOCK, "TWABDelegator/lock-too-long");   } ```
