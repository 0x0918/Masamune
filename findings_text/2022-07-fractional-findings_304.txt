# QA Report  # Documentation errors.  Some of the documentation mentions that Buyouts need 51% support but the code shows that, in reality, it is anything strictly greater than 50%. e.g. 50.0001%  See [Buyout.sol:208-211](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211)  # Non-critical: Use `permissions.size` to intialize `nodes` in `Buyout.getLeafNodes`  Instead of using the magic number 5 on [line 451](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451) why not simply use `permissions.length` to allocate the correct number of array indices?  Like so:  ```solidity function getLeafNodes() external view returns (bytes32[] memory nodes) {     Permission[] memory permissions = getPermissions();     nodes = new bytes32[](permissions.length);     for (uint256 i; i < permissions.length; ) {         // Hashes permission into leaf node         nodes[i] = keccak256(abi.encode(permissions[i]));         // Can't overflow since loop is a fixed size         unchecked {             ++i;         }     } } ```  ## Low Risk: `BaseVault.generateMerkleTree` will not work with new targets when total leaf length is greater than 6  ### Impact  Function `BaseVault.deployVault` takes a `modules` parameter which allows for any set of modules to be used with the contract.  If those modules have targets which have a total number of leaf nodes greater than 6 then `generateMerkleTree` will revert, which in turn causes `deployVault` to revert.  The impact is that one can successfully create a `BaseVault` but not call `deployVault`.  ### Proof of Concept  - Create a new instance of `BaseVault` called `baseVault`. - Call `baseVault.deployVault` with [modules](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L36) parameter which, collectively, have more than 6 leaf nodes. - Observe a revert with "Index out of bounds"  ### Tools used  Manual Inspection  ### Recommended Mitigation Steps  If the intention of `BaseVault` is to allow arbitrary modules then one could rewrite `generateMerkleTree` as follows.  ```solidity function generateMerkleTree(address[] calldata _modules)     public     view     returns (bytes32[] memory hashes) {     uint256 numLeaves;     uint256 counter;     bytes32[][] memory leavesList = new bytes32[][](_modules.length);      // Get leaf nodes      unchecked {         for (uint256 i; i < _modules.length; ++i) {             bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();             leavesList[i] = leaves;             numLeaves += leaves.length;         }     }      hashes = new bytes32[](numLeaves);     unchecked {         for (uint256 i; i < leavesList.length; ++i) {             bytes32[] memory leaves = leavesList[i];             for (uint256 j; j < leaves.length; ++j) {                 hashes[counter++] = leaves[j];             }         }     } } ```  If the intention is for it only to allow `Supply` and `Buyout` modules then simply add some checks with `require` statements.  ## Low Risk: There is no way to get ETH out of `Vault` when accidentally sent to it  There is no function to retrieve ETH accidentally sent to the `Vault` contract.  ## Low Risk: `BaseVault` batch deposit functions do not check arrays are of the same length  The functions `batchDepositERC20`, `batchDepositERC721`, and `batchDepositERC1155` all fail to check that the length of the their array arguments have the same length.  Although this only results in a revert, it will result in increased gas use.
