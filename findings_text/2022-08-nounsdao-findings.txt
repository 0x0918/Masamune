# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643   # Vulnerability details  ## Impact The veto power is import functionality for current NounsDAO in order to protect their treasury from malicious proposals.  However there is lack of zero address check and lack of 2 step address changing process for vetoer address. This might lead to Nounders losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.  Refrence from Nouns DAO contest documents: https://dialectic.ch/editorial/nouns-governance-attack https://dialectic.ch/editorial/nouns-governance-attack-2  ## Proof of Concept Lack of 0-address check for vetoer address at initialize() and _setVetoer() of NounsDAOLogicV2.sol and NounsDAOLogicV1.sol. Also it is better to make changing address process of vetoer at _setVetoer() into 2-step process to avoid accidently setting vetoer to zero address or any other arbitrary addresses and end up burning/losing veto power unintentionally.  1. vetoer address of initialize() of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150  2. vetoer address of _setVetoer() of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add zero address check for vetoer address at initialize(). Also change _setVetoer() vetoer address changing process to 2-step process like explained below.  First make the _setVetoer() function approve a new vetoer address as a pending vetoer. Next that pending vetoer has to claim the ownership in a separate transaction to be a new vetoer.
# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279 https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368   # Vulnerability details  ## Impact When User B calls the following `propose` function for creating a proposal, it checks that User B's prior number of votes at the relevant block is larger than the proposal threshold through executing `nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold`. This means that User B cannot create the proposal when the prior number of votes and the proposal threshold are the same.  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279 ```solidity     function propose(         address[] memory targets,         uint256[] memory values,         string[] memory signatures,         bytes[] memory calldatas,         string memory description     ) public returns (uint256) {         ProposalTemp memory temp;          temp.totalSupply = nouns.totalSupply();          temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);          require(             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,             'NounsDAO::propose: proposer votes below proposal threshold'         );         require(             targets.length == values.length &&                 targets.length == signatures.length &&                 targets.length == calldatas.length,             'NounsDAO::propose: proposal function information arity mismatch'         );         require(targets.length != 0, 'NounsDAO::propose: must provide actions');         require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');          temp.latestProposalId = latestProposalIds[msg.sender];         if (temp.latestProposalId != 0) {             ProposalState proposersLatestProposalState = state(temp.latestProposalId);             require(                 proposersLatestProposalState != ProposalState.Active,                 'NounsDAO::propose: one live proposal per proposer, found an already active proposal'             );             require(                 proposersLatestProposalState != ProposalState.Pending,                 'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'             );         }          temp.startBlock = block.number + votingDelay;         temp.endBlock = temp.startBlock + votingPeriod;          proposalCount++;         Proposal storage newProposal = _proposals[proposalCount];         newProposal.id = proposalCount;         newProposal.proposer = msg.sender;         newProposal.proposalThreshold = temp.proposalThreshold;         newProposal.eta = 0;         newProposal.targets = targets;         newProposal.values = values;         newProposal.signatures = signatures;         newProposal.calldatas = calldatas;         newProposal.startBlock = temp.startBlock;         newProposal.endBlock = temp.endBlock;         newProposal.forVotes = 0;         newProposal.againstVotes = 0;         newProposal.abstainVotes = 0;         newProposal.canceled = false;         newProposal.executed = false;         newProposal.vetoed = false;         newProposal.totalSupply = temp.totalSupply;         newProposal.creationBlock = block.number;          latestProposalIds[newProposal.proposer] = newProposal.id;          /// @notice Maintains backwards compatibility with GovernorBravo events         emit ProposalCreated(             newProposal.id,             msg.sender,             targets,             values,             signatures,             calldatas,             newProposal.startBlock,             newProposal.endBlock,             description         );          /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`         /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints         emit ProposalCreatedWithRequirements(             newProposal.id,             msg.sender,             targets,             values,             signatures,             calldatas,             newProposal.startBlock,             newProposal.endBlock,             newProposal.proposalThreshold,             minQuorumVotes(),             description         );          return newProposal.id;     } ```  After User B's proposal is created, User A can call the following `cancel` function to cancel it. When calling `cancel`, it checks that User B's prior number of votes at the relevant block is less than the proposal threshold through executing `nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold`. When User B's prior number of votes and the proposal threshold are the same, User A cannot cancel this proposal of User B. However, this contradicts the fact User B actually cannot create this proposal when the same condition holds true. In other words, if User B cannot create this proposal when the prior number of votes and the proposal threshold are the same, User A should be able to cancel User B's proposal under the same condition but it is not true. The functionality for canceling User B's proposal in this situation becomes unavailable for User A.  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368 ```solidity     function cancel(uint256 proposalId) external {         require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');          Proposal storage proposal = _proposals[proposalId];         require(             msg.sender == proposal.proposer ||                 nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,             'NounsDAO::cancel: proposer above threshold'         );          proposal.canceled = true;         for (uint256 i = 0; i < proposal.targets.length; i++) {             timelock.cancelTransaction(                 proposal.targets[i],                 proposal.values[i],                 proposal.signatures[i],                 proposal.calldatas[i],                 proposal.eta             );         }          emit ProposalCanceled(proposalId);     } ```  ## Proof of Concept Please append the following test in the `NounsDAOV2#inflationHandling` `describe` block in `test\governance\NounsDAO\V2\inflationHandling.test.ts`. This test should pass to demonstrate the described scenario. ```typescript   it("User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold",     async () => {     // account1 has 3 tokens at the beginning     // account1 gains 2 more to own 5 tokens in total     await token.transferFrom(deployer.address, account1.address, 11);     await token.transferFrom(deployer.address, account1.address, 12);      await mineBlock();      // account1 cannot create a proposal when owning 5 tokens in total     await expect(       gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing'),     ).to.be.revertedWith('NounsDAO::propose: proposer votes below proposal threshold');      // account1 gains 1 more to own 6 tokens in total     await token.transferFrom(deployer.address, account1.address, 13);      await mineBlock();      // account1 can create a proposal when owning 6 tokens in total     await gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing');     const proposalId = await gov.latestProposalIds(account1.address);     expect(await gov.state(proposalId)).to.equal(0);      // other user cannot cancel account1's proposal at this moment     await expect(       gov.cancel(proposalId, {gasLimit: 1e6})     ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');          // account1 removes 1 token to own 5 tokens in total     await token.connect(account1).transferFrom(account1.address, deployer.address, 13);      await mineBlock();      // other user still cannot cancel account1's proposal when account1 owns 5 tokens in total     // this contradicts the fact that account1 cannot create a proposal when owning 5 tokens in total     await expect(       gov.cancel(proposalId, {gasLimit: 1e6})     ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');      // account1 removes another token to own 4 tokens in total     await token.connect(account1).transferFrom(account1.address, deployer.address, 12);      await mineBlock();      // other user can now cancel account1's proposal when account1 owns 4 tokens in total     await gov.cancel(proposalId, {gasLimit: 1e6})     expect(await gov.state(proposalId)).to.equal(2);   }); ```   ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L197-L200 can be changed to the following code. ```solidity         require(             nouns.getPriorVotes(msg.sender, block.number - 1) >= temp.proposalThreshold,             'NounsDAO::propose: proposer votes below proposal threshold'         ); ``` or  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L350-L354 can be changed to the following code. ```solidity         require(             msg.sender == proposal.proposer ||                 nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,             'NounsDAO::cancel: proposer above threshold'         ); ```  but not both.
# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144   # Vulnerability details  ## Impact In the ERC721Checkpointable contract, when the user votes with the delegate function, the delegatee will not be address 0. ```     function delegate(address delegatee) public {         if (delegatee == address(0)) delegatee = msg.sender;         return _delegate(msg.sender, delegatee);     } ``` However, there is no such restriction in the delegateBySig function, which allows the user to vote to address 0. ```     function delegateBySig(         address delegatee,         uint256 nonce,         uint256 expiry,         uint8 v,         bytes32 r,         bytes32 s     ) public {         bytes32 domainSeparator = keccak256(             abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))         );         bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));         bytes32 digest = keccak256(abi.encodePacked('\x19\x01', domainSeparator, structHash));         address signatory = ecrecover(digest, v, r, s);         require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');         require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');         require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');         return _delegate(signatory, delegatee);     } ``` If user A votes to address 0 in the delegateBySig function, _delegates[A] will be address 0, but the delegates function will return the address of user A and getCurrentVotes(A) will return 0. ```     function _delegate(address delegator, address delegatee) internal {         /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation         address currentDelegate = delegates(delegator);          _delegates[delegator] = delegatee; ...     function delegates(address delegator) public view returns (address) {         address current = _delegates[delegator];         return current == address(0) ? delegator : current;     } ``` Later, if user A votes to another address or transfers NFT, the _moveDelegates function will fail due to overflow, which makes user A lose votes forever and cannot transfer NFT. ```     function _moveDelegates(         address srcRep,         address dstRep,         uint96 amount     ) internal {         if (srcRep != dstRep && amount > 0) {             if (srcRep != address(0)) {                 uint32 srcRepNum = numCheckpoints[srcRep];                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;                 uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows'); // auditor : overflow here                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);             } ``` On the other hand, since the burn function also fails, this can also be used to prevent the NFT from being burned by the minter ```     function burn(uint256 nounId) public override onlyMinter {         _burn(nounId);         emit NounBurned(nounId);     } ...     function _burn(uint256 tokenId) internal virtual {         address owner = ERC721.ownerOf(tokenId);          _beforeTokenTransfer(owner, address(0), tokenId); ...     function _beforeTokenTransfer(         address from,         address to,         uint256 tokenId     ) internal override {         super._beforeTokenTransfer(from, to, tokenId);          /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation         _moveDelegates(delegates(from), delegates(to), 1);     } ``` ## Proof of Concept https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L88-L91 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L97-L106 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L197-L208 ## Tools Used None ## Recommended Mitigation Steps Consider requiring in the delegateBySig function that delegatee cannot be address 0. ```diff     function delegateBySig(         address delegatee,         uint256 nonce,         uint256 expiry,         uint8 v,         bytes32 r,         bytes32 s     ) public { + require(delegatee != address(0)); ```
# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643   # Vulnerability details  ## Impact The veto power is import functionality for current NounsDAO in order to protect their treasury from malicious proposals.  However there is lack of zero address check and lack of 2 step address changing process for vetoer address. This might lead to Nounders losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.  Refrence from Nouns DAO contest documents: https://dialectic.ch/editorial/nouns-governance-attack https://dialectic.ch/editorial/nouns-governance-attack-2  ## Proof of Concept Lack of 0-address check for vetoer address at initialize() and _setVetoer() of NounsDAOLogicV2.sol and NounsDAOLogicV1.sol. Also it is better to make changing address process of vetoer at _setVetoer() into 2-step process to avoid accidently setting vetoer to zero address or any other arbitrary addresses and end up burning/losing veto power unintentionally.  1. vetoer address of initialize() of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150  2. vetoer address of _setVetoer() of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add zero address check for vetoer address at initialize(). Also change _setVetoer() vetoer address changing process to 2-step process like explained below.  First make the _setVetoer() function approve a new vetoer address as a pending vetoer. Next that pending vetoer has to claim the ownership in a separate transaction to be a new vetoer.
# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279 https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368   # Vulnerability details  ## Impact When User B calls the following `propose` function for creating a proposal, it checks that User B's prior number of votes at the relevant block is larger than the proposal threshold through executing `nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold`. This means that User B cannot create the proposal when the prior number of votes and the proposal threshold are the same.  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279 ```solidity     function propose(         address[] memory targets,         uint256[] memory values,         string[] memory signatures,         bytes[] memory calldatas,         string memory description     ) public returns (uint256) {         ProposalTemp memory temp;          temp.totalSupply = nouns.totalSupply();          temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);          require(             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,             'NounsDAO::propose: proposer votes below proposal threshold'         );         require(             targets.length == values.length &&                 targets.length == signatures.length &&                 targets.length == calldatas.length,             'NounsDAO::propose: proposal function information arity mismatch'         );         require(targets.length != 0, 'NounsDAO::propose: must provide actions');         require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');          temp.latestProposalId = latestProposalIds[msg.sender];         if (temp.latestProposalId != 0) {             ProposalState proposersLatestProposalState = state(temp.latestProposalId);             require(                 proposersLatestProposalState != ProposalState.Active,                 'NounsDAO::propose: one live proposal per proposer, found an already active proposal'             );             require(                 proposersLatestProposalState != ProposalState.Pending,                 'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'             );         }          temp.startBlock = block.number + votingDelay;         temp.endBlock = temp.startBlock + votingPeriod;          proposalCount++;         Proposal storage newProposal = _proposals[proposalCount];         newProposal.id = proposalCount;         newProposal.proposer = msg.sender;         newProposal.proposalThreshold = temp.proposalThreshold;         newProposal.eta = 0;         newProposal.targets = targets;         newProposal.values = values;         newProposal.signatures = signatures;         newProposal.calldatas = calldatas;         newProposal.startBlock = temp.startBlock;         newProposal.endBlock = temp.endBlock;         newProposal.forVotes = 0;         newProposal.againstVotes = 0;         newProposal.abstainVotes = 0;         newProposal.canceled = false;         newProposal.executed = false;         newProposal.vetoed = false;         newProposal.totalSupply = temp.totalSupply;         newProposal.creationBlock = block.number;          latestProposalIds[newProposal.proposer] = newProposal.id;          /// @notice Maintains backwards compatibility with GovernorBravo events         emit ProposalCreated(             newProposal.id,             msg.sender,             targets,             values,             signatures,             calldatas,             newProposal.startBlock,             newProposal.endBlock,             description         );          /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`         /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints         emit ProposalCreatedWithRequirements(             newProposal.id,             msg.sender,             targets,             values,             signatures,             calldatas,             newProposal.startBlock,             newProposal.endBlock,             newProposal.proposalThreshold,             minQuorumVotes(),             description         );          return newProposal.id;     } ```  After User B's proposal is created, User A can call the following `cancel` function to cancel it. When calling `cancel`, it checks that User B's prior number of votes at the relevant block is less than the proposal threshold through executing `nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold`. When User B's prior number of votes and the proposal threshold are the same, User A cannot cancel this proposal of User B. However, this contradicts the fact User B actually cannot create this proposal when the same condition holds true. In other words, if User B cannot create this proposal when the prior number of votes and the proposal threshold are the same, User A should be able to cancel User B's proposal under the same condition but it is not true. The functionality for canceling User B's proposal in this situation becomes unavailable for User A.  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368 ```solidity     function cancel(uint256 proposalId) external {         require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');          Proposal storage proposal = _proposals[proposalId];         require(             msg.sender == proposal.proposer ||                 nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,             'NounsDAO::cancel: proposer above threshold'         );          proposal.canceled = true;         for (uint256 i = 0; i < proposal.targets.length; i++) {             timelock.cancelTransaction(                 proposal.targets[i],                 proposal.values[i],                 proposal.signatures[i],                 proposal.calldatas[i],                 proposal.eta             );         }          emit ProposalCanceled(proposalId);     } ```  ## Proof of Concept Please append the following test in the `NounsDAOV2#inflationHandling` `describe` block in `test\governance\NounsDAO\V2\inflationHandling.test.ts`. This test should pass to demonstrate the described scenario. ```typescript   it("User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold",     async () => {     // account1 has 3 tokens at the beginning     // account1 gains 2 more to own 5 tokens in total     await token.transferFrom(deployer.address, account1.address, 11);     await token.transferFrom(deployer.address, account1.address, 12);      await mineBlock();      // account1 cannot create a proposal when owning 5 tokens in total     await expect(       gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing'),     ).to.be.revertedWith('NounsDAO::propose: proposer votes below proposal threshold');      // account1 gains 1 more to own 6 tokens in total     await token.transferFrom(deployer.address, account1.address, 13);      await mineBlock();      // account1 can create a proposal when owning 6 tokens in total     await gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing');     const proposalId = await gov.latestProposalIds(account1.address);     expect(await gov.state(proposalId)).to.equal(0);      // other user cannot cancel account1's proposal at this moment     await expect(       gov.cancel(proposalId, {gasLimit: 1e6})     ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');          // account1 removes 1 token to own 5 tokens in total     await token.connect(account1).transferFrom(account1.address, deployer.address, 13);      await mineBlock();      // other user still cannot cancel account1's proposal when account1 owns 5 tokens in total     // this contradicts the fact that account1 cannot create a proposal when owning 5 tokens in total     await expect(       gov.cancel(proposalId, {gasLimit: 1e6})     ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');      // account1 removes another token to own 4 tokens in total     await token.connect(account1).transferFrom(account1.address, deployer.address, 12);      await mineBlock();      // other user can now cancel account1's proposal when account1 owns 4 tokens in total     await gov.cancel(proposalId, {gasLimit: 1e6})     expect(await gov.state(proposalId)).to.equal(2);   }); ```   ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L197-L200 can be changed to the following code. ```solidity         require(             nouns.getPriorVotes(msg.sender, block.number - 1) >= temp.proposalThreshold,             'NounsDAO::propose: proposer votes below proposal threshold'         ); ``` or  https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L350-L354 can be changed to the following code. ```solidity         require(             msg.sender == proposal.proposer ||                 nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,             'NounsDAO::cancel: proposer above threshold'         ); ```  but not both.
# Lines of code  https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144   # Vulnerability details  ## Impact In the ERC721Checkpointable contract, when the user votes with the delegate function, the delegatee will not be address 0. ```     function delegate(address delegatee) public {         if (delegatee == address(0)) delegatee = msg.sender;         return _delegate(msg.sender, delegatee);     } ``` However, there is no such restriction in the delegateBySig function, which allows the user to vote to address 0. ```     function delegateBySig(         address delegatee,         uint256 nonce,         uint256 expiry,         uint8 v,         bytes32 r,         bytes32 s     ) public {         bytes32 domainSeparator = keccak256(             abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))         );         bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));         bytes32 digest = keccak256(abi.encodePacked('\x19\x01', domainSeparator, structHash));         address signatory = ecrecover(digest, v, r, s);         require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');         require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');         require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');         return _delegate(signatory, delegatee);     } ``` If user A votes to address 0 in the delegateBySig function, _delegates[A] will be address 0, but the delegates function will return the address of user A and getCurrentVotes(A) will return 0. ```     function _delegate(address delegator, address delegatee) internal {         /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation         address currentDelegate = delegates(delegator);          _delegates[delegator] = delegatee; ...     function delegates(address delegator) public view returns (address) {         address current = _delegates[delegator];         return current == address(0) ? delegator : current;     } ``` Later, if user A votes to another address or transfers NFT, the _moveDelegates function will fail due to overflow, which makes user A lose votes forever and cannot transfer NFT. ```     function _moveDelegates(         address srcRep,         address dstRep,         uint96 amount     ) internal {         if (srcRep != dstRep && amount > 0) {             if (srcRep != address(0)) {                 uint32 srcRepNum = numCheckpoints[srcRep];                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;                 uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows'); // auditor : overflow here                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);             } ``` On the other hand, since the burn function also fails, this can also be used to prevent the NFT from being burned by the minter ```     function burn(uint256 nounId) public override onlyMinter {         _burn(nounId);         emit NounBurned(nounId);     } ...     function _burn(uint256 tokenId) internal virtual {         address owner = ERC721.ownerOf(tokenId);          _beforeTokenTransfer(owner, address(0), tokenId); ...     function _beforeTokenTransfer(         address from,         address to,         uint256 tokenId     ) internal override {         super._beforeTokenTransfer(from, to, tokenId);          /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation         _moveDelegates(delegates(from), delegates(to), 1);     } ``` ## Proof of Concept https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L88-L91 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L97-L106 https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L197-L208 ## Tools Used None ## Recommended Mitigation Steps Consider requiring in the delegateBySig function that delegatee cannot be address 0. ```diff     function delegateBySig(         address delegatee,         uint256 nonce,         uint256 expiry,         uint8 v,         bytes32 r,         bytes32 s     ) public { + require(delegatee != address(0)); ```
