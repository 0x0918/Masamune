 1. Floating pragma is used in all the contracts  As different compiler versions have critical behavior specifics if the contracts get accidentally deployed using another compiler version compared to the one they were tested with, various types of undesired behavior can be introduced  ## Proof of Concept  `pragma solidity ^0.8.0` is used in all the system contracts, for example:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L2  ## Recommended Mitigation Steps  Consider fixing the version to 0.8.x across all the codebase, for example set x to 10   2. Most of events in BribeVault, TokemakBribe and ThecosomataETH aren't indexed  ## Impact  Filtering on not indexed events is disabled, which makes it harder to programmatically use and analyze the system  ## Proof of Concept  The following events are not indexed:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L37-57  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L42-43  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L44-48  ## Recommended Mitigation Steps  Consider making all events ids and addresses indexed to improve their usability   3. bytes32.length check is redundant and doesn't rule zero values out  ## Impact  bytes32.length do not control for bogus values as the bytes32 length is fixed to 32. This way, for example, depositBribe can be successfully called with any identifiers, for example `0x0000000000000000000000000000000000000000000000000000000000000000` id will not be reverted  ## Proof of Concept  bytes32 is a fixed size array, which length will always be 32, but it is checked for positive length anyway in BribeVault deposit functions:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L171-172  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L218-219  ## Recommended Mitigation Steps  If non-zero check is desired, `!= 0` can suffice (will revert on `0x0000000000000000000000000000000000000000000000000000000000000000`):  Now: ``` require(bribeIdentifier.length > 0, "Invalid bribeIdentifier"); ```  To be: ``` require(bribeIdentifier != 0, "Invalid bribeIdentifier"); ``` 
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209   # Vulnerability details  ## Impact  The `updateRewardsMetadata()` function is called by the `BribeVault` contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.   `reward.updateCount` is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to `updateRewardsMetadata()` and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.  ## Proof of Concept  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a delay where users cannot claim rewards before a call to `updateRewardsMetadata()` is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.  
## Missing Doc Comments in function `getBrige()`   The parameter `round` is missing in doc comments for the function  `getBrige()` at `TokemakBribe.sol`  Also consider add doc comments at  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol  Doc comments will increase the readability of the code and will avoid other more high risk issues.    For example in this contest I sent a medium severity issue related to the same parameter.  ## Poc  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L188-L204          @notice Get bribe from BribeVault         @param  proposal            address  Proposal         @param  token               address  Token   @audit-issue   need to add round parameter and all thecosomata eth         @return bribeToken          address  Token address         @return bribeAmount         address  Token address      */     function getBribe(         address proposal,         uint256 round,         address token     ) external view returns (address bribeToken, uint256 bribeAmount) {         return             IBribeVault(bribeVault).getBribe(                 generateBribeVaultIdentifier(proposal, round, token)             );     }   # Similar issues  https://github.com/code-423n4/2021-09-swivel-findings/issues/71
Low :  Title : proposal can be frontrun to support malicious token  Impact : When an authorized user set a proposal, a malicious user might call depositBribeERC20() right after the set proposal transaction is finish, since the token is not whitelisted, the malicious user might provide a malicious token, a token that will revert on all interaction with this contract, this can cause a dos on the proposal that just being set.  POC : https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L125
## Redacted Cartel QA Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The audit was done from February 15-17, 2022 by ye0lde through code4rena.  Overall, I found the code to be clear to follow and understand. A test suite was provided. Including more tests that tackle edge scenarios and providing coverage and gas reports by default would be useful.  - [Findings](#findings)   - [L-1 - Restrict funds receivable to be only from `BribeVault` (RewardDistributor.sol)](#l-1---restrict-funds-receivable-to-be-only-from-bribevault-rewarddistributorsol)   - [L-2 - Unchecked ERC20 transfer calls](#l-2---unchecked-erc20-transfer-calls)   - [NC-1 - Incorrect return value description for `getBribe` (TokemakBribe.sol)](#nc-1---incorrect-return-value-description-for-getbribe-tokemakbribesol)  ## Findings    ### L-1 - Restrict funds receivable to be only from `BribeVault` (RewardDistributor.sol)  #### Impact Native fund transfers into the `RewardDistributor` contract are only expected from the `BribeVault` contract. It would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  #### Proof of Concept The `receive` function is here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L58-L59  ``` // Enables BribeVault to transfer native tokens receive() external payable {} ```  #### Recommended Mitigation Steps Modify the receive() function to only accept transfers from the `BribeVault` contract.  ``` receive() external payable {       require(msg.sender == address(bribeVault), "Not BribeVault..."); } ``` ---  ### L-2 - Unchecked ERC20 transfer calls   #### Impact ERC20 transfer and transferFrom calls normally return true on a successful transfer.  If transfers are done with ERC20 token which does not comply with the EIP-20 standard it might return false on a failed transaction rather than revert. In this case, it would count as a valid transaction even though it is not.   #### Proof of Concept Unchecked transfer calls are here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L337 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L164  #### Recommended Mitigation Steps Consider using OpenZeppelin's library with safe versions of transfer functions as used in other areas of the code.  ---  ### NC-1 - Incorrect return value description for `getBribe` (TokemakBribe.sol)  #### Impact Code clarity  #### Proof of Concept The incorrect comment which appears to be copied from line #192 is here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L193  #### Recommended Mitigation Steps Correct the comment/description.  ---
##GasFindingsCartel 1-- -using storage to declare `b` struct https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L152 `b` just called twice in the `gotBribe`(struct data type consume more gas when it chaced and it depend on the size of the struct). Read from storage instead of caching it cost less gas ``` Bribe storage b = bribes[bribeIdentifier]; ```  2-- -using at least pragma 0.8.4 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2 The advantages of versions 0.8.4 over <0.8.0 are:     1. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.     2. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.     3. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  3-- -using && cost more gas https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L262-L266 instead of using &&, using double require to validate can save gas ``` require(             distributions.length == amounts.length,             "Distributions, amounts, and fees must contain the same # of elements"         ); require(                 distributions.length == fees.length,             "Distributions, amounts, and fees must contain the same # of elements"         ); ``` 4-- -using ++var for increment operation https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L109 using: ```       ++reward.updateCount; ```    is better method to do increment operation for gas opt  5-- -caching `Reward` to memory cost more gas https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L134 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L200 `reward` is merely called once at the `isRewardClaimed()` and twice at `_setClaimed()`. Its gas saving by just read it directly to the storage. ```         Reward storage reward = rewards[_identifier]; ``` 
## Summary: During the code assessment, we found multiple issues related to unchecked transfer and no handing of return values. Many functions call like "transfer," "deposit," "approve," etc., returns some value after the function call. Handling these calls is important to prevent unexpected outcomes. Apart from that, we found multiple functions which were missing zero address checks. It is advised to add a zero address check at all possible functions setting an address. In solidity, any error caused to set the value to default, and for an address variable, the default value is zero address. Hence any fund or privilege gets pointed to zero address, it will be unrecoverable.  The contract was found to be using floating pragma, which allows the contract to be compiled to multiple versions and hence can cause inconsistencies or errors on different versions. We also noticed the uses of large number literals. Although it is not a security issue but enhances readability and reduces the chance of errors or missing digits. We also noticed missing events in many critical functions. Events are important for logging purposes. Hence it is recommended to add events and indexed events at all possible function calls for better logging. Lastly, we also noticed that the fee value, which is set by an admin, can be set to zero due lack of proper input validation.    ## Low Severity findings:  ## QA - 1  ### Title:  Unchecked return value in transfer  ### Description: The return value of the token transfers is not checked or validated at all in the functions shown below. This may lead to issues if there's a critical contract logic happening below the transfer that affects or manipulates the number of ether or tokens. Therefore, if the return value is not checked, the adversaries will be able to call those functions without actually transferring any ether and manipulating the token balance.  ### PoC: Transfer: Go to the below lines of code and we will notice that transfer  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L146 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L164    ### Suggested Fix: Consider the use of safeTransfer instead of transfer that auto asserts and handles in case of transfer failure.     ## QA - 2  ### Title:  Unused return in approve call  ### Description: The contract was found to be making an external call (approve). The function which is called is returning some value which is never used. This may lead to discrepancies and improper assumptions in the calling function.  ### PoC: - Go to the lines below and we will notice that the approve function's return value is not used for any further validation or check. https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L68 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L69  ### Suggested Fix: It is recommended to make use of the return values coming from the external function that is called to make sure that the calculations following the external call are correct.    ## QA - 3  ### Title:  Use of Floating Pragma Version  ### Description: The contract was found to be using a floating pragma which is not considered safe as it can be compiled with all the versions described.  ### PoC: Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2)  Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L2) Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L2)  Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L2)   ### Suggested Fix: Use strict pragma version like  Pragma version 0.8.0  ## QA - 4  ### Title:  Missing input validation in setFee function   ### Description: The function `setFee` does not check if the fee value is set to zero.   ## Impact An admin can set fee value to zero by mistake, and it can cause free trades and loss to the organization.   ### PoC: - Notice the function below https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108-L113 - The `setFee` function just checks if the fee is less than feeDivisor but does not check if the fee is zero.   ### Suggested Fix: Check if the fee is being set to zero.    ## Non-critical findings  ## QA - 5  ### Title:  Use of Large Number Literals  ### Description: Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.   ## Impact  Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ### PoC: - Go to https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26 We will notice a large literal  `uint256 public constant feeDivisor = 1000000;` where 1000000 can be represnted as 10e6  ### Suggested Fix: Scientific notation in the form of `2e10` is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal `MeE` is equivalent to `M * 10**E`. Examples include `2e10`, `2e10`, `2e-10`, `2.5e1`.  Reference: [https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals](https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals)  ## QA - 6  ### Title:  Multiple missing events in critical functions  ### Description: Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction's log, a special data structure in the blockchain. These logs are associated with the address of the contract, which can then be used by developers and auditors to keep track of the transactions.   The contract was found to be missing these events on certain critical functions, which would make it difficult or impossible to track these transactions off-chain.  ## Impact  Events are used to track the transactions off-chain, and missing these events on critical functions makes it difficult to audit these logs if they're needed at a later stage.    ### PoC: The below functions are missing events. - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L76-L80 The function `setSlippage` is called by an admin and hence should have an event log regarding the change is slippage value.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L158-L165 The `withdraw` function is called by an admin to withdraw funds and hence should have an event log.   - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108-L110 The function `setRound` sets a new voting round by admins and hence should have an event log.   ### Suggested Fix: Consider emitting events for the functions mentioned above. It is also recommended to have the addresses indexed.   ## QA - 7  ### Title:  Multiple functions Lacking Zero address checks  ### Description: Address type parameters should include a zero-address check; otherwise, contract functionality may become inaccessible, or tokens burned forever.  ## Impact Tokens may become inaccessible or burnt forever without a zero-address check.  ### PoC: Below is the list of functions lacking zero address checks - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L212-L251 Function `depositBribeERC20` has address `proposal` that is missing zero address checks  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L257-L290 Function `depositBribe` has address input `proposal`, which is lacking zero address checks.    ### Suggested Fix: Address zero address check to all the missing places.      
- [S]: Suggested optimation, save a decent amount of gas without compromising readability; - [M]: Minor optimation, the amount of gas saved is minor, change when you see fit; - [N]: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [M] Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L118-L118  ## [S] Using immutable variable can save gas   https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L28-L28  ```solidity     address public bribeVault; ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L60-L65  ```solidity     constructor(address _bribeVault) {         require(_bribeVault != address(0), "Invalid bribeVault");         bribeVault = _bribeVault;          _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);     } ```  Considering that `bribeVault` will never change, changing it to immutable variable instead of storage variable can save gas.  ## [S] Remove redundant access control checks can save gas  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135  ```solidity     function setProposal(address proposal, uint256 deadline)         public         onlyAuthorized     {         require(proposal != address(0), "Invalid proposal");         require(deadline >= block.timestamp, "Deadline must be in the future");          proposalDeadlines[proposal] = deadline;          emit SetProposal(proposal, deadline, _round);     } ```   https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157  ```solidity     function setProposals(         address[] calldata proposals,         uint256[] calldata deadlines     ) external onlyAuthorized {         require(proposals.length > 0, "Need at least 1 proposal");         require(             proposals.length == deadlines.length,             "Must be equal # of proposals and deadlines"         );          for (uint256 i = 0; i < proposals.length; i += 1) {             setProposal(proposals[i], deadlines[i]);         }          emit SetProposals(proposals, deadlines, _round);     } ```    `setProposal()` already got `onlyAuthorized` check, and `setProposals()` will check it again multiple times.  Consider creating `_setProposal()` private function without access control and call it inside the public functions.  ### Recommendation  Change to:  ```solidity     function _setProposal(address proposal, uint256 deadline)         private     {         require(proposal != address(0), "Invalid proposal");         require(deadline >= block.timestamp, "Deadline must be in the future");          proposalDeadlines[proposal] = deadline;     }      /**         @notice Set a single proposal         @param  proposal  addresss Proposal address         @param  deadline  uint256  Proposal deadline      */     function setProposal(address proposal, uint256 deadline)         public         onlyAuthorized     {         _setProposal(proposal, deadline);         emit SetProposal(proposal, deadline, _round);     }      /**         @notice Set multiple proposals         @param  proposals  address[]  Proposal addresses         @param  deadlines  uint256[]  Proposal deadlines      */     function setProposals(         address[] calldata proposals,         uint256[] calldata deadlines     ) external onlyAuthorized {         require(proposals.length > 0, "Need at least 1 proposal");         require(             proposals.length == deadlines.length,             "Must be equal # of proposals and deadlines"         );          for (uint256 i = 0; i < proposals.length; i += 1) {             _setProposal(proposals[i], deadlines[i]);         }          emit SetProposals(proposals, deadlines, _round);     } ```  ## [S] Validation can be done earlier to save gas  Check if `ethLiquidity > 0 && btrflyLiquidity > 0` earlier can avoid unnecessary external call (`IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);`) when this check failed.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L124-L155  ```solidity     function performUpkeep() external onlyOwner {         require(checkUpkeep(), "Invalid upkeep state");          uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));         uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);         uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);         uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;          // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount         uint256 btrflyLiquidity = ethCap > ethAmount             ? btrfly             : calculateAmountRequiredForLP(ethLiquidity, false);          IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);          // Only complete upkeep only on sufficient amounts         require(ethLiquidity > 0 && btrflyLiquidity > 0, "Insufficient amounts");         // ...     } ```  ### Recommendation  Change to:  ```solidity     function performUpkeep() external onlyOwner {         require(checkUpkeep(), "Invalid upkeep state");          uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));         uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);         uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);         uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;          // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount         uint256 btrflyLiquidity = ethCap > ethAmount             ? btrfly             : calculateAmountRequiredForLP(ethLiquidity, false);          // Only complete upkeep only on sufficient amounts         require(ethLiquidity > 0 && btrflyLiquidity > 0, "Insufficient amounts");          IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);          // ...     } ```  ## [M] `type(uint256).max` is more gas efficient than `2**256 - 1`  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69  ## [M] `10e18` is more gas efficient than `10**18`  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L102-L108  ## [S] Cache array length in for loops can save gas  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L147-L152  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L261-L275  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L80-L82  ## [S] Avoid unnecessary storage read can save gas  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, "Invalid bribeIdentifier");         require(rewardIdentifier.length > 0, "Invalid rewardIdentifier");         require(briber != address(0), "Invalid briber");         require(msg.value > 0, "Value must be greater than 0");          Bribe storage b = bribes[bribeIdentifier];         address currentToken = b.token;         require(             // For native tokens, the token address is set to this contract to prevent             // overwriting storage - the address can be anything but address(this) safer             currentToken == address(0) || currentToken == address(this),             "Cannot change token"         );          b.amount += msg.value; // Allow bribers to increase bribe          // Only set the token address and update the reward-to-bribe mapping if not yet set         if (currentToken == address(0)) {             b.token = address(this);             rewardToBribes[rewardIdentifier].push(bribeIdentifier);         }          emit DepositBribe(             bribeIdentifier,             rewardIdentifier,             b.token,             msg.value,             b.amount,             briber         );     } ```  Based on L224~L230, L235~L236, we know that `b.token == address(this)`, therefore at L243 `b.token` can be replaced with `address(this)`.  Use `address(this)` directly can avoid unnecessary storage read of `b.token` and save some gas.  ### Recommendation  Replace:  ```solidity emit DepositBribe(     bribeIdentifier,     rewardIdentifier,     b.token,     msg.value,     b.amount,     briber ); ```  with:  ```solidity emit DepositBribe(     bribeIdentifier,     rewardIdentifier,     address(this),     msg.value,     b.amount,     briber ); ``` 
## [L] `bytes32Value.length > 0` is misused, should be `bytes32Value != bytes32(0)`   `bytes32Value.length > 0` is meanless, as it always be `true`, because `.length` yields the fixed length of the byte array. `bytes32Value.length` == 32.  `bytes32` is a value type, you should use `!=` to do the comparison.  See: https://docs.soliditylang.org/en/v0.8.12/types.html#fixed-size-byte-arrays  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L164-L205  ```solidity     function depositBribeERC20(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address token,         uint256 amount,         address briber     ) external onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, "Invalid bribeIdentifier");         require(rewardIdentifier.length > 0, "Invalid rewardIdentifier");         // ...     } ```  Can be changed to:  ```solidity     function depositBribeERC20(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address token,         uint256 amount,         address briber     ) external onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length != bytes32(0), "Invalid bribeIdentifier");         require(rewardIdentifier.length != bytes32(0), "Invalid rewardIdentifier");         // ...     } ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, "Invalid bribeIdentifier");         require(rewardIdentifier.length > 0, "Invalid rewardIdentifier");         // ...     } ```  Can be changed to:  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length != bytes32(0), "Invalid bribeIdentifier");         require(rewardIdentifier.length != bytes32(0), "Invalid rewardIdentifier");         // ...     } ```  ## [L] Unchecked return value for `token.transfer` call  It is usually good to add a require-statement that checks the return value or to use something like safeTransfer; unless one is sure the given token reverts in case of a failure.  Instances include:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297  ```solidity IERC20(token).transfer(feeRecipient, feeAmount); IERC20(token).transfer(distributor, distributorAmount); ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146-L146  ```solidity IERC20(token).transfer(TREASURY, tokenBalance); ```  ### Recommendation  Consider adding a require-statement or using `safeTransfer` of SafeERC20.
https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L38  `rewardForwarding` is redundant as it's not used. also, the function that sets it is redundant. https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L298
# Pin Solidity Version Pin solidity version to make the compilation more predictable. https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L2  # Fee cap too high The fee can be set as high as `feeDivisor` which equals to 100% https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L108  # Use of transfer might fail in the future `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L181 
## BribeVault: `fee` is not used anywhere The variable is [set](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L65) and [allowed to be changed](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108) and even an event is there, however it is not used anywhere. The fees are [being read](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L272) directly from the admin's sent parameters and there's no check against the fee previously set. Consider removing it or aligning the `transferBribes` function to use it.  ## RewardDistributor: no sender check for ETH receive function [This](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59) is RB's receive function: ```     // Enables BribeVault to transfer native tokens     receive() external payable {} ``` If it is only used from BribeVault, consider adding a check that verifies that the sender is BribeVault - otherwise misc ether might get sent and locked in the contract.  ## RewardDistributor: ETH being sent using `transfer` In _claim, ETH is [being sent](](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)) using the `transfer` function. While this might be a design choice, it might cause problems and fail to transfer to smart contracts, [such as gnosis safe](https://help.gnosis-safe.io/en/articles/5249851-why-can-t-i-transfer-eth-from-a-contract-into-a-safe). There are mitigations (see in the article), and this is why I rated it as a low issue and not medium. However, for normal user experience, consider changing the `transfer` to `call`. If the concern is reentrancy, you obviously know that there are other mitigations (CEI pattern and reentrancy guard).  ## TokemakBribe: consider adding sanity check for `round` When [setting a new round](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108:#L110), as there is no check that `_newRound > _round`, a team member can add rounds "retroactively": ```     function setRound(uint256 _newRound) external onlyAuthorized {         _round = _newRound;     } ``` I don't really consider this a danger. The worst case would be that a team member (not the admin) listens to TXs in the mempool, and when somebody deposits a bribe, the team member would change the round to be another one which is more beneficial for the team member, and therefore the bribe would be misattributed. However, we are talking about a team member, plus the emergency withdraw function can withdraw it, plus   anyway further releasing of the bribe to claimers requires admin actions. So I do not believe that this is a real risk. This is why I label this as low and not medium. However adding a check that `_newRound > _round` seems like an easy sanity check to add.  ## TokemakBribe: wrong comment for getRound [The comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L113:#L116) for `getRound` is same as for `setRound`. ```     /**         @notice Set a new voting round         @return round uint256 The current round number      */     function getRound() external view returns (uint256) { ```  ## ETH bribes dependent on BribeVault address Regarding using BribeVault's address as the native token address, [a comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L226) mentions "For native tokens, the token address is set to this contract to prevent overwriting storage - the address can be anything but address(this) safer". I might be missing something but I don't see how BribeVault's address is safer than an immutable like 0xEE..E. Since RewardDistributor [can change](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65) BribeVault, this means that the reward identifier would also need to be changed. So again, I might be missing something but at the moment it seems to me that using the changing BribeVault address as the native token identifier just adds complexity.  ## BribeVault: transferBribes: unchecked transfer of ERC20 tokens The function [doesn't use](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296:#L297) safeTransfer for sending of tokens: ```                 IERC20(token).transfer(feeRecipient, feeAmount);                 IERC20(token).transfer(distributor, distributorAmount); ``` This might be on purpose, to not totally fail the whole loop and lose gas if one token is problematic and failed to send. If so, make sure the admin properly checks that all transfers succeeded. For easy checking I believe you can change to safeTransfer and use try/catch to emit an event if the transfer failed.
# Codebase Impressions & Summary  This audit scope consisted of 4 contracts. Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.  Most issues raised are minor improvements to improve the security of the contracts. The only notable findings made had to do with the usage of the curve crypto pool’s price oracle, and protection against sandwich attacks when adding liquidity.  In addition, I made a suggestion regarding the syncing of Tokemak’s rounds with the `TokemakBribe` contract.  Note that I refrained raising issues regarding FoT tokens because I assume they are not meant to be supported.  # Low Severity Findings  ## L01: RewardDistributor: Change `payable(account).transfer()` to `.call()` for native fund transfers  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)  ### Description  `BribeVault` uses `.call()` for native fund transfers, but `RewardDistributor` uses `.transfer()`. They should be standardized to `.call()`, the currently recommended method since [`.transfer()` fowards 2300 gas whereas `.call()` forwards all / set gas.](https://solidity-by-example.org/sending-ether/)  ### Recommended Mitigation Steps  ```jsx (bool sentAccount, ) = _account.call{value: _amount}(""); require(sentAccount, "Failed to transfer to _account"); ```  ## L02: BribeVault: Use `safeTransfer` for tokens  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337)  ### Description  Some ERC20 tokens like ZRX don’t revert if the transfer fails. Since the `SafeERC20` has already been imported and the `safeTransferFrom` method used, the same should be done for token transfers.  ### Recommended Mitigation Steps  Replace `transfer` with `safeTransfer`.  ## L03: RewardDistributor: Limit native fund transfers to `bribeVault`  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59)  ### Description  Since the only source of native fund transfers is expected to be the `bribeVault` contract, it would be good to restrict incoming fund transfers from other sources to prevent accidental transfers.  ### Recommended Mitigation Steps  ```jsx receive() external payable {   require(msg.sender == bribeVault, 'only bribeVault'); } ```  ## L04: TokemakBribe: `getBribe()` has incorrect description  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194)  ### Description  - Missing `round` param - `bribeAmount` has incorrect description  ### Recommended Mitigation Steps  ```jsx /**    @notice Get bribe from BribeVault    @param  proposal            address  Proposal           @param  round               uint256  Round    @param  token               address  Token    @return bribeToken          address  Bribe token address    @return bribeAmount         uint256  Bribe token amount */ ```  ## L05: Emit relevant events in constructor methods when variables are set, or abstract to internal functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56)  ### Description  Some variables are set in the constructor method but do not emit events, unlike their setter counterparts. For instance, `bribeVault` in the `RewardDistributor` contract fails to emit the `SetBribeVault` event, but this is emitted in the `setBribeVault()` function.  ### Recommended Mitigation Steps  Either emit the events in the constructor, or make the setter functions public and have the constructor call it.  # Suggestions  ## S01: TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via `setRound()`  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110)  ### Description  Instead of manually setting rounds, consider fetching the round number directly from Tokemak’s manager contract via `[manager.currentCycleIndex()](https://etherscan.io/address/0xa86e412109f77c45a3bc1c5870b880492fb86a14#readProxyContract)`. While I initially wrote an issue about being able to set previous round numbers, after having chatted with the sponsor, it is intended to be a feature, not a bug.  ### Recommended Mitigation Steps  ```jsx // TODO: change _round to getRound() wherever it is called in other internal functions function getRound() public view returns (uint256) {   // if round is overridden, return set value   if (_round != 0) return _round;   // otherwise, if value is 0, use Tokemak's currentCycleIndex()   // Tokemak manager at 0xa86e412109f77c45a3bc1c5870b880492fb86a14   return manager.currentCycleIndex(); } ```
## G01: Redundant variables  The following variables are initialized, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  [`BribeVault.fee`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23)  [`BribeVault.feeDivisor`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26)  ## G02: TokemakBribe: `bribeVault` can be made immutable  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28)  ### Description  `bribeVault` is only set in the constructor, and there are no mutators to modify its value.  ### Recommended Mitigation Steps  `address public immutable bribeVault;`  ## G03: TokemakBribe: Redundant `SetProposals()` event  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154)  ### Description  The setting of multiple proposals does not require the `SetProposals()` event to be emitted because the `SetProposal()` event is emitted for each proposal when `setProposal()` is invoked.  ### Recommended Mitigation Steps  Remove the `SetProposals()` event.  ## G04: ThecosmataETH: Change `BTRFLY` and `CURVEPOOL` types to avoid repeated castings  ### Description  `BTRFLY` and `CURVEPOOL` are repeatedly casted to `IBTRFLY` and `ICurveCryptoPool`. It would be better to declare them as these types instead.  ### Recommended Mitigation Steps  ```jsx IBTRFLY public immutable BTRFLY; ICurveCryptoPool public immutable CURVEPOOL; ```  ## G05: ThecosmataETH: Call `add_liquidity()` with receiver specified  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146)  ### Description  The curve pool tokens can be transferred directly to the treasury by calling a different `add_liquidity` method.  ### Recommended Mitigation Steps  ```jsx interface ICurveCryptoPool {   function add_liquidity(     uint256[2] calldata amounts,     uint256 min_mint_amount,     bool use_eth,     address receiver   )   external   payable;    ... }  // in addLiquidity() ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount, false, TREASURY); ```  ## G06: RewardDistributor: Include updateCount in  `isRewardClaimed()` and `_setClaimed()` functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142)  ### Description  Based on the current tests, the `claim()` function takes an average of 129k gas (82k min, 206k max). By including the `updateCount` parameter in the `isRewardClaimed()` and `_setClaimed()` functions, this can be reduced by about 2k. With the changes, the `claim()` function will take an average of 127k gas (81k min, 202k max).  There is an added benefit to making this change. By taking the `updateCount` as a parameter in `isRewardClaimed()`, it enables the checking of past claims made.  ### Tools Used  `hardhat-gas-reporter`  ### Recommended Mitigation Steps  ```jsx function isRewardClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount)   public   view   returns (bool) {   // Get the group index for the specified index along with the bit index   // and check if the corresponding bit index is flipped   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;   uint256 claimedGroupState = claimed[_identifier][_updateCount][       claimedGroup   ];   uint256 mask = (1 << claimedIndex);   return claimedGroupState & mask == mask; }  function _setClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount) internal {   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;    // Flip the bit state to mark the corresponding index as claimed   claimed[_identifier][_updateCount][claimedGroup] =     claimed[_identifier][_updateCount][claimedGroup] |     (1 << claimedIndex); }  function _claim(..) {   require(     !isRewardClaimed(_rewardIdentifier, _index, reward.updateCount),     "Reward already claimed"   );   ...   _setClaimed(_rewardIdentifier, _index, reward.updateCount); } ```
## Low severity issues You use IBTRFLY instead of IERC20 to refer to WETH. This is minor because they are both ERC20 tokens but could cause confusion.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L72  You use transfer here, but you could use call instead. Transfer is generally avoided. https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L181  ## Non-critical issues You don't need this event here, frontend will be able to get the information based on each individual SetProposal event  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L49  You don't have an index on any of the TransferBribe or DepositBribe events, consider adding indexes on token and briber so consumers of events can easily go through them.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L42-L56  
# Report  * [Use SafeERC20 when working with arbitrary ERC20 tokens](#use-safeerc20-when-working-with-arbitrary-erc20-tokens) * [Force a new round to be greater than the old one in `TokemakBribe.sol`](#force-a-new-round-to-be-greater-than-the-old-one-in-tokemakbribesol) * [BribeVault doesn't work with fee-on-transfer tokens](#bribevault-doesnt-work-with-fee-on-transfer-tokens) * [Use `.call()` instead of `transfer()` to send funds](#use-call-instead-of-transfer-to-send-funds)  ## Use SafeERC20 when working with arbitrary ERC20 tokens  `SafeERC20` is already used in a couple of spots but not consistently.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297 - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  ## Force a new round to be greater than the old one in `TokemakBribe.sol`  Currently the admin can set the `newRound` to any value. But logically it should always be greater than the previous one. Adding the constraint to the function would prevent that from happening. If a smaller number is used an already finished round might be usable again.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L109  ```sol function setRound(uint256 _newRound) external onlyAuthorized {     require(_newRound > _round);     _round = _newRound; } ```  ## BribeVault doesn't work with fee-on-transfer tokens  There's no documentation on whether they are supported or not so I wanted to still mention it here. The `bribe.amount` value won't match with the actual tokens the vault holds. An easy way to do that would be to use the actual received amount instead of the user passed `amount` parameter:  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L187-L189  ```sol uint prevBalance = IERC20(token).balanceOf(address(this)); IERC20(token).safeTransferFrom(briber, address(this), amount); uint afterBalance = IERC20(token).balanceOf(address(this));  b.amount += afterBalance - prevBalance; // Allow bribers to increase bribe ```  ## Use `.call()` instead of `transfer()` to send funds  It's generally recommended to use `call()` instead of `transfer()` to send funds. The issue is that contracts might use more than 2300 gas in their receive function. In that case the transfer would fail. Since the state is written before the transfer of funds there shouldn't be a risk of reentrancy:  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ```sol (bool success, ) = _account.call{value:_amount}(""); require(success, "Transfer failed."); ```
Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           RewardDistributor.sol, _distributions, 103         RewardDistributor.sol, _claims, 82    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           ThecosomataETH.sol, 88: change 'balance > 0' to 'balance != 0'    Title: Cache powers of 10 used several times Severity: GAS  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ThecosomataETH.sol, 103 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals);  ThecosomataETH.sol, 107 : You should cache the used power of 10 as constant state variable since it's used several times (2):              (((amount * (10**18)) / priceOracle) *  ThecosomataETH.sol, 108 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals)) / (10**_ethDecimals);  ThecosomataETH.sol, 102 : You should cache the used power of 10 as constant state variable since it's used several times (2):              return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /     Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               RewardDistributor.sol.claim - double load of _claims[i]    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, calculateAmountRequiredForLP         ThecosomataETH.sol, addLiquidity    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           RewardDistributor.sol, isRewardClaimed         ThecosomataETH.sol, checkUpkeep    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: RewardDistributor.sol, i, 82         change to prefix increment and unchecked: RewardDistributor.sol, i, 103    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          RewardDistributor.sol, 82         RewardDistributor.sol, 103    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, addLiquidity    Title: Gas Optimization On The 2^256-1 Severity: GAS   Some projects (e.g. Uniswap - https://github.com/Uniswap/interface/blob/main/src/hooks/useApproveCallback.ts#L88) set the default value of the user's allowance to 2^256 - 1. Since the value 2^256 - 1 can also be represented in  hex as 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff. From Ethereum's yellow paper we know  that zeros are cheaper than non-zero values in the hex representation. Considering this fact, an alternative  choice could be now 0x8000000000000000000000000000000000000000000000000000000000000000 or 2^255 to represent  "infinity". If you do the calculations with Remix, you will see that the former costs 47'872 gas, while the latter  costs 45'888 gas. If you accept that infinity can also be represented via 2^255 (instead of 2^256-1), which almost  all projects can - you can already save about 4% gas leveraging this optimisation trick on those calculations.                    ThecosomataETH.sol (L#69): IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1); )         ThecosomataETH.sol (L#68): IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);)  
1. Used both named return and an actual return statement in [ThecosomataETH.sol#L89](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L89)  2. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of these methods. As following you can see the affected locations: - [ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69) - [ThecosomataETH.sol#L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146) - [ThecosomataETH.sol#L164](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L164) - [BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297) - [BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L337) 
2022-02-redacted-cartel  1 Use Lock pragmas to specific compiler version. If it is possible, set above 0.8.4 and you can use custom errors instead of require statements to save gas.  2 Use naming conventions for constant variable  Constants should be named with all capital letters with underscores separating words.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L31   3 write comments outside of require statement.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L225-L230  4 Use safeTransfer of SafeERC20 or check the return value of IERC().transfer which returns whether the operation succeeded  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  ThecosomataETH.sol line 146 and 164  5 Add require or custom error to check if sender is BribeVault contract or not and emit msg.value in receive.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59  For example  require(msg.sender == bribeVault, “Only from bribeVault allowed”); emit received(msg.value);   
2022-02-redacted-cartel Gas Optimization  1 Using custom errors instead of require statement saves gas if you can use a solidity version above 0.8.4.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L61 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L68-L72 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L84 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L129-L130 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L146-L150 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L218-L223 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L259-L263 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L64 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L67 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L70 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L84 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L109 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L123 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L137 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L171-L175 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L179-L183 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L218-L221 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L225-L230 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L261-L266 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L274-L279 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L286-L289 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L294 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L321 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L334-L335 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L350 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L353 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L52 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L69 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L80 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L100-L101 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L160-L164 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L168-L171  TokemakBribe.sol  2 Use immutable for bribeVault.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28  There are no functions to update bribeVault, so you can set bribeVault as immutable.  3 Use visibility external function instead of public  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L298  4 Use visibility private instead of internal  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L166-L170 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L180-L184   BribeVault.sol  5 All inputs checks must be executed at the beginning of function in constructor  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74  constructor(uint256 _fee, address _feeRecipient, address _distributo) {     require(_fee <= feeDivisor, "Invalid fee");     require(_feeRecipient != address(0), "Invalid feeRecipient");     require(_distributor != address(0), "Invalid distributor");          fee = _fee;     feeRecipient = _feeReceipient;     Distributor = _distributor;      _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); }  6 code duplication.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L310  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L322  Create private function to execute this code duplication. For example,  function _updateRewardsMetadata(     Common.Distribution[] calldata distributions ) private {     IRewardDistributor(distributor).updateRewardsMetadata(distributions); } and use this private function in transferBribes and updateRewardsMetadata.   RewardDistributor.sol  7 set visibility private instead of internal for _claim and _setClaimed in RewardDistributor.sol  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L152-L158  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L199  8 delete unused variable in struct Reward  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L17  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/libraries/Common.sol#L9   ThecosomataETH.sol  9 All inputs checks must be executed at the beginning of function in constructor  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L50-L73  constructor(     address _BTRFLY,      address _WETH,     address _TRESUARY,     address _CURVEPOOL ) {     require(_BTRFLY != address(0), “Invalid BTRFLY address”);     require(_WETH != address(0), “Invalid WRTH address”);     require(_TRESUARY != address(0), “Invalid TRESUARY address”);     require(_CURVEPOOL != address(0), “Invalid CURVEPOOL address”);    }  10 set visibility private instead of internal for calculateAmountRequiredLP and addLiquidity  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L113                     
# GAS issues  1. Change the incremental logic from `i++` to `++i` in order to save some opcodes: - [BribeVault.sol#L269](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L269) - [RewardDistributor.sol#L82](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L82) - [RewardDistributor.sol#L103](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L103) - [TokemakBribe.sol#L152](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L152)  2. It's possible to avoid storage access a save gas using `immutable` keyword for the following variables: - [TokemakBribe.sol#L62](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L62)  3. Avoid double events and calls - [TokemakBribe.sol#L156](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L156) `SetProposals` was already emited at line [134](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L134) also `onlyAuthorized`  4. Remove unused code - [setRewardForwarding](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L298-L302) is not used in TokemakBribe.sol  5. Use `type(uint).max` instead of `2**256 - 1` - [ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69)  6. Unneeded `require`, `bytes32.length` is always 32 - [BribeVault.sol#L171-L172](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L171-L172) - [BribeVault.sol#L218-L219](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L218-L219)  
Below are the places where Gas can be saved:  1. bribeVault can be set to immutable at TokemakBribe.sol#L28  2. Instead of using _setupRole function in TokemakBribe.sol#L64 we can directly use _grantRole as done in grantTeamRole function  3. In revokeTeamRole function at TokemakBribe.sol#L98, require(hasRole(TEAM_ROLE, teamMember), "Invalid teamMember"); is not required since this is already checked in _revokeRole function  4. In setProposals function at TokemakBribe.sol#L142, store proposals.length in local variable and use local variable instead at all places in this function  5. In setProposals function at TokemakBribe.sol#L152, use ++i instead of i+=1. Change this in all loops at all contracts (also change i++ to ++i)  6. In depositBribeERC20 function at  TokemakBribe.sol#L222-L223, require(token != address(0), "Invalid token"); and require(amount > 0, "Bribe amount must be greater than 0"); are not required as they are already checked in depositBribeERC20 function of BribeVault.sol#L173-L174  7. The setRewardForwarding function at TokemakBribe.sol#L298 can be declared external  8. In revokeDepositorRole function at BribeVault.sol#L98, require(hasRole(DEPOSITOR_ROLE, depositor), "Invalid depositor"); is not required since this is already checked in _revokeRole function  9. In transferBribes function at BribeVault.sol#L256, store distributions.length in local variable and use this local variable at all places  10. In claim function at RewardDistributor.sol#L79, add a check to revert when require( _claims[i].amount!=0, "Invalid amount")   
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73   # Vulnerability details  ## Impact  Claiming of the ETH native currency requires `token` to be set to `bribeVault`. If the `bribeVault` is modified in `setBribeVault()` then users who have ETH rewards will now be considered to have `ERC20(bribeVault)` tokens. Since `bribeVault` is not an ERC20 token the `transfer()` call will fail and the users will not be able to claim their funds.   ## Recommended Mitigation Steps  Consider removing the functionality to change the `bribeVault` or ensuring all funds have been withdraw i.e. `balanceOf(address(this)) == 0` before changing the `bribeVault`.  
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296   # Vulnerability details  ## Impact In BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.  Tokens that don’t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.    ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296  ## Tools Used Manual code review   ## Recommended Mitigation Steps It's recommended to use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.   
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164   # Vulnerability details  ## Impact In BribeVault.sol,  the depositBribeERC20() function deposits a bribe which is an ERC20 token from the briber to the contract itself and then updates the Bribe structs amount and token address.  The issue is that there is no whitelist of acceptable ERC20 tokens that are allowed to interact with the protocol.  Without a proper white list malicious attacker controlled tokens are able to be introduced into the protocol which should not be allowed.  ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a whitelist mapping of acceptable tokens and require that the token address argument in the depositBribeERC20() function is a whitelisted token allowed to interact with the protocol.   
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181   # Vulnerability details  ## Impact Use call instead of transfer to send ether. And return value must be checked if sending ether is successful or not. Sending ether with the transfer is no longer recommended. ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ## Tools Used review ## Recommended Mitigation Steps  (bool result, ) = payable(_account).call{value: _amount}(""); require(result, "Failed to send Ether");  
 1. Floating pragma is used in all the contracts  As different compiler versions have critical behavior specifics if the contracts get accidentally deployed using another compiler version compared to the one they were tested with, various types of undesired behavior can be introduced  ## Proof of Concept  `pragma solidity ^0.8.0` is used in all the system contracts, for example:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L2  ## Recommended Mitigation Steps  Consider fixing the version to 0.8.x across all the codebase, for example set x to 10   2. Most of events in BribeVault, TokemakBribe and ThecosomataETH aren't indexed  ## Impact  Filtering on not indexed events is disabled, which makes it harder to programmatically use and analyze the system  ## Proof of Concept  The following events are not indexed:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L37-57  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L42-43  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L44-48  ## Recommended Mitigation Steps  Consider making all events ids and addresses indexed to improve their usability   3. bytes32.length check is redundant and doesn't rule zero values out  ## Impact  bytes32.length do not control for bogus values as the bytes32 length is fixed to 32. This way, for example, depositBribe can be successfully called with any identifiers, for example `0x0000000000000000000000000000000000000000000000000000000000000000` id will not be reverted  ## Proof of Concept  bytes32 is a fixed size array, which length will always be 32, but it is checked for positive length anyway in BribeVault deposit functions:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L171-172  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L218-219  ## Recommended Mitigation Steps  If non-zero check is desired, `!= 0` can suffice (will revert on `0x0000000000000000000000000000000000000000000000000000000000000000`):  Now: ``` require(bribeIdentifier.length > 0, "Invalid bribeIdentifier"); ```  To be: ``` require(bribeIdentifier != 0, "Invalid bribeIdentifier"); ``` 
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209   # Vulnerability details  ## Impact  The `updateRewardsMetadata()` function is called by the `BribeVault` contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.   `reward.updateCount` is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to `updateRewardsMetadata()` and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.  ## Proof of Concept  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a delay where users cannot claim rewards before a call to `updateRewardsMetadata()` is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.  
## Missing Doc Comments in function `getBrige()`   The parameter `round` is missing in doc comments for the function  `getBrige()` at `TokemakBribe.sol`  Also consider add doc comments at  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol  Doc comments will increase the readability of the code and will avoid other more high risk issues.    For example in this contest I sent a medium severity issue related to the same parameter.  ## Poc  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L188-L204          @notice Get bribe from BribeVault         @param  proposal            address  Proposal         @param  token               address  Token   @audit-issue   need to add round parameter and all thecosomata eth         @return bribeToken          address  Token address         @return bribeAmount         address  Token address      */     function getBribe(         address proposal,         uint256 round,         address token     ) external view returns (address bribeToken, uint256 bribeAmount) {         return             IBribeVault(bribeVault).getBribe(                 generateBribeVaultIdentifier(proposal, round, token)             );     }   # Similar issues  https://github.com/code-423n4/2021-09-swivel-findings/issues/71
Low :  Title : proposal can be frontrun to support malicious token  Impact : When an authorized user set a proposal, a malicious user might call depositBribeERC20() right after the set proposal transaction is finish, since the token is not whitelisted, the malicious user might provide a malicious token, a token that will revert on all interaction with this contract, this can cause a dos on the proposal that just being set.  POC : https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L125
## Redacted Cartel QA Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The audit was done from February 15-17, 2022 by ye0lde through code4rena.  Overall, I found the code to be clear to follow and understand. A test suite was provided. Including more tests that tackle edge scenarios and providing coverage and gas reports by default would be useful.  - [Findings](#findings)   - [L-1 - Restrict funds receivable to be only from `BribeVault` (RewardDistributor.sol)](#l-1---restrict-funds-receivable-to-be-only-from-bribevault-rewarddistributorsol)   - [L-2 - Unchecked ERC20 transfer calls](#l-2---unchecked-erc20-transfer-calls)   - [NC-1 - Incorrect return value description for `getBribe` (TokemakBribe.sol)](#nc-1---incorrect-return-value-description-for-getbribe-tokemakbribesol)  ## Findings    ### L-1 - Restrict funds receivable to be only from `BribeVault` (RewardDistributor.sol)  #### Impact Native fund transfers into the `RewardDistributor` contract are only expected from the `BribeVault` contract. It would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  #### Proof of Concept The `receive` function is here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L58-L59  ``` // Enables BribeVault to transfer native tokens receive() external payable {} ```  #### Recommended Mitigation Steps Modify the receive() function to only accept transfers from the `BribeVault` contract.  ``` receive() external payable {       require(msg.sender == address(bribeVault), "Not BribeVault..."); } ``` ---  ### L-2 - Unchecked ERC20 transfer calls   #### Impact ERC20 transfer and transferFrom calls normally return true on a successful transfer.  If transfers are done with ERC20 token which does not comply with the EIP-20 standard it might return false on a failed transaction rather than revert. In this case, it would count as a valid transaction even though it is not.   #### Proof of Concept Unchecked transfer calls are here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L337 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L164  #### Recommended Mitigation Steps Consider using OpenZeppelin's library with safe versions of transfer functions as used in other areas of the code.  ---  ### NC-1 - Incorrect return value description for `getBribe` (TokemakBribe.sol)  #### Impact Code clarity  #### Proof of Concept The incorrect comment which appears to be copied from line #192 is here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L193  #### Recommended Mitigation Steps Correct the comment/description.  ---
##GasFindingsCartel 1-- -using storage to declare `b` struct https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L152 `b` just called twice in the `gotBribe`(struct data type consume more gas when it chaced and it depend on the size of the struct). Read from storage instead of caching it cost less gas ``` Bribe storage b = bribes[bribeIdentifier]; ```  2-- -using at least pragma 0.8.4 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2 The advantages of versions 0.8.4 over <0.8.0 are:     1. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.     2. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.     3. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  3-- -using && cost more gas https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L262-L266 instead of using &&, using double require to validate can save gas ``` require(             distributions.length == amounts.length,             "Distributions, amounts, and fees must contain the same # of elements"         ); require(                 distributions.length == fees.length,             "Distributions, amounts, and fees must contain the same # of elements"         ); ``` 4-- -using ++var for increment operation https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L109 using: ```       ++reward.updateCount; ```    is better method to do increment operation for gas opt  5-- -caching `Reward` to memory cost more gas https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L134 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L200 `reward` is merely called once at the `isRewardClaimed()` and twice at `_setClaimed()`. Its gas saving by just read it directly to the storage. ```         Reward storage reward = rewards[_identifier]; ``` 
## Summary: During the code assessment, we found multiple issues related to unchecked transfer and no handing of return values. Many functions call like "transfer," "deposit," "approve," etc., returns some value after the function call. Handling these calls is important to prevent unexpected outcomes. Apart from that, we found multiple functions which were missing zero address checks. It is advised to add a zero address check at all possible functions setting an address. In solidity, any error caused to set the value to default, and for an address variable, the default value is zero address. Hence any fund or privilege gets pointed to zero address, it will be unrecoverable.  The contract was found to be using floating pragma, which allows the contract to be compiled to multiple versions and hence can cause inconsistencies or errors on different versions. We also noticed the uses of large number literals. Although it is not a security issue but enhances readability and reduces the chance of errors or missing digits. We also noticed missing events in many critical functions. Events are important for logging purposes. Hence it is recommended to add events and indexed events at all possible function calls for better logging. Lastly, we also noticed that the fee value, which is set by an admin, can be set to zero due lack of proper input validation.    ## Low Severity findings:  ## QA - 1  ### Title:  Unchecked return value in transfer  ### Description: The return value of the token transfers is not checked or validated at all in the functions shown below. This may lead to issues if there's a critical contract logic happening below the transfer that affects or manipulates the number of ether or tokens. Therefore, if the return value is not checked, the adversaries will be able to call those functions without actually transferring any ether and manipulating the token balance.  ### PoC: Transfer: Go to the below lines of code and we will notice that transfer  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L146 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L164    ### Suggested Fix: Consider the use of safeTransfer instead of transfer that auto asserts and handles in case of transfer failure.     ## QA - 2  ### Title:  Unused return in approve call  ### Description: The contract was found to be making an external call (approve). The function which is called is returning some value which is never used. This may lead to discrepancies and improper assumptions in the calling function.  ### PoC: - Go to the lines below and we will notice that the approve function's return value is not used for any further validation or check. https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L68 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L69  ### Suggested Fix: It is recommended to make use of the return values coming from the external function that is called to make sure that the calculations following the external call are correct.    ## QA - 3  ### Title:  Use of Floating Pragma Version  ### Description: The contract was found to be using a floating pragma which is not considered safe as it can be compiled with all the versions described.  ### PoC: Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2)  Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L2) Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L2)  Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L2)   ### Suggested Fix: Use strict pragma version like  Pragma version 0.8.0  ## QA - 4  ### Title:  Missing input validation in setFee function   ### Description: The function `setFee` does not check if the fee value is set to zero.   ## Impact An admin can set fee value to zero by mistake, and it can cause free trades and loss to the organization.   ### PoC: - Notice the function below https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108-L113 - The `setFee` function just checks if the fee is less than feeDivisor but does not check if the fee is zero.   ### Suggested Fix: Check if the fee is being set to zero.    ## Non-critical findings  ## QA - 5  ### Title:  Use of Large Number Literals  ### Description: Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.   ## Impact  Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ### PoC: - Go to https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26 We will notice a large literal  `uint256 public constant feeDivisor = 1000000;` where 1000000 can be represnted as 10e6  ### Suggested Fix: Scientific notation in the form of `2e10` is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal `MeE` is equivalent to `M * 10**E`. Examples include `2e10`, `2e10`, `2e-10`, `2.5e1`.  Reference: [https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals](https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals)  ## QA - 6  ### Title:  Multiple missing events in critical functions  ### Description: Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction's log, a special data structure in the blockchain. These logs are associated with the address of the contract, which can then be used by developers and auditors to keep track of the transactions.   The contract was found to be missing these events on certain critical functions, which would make it difficult or impossible to track these transactions off-chain.  ## Impact  Events are used to track the transactions off-chain, and missing these events on critical functions makes it difficult to audit these logs if they're needed at a later stage.    ### PoC: The below functions are missing events. - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L76-L80 The function `setSlippage` is called by an admin and hence should have an event log regarding the change is slippage value.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L158-L165 The `withdraw` function is called by an admin to withdraw funds and hence should have an event log.   - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108-L110 The function `setRound` sets a new voting round by admins and hence should have an event log.   ### Suggested Fix: Consider emitting events for the functions mentioned above. It is also recommended to have the addresses indexed.   ## QA - 7  ### Title:  Multiple functions Lacking Zero address checks  ### Description: Address type parameters should include a zero-address check; otherwise, contract functionality may become inaccessible, or tokens burned forever.  ## Impact Tokens may become inaccessible or burnt forever without a zero-address check.  ### PoC: Below is the list of functions lacking zero address checks - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L212-L251 Function `depositBribeERC20` has address `proposal` that is missing zero address checks  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L257-L290 Function `depositBribe` has address input `proposal`, which is lacking zero address checks.    ### Suggested Fix: Address zero address check to all the missing places.      
- [S]: Suggested optimation, save a decent amount of gas without compromising readability; - [M]: Minor optimation, the amount of gas saved is minor, change when you see fit; - [N]: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [M] Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L118-L118  ## [S] Using immutable variable can save gas   https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L28-L28  ```solidity     address public bribeVault; ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L60-L65  ```solidity     constructor(address _bribeVault) {         require(_bribeVault != address(0), "Invalid bribeVault");         bribeVault = _bribeVault;          _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);     } ```  Considering that `bribeVault` will never change, changing it to immutable variable instead of storage variable can save gas.  ## [S] Remove redundant access control checks can save gas  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135  ```solidity     function setProposal(address proposal, uint256 deadline)         public         onlyAuthorized     {         require(proposal != address(0), "Invalid proposal");         require(deadline >= block.timestamp, "Deadline must be in the future");          proposalDeadlines[proposal] = deadline;          emit SetProposal(proposal, deadline, _round);     } ```   https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157  ```solidity     function setProposals(         address[] calldata proposals,         uint256[] calldata deadlines     ) external onlyAuthorized {         require(proposals.length > 0, "Need at least 1 proposal");         require(             proposals.length == deadlines.length,             "Must be equal # of proposals and deadlines"         );          for (uint256 i = 0; i < proposals.length; i += 1) {             setProposal(proposals[i], deadlines[i]);         }          emit SetProposals(proposals, deadlines, _round);     } ```    `setProposal()` already got `onlyAuthorized` check, and `setProposals()` will check it again multiple times.  Consider creating `_setProposal()` private function without access control and call it inside the public functions.  ### Recommendation  Change to:  ```solidity     function _setProposal(address proposal, uint256 deadline)         private     {         require(proposal != address(0), "Invalid proposal");         require(deadline >= block.timestamp, "Deadline must be in the future");          proposalDeadlines[proposal] = deadline;     }      /**         @notice Set a single proposal         @param  proposal  addresss Proposal address         @param  deadline  uint256  Proposal deadline      */     function setProposal(address proposal, uint256 deadline)         public         onlyAuthorized     {         _setProposal(proposal, deadline);         emit SetProposal(proposal, deadline, _round);     }      /**         @notice Set multiple proposals         @param  proposals  address[]  Proposal addresses         @param  deadlines  uint256[]  Proposal deadlines      */     function setProposals(         address[] calldata proposals,         uint256[] calldata deadlines     ) external onlyAuthorized {         require(proposals.length > 0, "Need at least 1 proposal");         require(             proposals.length == deadlines.length,             "Must be equal # of proposals and deadlines"         );          for (uint256 i = 0; i < proposals.length; i += 1) {             _setProposal(proposals[i], deadlines[i]);         }          emit SetProposals(proposals, deadlines, _round);     } ```  ## [S] Validation can be done earlier to save gas  Check if `ethLiquidity > 0 && btrflyLiquidity > 0` earlier can avoid unnecessary external call (`IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);`) when this check failed.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L124-L155  ```solidity     function performUpkeep() external onlyOwner {         require(checkUpkeep(), "Invalid upkeep state");          uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));         uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);         uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);         uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;          // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount         uint256 btrflyLiquidity = ethCap > ethAmount             ? btrfly             : calculateAmountRequiredForLP(ethLiquidity, false);          IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);          // Only complete upkeep only on sufficient amounts         require(ethLiquidity > 0 && btrflyLiquidity > 0, "Insufficient amounts");         // ...     } ```  ### Recommendation  Change to:  ```solidity     function performUpkeep() external onlyOwner {         require(checkUpkeep(), "Invalid upkeep state");          uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));         uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);         uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);         uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;          // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount         uint256 btrflyLiquidity = ethCap > ethAmount             ? btrfly             : calculateAmountRequiredForLP(ethLiquidity, false);          // Only complete upkeep only on sufficient amounts         require(ethLiquidity > 0 && btrflyLiquidity > 0, "Insufficient amounts");          IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);          // ...     } ```  ## [M] `type(uint256).max` is more gas efficient than `2**256 - 1`  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69  ## [M] `10e18` is more gas efficient than `10**18`  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L102-L108  ## [S] Cache array length in for loops can save gas  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L147-L152  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L261-L275  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L80-L82  ## [S] Avoid unnecessary storage read can save gas  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, "Invalid bribeIdentifier");         require(rewardIdentifier.length > 0, "Invalid rewardIdentifier");         require(briber != address(0), "Invalid briber");         require(msg.value > 0, "Value must be greater than 0");          Bribe storage b = bribes[bribeIdentifier];         address currentToken = b.token;         require(             // For native tokens, the token address is set to this contract to prevent             // overwriting storage - the address can be anything but address(this) safer             currentToken == address(0) || currentToken == address(this),             "Cannot change token"         );          b.amount += msg.value; // Allow bribers to increase bribe          // Only set the token address and update the reward-to-bribe mapping if not yet set         if (currentToken == address(0)) {             b.token = address(this);             rewardToBribes[rewardIdentifier].push(bribeIdentifier);         }          emit DepositBribe(             bribeIdentifier,             rewardIdentifier,             b.token,             msg.value,             b.amount,             briber         );     } ```  Based on L224~L230, L235~L236, we know that `b.token == address(this)`, therefore at L243 `b.token` can be replaced with `address(this)`.  Use `address(this)` directly can avoid unnecessary storage read of `b.token` and save some gas.  ### Recommendation  Replace:  ```solidity emit DepositBribe(     bribeIdentifier,     rewardIdentifier,     b.token,     msg.value,     b.amount,     briber ); ```  with:  ```solidity emit DepositBribe(     bribeIdentifier,     rewardIdentifier,     address(this),     msg.value,     b.amount,     briber ); ``` 
## [L] `bytes32Value.length > 0` is misused, should be `bytes32Value != bytes32(0)`   `bytes32Value.length > 0` is meanless, as it always be `true`, because `.length` yields the fixed length of the byte array. `bytes32Value.length` == 32.  `bytes32` is a value type, you should use `!=` to do the comparison.  See: https://docs.soliditylang.org/en/v0.8.12/types.html#fixed-size-byte-arrays  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L164-L205  ```solidity     function depositBribeERC20(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address token,         uint256 amount,         address briber     ) external onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, "Invalid bribeIdentifier");         require(rewardIdentifier.length > 0, "Invalid rewardIdentifier");         // ...     } ```  Can be changed to:  ```solidity     function depositBribeERC20(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address token,         uint256 amount,         address briber     ) external onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length != bytes32(0), "Invalid bribeIdentifier");         require(rewardIdentifier.length != bytes32(0), "Invalid rewardIdentifier");         // ...     } ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, "Invalid bribeIdentifier");         require(rewardIdentifier.length > 0, "Invalid rewardIdentifier");         // ...     } ```  Can be changed to:  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length != bytes32(0), "Invalid bribeIdentifier");         require(rewardIdentifier.length != bytes32(0), "Invalid rewardIdentifier");         // ...     } ```  ## [L] Unchecked return value for `token.transfer` call  It is usually good to add a require-statement that checks the return value or to use something like safeTransfer; unless one is sure the given token reverts in case of a failure.  Instances include:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297  ```solidity IERC20(token).transfer(feeRecipient, feeAmount); IERC20(token).transfer(distributor, distributorAmount); ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146-L146  ```solidity IERC20(token).transfer(TREASURY, tokenBalance); ```  ### Recommendation  Consider adding a require-statement or using `safeTransfer` of SafeERC20.
https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L38  `rewardForwarding` is redundant as it's not used. also, the function that sets it is redundant. https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L298
# Pin Solidity Version Pin solidity version to make the compilation more predictable. https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L2  # Fee cap too high The fee can be set as high as `feeDivisor` which equals to 100% https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L108  # Use of transfer might fail in the future `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L181 
## BribeVault: `fee` is not used anywhere The variable is [set](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L65) and [allowed to be changed](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108) and even an event is there, however it is not used anywhere. The fees are [being read](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L272) directly from the admin's sent parameters and there's no check against the fee previously set. Consider removing it or aligning the `transferBribes` function to use it.  ## RewardDistributor: no sender check for ETH receive function [This](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59) is RB's receive function: ```     // Enables BribeVault to transfer native tokens     receive() external payable {} ``` If it is only used from BribeVault, consider adding a check that verifies that the sender is BribeVault - otherwise misc ether might get sent and locked in the contract.  ## RewardDistributor: ETH being sent using `transfer` In _claim, ETH is [being sent](](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)) using the `transfer` function. While this might be a design choice, it might cause problems and fail to transfer to smart contracts, [such as gnosis safe](https://help.gnosis-safe.io/en/articles/5249851-why-can-t-i-transfer-eth-from-a-contract-into-a-safe). There are mitigations (see in the article), and this is why I rated it as a low issue and not medium. However, for normal user experience, consider changing the `transfer` to `call`. If the concern is reentrancy, you obviously know that there are other mitigations (CEI pattern and reentrancy guard).  ## TokemakBribe: consider adding sanity check for `round` When [setting a new round](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108:#L110), as there is no check that `_newRound > _round`, a team member can add rounds "retroactively": ```     function setRound(uint256 _newRound) external onlyAuthorized {         _round = _newRound;     } ``` I don't really consider this a danger. The worst case would be that a team member (not the admin) listens to TXs in the mempool, and when somebody deposits a bribe, the team member would change the round to be another one which is more beneficial for the team member, and therefore the bribe would be misattributed. However, we are talking about a team member, plus the emergency withdraw function can withdraw it, plus   anyway further releasing of the bribe to claimers requires admin actions. So I do not believe that this is a real risk. This is why I label this as low and not medium. However adding a check that `_newRound > _round` seems like an easy sanity check to add.  ## TokemakBribe: wrong comment for getRound [The comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L113:#L116) for `getRound` is same as for `setRound`. ```     /**         @notice Set a new voting round         @return round uint256 The current round number      */     function getRound() external view returns (uint256) { ```  ## ETH bribes dependent on BribeVault address Regarding using BribeVault's address as the native token address, [a comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L226) mentions "For native tokens, the token address is set to this contract to prevent overwriting storage - the address can be anything but address(this) safer". I might be missing something but I don't see how BribeVault's address is safer than an immutable like 0xEE..E. Since RewardDistributor [can change](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65) BribeVault, this means that the reward identifier would also need to be changed. So again, I might be missing something but at the moment it seems to me that using the changing BribeVault address as the native token identifier just adds complexity.  ## BribeVault: transferBribes: unchecked transfer of ERC20 tokens The function [doesn't use](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296:#L297) safeTransfer for sending of tokens: ```                 IERC20(token).transfer(feeRecipient, feeAmount);                 IERC20(token).transfer(distributor, distributorAmount); ``` This might be on purpose, to not totally fail the whole loop and lose gas if one token is problematic and failed to send. If so, make sure the admin properly checks that all transfers succeeded. For easy checking I believe you can change to safeTransfer and use try/catch to emit an event if the transfer failed.
# Codebase Impressions & Summary  This audit scope consisted of 4 contracts. Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.  Most issues raised are minor improvements to improve the security of the contracts. The only notable findings made had to do with the usage of the curve crypto pool’s price oracle, and protection against sandwich attacks when adding liquidity.  In addition, I made a suggestion regarding the syncing of Tokemak’s rounds with the `TokemakBribe` contract.  Note that I refrained raising issues regarding FoT tokens because I assume they are not meant to be supported.  # Low Severity Findings  ## L01: RewardDistributor: Change `payable(account).transfer()` to `.call()` for native fund transfers  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)  ### Description  `BribeVault` uses `.call()` for native fund transfers, but `RewardDistributor` uses `.transfer()`. They should be standardized to `.call()`, the currently recommended method since [`.transfer()` fowards 2300 gas whereas `.call()` forwards all / set gas.](https://solidity-by-example.org/sending-ether/)  ### Recommended Mitigation Steps  ```jsx (bool sentAccount, ) = _account.call{value: _amount}(""); require(sentAccount, "Failed to transfer to _account"); ```  ## L02: BribeVault: Use `safeTransfer` for tokens  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337)  ### Description  Some ERC20 tokens like ZRX don’t revert if the transfer fails. Since the `SafeERC20` has already been imported and the `safeTransferFrom` method used, the same should be done for token transfers.  ### Recommended Mitigation Steps  Replace `transfer` with `safeTransfer`.  ## L03: RewardDistributor: Limit native fund transfers to `bribeVault`  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59)  ### Description  Since the only source of native fund transfers is expected to be the `bribeVault` contract, it would be good to restrict incoming fund transfers from other sources to prevent accidental transfers.  ### Recommended Mitigation Steps  ```jsx receive() external payable {   require(msg.sender == bribeVault, 'only bribeVault'); } ```  ## L04: TokemakBribe: `getBribe()` has incorrect description  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194)  ### Description  - Missing `round` param - `bribeAmount` has incorrect description  ### Recommended Mitigation Steps  ```jsx /**    @notice Get bribe from BribeVault    @param  proposal            address  Proposal           @param  round               uint256  Round    @param  token               address  Token    @return bribeToken          address  Bribe token address    @return bribeAmount         uint256  Bribe token amount */ ```  ## L05: Emit relevant events in constructor methods when variables are set, or abstract to internal functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56)  ### Description  Some variables are set in the constructor method but do not emit events, unlike their setter counterparts. For instance, `bribeVault` in the `RewardDistributor` contract fails to emit the `SetBribeVault` event, but this is emitted in the `setBribeVault()` function.  ### Recommended Mitigation Steps  Either emit the events in the constructor, or make the setter functions public and have the constructor call it.  # Suggestions  ## S01: TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via `setRound()`  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110)  ### Description  Instead of manually setting rounds, consider fetching the round number directly from Tokemak’s manager contract via `[manager.currentCycleIndex()](https://etherscan.io/address/0xa86e412109f77c45a3bc1c5870b880492fb86a14#readProxyContract)`. While I initially wrote an issue about being able to set previous round numbers, after having chatted with the sponsor, it is intended to be a feature, not a bug.  ### Recommended Mitigation Steps  ```jsx // TODO: change _round to getRound() wherever it is called in other internal functions function getRound() public view returns (uint256) {   // if round is overridden, return set value   if (_round != 0) return _round;   // otherwise, if value is 0, use Tokemak's currentCycleIndex()   // Tokemak manager at 0xa86e412109f77c45a3bc1c5870b880492fb86a14   return manager.currentCycleIndex(); } ```
## G01: Redundant variables  The following variables are initialized, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  [`BribeVault.fee`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23)  [`BribeVault.feeDivisor`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26)  ## G02: TokemakBribe: `bribeVault` can be made immutable  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28)  ### Description  `bribeVault` is only set in the constructor, and there are no mutators to modify its value.  ### Recommended Mitigation Steps  `address public immutable bribeVault;`  ## G03: TokemakBribe: Redundant `SetProposals()` event  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154)  ### Description  The setting of multiple proposals does not require the `SetProposals()` event to be emitted because the `SetProposal()` event is emitted for each proposal when `setProposal()` is invoked.  ### Recommended Mitigation Steps  Remove the `SetProposals()` event.  ## G04: ThecosmataETH: Change `BTRFLY` and `CURVEPOOL` types to avoid repeated castings  ### Description  `BTRFLY` and `CURVEPOOL` are repeatedly casted to `IBTRFLY` and `ICurveCryptoPool`. It would be better to declare them as these types instead.  ### Recommended Mitigation Steps  ```jsx IBTRFLY public immutable BTRFLY; ICurveCryptoPool public immutable CURVEPOOL; ```  ## G05: ThecosmataETH: Call `add_liquidity()` with receiver specified  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146)  ### Description  The curve pool tokens can be transferred directly to the treasury by calling a different `add_liquidity` method.  ### Recommended Mitigation Steps  ```jsx interface ICurveCryptoPool {   function add_liquidity(     uint256[2] calldata amounts,     uint256 min_mint_amount,     bool use_eth,     address receiver   )   external   payable;    ... }  // in addLiquidity() ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount, false, TREASURY); ```  ## G06: RewardDistributor: Include updateCount in  `isRewardClaimed()` and `_setClaimed()` functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142)  ### Description  Based on the current tests, the `claim()` function takes an average of 129k gas (82k min, 206k max). By including the `updateCount` parameter in the `isRewardClaimed()` and `_setClaimed()` functions, this can be reduced by about 2k. With the changes, the `claim()` function will take an average of 127k gas (81k min, 202k max).  There is an added benefit to making this change. By taking the `updateCount` as a parameter in `isRewardClaimed()`, it enables the checking of past claims made.  ### Tools Used  `hardhat-gas-reporter`  ### Recommended Mitigation Steps  ```jsx function isRewardClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount)   public   view   returns (bool) {   // Get the group index for the specified index along with the bit index   // and check if the corresponding bit index is flipped   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;   uint256 claimedGroupState = claimed[_identifier][_updateCount][       claimedGroup   ];   uint256 mask = (1 << claimedIndex);   return claimedGroupState & mask == mask; }  function _setClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount) internal {   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;    // Flip the bit state to mark the corresponding index as claimed   claimed[_identifier][_updateCount][claimedGroup] =     claimed[_identifier][_updateCount][claimedGroup] |     (1 << claimedIndex); }  function _claim(..) {   require(     !isRewardClaimed(_rewardIdentifier, _index, reward.updateCount),     "Reward already claimed"   );   ...   _setClaimed(_rewardIdentifier, _index, reward.updateCount); } ```
## Low severity issues You use IBTRFLY instead of IERC20 to refer to WETH. This is minor because they are both ERC20 tokens but could cause confusion.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L72  You use transfer here, but you could use call instead. Transfer is generally avoided. https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L181  ## Non-critical issues You don't need this event here, frontend will be able to get the information based on each individual SetProposal event  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L49  You don't have an index on any of the TransferBribe or DepositBribe events, consider adding indexes on token and briber so consumers of events can easily go through them.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L42-L56  
# Report  * [Use SafeERC20 when working with arbitrary ERC20 tokens](#use-safeerc20-when-working-with-arbitrary-erc20-tokens) * [Force a new round to be greater than the old one in `TokemakBribe.sol`](#force-a-new-round-to-be-greater-than-the-old-one-in-tokemakbribesol) * [BribeVault doesn't work with fee-on-transfer tokens](#bribevault-doesnt-work-with-fee-on-transfer-tokens) * [Use `.call()` instead of `transfer()` to send funds](#use-call-instead-of-transfer-to-send-funds)  ## Use SafeERC20 when working with arbitrary ERC20 tokens  `SafeERC20` is already used in a couple of spots but not consistently.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297 - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  ## Force a new round to be greater than the old one in `TokemakBribe.sol`  Currently the admin can set the `newRound` to any value. But logically it should always be greater than the previous one. Adding the constraint to the function would prevent that from happening. If a smaller number is used an already finished round might be usable again.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L109  ```sol function setRound(uint256 _newRound) external onlyAuthorized {     require(_newRound > _round);     _round = _newRound; } ```  ## BribeVault doesn't work with fee-on-transfer tokens  There's no documentation on whether they are supported or not so I wanted to still mention it here. The `bribe.amount` value won't match with the actual tokens the vault holds. An easy way to do that would be to use the actual received amount instead of the user passed `amount` parameter:  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L187-L189  ```sol uint prevBalance = IERC20(token).balanceOf(address(this)); IERC20(token).safeTransferFrom(briber, address(this), amount); uint afterBalance = IERC20(token).balanceOf(address(this));  b.amount += afterBalance - prevBalance; // Allow bribers to increase bribe ```  ## Use `.call()` instead of `transfer()` to send funds  It's generally recommended to use `call()` instead of `transfer()` to send funds. The issue is that contracts might use more than 2300 gas in their receive function. In that case the transfer would fail. Since the state is written before the transfer of funds there shouldn't be a risk of reentrancy:  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ```sol (bool success, ) = _account.call{value:_amount}(""); require(success, "Transfer failed."); ```
Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           RewardDistributor.sol, _distributions, 103         RewardDistributor.sol, _claims, 82    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           ThecosomataETH.sol, 88: change 'balance > 0' to 'balance != 0'    Title: Cache powers of 10 used several times Severity: GAS  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ThecosomataETH.sol, 103 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals);  ThecosomataETH.sol, 107 : You should cache the used power of 10 as constant state variable since it's used several times (2):              (((amount * (10**18)) / priceOracle) *  ThecosomataETH.sol, 108 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals)) / (10**_ethDecimals);  ThecosomataETH.sol, 102 : You should cache the used power of 10 as constant state variable since it's used several times (2):              return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /     Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               RewardDistributor.sol.claim - double load of _claims[i]    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, calculateAmountRequiredForLP         ThecosomataETH.sol, addLiquidity    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           RewardDistributor.sol, isRewardClaimed         ThecosomataETH.sol, checkUpkeep    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: RewardDistributor.sol, i, 82         change to prefix increment and unchecked: RewardDistributor.sol, i, 103    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          RewardDistributor.sol, 82         RewardDistributor.sol, 103    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, addLiquidity    Title: Gas Optimization On The 2^256-1 Severity: GAS   Some projects (e.g. Uniswap - https://github.com/Uniswap/interface/blob/main/src/hooks/useApproveCallback.ts#L88) set the default value of the user's allowance to 2^256 - 1. Since the value 2^256 - 1 can also be represented in  hex as 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff. From Ethereum's yellow paper we know  that zeros are cheaper than non-zero values in the hex representation. Considering this fact, an alternative  choice could be now 0x8000000000000000000000000000000000000000000000000000000000000000 or 2^255 to represent  "infinity". If you do the calculations with Remix, you will see that the former costs 47'872 gas, while the latter  costs 45'888 gas. If you accept that infinity can also be represented via 2^255 (instead of 2^256-1), which almost  all projects can - you can already save about 4% gas leveraging this optimisation trick on those calculations.                    ThecosomataETH.sol (L#69): IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1); )         ThecosomataETH.sol (L#68): IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);)  
1. Used both named return and an actual return statement in [ThecosomataETH.sol#L89](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L89)  2. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of these methods. As following you can see the affected locations: - [ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69) - [ThecosomataETH.sol#L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146) - [ThecosomataETH.sol#L164](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L164) - [BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297) - [BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L337) 
2022-02-redacted-cartel  1 Use Lock pragmas to specific compiler version. If it is possible, set above 0.8.4 and you can use custom errors instead of require statements to save gas.  2 Use naming conventions for constant variable  Constants should be named with all capital letters with underscores separating words.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L31   3 write comments outside of require statement.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L225-L230  4 Use safeTransfer of SafeERC20 or check the return value of IERC().transfer which returns whether the operation succeeded  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  ThecosomataETH.sol line 146 and 164  5 Add require or custom error to check if sender is BribeVault contract or not and emit msg.value in receive.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59  For example  require(msg.sender == bribeVault, “Only from bribeVault allowed”); emit received(msg.value);   
2022-02-redacted-cartel Gas Optimization  1 Using custom errors instead of require statement saves gas if you can use a solidity version above 0.8.4.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L61 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L68-L72 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L84 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L129-L130 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L146-L150 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L218-L223 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L259-L263 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L64 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L67 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L70 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L84 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L109 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L123 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L137 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L171-L175 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L179-L183 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L218-L221 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L225-L230 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L261-L266 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L274-L279 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L286-L289 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L294 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L321 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L334-L335 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L350 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L353 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L52 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L69 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L80 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L100-L101 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L160-L164 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L168-L171  TokemakBribe.sol  2 Use immutable for bribeVault.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28  There are no functions to update bribeVault, so you can set bribeVault as immutable.  3 Use visibility external function instead of public  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L298  4 Use visibility private instead of internal  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L166-L170 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L180-L184   BribeVault.sol  5 All inputs checks must be executed at the beginning of function in constructor  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74  constructor(uint256 _fee, address _feeRecipient, address _distributo) {     require(_fee <= feeDivisor, "Invalid fee");     require(_feeRecipient != address(0), "Invalid feeRecipient");     require(_distributor != address(0), "Invalid distributor");          fee = _fee;     feeRecipient = _feeReceipient;     Distributor = _distributor;      _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); }  6 code duplication.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L310  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L322  Create private function to execute this code duplication. For example,  function _updateRewardsMetadata(     Common.Distribution[] calldata distributions ) private {     IRewardDistributor(distributor).updateRewardsMetadata(distributions); } and use this private function in transferBribes and updateRewardsMetadata.   RewardDistributor.sol  7 set visibility private instead of internal for _claim and _setClaimed in RewardDistributor.sol  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L152-L158  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L199  8 delete unused variable in struct Reward  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L17  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/libraries/Common.sol#L9   ThecosomataETH.sol  9 All inputs checks must be executed at the beginning of function in constructor  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L50-L73  constructor(     address _BTRFLY,      address _WETH,     address _TRESUARY,     address _CURVEPOOL ) {     require(_BTRFLY != address(0), “Invalid BTRFLY address”);     require(_WETH != address(0), “Invalid WRTH address”);     require(_TRESUARY != address(0), “Invalid TRESUARY address”);     require(_CURVEPOOL != address(0), “Invalid CURVEPOOL address”);    }  10 set visibility private instead of internal for calculateAmountRequiredLP and addLiquidity  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L113                     
# GAS issues  1. Change the incremental logic from `i++` to `++i` in order to save some opcodes: - [BribeVault.sol#L269](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L269) - [RewardDistributor.sol#L82](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L82) - [RewardDistributor.sol#L103](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L103) - [TokemakBribe.sol#L152](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L152)  2. It's possible to avoid storage access a save gas using `immutable` keyword for the following variables: - [TokemakBribe.sol#L62](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L62)  3. Avoid double events and calls - [TokemakBribe.sol#L156](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L156) `SetProposals` was already emited at line [134](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L134) also `onlyAuthorized`  4. Remove unused code - [setRewardForwarding](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L298-L302) is not used in TokemakBribe.sol  5. Use `type(uint).max` instead of `2**256 - 1` - [ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69)  6. Unneeded `require`, `bytes32.length` is always 32 - [BribeVault.sol#L171-L172](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L171-L172) - [BribeVault.sol#L218-L219](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L218-L219)  
Below are the places where Gas can be saved:  1. bribeVault can be set to immutable at TokemakBribe.sol#L28  2. Instead of using _setupRole function in TokemakBribe.sol#L64 we can directly use _grantRole as done in grantTeamRole function  3. In revokeTeamRole function at TokemakBribe.sol#L98, require(hasRole(TEAM_ROLE, teamMember), "Invalid teamMember"); is not required since this is already checked in _revokeRole function  4. In setProposals function at TokemakBribe.sol#L142, store proposals.length in local variable and use local variable instead at all places in this function  5. In setProposals function at TokemakBribe.sol#L152, use ++i instead of i+=1. Change this in all loops at all contracts (also change i++ to ++i)  6. In depositBribeERC20 function at  TokemakBribe.sol#L222-L223, require(token != address(0), "Invalid token"); and require(amount > 0, "Bribe amount must be greater than 0"); are not required as they are already checked in depositBribeERC20 function of BribeVault.sol#L173-L174  7. The setRewardForwarding function at TokemakBribe.sol#L298 can be declared external  8. In revokeDepositorRole function at BribeVault.sol#L98, require(hasRole(DEPOSITOR_ROLE, depositor), "Invalid depositor"); is not required since this is already checked in _revokeRole function  9. In transferBribes function at BribeVault.sol#L256, store distributions.length in local variable and use this local variable at all places  10. In claim function at RewardDistributor.sol#L79, add a check to revert when require( _claims[i].amount!=0, "Invalid amount")   
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73   # Vulnerability details  ## Impact  Claiming of the ETH native currency requires `token` to be set to `bribeVault`. If the `bribeVault` is modified in `setBribeVault()` then users who have ETH rewards will now be considered to have `ERC20(bribeVault)` tokens. Since `bribeVault` is not an ERC20 token the `transfer()` call will fail and the users will not be able to claim their funds.   ## Recommended Mitigation Steps  Consider removing the functionality to change the `bribeVault` or ensuring all funds have been withdraw i.e. `balanceOf(address(this)) == 0` before changing the `bribeVault`.  
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296   # Vulnerability details  ## Impact In BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.  Tokens that don’t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.    ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296  ## Tools Used Manual code review   ## Recommended Mitigation Steps It's recommended to use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.   
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164   # Vulnerability details  ## Impact In BribeVault.sol,  the depositBribeERC20() function deposits a bribe which is an ERC20 token from the briber to the contract itself and then updates the Bribe structs amount and token address.  The issue is that there is no whitelist of acceptable ERC20 tokens that are allowed to interact with the protocol.  Without a proper white list malicious attacker controlled tokens are able to be introduced into the protocol which should not be allowed.  ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a whitelist mapping of acceptable tokens and require that the token address argument in the depositBribeERC20() function is a whitelisted token allowed to interact with the protocol.   
# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181   # Vulnerability details  ## Impact Use call instead of transfer to send ether. And return value must be checked if sending ether is successful or not. Sending ether with the transfer is no longer recommended. ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ## Tools Used review ## Recommended Mitigation Steps  (bool result, ) = payable(_account).call{value: _amount}(""); require(result, "Failed to send Ether");  
