# Handle  pauliax   # Vulnerability details  ## Impact Slingshot contract does not need a 'receive' function as it is not supposed to receive ETH directly. Executioner has this function too and it needs to receive ETH from the WETH contract. Because it expects only WETH to send the native asset directly, it should check that the msg.sender is actually WETH contract.  ## Recommended Mitigation Steps receive() external payable {   require(msg.sender == wrappedNativeToken, "..."); }   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L76-L79  ```solidity=76 for(uint256 i = 0; i < trades.length; i++) {     // Checks to make sure that module exists and is correct     require(moduleRegistry.isModule(trades[i].moduleAddress), "Slingshot: not a module"); } ```  An external call to `moduleRegistry.isModule()` will be called each time in this for loop. They can be combined into one external call by creating an `moduleRegistry.isModuleBatch(address[] memory _moduleAddresses)` function and call that function instead.  ### Recommendation  Change to:  ```solidity address[] memory moduleAddresses = new address[](trades.length); for(uint256 i = 0; i < trades.length; i++) {     moduleAddresses[i] = trades[i].moduleAddress; } require(moduleRegistry.isModuleBatch(moduleAddresses), "Slingshot: not a module"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L57-L73  ```solidity=57 /// @notice Executes multi-hop trades to get the best result ///         It's up to BE to whitelist tokens /// @param fromToken Start token address /// @param toToken Target token address /// @param fromAmount The initial amount of fromToken to start trading with /// @param trades Array of encoded trades that are atomically executed /// @param finalAmountMin The minimum expected output after all trades have been executed /// @param depricated to be removed function executeTrades(     address fromToken,     address toToken,     uint256 fromAmount,     TradeFormat[] calldata trades,     uint256 finalAmountMin,     address depricated ) external nonReentrant payable {     depricated; ```  `depricated` should be `deprecated`.   
# Handle  WatchPug   # Vulnerability details  1. Use of `uint256` vs `uint`;      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L86      ```solidity=65     function executeTrades(         address fromToken,         address toToken,         uint256 fromAmount,         TradeFormat[] calldata trades,         uint256 finalAmountMin,         address depricated     ) external nonReentrant payable {         depricated;         require(finalAmountMin > 0, "Slingshot: finalAmountMin cannot be zero");         require(trades.length > 0, "Slingshot: trades cannot be empty");         for(uint256 i = 0; i < trades.length; i++) {             // Checks to make sure that module exists and is correct             require(moduleRegistry.isModule(trades[i].moduleAddress), "Slingshot: not a module");         }          uint256 initialBalance = _getTokenBalance(toToken);         _transferFromOrWrap(fromToken, _msgSender(), fromAmount);          executioner.executeTrades(trades);          uint finalBalance;     ```  2. Error message prefixed by the module name.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ApprovalHandler.sol#L14-L17      ```solidity=14     modifier onlySlingshot() {         require(isSlingshot(_msgSender()), "Adminable: not a SLINGSHOT_CONTRACT_ROLE");         _;     }     ```      `ApprovalHandler.sol#onlySlingshot()` The prefix `Adminable` in the error message should be `ApprovalHandler`.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L36-L38      ```solidity=36     function registerSwapModule(address _moduleAddress) public onlyAdmin {         require(!modulesIndex[_moduleAddress], "oops module already exists");         require(ISlingshotModule(_moduleAddress).slingshotPing(), "not a module");     ```      `ModuleRegistry.sol#registerSwapModule()` Error messages are not prefixed.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `ModuleRegistry.sol#registerSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L46-L46  - `ModuleRegistry.sol#unregisterSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L61-L61  - `Executioner.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L34-L34  - `Slingshot.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L75-L76  
# Handle  pmerkleplant   # Vulnerability details  The `setupAdmin` function in `Adminable.sol` uses the `_setupRole` function from OpenZeppelin's `AccessControl.sol`.  This function is marked as deprecated in favor of `AccessControl::_grantRole`.  See [line 21 in Adminable.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L21) and [line 183 in OpenZeppelin's AccessControl.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183)  
# Handle  pmerkleplant   # Vulnerability details  The documentation for the function `appendUint` in `ConcatStrings.sol` is incorrect. It states: "Concat two strings". However, the function concats a string and a uint256.  See: [line 19 in ConcatStrings.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/lib/ConcatStrings.sol#L19)  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Native fund transfers into the executioner contract are only expected from the wrapped token contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(wrappedNativeToken), 'only wrapped native token'); } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The executioner is designed to handle only ERC20-ERC20 token trades by modules. The balancer V2 vault is able to [automatically unwrap the wrapped native token](https://dev.balancer.fi/helpers/using-native-eth#overview). Hence, it is recommended to ensure that the `tokenOut` parameter passed into the `swap()` function is not the sentinel value.  The [sentinel value used is the null address.](https://dev.balancer.fi/helpers/using-native-eth#sentinel-value)  ## Recommended Mitigation Steps  Consider adding the following check in the function.  `require(tokenOut != address(0), 'native token swap not supported');`  
# Handle  TomFrench   # Vulnerability details  ## Impact  Switching to custom errors results in reduced deployment/runtime gas cost + ease of decoding revert message  ## Proof of Concept  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L38  Should any of the calls to individual modules fail an error message of the form "<ERROR> Executioner: swap failed: <STEP>" where ERROR is the underlying error message and STEP displays which trade failed  This requires the inclusion of the `ConcatStrings` library and in order to isolate ERROR, knowledge of the string format is necessary. If instead [custom errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) were used, `ConcatStrings` could be removed which results in reduced deployment + runtime costs along with simplifying the codebase. (see ["Errors in Depth"](https://blog.soliditylang.org/2021/04/21/custom-errors/))  ``` // old require(success, appendString(string(data), appendUint(string("Executioner: swap failed: "), i)));  // new error SwapFailed(uint256 step, bytes errorMessage); // at top of file if (!success) revert SwapFailed(i, data); ```  If this is done the Executioner's error messages can then be decoded with a standard abi decoder giving greater compatibility with other tools (helpful should you want to filter for certain error strings at some point) without them having to understand the format of your error messages.  Example of a decoded error message with arguments https://rinkeby.etherscan.io/tx/0x37004044a0a55cce13e2f1dd1813a5f21531cd875fed87ec23ae193e0bb96876  ## Recommended Mitigation Steps  Replace `ConcatStrings` library with custom errors.  
# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. Navigate to the following code sections.   https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/ApprovalHandler.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Executioner.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L3  ## Tools Used  None  ## Recommended Mitigation Steps  ABI coder v2 is activated by default. It is recommended to delete redundant codes.   From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  
# Handle  TomFrench   # Vulnerability details  ## Impact Increase gas costs on all `onlyAdmin` operations  ## Proof of Concept  The `SLINGSHOT_ADMIN_ROLE` variable is marked as `constant`: https://github.com/code-423n4/2021-10-slingshot/blob/f6e7a0a39e3267bbe3c7fe60d6074cbf54f5750f/contracts/Adminable.sol#L11  This results in the `keccak` operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to `immutable` will only perform hashing on contract deployment which will save gas.  See: https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646  ## Recommended Mitigation Steps  Change the variable to be `immutable` rather than `constant`  
# Handle  pauliax   # Vulnerability details  ## Impact Slingshot contract does not need a 'receive' function as it is not supposed to receive ETH directly. Executioner has this function too and it needs to receive ETH from the WETH contract. Because it expects only WETH to send the native asset directly, it should check that the msg.sender is actually WETH contract.  ## Recommended Mitigation Steps receive() external payable {   require(msg.sender == wrappedNativeToken, "..."); }   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L76-L79  ```solidity=76 for(uint256 i = 0; i < trades.length; i++) {     // Checks to make sure that module exists and is correct     require(moduleRegistry.isModule(trades[i].moduleAddress), "Slingshot: not a module"); } ```  An external call to `moduleRegistry.isModule()` will be called each time in this for loop. They can be combined into one external call by creating an `moduleRegistry.isModuleBatch(address[] memory _moduleAddresses)` function and call that function instead.  ### Recommendation  Change to:  ```solidity address[] memory moduleAddresses = new address[](trades.length); for(uint256 i = 0; i < trades.length; i++) {     moduleAddresses[i] = trades[i].moduleAddress; } require(moduleRegistry.isModuleBatch(moduleAddresses), "Slingshot: not a module"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L57-L73  ```solidity=57 /// @notice Executes multi-hop trades to get the best result ///         It's up to BE to whitelist tokens /// @param fromToken Start token address /// @param toToken Target token address /// @param fromAmount The initial amount of fromToken to start trading with /// @param trades Array of encoded trades that are atomically executed /// @param finalAmountMin The minimum expected output after all trades have been executed /// @param depricated to be removed function executeTrades(     address fromToken,     address toToken,     uint256 fromAmount,     TradeFormat[] calldata trades,     uint256 finalAmountMin,     address depricated ) external nonReentrant payable {     depricated; ```  `depricated` should be `deprecated`.   
# Handle  WatchPug   # Vulnerability details  1. Use of `uint256` vs `uint`;      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L86      ```solidity=65     function executeTrades(         address fromToken,         address toToken,         uint256 fromAmount,         TradeFormat[] calldata trades,         uint256 finalAmountMin,         address depricated     ) external nonReentrant payable {         depricated;         require(finalAmountMin > 0, "Slingshot: finalAmountMin cannot be zero");         require(trades.length > 0, "Slingshot: trades cannot be empty");         for(uint256 i = 0; i < trades.length; i++) {             // Checks to make sure that module exists and is correct             require(moduleRegistry.isModule(trades[i].moduleAddress), "Slingshot: not a module");         }          uint256 initialBalance = _getTokenBalance(toToken);         _transferFromOrWrap(fromToken, _msgSender(), fromAmount);          executioner.executeTrades(trades);          uint finalBalance;     ```  2. Error message prefixed by the module name.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ApprovalHandler.sol#L14-L17      ```solidity=14     modifier onlySlingshot() {         require(isSlingshot(_msgSender()), "Adminable: not a SLINGSHOT_CONTRACT_ROLE");         _;     }     ```      `ApprovalHandler.sol#onlySlingshot()` The prefix `Adminable` in the error message should be `ApprovalHandler`.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L36-L38      ```solidity=36     function registerSwapModule(address _moduleAddress) public onlyAdmin {         require(!modulesIndex[_moduleAddress], "oops module already exists");         require(ISlingshotModule(_moduleAddress).slingshotPing(), "not a module");     ```      `ModuleRegistry.sol#registerSwapModule()` Error messages are not prefixed.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `ModuleRegistry.sol#registerSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L46-L46  - `ModuleRegistry.sol#unregisterSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L61-L61  - `Executioner.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L34-L34  - `Slingshot.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L75-L76  
# Handle  pmerkleplant   # Vulnerability details  The `setupAdmin` function in `Adminable.sol` uses the `_setupRole` function from OpenZeppelin's `AccessControl.sol`.  This function is marked as deprecated in favor of `AccessControl::_grantRole`.  See [line 21 in Adminable.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L21) and [line 183 in OpenZeppelin's AccessControl.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183)  
# Handle  pmerkleplant   # Vulnerability details  The documentation for the function `appendUint` in `ConcatStrings.sol` is incorrect. It states: "Concat two strings". However, the function concats a string and a uint256.  See: [line 19 in ConcatStrings.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/lib/ConcatStrings.sol#L19)  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Native fund transfers into the executioner contract are only expected from the wrapped token contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(wrappedNativeToken), 'only wrapped native token'); } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The executioner is designed to handle only ERC20-ERC20 token trades by modules. The balancer V2 vault is able to [automatically unwrap the wrapped native token](https://dev.balancer.fi/helpers/using-native-eth#overview). Hence, it is recommended to ensure that the `tokenOut` parameter passed into the `swap()` function is not the sentinel value.  The [sentinel value used is the null address.](https://dev.balancer.fi/helpers/using-native-eth#sentinel-value)  ## Recommended Mitigation Steps  Consider adding the following check in the function.  `require(tokenOut != address(0), 'native token swap not supported');`  
# Handle  TomFrench   # Vulnerability details  ## Impact  Switching to custom errors results in reduced deployment/runtime gas cost + ease of decoding revert message  ## Proof of Concept  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L38  Should any of the calls to individual modules fail an error message of the form "<ERROR> Executioner: swap failed: <STEP>" where ERROR is the underlying error message and STEP displays which trade failed  This requires the inclusion of the `ConcatStrings` library and in order to isolate ERROR, knowledge of the string format is necessary. If instead [custom errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) were used, `ConcatStrings` could be removed which results in reduced deployment + runtime costs along with simplifying the codebase. (see ["Errors in Depth"](https://blog.soliditylang.org/2021/04/21/custom-errors/))  ``` // old require(success, appendString(string(data), appendUint(string("Executioner: swap failed: "), i)));  // new error SwapFailed(uint256 step, bytes errorMessage); // at top of file if (!success) revert SwapFailed(i, data); ```  If this is done the Executioner's error messages can then be decoded with a standard abi decoder giving greater compatibility with other tools (helpful should you want to filter for certain error strings at some point) without them having to understand the format of your error messages.  Example of a decoded error message with arguments https://rinkeby.etherscan.io/tx/0x37004044a0a55cce13e2f1dd1813a5f21531cd875fed87ec23ae193e0bb96876  ## Recommended Mitigation Steps  Replace `ConcatStrings` library with custom errors.  
# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. Navigate to the following code sections.   https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/ApprovalHandler.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Executioner.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L3  ## Tools Used  None  ## Recommended Mitigation Steps  ABI coder v2 is activated by default. It is recommended to delete redundant codes.   From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  
# Handle  TomFrench   # Vulnerability details  ## Impact Increase gas costs on all `onlyAdmin` operations  ## Proof of Concept  The `SLINGSHOT_ADMIN_ROLE` variable is marked as `constant`: https://github.com/code-423n4/2021-10-slingshot/blob/f6e7a0a39e3267bbe3c7fe60d6074cbf54f5750f/contracts/Adminable.sol#L11  This results in the `keccak` operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to `immutable` will only perform hashing on contract deployment which will save gas.  See: https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646  ## Recommended Mitigation Steps  Change the variable to be `immutable` rather than `constant`  
# Handle  pauliax   # Vulnerability details  ## Impact Slingshot contract does not need a 'receive' function as it is not supposed to receive ETH directly. Executioner has this function too and it needs to receive ETH from the WETH contract. Because it expects only WETH to send the native asset directly, it should check that the msg.sender is actually WETH contract.  ## Recommended Mitigation Steps receive() external payable {   require(msg.sender == wrappedNativeToken, "..."); }   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L76-L79  ```solidity=76 for(uint256 i = 0; i < trades.length; i++) {     // Checks to make sure that module exists and is correct     require(moduleRegistry.isModule(trades[i].moduleAddress), "Slingshot: not a module"); } ```  An external call to `moduleRegistry.isModule()` will be called each time in this for loop. They can be combined into one external call by creating an `moduleRegistry.isModuleBatch(address[] memory _moduleAddresses)` function and call that function instead.  ### Recommendation  Change to:  ```solidity address[] memory moduleAddresses = new address[](trades.length); for(uint256 i = 0; i < trades.length; i++) {     moduleAddresses[i] = trades[i].moduleAddress; } require(moduleRegistry.isModuleBatch(moduleAddresses), "Slingshot: not a module"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L57-L73  ```solidity=57 /// @notice Executes multi-hop trades to get the best result ///         It's up to BE to whitelist tokens /// @param fromToken Start token address /// @param toToken Target token address /// @param fromAmount The initial amount of fromToken to start trading with /// @param trades Array of encoded trades that are atomically executed /// @param finalAmountMin The minimum expected output after all trades have been executed /// @param depricated to be removed function executeTrades(     address fromToken,     address toToken,     uint256 fromAmount,     TradeFormat[] calldata trades,     uint256 finalAmountMin,     address depricated ) external nonReentrant payable {     depricated; ```  `depricated` should be `deprecated`.   
# Handle  WatchPug   # Vulnerability details  1. Use of `uint256` vs `uint`;      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L86      ```solidity=65     function executeTrades(         address fromToken,         address toToken,         uint256 fromAmount,         TradeFormat[] calldata trades,         uint256 finalAmountMin,         address depricated     ) external nonReentrant payable {         depricated;         require(finalAmountMin > 0, "Slingshot: finalAmountMin cannot be zero");         require(trades.length > 0, "Slingshot: trades cannot be empty");         for(uint256 i = 0; i < trades.length; i++) {             // Checks to make sure that module exists and is correct             require(moduleRegistry.isModule(trades[i].moduleAddress), "Slingshot: not a module");         }          uint256 initialBalance = _getTokenBalance(toToken);         _transferFromOrWrap(fromToken, _msgSender(), fromAmount);          executioner.executeTrades(trades);          uint finalBalance;     ```  2. Error message prefixed by the module name.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ApprovalHandler.sol#L14-L17      ```solidity=14     modifier onlySlingshot() {         require(isSlingshot(_msgSender()), "Adminable: not a SLINGSHOT_CONTRACT_ROLE");         _;     }     ```      `ApprovalHandler.sol#onlySlingshot()` The prefix `Adminable` in the error message should be `ApprovalHandler`.      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L36-L38      ```solidity=36     function registerSwapModule(address _moduleAddress) public onlyAdmin {         require(!modulesIndex[_moduleAddress], "oops module already exists");         require(ISlingshotModule(_moduleAddress).slingshotPing(), "not a module");     ```      `ModuleRegistry.sol#registerSwapModule()` Error messages are not prefixed.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `ModuleRegistry.sol#registerSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L46-L46  - `ModuleRegistry.sol#unregisterSwapModuleBatch()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/ModuleRegistry.sol#L61-L61  - `Executioner.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L34-L34  - `Slingshot.sol#executeTrades()`      https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L75-L76  
# Handle  pmerkleplant   # Vulnerability details  The `setupAdmin` function in `Adminable.sol` uses the `_setupRole` function from OpenZeppelin's `AccessControl.sol`.  This function is marked as deprecated in favor of `AccessControl::_grantRole`.  See [line 21 in Adminable.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L21) and [line 183 in OpenZeppelin's AccessControl.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183)  
# Handle  pmerkleplant   # Vulnerability details  The documentation for the function `appendUint` in `ConcatStrings.sol` is incorrect. It states: "Concat two strings". However, the function concats a string and a uint256.  See: [line 19 in ConcatStrings.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/lib/ConcatStrings.sol#L19)  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Native fund transfers into the executioner contract are only expected from the wrapped token contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(wrappedNativeToken), 'only wrapped native token'); } ```  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The executioner is designed to handle only ERC20-ERC20 token trades by modules. The balancer V2 vault is able to [automatically unwrap the wrapped native token](https://dev.balancer.fi/helpers/using-native-eth#overview). Hence, it is recommended to ensure that the `tokenOut` parameter passed into the `swap()` function is not the sentinel value.  The [sentinel value used is the null address.](https://dev.balancer.fi/helpers/using-native-eth#sentinel-value)  ## Recommended Mitigation Steps  Consider adding the following check in the function.  `require(tokenOut != address(0), 'native token swap not supported');`  
# Handle  TomFrench   # Vulnerability details  ## Impact  Switching to custom errors results in reduced deployment/runtime gas cost + ease of decoding revert message  ## Proof of Concept  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L38  Should any of the calls to individual modules fail an error message of the form "<ERROR> Executioner: swap failed: <STEP>" where ERROR is the underlying error message and STEP displays which trade failed  This requires the inclusion of the `ConcatStrings` library and in order to isolate ERROR, knowledge of the string format is necessary. If instead [custom errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) were used, `ConcatStrings` could be removed which results in reduced deployment + runtime costs along with simplifying the codebase. (see ["Errors in Depth"](https://blog.soliditylang.org/2021/04/21/custom-errors/))  ``` // old require(success, appendString(string(data), appendUint(string("Executioner: swap failed: "), i)));  // new error SwapFailed(uint256 step, bytes errorMessage); // at top of file if (!success) revert SwapFailed(i, data); ```  If this is done the Executioner's error messages can then be decoded with a standard abi decoder giving greater compatibility with other tools (helpful should you want to filter for certain error strings at some point) without them having to understand the format of your error messages.  Example of a decoded error message with arguments https://rinkeby.etherscan.io/tx/0x37004044a0a55cce13e2f1dd1813a5f21531cd875fed87ec23ae193e0bb96876  ## Recommended Mitigation Steps  Replace `ConcatStrings` library with custom errors.  
# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. Navigate to the following code sections.   https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/ApprovalHandler.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Executioner.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L3  ## Tools Used  None  ## Recommended Mitigation Steps  ABI coder v2 is activated by default. It is recommended to delete redundant codes.   From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  
# Handle  TomFrench   # Vulnerability details  ## Impact Increase gas costs on all `onlyAdmin` operations  ## Proof of Concept  The `SLINGSHOT_ADMIN_ROLE` variable is marked as `constant`: https://github.com/code-423n4/2021-10-slingshot/blob/f6e7a0a39e3267bbe3c7fe60d6074cbf54f5750f/contracts/Adminable.sol#L11  This results in the `keccak` operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to `immutable` will only perform hashing on contract deployment which will save gas.  See: https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646  ## Recommended Mitigation Steps  Change the variable to be `immutable` rather than `constant`  
