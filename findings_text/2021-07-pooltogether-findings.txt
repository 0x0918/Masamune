# Handle  pauliax   # Vulnerability details  ## Impact Consider adding functions in SwappableYieldSource to supply/redeem the whole balance of the user, so users will not need to pass an exact amount in case they want to fully join/exit the pool.  Also, you can consider joining the BoostedVault for some extra rewards, however, I think then funds will need to be locked for some time for the rewards to start accruing.   
# Handle  pauliax   # Vulnerability details  ## Impact function supplyTokenTo should check that mAssetAmount and creditsIssued > 0 and to != address(0) or if empty to address is provided, it can replace it with msg.sender to prevent potential burn of funds. function redeemToken should check that mAssetAmount and creditsBurned > 0. function transferERC20 should similarly validate erc20Token, to and amount parameters. function _mintShares requires that shares > 0, while _burnShares lacks such requirement.   
# Handle  pauliax   # Vulnerability details  ## Impact Tokens sent directly to the MStableYieldSource will be stuck forever. Consider adding a function that allows an admin to retrieve stuck tokens: * Balance of mAsset - total deposited amount of mAsset; * Similar with credit balances as credits are issued as a separate erc20 token. * All the other tokens.  
# Handle  hrkrshnn   # Vulnerability details  ## Incorrect comment  [Context](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L47)  ``` diff modified   contracts/MStableYieldSource.sol @@ -44,7 +44,7 @@ contract MStableYieldSource is IYieldSource, ReentrancyGuard {       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {          // As immutable storage variables can not be accessed in the constructor, -        // create in-memory variables that can be used instead. +        // create in-stack variables that can be used instead.          IERC20 mAssetMemory = IERC20(_savings.underlying());           // infinite approve Savings Contract to transfer mAssets from this contract ```  The comment and therefore the variable name aren't accurate. The value would be in stack, and not memory.  However, this doesn't affect the code in any way.   
# Handle  hrkrshnn   # Vulnerability details  ## Use 0.8.4  The version 0.8.4 includes an important low level inliner that can save gas. Upgrading `MStableYieldSource.sol` from 0.8.2 to 0.8.4 should improve gas.   
# Handle  cmichel   # Vulnerability details  The `SwappableYieldSource.swapYieldSource` function receives a `_newYieldSource` as a parameter and reads a `_currentYieldSource` from storage. A single storage read should therefore be enough for the entire function and sub-calls.  However, the `_transferFunds` function reads the new yield source from storage again, performing a second storage read. This can be optimized by `_transferFunds` taking an `oldYieldSource` and `newYieldSource` as parameters instead.   
# Handle  cmichel   # Vulnerability details  The `_requireYieldSource` function performs a low-level status code and parses the return data even if the call failed as it does not check the first return value (`success`). It could be the case that non-zero data is returned even though the call failed, and the function would return `true`.  Check the return value or perform a high-level call using the `_yieldSource` interface.  
# Handle  shw   # Vulnerability details  ## Impact  In general, if not called by the contract itself, public functions can be declared as `external` to save gas.  ## Proof of Concept  Referenced code: [MStableYieldSource.sol#L61](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61) [MStableYieldSource.sol#L69](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L69) [SwappableYieldSource.sol#L67](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L67) [SwappableYieldSource.sol#L98](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98) [SwappableYieldSource.sol#L219](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L219)  ## Recommended Mitigation Steps  Change `public` to `external` in the referenced functions.  
# Handle  shw   # Vulnerability details  ## Impact  Changing the `abi.encode` function to `abi.encodePacked` at line 77 of `SwappableYieldSource` can save gas since the `abi.encode` function pads extra null bytes at the end of the call data, which is unnecessary. Also, in general, `abi.encodePacked` is more gas-efficient.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L77](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L77)  [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked` at line 77.  
# Handle  shw   # Vulnerability details  ## Impact  The `supplyTokenTo` function of `SwappableYieldSource` assumes that `amount` of `_depositToken` is transferred to itself after calling the `safeTransferFrom` function (and thus it supplies `amount` of token to the yield source). However, this may not be true if the `_depositToken` is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L211-L212](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L211-L212)  ## Recommended Mitigation Steps  Get the actual received amount by calculating the difference of token balance before and after the transfer. For example, re-writing line 211-212 to:  ```solidity uint256 balanceBefore = _depositToken.balanceOf(address(this)); _depositToken.safeTransferFrom(msg.sender, address(this), amount); uint256 receivedAmount = _depositToken.balanceOf(address(this)) - balanceBefore; yieldSource.supplyTokenTo(receivedAmount, address(this)); ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as 1) Deprecated because of approve-like race condition and 2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.  The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L60-L65  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L51  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L135-L143  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L37-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use logic similar to SwappableYieldSource instead of using safeApprove().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Overly permissive access control to lets anyone approve max amount. This may be ok but is inconsistent with SwappableYieldSource.sol where the similar function is onlyOwner.   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61-L65  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L133-L135   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check requirements/spec and ensure this is ok or else add Ownable inheritance to enforce onlyOwner for this function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks as input validation closest to the function beginning is a best-practice. There are two places where an explicit zero-address check is missing which may lead to a later revert, gas wastage or even token burn.  ## Proof of Concept  1. Explicit zero-address check is missing here for _newYieldSource  and will revert later down the control flow on L256: https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L269  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L256   2. Missing zero-address check on ‘to’ address will lead to token burn because imBalances accounts it for the zero-address from which it can never be redeemed using msg.sender: https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L85  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L94   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add explicit zero-address checks closest to the function entry.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In redeemToken(), given that mAssetBalanceAfter will always be >= mAssetBalanceBefore, using the unchecked directive (solc 0.8.2 has default overflow/underflow checks) on L106 can save bit of gas from the unnecessary (in this case) internal underflow checks on the subtraction.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L2  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L106  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L100-L106  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change to unchecked {mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;}  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The zero-address check on owner is present even in transferOwnership() which makes it redundant.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L110   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/access/OwnableUpgradeable.sol#L68  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove explicit check to rely on the one in transferOwnership().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Assuming the initialize() function is going to be called from a deployment script, its visibility can be made external.   For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function’s parameters are not copied into memory and are instead read from calldata directly.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98-L104   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change visibility to external.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `transferFunds()` will transfer funds from a specified yield source `_yieldSource` to the current yield source set in the contract `_currentYieldSource`. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  ### Proof of Concept  Assumptions:  - `_yieldSource` has a deposit token of WETH (18 decimals) - `_currentYieldSource` has a deposit token of DAI (18 decimals) - 1 WETH > 1 DAI (definitely true, I'd be really sad otherwise)  Attacker does the following:  1. Deposit 100 DAI into the swappable yield source contract 2. Call `transferFunds(_yieldSource, 100 * 1e18)`     - `_requireDifferentYieldSource()` passes     - `_transferFunds(_yieldSource, 100 * 1e18)` is called         - `_yieldSource.redeemToken(_amount);` → This will transfer 100 WETH out of the `_yieldSource` into the contract         - `uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));` → This will equate to ≥ 100 WETH.         - `require(_amount <= currentBalance, "SwappableYieldSource/transfer-amount-different");` is true since both are `100 * 1e18`         - `_currentYieldSource.supplyTokenTo(currentBalance, address(this));` → This supplies the transferred 100 DAI from step 1 to the current yield source     - We now have 100 WETH in the swappable yield source contract 3. Call `transferERC20(WETH, attackerAddress, 100 * 1e18)` to withdraw 100 WETH out of the contract to the attacker's desired address.   ### Recommended Mitigation Steps  `_requireDifferentYieldSource()` should also verify that the yield sources' deposit token addresses are the same.  ```jsx function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(yieldSource), "SwappableYieldSource/same-yield-source");   require(_newYieldSource.depositToken() == yieldSource.depositToken(), "SwappableYieldSource/different-deposit-token"); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `FundsTransferred()` event in `_transferFunds()` will report a smaller amount than expected if `currentBalance > _amount`.  This would affect applications utilizing event logs like subgraphs.  ### Recommended Mitigation Steps  Update the event emission to `emit FundsTransferred(_yieldSource, currentBalance);`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Assuming that `depositToken` of a yield source doesn't change, it would make sense to save its value as a storage variable in the contract as well, so that an external call to `yieldSource` to retrieve it can be avoided whenever it is needed.  ### Recommended Mitigation Steps  Define `address public override depositToken;` or `IERC20Upgradeable public depositToken;` which gets initialized in the `initialize()` function. The nice thing is that it also doesn't need to be updated when swapping sources because a requirement is that the new yield source must have the same deposit token.  As an optimization, since the `_requireYieldSource()` function already retrieves the `depositToken` address, it can return it so that its value need not be externally retrieved again in the `initialize()` function.  The `depositToken()` function can be removed if the former suggestion is implemented (ie. `address public override depositToken`).  Then, `yieldSource.depositToken()` can be replaced with `depositToken` where applicable (with appropriate casting).  A part of the former implementation is provided below.  ```jsx address public override depositToken;  function initialize(...) {  address depositTokenAddress = _requireYieldSource(_yieldSource);  yieldSource = _yieldSource;   depositToken = depositTokenAddress;  ...  IERC20Upgradeable(depositTokenAddress).safeApprove(address(_yieldSource), type(uint256).max); }  function _requireYieldSource(IYieldSource _yieldSource) internal view returns (address depositTokenAddress) {  ...  (depositTokenAddress) = abi.decode(depositTokenAddressData, (address)); }  // function depositToken() can be removed // yieldSource.depositToken() can be replaced with depositToken in other functions // Example: _setYieldSource function _setYieldSource(IYieldSource _newYieldSource) internal {  _requireDifferentYieldSource(_newYieldSource);  // Commented out check below should be shifted to inside _requireDifferentYieldSource()  // Optimization: it can also return depositToken to avoid another SLOAD  // similar to _requireYieldSource() above  // require(_newYieldSource.depositToken() == depositToken, "SwappableYieldSource/different-deposit-token");    yieldSource = _newYieldSource;   IERC20Upgradeable(depositToken).safeApprove(address(_newYieldSource), type(uint256).max);    emit SwappableYieldSourceSet(_newYieldSource); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The immutable `mAsset` is assigned to the immutable `savings` contract. Hence, we can avoid an external function call to the savings contract in the `approveMax` function by replacing it with `mAsset`.   ### Recommended Mitigation Steps  ```jsx function approveMax() public {  mAsset.safeApprove(address(savings), type(uint256).max);   emit ApprovedMax(msg.sender); } ```  
# Handle  JMukesh   # Vulnerability details  ## Impact Since  immutable state variable cant be change after initialization in constructor, their value should be checked before initialization       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {             // @audit --> there should be a input validation          // As immutable storage variables can not be accessed in the constructor,         // create in-memory variables that can be used instead.         IERC20 mAssetMemory = IERC20(_savings.underlying());          // infinite approve Savings Contract to transfer mAssets from this contract         mAssetMemory.safeApprove(address(_savings), type(uint256).max);          // save to immutable storage         savings = _savings;         mAsset = mAssetMemory;          emit Initialized(_savings);     }   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L45  ## Tools Used no tool used  ## Recommended Mitigation Steps add a require condition to validate input values  
# Handle  maplesyrup   # Vulnerability details  ## Impact  This is a gas optimization, does not affect the contract negatively, only optimizes it.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), functions that are never called within the contract should be declared as external to save gas for the contract.  In this case, there were only 2 functions in the contract that were found that should be declared as external for further gas optimization.  -----------  Code Snippet:  function approveMax() public {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #61-65)  function depositToken() public view override returns (address underlyingMasset) {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #69-71)   ------------  Console output:  INFO:Detectors: approveMax() should be declared external:  - MStableYieldSource.approveMax() (contracts/yield-source/MStableYieldSource.sol#61-65) depositToken() should be declared external:  - MStableYieldSource.depositToken() (contracts/yield-source/MStableYieldSource.sol#69-71) Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external  ## Tools Used  PoolTogether Contracts Solidity (v 0.7.4) Hardhat (v 2.5.0) Yarn (v 1.22.10) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for PoolTogether Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts via artifacts  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _requireYieldSource of the contract SwappableYieldSource has a state variable: isInvalidYieldSource  You would expect isInvalidYieldSource == true would mean the yield source in invalid However in the source code  isInvalidYieldSource == true mean the yield source is valid.  This is confusing for readers and future maintainers. Future maintainers could easily make a mistake and thus introduce vulnerabilities.  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol#L74 function _requireYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(0), "SwappableYieldSource/yieldSource-not-zero-address");     (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));     bool isInvalidYieldSource;     if (depositTokenAddressData.length > 0) {       (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));       isInvalidYieldSource = depositTokenAddress != address(0);     }     require(isInvalidYieldSource, "SwappableYieldSource/invalid-yield-source");   }  ## Tools Used  ## Recommended Mitigation Steps Change isInvalidYieldSource to isValidYieldSource   
# Handle  gpersoon   # Vulnerability details  ## Impact The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.  The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.  More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).  It is possible to make use of this problem in the following way: - monitor the blockchain until you see setYieldSource has been done - immediately call the function supplyTokenTo (which can be called because there is no access control on this function)  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {     _setYieldSource(_newYieldSource);    function _setYieldSource(IYieldSource _newYieldSource) internal { ..     yieldSource = _newYieldSource;   function supplyTokenTo(uint256 amount, address to) external override nonReentrant {    ..     yieldSource.supplyTokenTo(amount, address(this));     _mintShares(amount, to);   }   function _mintShares(uint256 mintAmount, address to) internal {     uint256 shares = _tokenToShares(mintAmount);     require(shares > 0, "SwappableYieldSource/shares-gt-zero");     _mint(to, shares);   }   function _tokenToShares(uint256 tokens) internal returns (uint256) {     uint256 shares;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))       shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);     function balanceOfToken(address addr) external override returns (uint256) {     return _sharesToToken(balanceOf(addr));   }   function _sharesToToken(uint256 shares) internal returns (uint256) {     uint256 tokens;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))       tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);  ## Tools Used  ## Recommended Mitigation Steps Remove the function setYieldSource  (e.g. only leave swapYieldSource) Or temporally disable actions like supplyTokenTo, redeemToken and balanceOfToken, after setYieldSource and until transferFunds has been done  
# Handle  tensors   # Vulnerability details  ## Impact After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L268  ## Recommended Mitigation Steps Decrease approval after swapping the yield source.  
# Handle  tensors   # Vulnerability details  ## Impact There are a few tokens out there that do not use any decimals. As far as I know none of them would be a good yield source, but just in case something comes out, you may want to include the possibility that decimals = 0.  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L116  ## Recommended Mitigation Steps Remove the require statement.   
# Handle  tensors   # Vulnerability details  ## Impact The sponsored event is declared but never used.  ## Proof of Concept https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L27  ## Recommended Mitigation Steps Remove the unused event.  
# Handle  pauliax   # Vulnerability details  ## Impact Consider adding functions in SwappableYieldSource to supply/redeem the whole balance of the user, so users will not need to pass an exact amount in case they want to fully join/exit the pool.  Also, you can consider joining the BoostedVault for some extra rewards, however, I think then funds will need to be locked for some time for the rewards to start accruing.   
# Handle  pauliax   # Vulnerability details  ## Impact function supplyTokenTo should check that mAssetAmount and creditsIssued > 0 and to != address(0) or if empty to address is provided, it can replace it with msg.sender to prevent potential burn of funds. function redeemToken should check that mAssetAmount and creditsBurned > 0. function transferERC20 should similarly validate erc20Token, to and amount parameters. function _mintShares requires that shares > 0, while _burnShares lacks such requirement.   
# Handle  pauliax   # Vulnerability details  ## Impact Tokens sent directly to the MStableYieldSource will be stuck forever. Consider adding a function that allows an admin to retrieve stuck tokens: * Balance of mAsset - total deposited amount of mAsset; * Similar with credit balances as credits are issued as a separate erc20 token. * All the other tokens.  
# Handle  hrkrshnn   # Vulnerability details  ## Incorrect comment  [Context](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L47)  ``` diff modified   contracts/MStableYieldSource.sol @@ -44,7 +44,7 @@ contract MStableYieldSource is IYieldSource, ReentrancyGuard {       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {          // As immutable storage variables can not be accessed in the constructor, -        // create in-memory variables that can be used instead. +        // create in-stack variables that can be used instead.          IERC20 mAssetMemory = IERC20(_savings.underlying());           // infinite approve Savings Contract to transfer mAssets from this contract ```  The comment and therefore the variable name aren't accurate. The value would be in stack, and not memory.  However, this doesn't affect the code in any way.   
# Handle  hrkrshnn   # Vulnerability details  ## Use 0.8.4  The version 0.8.4 includes an important low level inliner that can save gas. Upgrading `MStableYieldSource.sol` from 0.8.2 to 0.8.4 should improve gas.   
# Handle  cmichel   # Vulnerability details  The `SwappableYieldSource.swapYieldSource` function receives a `_newYieldSource` as a parameter and reads a `_currentYieldSource` from storage. A single storage read should therefore be enough for the entire function and sub-calls.  However, the `_transferFunds` function reads the new yield source from storage again, performing a second storage read. This can be optimized by `_transferFunds` taking an `oldYieldSource` and `newYieldSource` as parameters instead.   
# Handle  cmichel   # Vulnerability details  The `_requireYieldSource` function performs a low-level status code and parses the return data even if the call failed as it does not check the first return value (`success`). It could be the case that non-zero data is returned even though the call failed, and the function would return `true`.  Check the return value or perform a high-level call using the `_yieldSource` interface.  
# Handle  shw   # Vulnerability details  ## Impact  In general, if not called by the contract itself, public functions can be declared as `external` to save gas.  ## Proof of Concept  Referenced code: [MStableYieldSource.sol#L61](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61) [MStableYieldSource.sol#L69](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L69) [SwappableYieldSource.sol#L67](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L67) [SwappableYieldSource.sol#L98](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98) [SwappableYieldSource.sol#L219](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L219)  ## Recommended Mitigation Steps  Change `public` to `external` in the referenced functions.  
# Handle  shw   # Vulnerability details  ## Impact  Changing the `abi.encode` function to `abi.encodePacked` at line 77 of `SwappableYieldSource` can save gas since the `abi.encode` function pads extra null bytes at the end of the call data, which is unnecessary. Also, in general, `abi.encodePacked` is more gas-efficient.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L77](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L77)  [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked` at line 77.  
# Handle  shw   # Vulnerability details  ## Impact  The `supplyTokenTo` function of `SwappableYieldSource` assumes that `amount` of `_depositToken` is transferred to itself after calling the `safeTransferFrom` function (and thus it supplies `amount` of token to the yield source). However, this may not be true if the `_depositToken` is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L211-L212](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L211-L212)  ## Recommended Mitigation Steps  Get the actual received amount by calculating the difference of token balance before and after the transfer. For example, re-writing line 211-212 to:  ```solidity uint256 balanceBefore = _depositToken.balanceOf(address(this)); _depositToken.safeTransferFrom(msg.sender, address(this), amount); uint256 receivedAmount = _depositToken.balanceOf(address(this)) - balanceBefore; yieldSource.supplyTokenTo(receivedAmount, address(this)); ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as 1) Deprecated because of approve-like race condition and 2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.  The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L60-L65  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L51  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L135-L143  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L37-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use logic similar to SwappableYieldSource instead of using safeApprove().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Overly permissive access control to lets anyone approve max amount. This may be ok but is inconsistent with SwappableYieldSource.sol where the similar function is onlyOwner.   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61-L65  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L133-L135   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check requirements/spec and ensure this is ok or else add Ownable inheritance to enforce onlyOwner for this function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks as input validation closest to the function beginning is a best-practice. There are two places where an explicit zero-address check is missing which may lead to a later revert, gas wastage or even token burn.  ## Proof of Concept  1. Explicit zero-address check is missing here for _newYieldSource  and will revert later down the control flow on L256: https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L269  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L256   2. Missing zero-address check on ‘to’ address will lead to token burn because imBalances accounts it for the zero-address from which it can never be redeemed using msg.sender: https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L85  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L94   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add explicit zero-address checks closest to the function entry.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In redeemToken(), given that mAssetBalanceAfter will always be >= mAssetBalanceBefore, using the unchecked directive (solc 0.8.2 has default overflow/underflow checks) on L106 can save bit of gas from the unnecessary (in this case) internal underflow checks on the subtraction.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L2  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L106  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L100-L106  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change to unchecked {mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;}  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The zero-address check on owner is present even in transferOwnership() which makes it redundant.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L110   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/access/OwnableUpgradeable.sol#L68  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove explicit check to rely on the one in transferOwnership().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Assuming the initialize() function is going to be called from a deployment script, its visibility can be made external.   For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function’s parameters are not copied into memory and are instead read from calldata directly.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98-L104   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change visibility to external.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `transferFunds()` will transfer funds from a specified yield source `_yieldSource` to the current yield source set in the contract `_currentYieldSource`. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  ### Proof of Concept  Assumptions:  - `_yieldSource` has a deposit token of WETH (18 decimals) - `_currentYieldSource` has a deposit token of DAI (18 decimals) - 1 WETH > 1 DAI (definitely true, I'd be really sad otherwise)  Attacker does the following:  1. Deposit 100 DAI into the swappable yield source contract 2. Call `transferFunds(_yieldSource, 100 * 1e18)`     - `_requireDifferentYieldSource()` passes     - `_transferFunds(_yieldSource, 100 * 1e18)` is called         - `_yieldSource.redeemToken(_amount);` → This will transfer 100 WETH out of the `_yieldSource` into the contract         - `uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));` → This will equate to ≥ 100 WETH.         - `require(_amount <= currentBalance, "SwappableYieldSource/transfer-amount-different");` is true since both are `100 * 1e18`         - `_currentYieldSource.supplyTokenTo(currentBalance, address(this));` → This supplies the transferred 100 DAI from step 1 to the current yield source     - We now have 100 WETH in the swappable yield source contract 3. Call `transferERC20(WETH, attackerAddress, 100 * 1e18)` to withdraw 100 WETH out of the contract to the attacker's desired address.   ### Recommended Mitigation Steps  `_requireDifferentYieldSource()` should also verify that the yield sources' deposit token addresses are the same.  ```jsx function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(yieldSource), "SwappableYieldSource/same-yield-source");   require(_newYieldSource.depositToken() == yieldSource.depositToken(), "SwappableYieldSource/different-deposit-token"); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `FundsTransferred()` event in `_transferFunds()` will report a smaller amount than expected if `currentBalance > _amount`.  This would affect applications utilizing event logs like subgraphs.  ### Recommended Mitigation Steps  Update the event emission to `emit FundsTransferred(_yieldSource, currentBalance);`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Assuming that `depositToken` of a yield source doesn't change, it would make sense to save its value as a storage variable in the contract as well, so that an external call to `yieldSource` to retrieve it can be avoided whenever it is needed.  ### Recommended Mitigation Steps  Define `address public override depositToken;` or `IERC20Upgradeable public depositToken;` which gets initialized in the `initialize()` function. The nice thing is that it also doesn't need to be updated when swapping sources because a requirement is that the new yield source must have the same deposit token.  As an optimization, since the `_requireYieldSource()` function already retrieves the `depositToken` address, it can return it so that its value need not be externally retrieved again in the `initialize()` function.  The `depositToken()` function can be removed if the former suggestion is implemented (ie. `address public override depositToken`).  Then, `yieldSource.depositToken()` can be replaced with `depositToken` where applicable (with appropriate casting).  A part of the former implementation is provided below.  ```jsx address public override depositToken;  function initialize(...) {  address depositTokenAddress = _requireYieldSource(_yieldSource);  yieldSource = _yieldSource;   depositToken = depositTokenAddress;  ...  IERC20Upgradeable(depositTokenAddress).safeApprove(address(_yieldSource), type(uint256).max); }  function _requireYieldSource(IYieldSource _yieldSource) internal view returns (address depositTokenAddress) {  ...  (depositTokenAddress) = abi.decode(depositTokenAddressData, (address)); }  // function depositToken() can be removed // yieldSource.depositToken() can be replaced with depositToken in other functions // Example: _setYieldSource function _setYieldSource(IYieldSource _newYieldSource) internal {  _requireDifferentYieldSource(_newYieldSource);  // Commented out check below should be shifted to inside _requireDifferentYieldSource()  // Optimization: it can also return depositToken to avoid another SLOAD  // similar to _requireYieldSource() above  // require(_newYieldSource.depositToken() == depositToken, "SwappableYieldSource/different-deposit-token");    yieldSource = _newYieldSource;   IERC20Upgradeable(depositToken).safeApprove(address(_newYieldSource), type(uint256).max);    emit SwappableYieldSourceSet(_newYieldSource); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The immutable `mAsset` is assigned to the immutable `savings` contract. Hence, we can avoid an external function call to the savings contract in the `approveMax` function by replacing it with `mAsset`.   ### Recommended Mitigation Steps  ```jsx function approveMax() public {  mAsset.safeApprove(address(savings), type(uint256).max);   emit ApprovedMax(msg.sender); } ```  
# Handle  JMukesh   # Vulnerability details  ## Impact Since  immutable state variable cant be change after initialization in constructor, their value should be checked before initialization       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {             // @audit --> there should be a input validation          // As immutable storage variables can not be accessed in the constructor,         // create in-memory variables that can be used instead.         IERC20 mAssetMemory = IERC20(_savings.underlying());          // infinite approve Savings Contract to transfer mAssets from this contract         mAssetMemory.safeApprove(address(_savings), type(uint256).max);          // save to immutable storage         savings = _savings;         mAsset = mAssetMemory;          emit Initialized(_savings);     }   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L45  ## Tools Used no tool used  ## Recommended Mitigation Steps add a require condition to validate input values  
# Handle  maplesyrup   # Vulnerability details  ## Impact  This is a gas optimization, does not affect the contract negatively, only optimizes it.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), functions that are never called within the contract should be declared as external to save gas for the contract.  In this case, there were only 2 functions in the contract that were found that should be declared as external for further gas optimization.  -----------  Code Snippet:  function approveMax() public {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #61-65)  function depositToken() public view override returns (address underlyingMasset) {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #69-71)   ------------  Console output:  INFO:Detectors: approveMax() should be declared external:  - MStableYieldSource.approveMax() (contracts/yield-source/MStableYieldSource.sol#61-65) depositToken() should be declared external:  - MStableYieldSource.depositToken() (contracts/yield-source/MStableYieldSource.sol#69-71) Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external  ## Tools Used  PoolTogether Contracts Solidity (v 0.7.4) Hardhat (v 2.5.0) Yarn (v 1.22.10) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for PoolTogether Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts via artifacts  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _requireYieldSource of the contract SwappableYieldSource has a state variable: isInvalidYieldSource  You would expect isInvalidYieldSource == true would mean the yield source in invalid However in the source code  isInvalidYieldSource == true mean the yield source is valid.  This is confusing for readers and future maintainers. Future maintainers could easily make a mistake and thus introduce vulnerabilities.  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol#L74 function _requireYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(0), "SwappableYieldSource/yieldSource-not-zero-address");     (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));     bool isInvalidYieldSource;     if (depositTokenAddressData.length > 0) {       (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));       isInvalidYieldSource = depositTokenAddress != address(0);     }     require(isInvalidYieldSource, "SwappableYieldSource/invalid-yield-source");   }  ## Tools Used  ## Recommended Mitigation Steps Change isInvalidYieldSource to isValidYieldSource   
# Handle  gpersoon   # Vulnerability details  ## Impact The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.  The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.  More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).  It is possible to make use of this problem in the following way: - monitor the blockchain until you see setYieldSource has been done - immediately call the function supplyTokenTo (which can be called because there is no access control on this function)  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {     _setYieldSource(_newYieldSource);    function _setYieldSource(IYieldSource _newYieldSource) internal { ..     yieldSource = _newYieldSource;   function supplyTokenTo(uint256 amount, address to) external override nonReentrant {    ..     yieldSource.supplyTokenTo(amount, address(this));     _mintShares(amount, to);   }   function _mintShares(uint256 mintAmount, address to) internal {     uint256 shares = _tokenToShares(mintAmount);     require(shares > 0, "SwappableYieldSource/shares-gt-zero");     _mint(to, shares);   }   function _tokenToShares(uint256 tokens) internal returns (uint256) {     uint256 shares;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))       shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);     function balanceOfToken(address addr) external override returns (uint256) {     return _sharesToToken(balanceOf(addr));   }   function _sharesToToken(uint256 shares) internal returns (uint256) {     uint256 tokens;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))       tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);  ## Tools Used  ## Recommended Mitigation Steps Remove the function setYieldSource  (e.g. only leave swapYieldSource) Or temporally disable actions like supplyTokenTo, redeemToken and balanceOfToken, after setYieldSource and until transferFunds has been done  
# Handle  tensors   # Vulnerability details  ## Impact After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L268  ## Recommended Mitigation Steps Decrease approval after swapping the yield source.  
# Handle  tensors   # Vulnerability details  ## Impact There are a few tokens out there that do not use any decimals. As far as I know none of them would be a good yield source, but just in case something comes out, you may want to include the possibility that decimals = 0.  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L116  ## Recommended Mitigation Steps Remove the require statement.   
# Handle  tensors   # Vulnerability details  ## Impact The sponsored event is declared but never used.  ## Proof of Concept https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L27  ## Recommended Mitigation Steps Remove the unused event.  
# Handle  pauliax   # Vulnerability details  ## Impact Consider adding functions in SwappableYieldSource to supply/redeem the whole balance of the user, so users will not need to pass an exact amount in case they want to fully join/exit the pool.  Also, you can consider joining the BoostedVault for some extra rewards, however, I think then funds will need to be locked for some time for the rewards to start accruing.   
# Handle  pauliax   # Vulnerability details  ## Impact function supplyTokenTo should check that mAssetAmount and creditsIssued > 0 and to != address(0) or if empty to address is provided, it can replace it with msg.sender to prevent potential burn of funds. function redeemToken should check that mAssetAmount and creditsBurned > 0. function transferERC20 should similarly validate erc20Token, to and amount parameters. function _mintShares requires that shares > 0, while _burnShares lacks such requirement.   
# Handle  pauliax   # Vulnerability details  ## Impact Tokens sent directly to the MStableYieldSource will be stuck forever. Consider adding a function that allows an admin to retrieve stuck tokens: * Balance of mAsset - total deposited amount of mAsset; * Similar with credit balances as credits are issued as a separate erc20 token. * All the other tokens.  
# Handle  hrkrshnn   # Vulnerability details  ## Incorrect comment  [Context](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L47)  ``` diff modified   contracts/MStableYieldSource.sol @@ -44,7 +44,7 @@ contract MStableYieldSource is IYieldSource, ReentrancyGuard {       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {          // As immutable storage variables can not be accessed in the constructor, -        // create in-memory variables that can be used instead. +        // create in-stack variables that can be used instead.          IERC20 mAssetMemory = IERC20(_savings.underlying());           // infinite approve Savings Contract to transfer mAssets from this contract ```  The comment and therefore the variable name aren't accurate. The value would be in stack, and not memory.  However, this doesn't affect the code in any way.   
# Handle  hrkrshnn   # Vulnerability details  ## Use 0.8.4  The version 0.8.4 includes an important low level inliner that can save gas. Upgrading `MStableYieldSource.sol` from 0.8.2 to 0.8.4 should improve gas.   
# Handle  cmichel   # Vulnerability details  The `SwappableYieldSource.swapYieldSource` function receives a `_newYieldSource` as a parameter and reads a `_currentYieldSource` from storage. A single storage read should therefore be enough for the entire function and sub-calls.  However, the `_transferFunds` function reads the new yield source from storage again, performing a second storage read. This can be optimized by `_transferFunds` taking an `oldYieldSource` and `newYieldSource` as parameters instead.   
# Handle  cmichel   # Vulnerability details  The `_requireYieldSource` function performs a low-level status code and parses the return data even if the call failed as it does not check the first return value (`success`). It could be the case that non-zero data is returned even though the call failed, and the function would return `true`.  Check the return value or perform a high-level call using the `_yieldSource` interface.  
# Handle  shw   # Vulnerability details  ## Impact  In general, if not called by the contract itself, public functions can be declared as `external` to save gas.  ## Proof of Concept  Referenced code: [MStableYieldSource.sol#L61](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61) [MStableYieldSource.sol#L69](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L69) [SwappableYieldSource.sol#L67](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L67) [SwappableYieldSource.sol#L98](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98) [SwappableYieldSource.sol#L219](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L219)  ## Recommended Mitigation Steps  Change `public` to `external` in the referenced functions.  
# Handle  shw   # Vulnerability details  ## Impact  Changing the `abi.encode` function to `abi.encodePacked` at line 77 of `SwappableYieldSource` can save gas since the `abi.encode` function pads extra null bytes at the end of the call data, which is unnecessary. Also, in general, `abi.encodePacked` is more gas-efficient.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L77](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L77)  [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked` at line 77.  
# Handle  shw   # Vulnerability details  ## Impact  The `supplyTokenTo` function of `SwappableYieldSource` assumes that `amount` of `_depositToken` is transferred to itself after calling the `safeTransferFrom` function (and thus it supplies `amount` of token to the yield source). However, this may not be true if the `_depositToken` is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L211-L212](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L211-L212)  ## Recommended Mitigation Steps  Get the actual received amount by calculating the difference of token balance before and after the transfer. For example, re-writing line 211-212 to:  ```solidity uint256 balanceBefore = _depositToken.balanceOf(address(this)); _depositToken.safeTransferFrom(msg.sender, address(this), amount); uint256 receivedAmount = _depositToken.balanceOf(address(this)) - balanceBefore; yieldSource.supplyTokenTo(receivedAmount, address(this)); ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as 1) Deprecated because of approve-like race condition and 2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.  The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L60-L65  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L51  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L135-L143  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L37-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use logic similar to SwappableYieldSource instead of using safeApprove().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Overly permissive access control to lets anyone approve max amount. This may be ok but is inconsistent with SwappableYieldSource.sol where the similar function is onlyOwner.   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61-L65  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L133-L135   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check requirements/spec and ensure this is ok or else add Ownable inheritance to enforce onlyOwner for this function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks as input validation closest to the function beginning is a best-practice. There are two places where an explicit zero-address check is missing which may lead to a later revert, gas wastage or even token burn.  ## Proof of Concept  1. Explicit zero-address check is missing here for _newYieldSource  and will revert later down the control flow on L256: https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L269  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L256   2. Missing zero-address check on ‘to’ address will lead to token burn because imBalances accounts it for the zero-address from which it can never be redeemed using msg.sender: https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L85  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L94   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add explicit zero-address checks closest to the function entry.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In redeemToken(), given that mAssetBalanceAfter will always be >= mAssetBalanceBefore, using the unchecked directive (solc 0.8.2 has default overflow/underflow checks) on L106 can save bit of gas from the unnecessary (in this case) internal underflow checks on the subtraction.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L2  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L106  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L100-L106  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change to unchecked {mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;}  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The zero-address check on owner is present even in transferOwnership() which makes it redundant.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L110   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/access/OwnableUpgradeable.sol#L68  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove explicit check to rely on the one in transferOwnership().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Assuming the initialize() function is going to be called from a deployment script, its visibility can be made external.   For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function’s parameters are not copied into memory and are instead read from calldata directly.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98-L104   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change visibility to external.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `transferFunds()` will transfer funds from a specified yield source `_yieldSource` to the current yield source set in the contract `_currentYieldSource`. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  ### Proof of Concept  Assumptions:  - `_yieldSource` has a deposit token of WETH (18 decimals) - `_currentYieldSource` has a deposit token of DAI (18 decimals) - 1 WETH > 1 DAI (definitely true, I'd be really sad otherwise)  Attacker does the following:  1. Deposit 100 DAI into the swappable yield source contract 2. Call `transferFunds(_yieldSource, 100 * 1e18)`     - `_requireDifferentYieldSource()` passes     - `_transferFunds(_yieldSource, 100 * 1e18)` is called         - `_yieldSource.redeemToken(_amount);` → This will transfer 100 WETH out of the `_yieldSource` into the contract         - `uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));` → This will equate to ≥ 100 WETH.         - `require(_amount <= currentBalance, "SwappableYieldSource/transfer-amount-different");` is true since both are `100 * 1e18`         - `_currentYieldSource.supplyTokenTo(currentBalance, address(this));` → This supplies the transferred 100 DAI from step 1 to the current yield source     - We now have 100 WETH in the swappable yield source contract 3. Call `transferERC20(WETH, attackerAddress, 100 * 1e18)` to withdraw 100 WETH out of the contract to the attacker's desired address.   ### Recommended Mitigation Steps  `_requireDifferentYieldSource()` should also verify that the yield sources' deposit token addresses are the same.  ```jsx function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(yieldSource), "SwappableYieldSource/same-yield-source");   require(_newYieldSource.depositToken() == yieldSource.depositToken(), "SwappableYieldSource/different-deposit-token"); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `FundsTransferred()` event in `_transferFunds()` will report a smaller amount than expected if `currentBalance > _amount`.  This would affect applications utilizing event logs like subgraphs.  ### Recommended Mitigation Steps  Update the event emission to `emit FundsTransferred(_yieldSource, currentBalance);`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Assuming that `depositToken` of a yield source doesn't change, it would make sense to save its value as a storage variable in the contract as well, so that an external call to `yieldSource` to retrieve it can be avoided whenever it is needed.  ### Recommended Mitigation Steps  Define `address public override depositToken;` or `IERC20Upgradeable public depositToken;` which gets initialized in the `initialize()` function. The nice thing is that it also doesn't need to be updated when swapping sources because a requirement is that the new yield source must have the same deposit token.  As an optimization, since the `_requireYieldSource()` function already retrieves the `depositToken` address, it can return it so that its value need not be externally retrieved again in the `initialize()` function.  The `depositToken()` function can be removed if the former suggestion is implemented (ie. `address public override depositToken`).  Then, `yieldSource.depositToken()` can be replaced with `depositToken` where applicable (with appropriate casting).  A part of the former implementation is provided below.  ```jsx address public override depositToken;  function initialize(...) {  address depositTokenAddress = _requireYieldSource(_yieldSource);  yieldSource = _yieldSource;   depositToken = depositTokenAddress;  ...  IERC20Upgradeable(depositTokenAddress).safeApprove(address(_yieldSource), type(uint256).max); }  function _requireYieldSource(IYieldSource _yieldSource) internal view returns (address depositTokenAddress) {  ...  (depositTokenAddress) = abi.decode(depositTokenAddressData, (address)); }  // function depositToken() can be removed // yieldSource.depositToken() can be replaced with depositToken in other functions // Example: _setYieldSource function _setYieldSource(IYieldSource _newYieldSource) internal {  _requireDifferentYieldSource(_newYieldSource);  // Commented out check below should be shifted to inside _requireDifferentYieldSource()  // Optimization: it can also return depositToken to avoid another SLOAD  // similar to _requireYieldSource() above  // require(_newYieldSource.depositToken() == depositToken, "SwappableYieldSource/different-deposit-token");    yieldSource = _newYieldSource;   IERC20Upgradeable(depositToken).safeApprove(address(_newYieldSource), type(uint256).max);    emit SwappableYieldSourceSet(_newYieldSource); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The immutable `mAsset` is assigned to the immutable `savings` contract. Hence, we can avoid an external function call to the savings contract in the `approveMax` function by replacing it with `mAsset`.   ### Recommended Mitigation Steps  ```jsx function approveMax() public {  mAsset.safeApprove(address(savings), type(uint256).max);   emit ApprovedMax(msg.sender); } ```  
# Handle  JMukesh   # Vulnerability details  ## Impact Since  immutable state variable cant be change after initialization in constructor, their value should be checked before initialization       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {             // @audit --> there should be a input validation          // As immutable storage variables can not be accessed in the constructor,         // create in-memory variables that can be used instead.         IERC20 mAssetMemory = IERC20(_savings.underlying());          // infinite approve Savings Contract to transfer mAssets from this contract         mAssetMemory.safeApprove(address(_savings), type(uint256).max);          // save to immutable storage         savings = _savings;         mAsset = mAssetMemory;          emit Initialized(_savings);     }   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L45  ## Tools Used no tool used  ## Recommended Mitigation Steps add a require condition to validate input values  
# Handle  maplesyrup   # Vulnerability details  ## Impact  This is a gas optimization, does not affect the contract negatively, only optimizes it.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), functions that are never called within the contract should be declared as external to save gas for the contract.  In this case, there were only 2 functions in the contract that were found that should be declared as external for further gas optimization.  -----------  Code Snippet:  function approveMax() public {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #61-65)  function depositToken() public view override returns (address underlyingMasset) {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #69-71)   ------------  Console output:  INFO:Detectors: approveMax() should be declared external:  - MStableYieldSource.approveMax() (contracts/yield-source/MStableYieldSource.sol#61-65) depositToken() should be declared external:  - MStableYieldSource.depositToken() (contracts/yield-source/MStableYieldSource.sol#69-71) Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external  ## Tools Used  PoolTogether Contracts Solidity (v 0.7.4) Hardhat (v 2.5.0) Yarn (v 1.22.10) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for PoolTogether Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts via artifacts  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _requireYieldSource of the contract SwappableYieldSource has a state variable: isInvalidYieldSource  You would expect isInvalidYieldSource == true would mean the yield source in invalid However in the source code  isInvalidYieldSource == true mean the yield source is valid.  This is confusing for readers and future maintainers. Future maintainers could easily make a mistake and thus introduce vulnerabilities.  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol#L74 function _requireYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(0), "SwappableYieldSource/yieldSource-not-zero-address");     (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));     bool isInvalidYieldSource;     if (depositTokenAddressData.length > 0) {       (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));       isInvalidYieldSource = depositTokenAddress != address(0);     }     require(isInvalidYieldSource, "SwappableYieldSource/invalid-yield-source");   }  ## Tools Used  ## Recommended Mitigation Steps Change isInvalidYieldSource to isValidYieldSource   
# Handle  gpersoon   # Vulnerability details  ## Impact The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.  The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.  More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).  It is possible to make use of this problem in the following way: - monitor the blockchain until you see setYieldSource has been done - immediately call the function supplyTokenTo (which can be called because there is no access control on this function)  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {     _setYieldSource(_newYieldSource);    function _setYieldSource(IYieldSource _newYieldSource) internal { ..     yieldSource = _newYieldSource;   function supplyTokenTo(uint256 amount, address to) external override nonReentrant {    ..     yieldSource.supplyTokenTo(amount, address(this));     _mintShares(amount, to);   }   function _mintShares(uint256 mintAmount, address to) internal {     uint256 shares = _tokenToShares(mintAmount);     require(shares > 0, "SwappableYieldSource/shares-gt-zero");     _mint(to, shares);   }   function _tokenToShares(uint256 tokens) internal returns (uint256) {     uint256 shares;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))       shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);     function balanceOfToken(address addr) external override returns (uint256) {     return _sharesToToken(balanceOf(addr));   }   function _sharesToToken(uint256 shares) internal returns (uint256) {     uint256 tokens;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))       tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);  ## Tools Used  ## Recommended Mitigation Steps Remove the function setYieldSource  (e.g. only leave swapYieldSource) Or temporally disable actions like supplyTokenTo, redeemToken and balanceOfToken, after setYieldSource and until transferFunds has been done  
# Handle  tensors   # Vulnerability details  ## Impact After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L268  ## Recommended Mitigation Steps Decrease approval after swapping the yield source.  
# Handle  tensors   # Vulnerability details  ## Impact There are a few tokens out there that do not use any decimals. As far as I know none of them would be a good yield source, but just in case something comes out, you may want to include the possibility that decimals = 0.  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L116  ## Recommended Mitigation Steps Remove the require statement.   
# Handle  tensors   # Vulnerability details  ## Impact The sponsored event is declared but never used.  ## Proof of Concept https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L27  ## Recommended Mitigation Steps Remove the unused event.  
