See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/matrix_0wl-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/SleepingBugs-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/rbserver-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/joestakey-Q.md).
# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229   # Vulnerability details  A user mints a receipt (ERC721) in order to be able to claim their reward. As shown by the claim flowchart, the quest should be initially started before the user completes the on-chain tasks and mints a receipt. At the current moment within `mintReceipt` there is no modifier or check through the code that would revert if quest has not started at both the function level and at the start time.  ## Impact If there is sufficient validation by the rabbithole ECSDA hash endpoint to check off-chain by calling various view functions from the Quest Contract to establish whether the Quest has truly started then it will not be an issue. However, it may be good practice to implement this check within the contract. Hence why I have labelled as potentially a medium risk.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. Claim flowchart -> (https://user-images.githubusercontent.com/14314818/214354756-0af7e34d-746e-4429-8b55-8eb6d8bb1e31.png) https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229  ## Tools Used Manual Code Review, Visual Studio Code  ## Recommended Mitigation Steps Add modifier or if condition to revert if quest in question is has not started yet (at function level and based on start time)
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/lukris02-Q.md).
# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L90-L93   # Vulnerability details  In the [QuestFactory.sol](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol) contract, as expected there is an upper limit on the `questFee_` so that no unjust amount is set for the `questFee_`  ``` 186-189:     function setQuestFee(uint256 questFee_) public onlyOwner {          if (questFee_ > 10_000) revert QuestFeeTooHigh();           questFee = questFee_;     } ```   However, in [RabbitHoleReceipt.sol](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol), the function `setRoyaltyFee()` does not set an upper limit to the `royaltyFee_` parameter. Thus any arbitrarily large values can be set for `royaltyFee_`  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L90-L93  ``` 90-93: function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {         royaltyFee = royaltyFee_;         emit RoyaltyFeeSet(royaltyFee_);     } ```  setting large values of `royaltyFee_` will change all calculations in the contract wherever `royaltyFee_` is involved and very large sums of money will flow towards royalty fees. Royalty fee is meant to be a small amount, however here that is not the case.  #### Recommended Mitigation Steps  modify the `setRoyaltyFee()` function to set an upper limit to the `royaltyFee_` . A code similar to the following can be used  ``` function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {   if (royaltyFee_ > 1_000) revert RoyaltyFeeTooHigh();           royaltyFee = royaltyFee_;         emit RoyaltyFeeSet(royaltyFee_);     } ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/Josiah-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/CodingNameKiki-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/adriro-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/ddimitrov22-Q.md).
# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L58-L61 https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L47-L50   # Vulnerability details  Both `RabbitHoleReceipt` and `RabbitHoleTickets` contracts define a `mint` function that is protected by a `onlyMinter` modifier:  RabbitHoleReceipt:  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98-L104  ```solidity function mint(address to_, string memory questId_) public onlyMinter {     _tokenIds.increment();     uint newTokenID = _tokenIds.current();     questIdForTokenId[newTokenID] = questId_;     timestampForTokenId[newTokenID] = block.timestamp;     _safeMint(to_, newTokenID); } ```  RabbitHoleTickets:  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83-L85  ```solidity function mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {     _mint(to_, id_, amount_, data_); } ```  However, in both cases the modifier implementation is flawed as there isn't any check for a require or revert, the comparison will silently return false and let the execution continue:  ```solidity modifier onlyMinter() {     msg.sender == minterAddress;     _; } ```  ## Impact  Any account can mint any number of `RabbitHoleReceipt` and `RabbitHoleTickets` tokens.  This represents a critical issue as receipts can be used to claim rewards in quests. An attacker can freely mint receipt tokens for any quest to steal all the rewards from it.  ## PoC  The following test demonstrates the issue.  ```solidity contract AuditTest is Test {     address deployer;     uint256 signerPrivateKey;     address signer;     address royaltyRecipient;     address minter;     address protocolFeeRecipient;      QuestFactory factory;     ReceiptRenderer receiptRenderer;     RabbitHoleReceipt receipt;     TicketRenderer ticketRenderer;     RabbitHoleTickets tickets;     ERC20 token;      function setUp() public {         deployer = makeAddr("deployer");         signerPrivateKey = 0x123;         signer = vm.addr(signerPrivateKey);         vm.label(signer, "signer");         royaltyRecipient = makeAddr("royaltyRecipient");         minter = makeAddr("minter");         protocolFeeRecipient = makeAddr("protocolFeeRecipient");          vm.startPrank(deployer);          // Receipt         receiptRenderer = new ReceiptRenderer();         RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();         receipt = RabbitHoleReceipt(             address(new ERC1967Proxy(address(receiptImpl), ""))         );         receipt.initialize(             address(receiptRenderer),             royaltyRecipient,             minter,             0         );          // factory         QuestFactory factoryImpl = new QuestFactory();         factory = QuestFactory(             address(new ERC1967Proxy(address(factoryImpl), ""))         );         factory.initialize(signer, address(receipt), protocolFeeRecipient);         receipt.setMinterAddress(address(factory));          // tickets         ticketRenderer = new TicketRenderer();         RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();         tickets = RabbitHoleTickets(             address(new ERC1967Proxy(address(ticketsImpl), ""))         );         tickets.initialize(             address(ticketRenderer),             royaltyRecipient,             minter,             0         );          // ERC20 token         token = new ERC20("Mock ERC20", "MERC20");         factory.setRewardAllowlistAddress(address(token), true);          vm.stopPrank();     }          function test_RabbitHoleReceipt_RabbitHoleTickets_AnyoneCanMint() public {         address attacker = makeAddr("attacker");          vm.startPrank(attacker);          // Anyone can freely mint RabbitHoleReceipt         string memory questId = "a quest";         receipt.mint(attacker, questId);         assertEq(receipt.balanceOf(attacker), 1);          // Anyone can freely mint RabbitHoleTickets         uint256 tokenId = 0;         tickets.mint(attacker, tokenId, 1, "");         assertEq(tickets.balanceOf(attacker, tokenId), 1);          vm.stopPrank();     } } ```  ## Recommendation  The modifier should require that the caller is the `minterAddress` in order to revert the call in case this condition doesn't hold.  ```solidity modifier onlyMinter() {     require(msg.sender == minterAddress);     _; } ``` 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/catellatech-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/peanuts-Q.md).
# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/068d628f019e9469aecbf676370075c1f6c980fd/contracts/Quest.sol#L113-L116   # Vulnerability details  ## Impact If the reward token is `erc1155/erc777` an attacker can reenter and then buy/transfer another unclaimed token to the attacker address and then  the var  `redeemTokens` wont be equal to how many tokens were actually redeemed.   ## Proof of Concept ex: reward token is an erc1155 that has  `_afterTokenTransfer`  Alice(attacker) has 2  receipt tokens, the first one is on a  smart contract that will do the reentrancy, and the second  one is on Alice's address but is approved   to transfer to  the  smart contract(the own that holds the first receipt) 1. Alice calls the sc to `claim` rewards ```solidity  IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00'); ```  2. `_afterTokenTransfer`  which causes the sc  to  call a function in its fallback function that transfers  the approved token to  the sc ```solidity    try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) { ``` 3. We then reenter with  recipient,not yet claimed token  and we claim it  result:  the invariant that `redeemedTokens` = tokens that are redeemed is false because it doesn't account for the first token that we reentered.  The issue is worse  with `erc777` tokens because of  the fact  that accounting will be in  the `withdrawRemainingTokens` function ```solidity           uint256 unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;         uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;         IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);  ``` after the reentrancy  ex: `redeemedTokens=9` but should be 10 `receiptRedeemers()=12`  `rewardAmountInWeiOrTokenId=1e5` `unclaimedTokens=300000 ` assuming they are some tokens left  `balance(address(this)=201000` and `protocolFee=500` `nonClaimableTokens=201000 - 500 - 300000` it would revert ( negative numbers  with uint) and   funds would be stuck in the contract forever The real estimate for `nonClaimableTokens=201000-500-200000=500` and the owner can get funds out  but 500 wei will be lost in the contract  and  it can get worse with large amounts of quests and the attacker  reentering multiple times to cause a bigger gap between the real `redeemedTokens`   ## Tools Used  ## Recommended Mitigation Steps add  nonReentrancy modifier 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/BClabs-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/nicobevi-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/tsvetanovv-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/hl_-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/zadaru13-Q.md).
# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L74 https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81   # Vulnerability details  ## Lines of code  [1. File: Erc20Quest.sol#L74](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L74)  [2. File: Erc20Quest.sol#L81](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81)   ## Vulnerability details  ### The logic for  calculating reward, unclaimed, and fee funds all multiply by `rewardAmountInWeiOrTokenId`, which will always result in a value of zero, leaving no possible way to withdraw funds.  ``` solidity function _calculateRewards(uint256 redeemableTokenCount_) internal view override returns (uint256) {         return redeemableTokenCount_ * rewardAmountInWeiOrTokenId;     } ``` ``` solidity function withdrawRemainingTokens(address to_) public override onlyOwner {         super.withdrawRemainingTokens(to_);          uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;         uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;         IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);     } ```    This issue could arise when the account creating a quest mistakenly passes in zero for `rewardAmountInWeiOrTokenId` and deposits the rewards into the distribution contract before realizing the mistake.  This issue would be further compounded if a smart contract was used to deploy the quest and deposit the funds all in one transaction, leaving no room for recovery.  ## Proof of Concept  A smart contract with the `CREATE_QUEST_ROLE` and the following pseudo code.  ```solidity  newQuest = QuestFactory.createQuest(...,rewardAmountOrTokenId_=0,...);  IERC20(rewardToken).safeTransfer(newQuest, amount);  newQuest.start();  ``` A similar situation could also arise when using a script to deploy and fund the quest.  ## Tools Used Vscode  ## Recommended Mitigation Steps  Require `rewardAmountOrTokenId_` to be greater than 0 on `Erc20Quest` creation.  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/martin-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/glcanvas-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/0x4non-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/IllIllI-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/RaymondFam-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/0xSmartContract-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/zaskoh-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/SaeedAlipoor01988-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/Rolezn-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/trustindistrust-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/carrotsmuggler-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/brevis-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/prestoncodes-Q.md).
# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L50-L53   # Vulnerability details  ## Impact Detailed description of the impact of this finding. An owner might start a quest before the publicly declared official  ``startTime``. This might be done by mistake or on purpose, creating undesirable user experience since a user would expect a quest won't start before its declared public ``startTime``.  This contradicts the [documentation](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L56-L57), which says "Marking a quest ready to start does not mean that it is live. It also requires that the start time has passed".  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The ``start()`` below allows an owner to start a quest before the publicly declared official  ``startTime``: ```javascript  function start() public virtual onlyOwner {         isPaused = false;         hasStarted = true;     }  function start() public override {         if (IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId) < totalParticipants)             revert TotalAmountExceedsBalance();         super.start();     }   function start() public override {         if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())             revert TotalAmountExceedsBalance();         super.start();     }  ```     ## Tools Used Remix  ## Recommended Mitigation Steps There are two ways to fix, 1) automatic start; 2) manual start.  For the automatic start, we just need to introduce a modifier called hasStarted() to replace the state variable ``hasStarted``: ```javascript modifier hasStarted() {           if(block.timestamp < startTime) revert hasNotStarted();           _; } ```  To performed a manual start: ```javasript  function start() public virtual onlyOwner {         if(block.timestamp < startTime) revert tooEarlyToStart();          isPaused = false;         hasStarted = true; } ```   
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/btk-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/chrisdior4-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/arialblack14-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/HollaDieWaldfee-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/seeu-Q.md).
