 **AddressProvider.sol** - L93/117 - It is validated that pool != address(0) but actually pool is needed to put it inside the ILiquidityPool interface, therefore, the best thing would be to request the interface directly in the signature, like this: addPool(ILiquidityPool pool) and removePool(ILiquidityPool pool). In this way, it would be avoided to validate that pool != address(0), since address(0) does not comply with the ILiquidityPool interface.  - L288 - An address is requested in the addStakerVault() function and as soon as the function starts it is put inside the IStakerVault interface, therefore, the best would be to request the interface directly in the signature, like this: addStakerVault(IStakerVault stakerVault). This way it would avoid starting to execute inside the function.  **Controller.sol** - L33 - The setInflationManager() function performs two validations, the second would not be necessary if an IInflationManager is requested directly in the signature (as is done in the constructor). This would also have the benefit of not being wrapear on line 36.  - L39 - The addStakerVault() function has as its first validation, return false if this validation is true (!addressProvider.addStakerVault(stakerVault)), The problem with this validation is that in the implementation of AddressProvider it never returns false, therefore the validation is not necessary (it is also immutable, therefore it can only be modified in the deploy).  - L121/123/127/129 - The code of the function getTotalEthRequiredForGas() would be much cleaner if the signature contains the creation of the variable (returns (uint256 totalEthRequired)), in this way the creation of the variable in line 123 and the final return would be avoided.  **contracts/zaps/PoolMigrationZap.sol** - L24/25 - If when executing: newPool_.getUnderlying(), we get address(0) as response, it should not be correct to set _underlyingNewPools[address(0)] and this is currently happening. The validation of line 26: if (underlying_ == address(0)) continue; it should be earlier.  **contracts/BkdLocker.sol** - L188 - It is not validated in the getShareOfTotalBoostedBalance() function that when the division is performed with totalLockedBoosted, totalLockedBoosted is != 0.  **contracts/tokenomics/FeeBurner.sol** - L25 - The WETH address is hardcoded, this implies that this code is only usable in a single network. If it's on testnet, it can't be deployed on mainnet. If it's on mainnet, you can't test it.  - L79 - When the targetUnderlying_ variable is created, it is never validated that it is != address(0), this is important, since otherwise when swapAll() is executed they would be burning WETH.   **contracts/tokenomics/KeeperGauge.sol** - L77 - The function requests an extra variable that is not requested. There is a comment that says to add it so that the compiler don't throw warnings.  **contracts/StakerVault.sol** - L156/157 - First it should be validated that the src has an amount to transfer and then check if it needs allowance or not.  - L185 - If a malicious address is approved and if the src wants to change the approve it has, the spender could front run it to spend that approve you have and end up with more allowance.  **contracts/tokenomics/InflationManager.sol** - L80/81 - In the mint() function of the minter contract it can only be executed by the deployer of the BkdToken contract. Therefore, there is not much benefit in mintRewards() being executed for any address that returns true in the modifieronlyGauge(). 
