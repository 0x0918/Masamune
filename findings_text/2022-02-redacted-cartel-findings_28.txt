Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           RewardDistributor.sol, _distributions, 103         RewardDistributor.sol, _claims, 82    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           ThecosomataETH.sol, 88: change 'balance > 0' to 'balance != 0'    Title: Cache powers of 10 used several times Severity: GAS  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ThecosomataETH.sol, 103 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals);  ThecosomataETH.sol, 107 : You should cache the used power of 10 as constant state variable since it's used several times (2):              (((amount * (10**18)) / priceOracle) *  ThecosomataETH.sol, 108 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals)) / (10**_ethDecimals);  ThecosomataETH.sol, 102 : You should cache the used power of 10 as constant state variable since it's used several times (2):              return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /     Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               RewardDistributor.sol.claim - double load of _claims[i]    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, calculateAmountRequiredForLP         ThecosomataETH.sol, addLiquidity    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           RewardDistributor.sol, isRewardClaimed         ThecosomataETH.sol, checkUpkeep    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: RewardDistributor.sol, i, 82         change to prefix increment and unchecked: RewardDistributor.sol, i, 103    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          RewardDistributor.sol, 82         RewardDistributor.sol, 103    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, addLiquidity    Title: Gas Optimization On The 2^256-1 Severity: GAS   Some projects (e.g. Uniswap - https://github.com/Uniswap/interface/blob/main/src/hooks/useApproveCallback.ts#L88) set the default value of the user's allowance to 2^256 - 1. Since the value 2^256 - 1 can also be represented in  hex as 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff. From Ethereum's yellow paper we know  that zeros are cheaper than non-zero values in the hex representation. Considering this fact, an alternative  choice could be now 0x8000000000000000000000000000000000000000000000000000000000000000 or 2^255 to represent  "infinity". If you do the calculations with Remix, you will see that the former costs 47'872 gas, while the latter  costs 45'888 gas. If you accept that infinity can also be represented via 2^255 (instead of 2^256-1), which almost  all projects can - you can already save about 4% gas leveraging this optimisation trick on those calculations.                    ThecosomataETH.sol (L#69): IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1); )         ThecosomataETH.sol (L#68): IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);)  
