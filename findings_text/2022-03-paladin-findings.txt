# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L284-L294  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1137-L1233  # Vulnerability details  ## Impact  Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged.   However, if a user increases the lock amount on an expired lock, a new lock will be created with the duration of the previous lock and the provided non-zero amount. Because the `action != LockAction.INCREASE_AMOUNT` check later on in the function does not hold true, `userCurrentBonusRatio` will contain the last updated value from the previous lock. As a result, the user will not receive any rewards for their active lock and they will need to increase the duration of the lock to fix lock's bonus ratio.  ## Recommended Mitigation Steps  Consider preventing users from increasing the amount on an expired lock. This should help to mitigate this issue. 
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1338-L1378  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L876-L906  # Vulnerability details  ## Impact  The `emergencyWithdraw()` function intends to withdraw their tokens regardless if they are locked up for any duration. This emergency must be triggered by the owner of the contract by calling `triggerEmergencyWithdraw()`. A number of functions will revert when the protocol is in an emergency state, including all stake, lock, unlock and kick actions and the updating of a user's rewards. However, a user could bypass the restriction on `_updateUserRewards()` by transferring a small amount of unlocked tokens to their account. `_beforeTokenTransfer()` will call `_updateUserRewards()` on the `from` and `to` accounts. As a result, users can continue to accrue rewards while the protocol is in an emergency state and it makes sense for users to delay their emergency withdraw as they will be able to claim a higher proportion of the allocated rewards.  ## Recommended Mitigation Steps  Consider adding a check for the boolean `emergency` value in `_beforeTokenTransfer()` to not call `_updateUserRewards` on any account if this value is set. Alternatively, a check could be added into the `_updateUserRewards()` function to return if `emergency` is true. 
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L253 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L284 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L268   # Vulnerability details  ## Impact Anyone could create a contract or a contract factory "PAL Locker" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.   Paladin should expect this behavior to happen as we've seen it happening with veToken models and model implying locking features (see https://lockers.stakedao.org/ and https://www.convexfinance.com/).   This behavior could eventually be beneficial to the original DAO (ex. https://www.convexfinance.com/ for Curve and Frax), but the original DAO needs to at least be able to blacklist / whitelist such contracts and actors to ensure their interests are aligned with the protocol.  ## Proof of Concept  To make locked hPAL liquid, Alice could create a contact C. Then, she can deposit hPAL through the contract, lock them and delegate voting power to herself. She can then sell or tokenize the ownership of the contract C.  ## Recommended Mitigation Steps  Depending of if Paladin wants to be optimistic or pessimistic, implement a whitelisting / blacklisting system for contracts.   See: https://github.com/curvefi/curve-dao-contracts/blob/4e428823c8ae9c0f8a669d796006fade11edb141/contracts/VotingEscrow.vy#L185  https://github.com/FraxFinance/frax-solidity/blob/7375949a73042c1e6dd14848fc4ea1ba62e36fb5/src/hardhat/contracts/FXS/veFXS_Solidity.sol.old#L370  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L446-L468   # Vulnerability details   When the contract is in blocked state (emergency mode), the protocol wants to return an empty UserLock info, on calling the function getUserLock. However, there is another way, by which the users can find the same information.  The below function is not protected when in emergency mode, and users can use this alternatively. Line#466 function getUserPastLock(address user, uint256 blockNumber)   ## Impact There is no loss of funds, however the intention to block information (return empty lock info) is defeated, because not all functions are protected. There is inconsistency in implementing the emergency mode check.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Functions getUserLock and getUserPastLock  ## Recommended Mitigation Steps Add checking for emergency mode for this function getUserPastLock. ``` if(emergency) revert EmergencyBlock(); ``` Additional user access check can be added, so that the function returns correct value when the caller(msg.sender) is admin or owner.   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L228-L235   # Vulnerability details  Function cooldown() is not protected when protocol is in emergency mode. Its behavior is not consistent with the other major functions defined.  ## Impact While other major functions like stake, unstake, lock, unlock, etc., of this contract is protected by checking for emergency flag and reverting,  this function cooldown() is not checked. The impact of this is that during emergency mode, users can set immediately the cooldown() and plan for unstaking when the emergency mode is lifted and cooldown period expires. This may not be the desirable behaviour expected by the protocol.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Function cooldown()  ## Recommended Mitigation Steps Add checking for emergency mode for this function also. ``` if(emergency) revert EmergencyBlock(); ```   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743   # Vulnerability details  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  When current time is `lastDropUpdate + (2*MONTH-1)`:  `nbMonthEllapsed` will be round down to `1`, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result, `DropPerSecond` will only decrease by 1 * `dropDecreasePerMonth`.  In another word, due to the precision loss in calculating the number of months elapsed, for each `_updateDropPerSecond()` there can be a short of up to `1 * dropDecreasePerMonth` for the decrease of emission rate.  At the very edge case, if all the updates happened just like the scenario above. by the end of the `dropDecreaseDuration`, it will drop only `12 * dropDecreasePerMonth` in total, while it's expected to be `24 * dropDecreasePerMonth`.  So only half of `(startDropPerSecond - endDropPerSecond)` is actually decreased. And the last time `updateDropPerSecond` is called, `DropPerSecond` will suddenly drop to `endDropPerSecond`.  ### Impact  As the `DropPerSecond` is not updated correctly, in most of the `dropDecreaseDuration`, the actual rewards emission rate is much higher than expected. As a result, the total rewards emission can be much higher than expected.  ### Recommendation  Change to:  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = UNIT * (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed / UNIT;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L729   # Vulnerability details  ## Impact If `startDropPerSecond` is initialized at less than `endDropPerSecond` the contract will be unusable. There will be an underflow in `_updateDropPerSecond` which will always revert. This function is called throughout the contract, in critical functions like `lock` and `claim`, if it were to always revert the contract would be broken and unusable.  ## Proof of Concept If `startDropPerSecond` is initialized at less than `endDropPerSecond` in the constructor, the contract will be deployed without issue but will be broken.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a check in the constructor that ensures `startDropPerSecond` >= `endDropPerSecond`  
## Don't Initialize Variables with Default Value  ### Impact Issue Information: [G001](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g001---dont-initialize-variables-with-default-value)  ### Findings: ``` HolyPaladinToken.sol::516 => uint256 low = 0; HolyPaladinToken.sol::688 => uint256 low = 0; HolyPaladinToken.sol::796 => uint256 userLockedBalance = 0; HolyPaladinToken.sol::807 => uint256 lockingRewards = 0; HolyPaladinToken.sol::940 => uint256 low = 0; HolyPaladinToken.sol::972 => uint256 low = 0; HolyPaladinToken.sol::1004 => uint256 low = 0; ``` ### Tools used [c4udit](https://github.com/byterocket/c4udit)
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol   # Vulnerability details  ## Impact ``PaladinRewardReserve.sol`` may have potential bugs if it uses new tokens as rewards.  ## Proof of Concept Currently, ``PaladinRewardReserve.sol`` has following behaviors:  - ``mapping(address => bool) public approvedSpenders`` does not store the info regarding which token it targets - ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions can set ``token`` arbitrarily  Hence, some corner cases may happen as follows: - Use TokenA at PaladinRewardReserve.sol and do operations. - Start TokenB as rewards at PaladinRewardReserve.sol.  - All the information stored in ``approvedSpenders`` was intended for TokenA. So it is possible that following corner cases happen:   - ``setNewSpender`` function cannot set new token   - If userA is already added in ``approvedSpenders`` for TokenA, it can call ``updateSpenderAllowance``.   ## Tools Used Statis code analysis  ## Recommended Mitigation Steps Do either of followings depending on the product specification:  (1) If PAL token is only used and other token will never be used at ``PaladinRewardReserve.sol``, stop having ``address token`` argument at ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions. Instead, set ``token`` at the constructor or other ways, and limit the ability to flexibly set ``token`` from functions.  (2) If other tokens potentially will be used at ``PaladinRewardReserve.sol``, update data structure of ``approvedSpenders`` mapping and change the logic.  Firstly, it should also contain the info which ``token`` it targets such as ``mapping(address => address => bool)``.  Secondly, it should rewrite the ``require`` logic at each function as follows.  ``` require(!approvedSpenders[spender][token], "Already Spender on the specified Token"); ```  ``` require(approvedSpenders[spender][token], "Not approved Spender on the specified Token"); ```  
# Summary  We list 3 low-critical findings and 1 non-critical finding here: * (Low) Rewrite `_updateDropPerSecond` to avoid loss of precision * (Low) Rewrite `_getUserAccruedRewards` to avoid loss of precision * (Low) Lock pragma to ensure compiler version * (Non) `_getNewReceiverCooldown` revert when divided by zero  In summary of recommended security practices, it's better to rewrite formulas to avoid loss of precision, lock pragma version, and check division by zero.  # (Low) Rewrite `_updateDropPerSecond` to avoid loss of precision  ## Impact  In `_updateDropPerSecond`:  ```         uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH); ```  `dropDecreasePerMonth` may suffer from loss of precision due to ordering of operations.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L729  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  rewrite to avoid loss of precision:  ```         uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) * MONTH / dropDecreaseDuration; ```  # (Low) Rewrite `_getUserAccruedRewards` to avoid loss of precision  ## Impact  In `_getUserAccruedRewards`:  ```         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT; ```  `lockingRewards` may suffer from loss of precision.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L842  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  rewrite to avoid loss of precision:  ```         lockingRewards = userLockedBalance * indexDiff * vars.periodBonusRatio / UNIT / UNIT; ```  # (Low) Lock pragma to ensure compiler version  ## Impact  Floating pragma may cause unexpected compilation time behaviour and introduce unintended bugs.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L2 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/PaladinRewardReserve.sol#L2  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Don't use `^`, lock pragma to ensure compiler version. e.g. `pragma solidity 0.8.4;`  # (Non) `_getNewReceiverCooldown` revert when divided by zero  ## Impact  `_getNewReceiverCooldown` reverts on transferring 0 amount to someone with 0 balance due to division by 0.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1108  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Explicitly check `(amount + receiverBalance)` should not equal to 0. 
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L466 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L492 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L644 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L663 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L917 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L961 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L993 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1148 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1164 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1184 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1199 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1225 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1250 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1260 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1287 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1293 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1324 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1352 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1357   # Vulnerability details  ## Impact  4 kinds of states (`UserLock`, `TotalLock`, `Checkpoint`, `DelegateCheckpoint`) are maintained in the protocol to keep record of history. For functions that query history states, target block number is used as an index to search for the corresponding state.  However, 3 (`DelegateCheckpoint`, `TotalLock`, `UserLocks`) out of the 4 states are allowed to have multiple entries with same `fromBlock`, resulting in a one-to-many mapping between block number and history entry. This makes queried results at best imprecise, and at worst manipulatable by malicious users to present an incorrect history.  ## Proof of Concept  Functions that query history states including `_getPastLock`, `getPastTotalLock`, `_getPastDelegate` perform a binary search through the array of history states to find entry matching queried block number. However, the searched arrays can contain multiple entries with the same `fromBlock`.  For example the `_lock` function pushes a new `UserLock` to `userLocks[user]` regardless of previous lock block number.  ```     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {         require(user != address(0)); //Never supposed to happen, but security check         require(amount != 0, "hPAL: Null amount");         uint256 userBalance = balanceOf(user);         require(amount <= userBalance, "hPAL: Amount over balance");         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");          if(userLocks[user].length == 0){             ...         }         else {             // Get the current user Lock             uint256 currentUserLockIndex = userLocks[user].length - 1;             UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];             // Calculate the end of the user current lock             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;              uint256 startTimestamp = block.timestamp;              if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                 // User locked, and then unlocked                 // or user lock expired                  userLocks[user].push(UserLock(                     safe128(amount),                     safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));             }             else {                 // Update of the current Lock : increase amount or increase duration                 // or renew with the same parameters, but starting at the current timestamp                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                  // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                  userLocks[user].push(UserLock(                     safe128(amount),                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));                 ...             }         ...     } ```  This makes the history searches imprecise at best. Additionally, if a user intends to shadow his past states from queries through public search functions, it is possible to control the number of entries precisely such that binsearch returns the entry he wants to show.   ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Adopt the same strategy as checkpoint, and modify last entry in array instead of pushing new one if it `fromBlock == block.number`   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38-L39 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47   # Vulnerability details  ## Impact - In function  `updateSpenderAllowance` of `PaladinRewardReserve`, line 38 `safeApprove` to 0 before `safeApprove` to amount in line 39. This is because we can only approve their allowance to zero or from zero in `SafeERC20`.  - In `SafeERC20`, it is used to prevent front-run by approved addresses and usually users have to do 2 TXs. - But when we do both in 1 TX, it does not add any layer of security and just wasting gas. Such behavior creates a false sense of security. Also `safeApprove` is deprecated by OZ (ref) ## Proof of concept - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31 - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38-L39 - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47 ## Recommended Mitigation Steps - As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()`. - And in the case of line 38-39, just use normal `approve` instead of 2 `safeApprove`.   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905   # Vulnerability details  ## Impact In the _beforeTokenTransfer function, cooldowns will be set to 0 when the user transfers all tokens to himself. Consider the following scenario Day 0: The user stakes 100 tokens and calls the cooldown function Day 10: the user wanted to unstake the tokens, but accidentally transferred all the tokens to himself, which caused the cooldown to be set to 0 and the user could not unstake. ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905 ## Tools Used None ## Recommended Mitigation Steps ```   function _beforeTokenTransfer(       address from,       address to,       uint256 amount   ) internal virtual override {       if(from != address(0)) { //check must be skipped on minting           // Only allow the balance that is unlocked to be transfered           require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");       }        // Update user rewards before any change on their balance (staked and locked)       _updateUserRewards(from);        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0        if(from != to) {           // Update user rewards before any change on their balance (staked and locked)           _updateUserRewards(to);           // => we don't want a self-transfer to double count new claimable rewards           // + no need to update the cooldown on a self-transfer            uint256 previousToBalance = balanceOf(to);           cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);           // If from transfer all of its balance, reset the cooldown to 0           uint256 previousFromBalance = balanceOf(from);           if(previousFromBalance == amount && fromCooldown != 0) {               cooldowns[from] = 0;           }       }   } ```  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131   # Vulnerability details  ## Impact Consider the following scenario: Day 0: User A stakes 200 tokens and calls the cooldown function. At this time, user A's cooldown is Day 0. Day 15: User B stakes 100 tokens, but then wants to unstake tokens. So user A said that he could assist user B in unstaking tokens, and this could be done by deploying a smart contract. In the smart contract deployed by user A, user B first needs to transfer 100 tokens to user A. In the _getNewReceiverCooldown function, _senderCooldown is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5. ```     function _getNewReceiverCooldown(         uint256 senderCooldown,         uint256 amount,         address receiver,         uint256 receiverBalance     ) internal view returns(uint256) {         uint256 receiverCooldown = cooldowns[receiver];          // If receiver has no cooldown, no need to set a new one         if(receiverCooldown == 0) return 0;          uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);          // If last receiver cooldown is expired, set it back to 0         if(receiverCooldown < minValidCooldown) return 0;          // In case the given senderCooldown is 0 (sender has no cooldown, or minting)         uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;          // If the sender cooldown is better, we keep the receiver cooldown         if(_senderCooldown < receiverCooldown) return receiverCooldown;          // Default new cooldown, weighted average based on the amount and the previous balance         return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);      } ``` Since User A is still at UNSTAKE_PERIOD after receiving the tokens, User A unstakes 100 tokens and sends it to User B.  After calculation, we found that when user A has a balance of X and is at the edge of UNSTAKE_PERIOD, user A can assist in unstaking the X/2 amount of tokens just staked.  ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131  ## Tools Used None ## Recommended Mitigation Steps After calculation, we found that the number of tokens that users at the edge of UNSTAKE_PERIOD can assist in unstaking conforms to the following equation UNSTAKE_PERIOD/COOLDOWN_PERIOD = UNSTAKE_AMOUNT/USER_BALANCE, when COOLDOWN_PERIOD remains unchanged, the smaller the UNSTAKE_PERIOD, the less tokens the user can assist in unstaking, so UNSTAKE_PERIOD can be adjusted to alleviate this situation.  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` the `ONE_YEAR` variable claims that there are `31557600` seconds in a year when this is incorrect.  The `ONE_YEAR` variable is used in the `getCurrentVotes()` function as well as the `getPastVotes()` function so it is vital that the correct time in seconds be used as it can effect users negatively.   ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25  86,400 seconds in a day x 365 = 31_536_000  ## Tools Used Manual code review   ## Recommended Mitigation Steps The correct number of seconds in a year is 31_536_000 so the `ONE_YEAR` variable should be changed to `ONE_YEAR = 31_536_000`   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` it imports `ERC20.sol` with some changes from the original Open Zeppelin standard.  One change is that the `transferFrom()` function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates,  followed by the external call to prevent reentrancy attacks.  Currently the `transferFrom()` function in `ERC20.sol` used by `HolyPaladinToken.sol` calls `_transfer()` first and then updates the `sender` allowance which is highly unsafe.  The openZeppelin `ER20.sol` contract which is the industry standard first updates the `sender` allowance before calling `_transfer`.  The external call should always be done last to avoid any double spending bugs or reentrancy attacks.   ## Proof of Concept https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149  Open Zeppelins Implementation https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol  ## Tools Used Manual code review   ## Recommended Mitigation Steps Be sure to follow the Checks Effects and Interactions safety pattern as the `transferFrom` function is one of the most important functions in any protocol.  Consider importing the Open Zeppelin `ERC20.sol` contract code directly as it is battle tested and safe code.   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L284-L294  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1137-L1233  # Vulnerability details  ## Impact  Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged.   However, if a user increases the lock amount on an expired lock, a new lock will be created with the duration of the previous lock and the provided non-zero amount. Because the `action != LockAction.INCREASE_AMOUNT` check later on in the function does not hold true, `userCurrentBonusRatio` will contain the last updated value from the previous lock. As a result, the user will not receive any rewards for their active lock and they will need to increase the duration of the lock to fix lock's bonus ratio.  ## Recommended Mitigation Steps  Consider preventing users from increasing the amount on an expired lock. This should help to mitigate this issue. 
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1338-L1378  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L876-L906  # Vulnerability details  ## Impact  The `emergencyWithdraw()` function intends to withdraw their tokens regardless if they are locked up for any duration. This emergency must be triggered by the owner of the contract by calling `triggerEmergencyWithdraw()`. A number of functions will revert when the protocol is in an emergency state, including all stake, lock, unlock and kick actions and the updating of a user's rewards. However, a user could bypass the restriction on `_updateUserRewards()` by transferring a small amount of unlocked tokens to their account. `_beforeTokenTransfer()` will call `_updateUserRewards()` on the `from` and `to` accounts. As a result, users can continue to accrue rewards while the protocol is in an emergency state and it makes sense for users to delay their emergency withdraw as they will be able to claim a higher proportion of the allocated rewards.  ## Recommended Mitigation Steps  Consider adding a check for the boolean `emergency` value in `_beforeTokenTransfer()` to not call `_updateUserRewards` on any account if this value is set. Alternatively, a check could be added into the `_updateUserRewards()` function to return if `emergency` is true. 
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L253 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L284 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L268   # Vulnerability details  ## Impact Anyone could create a contract or a contract factory "PAL Locker" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.   Paladin should expect this behavior to happen as we've seen it happening with veToken models and model implying locking features (see https://lockers.stakedao.org/ and https://www.convexfinance.com/).   This behavior could eventually be beneficial to the original DAO (ex. https://www.convexfinance.com/ for Curve and Frax), but the original DAO needs to at least be able to blacklist / whitelist such contracts and actors to ensure their interests are aligned with the protocol.  ## Proof of Concept  To make locked hPAL liquid, Alice could create a contact C. Then, she can deposit hPAL through the contract, lock them and delegate voting power to herself. She can then sell or tokenize the ownership of the contract C.  ## Recommended Mitigation Steps  Depending of if Paladin wants to be optimistic or pessimistic, implement a whitelisting / blacklisting system for contracts.   See: https://github.com/curvefi/curve-dao-contracts/blob/4e428823c8ae9c0f8a669d796006fade11edb141/contracts/VotingEscrow.vy#L185  https://github.com/FraxFinance/frax-solidity/blob/7375949a73042c1e6dd14848fc4ea1ba62e36fb5/src/hardhat/contracts/FXS/veFXS_Solidity.sol.old#L370  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L446-L468   # Vulnerability details   When the contract is in blocked state (emergency mode), the protocol wants to return an empty UserLock info, on calling the function getUserLock. However, there is another way, by which the users can find the same information.  The below function is not protected when in emergency mode, and users can use this alternatively. Line#466 function getUserPastLock(address user, uint256 blockNumber)   ## Impact There is no loss of funds, however the intention to block information (return empty lock info) is defeated, because not all functions are protected. There is inconsistency in implementing the emergency mode check.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Functions getUserLock and getUserPastLock  ## Recommended Mitigation Steps Add checking for emergency mode for this function getUserPastLock. ``` if(emergency) revert EmergencyBlock(); ``` Additional user access check can be added, so that the function returns correct value when the caller(msg.sender) is admin or owner.   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L228-L235   # Vulnerability details  Function cooldown() is not protected when protocol is in emergency mode. Its behavior is not consistent with the other major functions defined.  ## Impact While other major functions like stake, unstake, lock, unlock, etc., of this contract is protected by checking for emergency flag and reverting,  this function cooldown() is not checked. The impact of this is that during emergency mode, users can set immediately the cooldown() and plan for unstaking when the emergency mode is lifted and cooldown period expires. This may not be the desirable behaviour expected by the protocol.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Function cooldown()  ## Recommended Mitigation Steps Add checking for emergency mode for this function also. ``` if(emergency) revert EmergencyBlock(); ```   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743   # Vulnerability details  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  When current time is `lastDropUpdate + (2*MONTH-1)`:  `nbMonthEllapsed` will be round down to `1`, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result, `DropPerSecond` will only decrease by 1 * `dropDecreasePerMonth`.  In another word, due to the precision loss in calculating the number of months elapsed, for each `_updateDropPerSecond()` there can be a short of up to `1 * dropDecreasePerMonth` for the decrease of emission rate.  At the very edge case, if all the updates happened just like the scenario above. by the end of the `dropDecreaseDuration`, it will drop only `12 * dropDecreasePerMonth` in total, while it's expected to be `24 * dropDecreasePerMonth`.  So only half of `(startDropPerSecond - endDropPerSecond)` is actually decreased. And the last time `updateDropPerSecond` is called, `DropPerSecond` will suddenly drop to `endDropPerSecond`.  ### Impact  As the `DropPerSecond` is not updated correctly, in most of the `dropDecreaseDuration`, the actual rewards emission rate is much higher than expected. As a result, the total rewards emission can be much higher than expected.  ### Recommendation  Change to:  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = UNIT * (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed / UNIT;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L729   # Vulnerability details  ## Impact If `startDropPerSecond` is initialized at less than `endDropPerSecond` the contract will be unusable. There will be an underflow in `_updateDropPerSecond` which will always revert. This function is called throughout the contract, in critical functions like `lock` and `claim`, if it were to always revert the contract would be broken and unusable.  ## Proof of Concept If `startDropPerSecond` is initialized at less than `endDropPerSecond` in the constructor, the contract will be deployed without issue but will be broken.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a check in the constructor that ensures `startDropPerSecond` >= `endDropPerSecond`  
## Don't Initialize Variables with Default Value  ### Impact Issue Information: [G001](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g001---dont-initialize-variables-with-default-value)  ### Findings: ``` HolyPaladinToken.sol::516 => uint256 low = 0; HolyPaladinToken.sol::688 => uint256 low = 0; HolyPaladinToken.sol::796 => uint256 userLockedBalance = 0; HolyPaladinToken.sol::807 => uint256 lockingRewards = 0; HolyPaladinToken.sol::940 => uint256 low = 0; HolyPaladinToken.sol::972 => uint256 low = 0; HolyPaladinToken.sol::1004 => uint256 low = 0; ``` ### Tools used [c4udit](https://github.com/byterocket/c4udit)
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol   # Vulnerability details  ## Impact ``PaladinRewardReserve.sol`` may have potential bugs if it uses new tokens as rewards.  ## Proof of Concept Currently, ``PaladinRewardReserve.sol`` has following behaviors:  - ``mapping(address => bool) public approvedSpenders`` does not store the info regarding which token it targets - ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions can set ``token`` arbitrarily  Hence, some corner cases may happen as follows: - Use TokenA at PaladinRewardReserve.sol and do operations. - Start TokenB as rewards at PaladinRewardReserve.sol.  - All the information stored in ``approvedSpenders`` was intended for TokenA. So it is possible that following corner cases happen:   - ``setNewSpender`` function cannot set new token   - If userA is already added in ``approvedSpenders`` for TokenA, it can call ``updateSpenderAllowance``.   ## Tools Used Statis code analysis  ## Recommended Mitigation Steps Do either of followings depending on the product specification:  (1) If PAL token is only used and other token will never be used at ``PaladinRewardReserve.sol``, stop having ``address token`` argument at ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions. Instead, set ``token`` at the constructor or other ways, and limit the ability to flexibly set ``token`` from functions.  (2) If other tokens potentially will be used at ``PaladinRewardReserve.sol``, update data structure of ``approvedSpenders`` mapping and change the logic.  Firstly, it should also contain the info which ``token`` it targets such as ``mapping(address => address => bool)``.  Secondly, it should rewrite the ``require`` logic at each function as follows.  ``` require(!approvedSpenders[spender][token], "Already Spender on the specified Token"); ```  ``` require(approvedSpenders[spender][token], "Not approved Spender on the specified Token"); ```  
# Summary  We list 3 low-critical findings and 1 non-critical finding here: * (Low) Rewrite `_updateDropPerSecond` to avoid loss of precision * (Low) Rewrite `_getUserAccruedRewards` to avoid loss of precision * (Low) Lock pragma to ensure compiler version * (Non) `_getNewReceiverCooldown` revert when divided by zero  In summary of recommended security practices, it's better to rewrite formulas to avoid loss of precision, lock pragma version, and check division by zero.  # (Low) Rewrite `_updateDropPerSecond` to avoid loss of precision  ## Impact  In `_updateDropPerSecond`:  ```         uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH); ```  `dropDecreasePerMonth` may suffer from loss of precision due to ordering of operations.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L729  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  rewrite to avoid loss of precision:  ```         uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) * MONTH / dropDecreaseDuration; ```  # (Low) Rewrite `_getUserAccruedRewards` to avoid loss of precision  ## Impact  In `_getUserAccruedRewards`:  ```         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT; ```  `lockingRewards` may suffer from loss of precision.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L842  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  rewrite to avoid loss of precision:  ```         lockingRewards = userLockedBalance * indexDiff * vars.periodBonusRatio / UNIT / UNIT; ```  # (Low) Lock pragma to ensure compiler version  ## Impact  Floating pragma may cause unexpected compilation time behaviour and introduce unintended bugs.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L2 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/PaladinRewardReserve.sol#L2  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Don't use `^`, lock pragma to ensure compiler version. e.g. `pragma solidity 0.8.4;`  # (Non) `_getNewReceiverCooldown` revert when divided by zero  ## Impact  `_getNewReceiverCooldown` reverts on transferring 0 amount to someone with 0 balance due to division by 0.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1108  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Explicitly check `(amount + receiverBalance)` should not equal to 0. 
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L466 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L492 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L644 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L663 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L917 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L961 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L993 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1148 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1164 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1184 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1199 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1225 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1250 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1260 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1287 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1293 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1324 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1352 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1357   # Vulnerability details  ## Impact  4 kinds of states (`UserLock`, `TotalLock`, `Checkpoint`, `DelegateCheckpoint`) are maintained in the protocol to keep record of history. For functions that query history states, target block number is used as an index to search for the corresponding state.  However, 3 (`DelegateCheckpoint`, `TotalLock`, `UserLocks`) out of the 4 states are allowed to have multiple entries with same `fromBlock`, resulting in a one-to-many mapping between block number and history entry. This makes queried results at best imprecise, and at worst manipulatable by malicious users to present an incorrect history.  ## Proof of Concept  Functions that query history states including `_getPastLock`, `getPastTotalLock`, `_getPastDelegate` perform a binary search through the array of history states to find entry matching queried block number. However, the searched arrays can contain multiple entries with the same `fromBlock`.  For example the `_lock` function pushes a new `UserLock` to `userLocks[user]` regardless of previous lock block number.  ```     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {         require(user != address(0)); //Never supposed to happen, but security check         require(amount != 0, "hPAL: Null amount");         uint256 userBalance = balanceOf(user);         require(amount <= userBalance, "hPAL: Amount over balance");         require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");         require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");          if(userLocks[user].length == 0){             ...         }         else {             // Get the current user Lock             uint256 currentUserLockIndex = userLocks[user].length - 1;             UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];             // Calculate the end of the user current lock             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;              uint256 startTimestamp = block.timestamp;              if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                 // User locked, and then unlocked                 // or user lock expired                  userLocks[user].push(UserLock(                     safe128(amount),                     safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));             }             else {                 // Update of the current Lock : increase amount or increase duration                 // or renew with the same parameters, but starting at the current timestamp                 require(amount >=  currentUserLock.amount,"hPAL: smaller amount");                 require(duration >=  currentUserLock.duration,"hPAL: smaller duration");                  // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                  userLocks[user].push(UserLock(                     safe128(amount),                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));                 ...             }         ...     } ```  This makes the history searches imprecise at best. Additionally, if a user intends to shadow his past states from queries through public search functions, it is possible to control the number of entries precisely such that binsearch returns the entry he wants to show.   ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Adopt the same strategy as checkpoint, and modify last entry in array instead of pushing new one if it `fromBlock == block.number`   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38-L39 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47   # Vulnerability details  ## Impact - In function  `updateSpenderAllowance` of `PaladinRewardReserve`, line 38 `safeApprove` to 0 before `safeApprove` to amount in line 39. This is because we can only approve their allowance to zero or from zero in `SafeERC20`.  - In `SafeERC20`, it is used to prevent front-run by approved addresses and usually users have to do 2 TXs. - But when we do both in 1 TX, it does not add any layer of security and just wasting gas. Such behavior creates a false sense of security. Also `safeApprove` is deprecated by OZ (ref) ## Proof of concept - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31 - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38-L39 - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47 ## Recommended Mitigation Steps - As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()`. - And in the case of line 38-39, just use normal `approve` instead of 2 `safeApprove`.   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905   # Vulnerability details  ## Impact In the _beforeTokenTransfer function, cooldowns will be set to 0 when the user transfers all tokens to himself. Consider the following scenario Day 0: The user stakes 100 tokens and calls the cooldown function Day 10: the user wanted to unstake the tokens, but accidentally transferred all the tokens to himself, which caused the cooldown to be set to 0 and the user could not unstake. ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905 ## Tools Used None ## Recommended Mitigation Steps ```   function _beforeTokenTransfer(       address from,       address to,       uint256 amount   ) internal virtual override {       if(from != address(0)) { //check must be skipped on minting           // Only allow the balance that is unlocked to be transfered           require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");       }        // Update user rewards before any change on their balance (staked and locked)       _updateUserRewards(from);        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0        if(from != to) {           // Update user rewards before any change on their balance (staked and locked)           _updateUserRewards(to);           // => we don't want a self-transfer to double count new claimable rewards           // + no need to update the cooldown on a self-transfer            uint256 previousToBalance = balanceOf(to);           cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);           // If from transfer all of its balance, reset the cooldown to 0           uint256 previousFromBalance = balanceOf(from);           if(previousFromBalance == amount && fromCooldown != 0) {               cooldowns[from] = 0;           }       }   } ```  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131   # Vulnerability details  ## Impact Consider the following scenario: Day 0: User A stakes 200 tokens and calls the cooldown function. At this time, user A's cooldown is Day 0. Day 15: User B stakes 100 tokens, but then wants to unstake tokens. So user A said that he could assist user B in unstaking tokens, and this could be done by deploying a smart contract. In the smart contract deployed by user A, user B first needs to transfer 100 tokens to user A. In the _getNewReceiverCooldown function, _senderCooldown is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5. ```     function _getNewReceiverCooldown(         uint256 senderCooldown,         uint256 amount,         address receiver,         uint256 receiverBalance     ) internal view returns(uint256) {         uint256 receiverCooldown = cooldowns[receiver];          // If receiver has no cooldown, no need to set a new one         if(receiverCooldown == 0) return 0;          uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);          // If last receiver cooldown is expired, set it back to 0         if(receiverCooldown < minValidCooldown) return 0;          // In case the given senderCooldown is 0 (sender has no cooldown, or minting)         uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;          // If the sender cooldown is better, we keep the receiver cooldown         if(_senderCooldown < receiverCooldown) return receiverCooldown;          // Default new cooldown, weighted average based on the amount and the previous balance         return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);      } ``` Since User A is still at UNSTAKE_PERIOD after receiving the tokens, User A unstakes 100 tokens and sends it to User B.  After calculation, we found that when user A has a balance of X and is at the edge of UNSTAKE_PERIOD, user A can assist in unstaking the X/2 amount of tokens just staked.  ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131  ## Tools Used None ## Recommended Mitigation Steps After calculation, we found that the number of tokens that users at the edge of UNSTAKE_PERIOD can assist in unstaking conforms to the following equation UNSTAKE_PERIOD/COOLDOWN_PERIOD = UNSTAKE_AMOUNT/USER_BALANCE, when COOLDOWN_PERIOD remains unchanged, the smaller the UNSTAKE_PERIOD, the less tokens the user can assist in unstaking, so UNSTAKE_PERIOD can be adjusted to alleviate this situation.  
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` the `ONE_YEAR` variable claims that there are `31557600` seconds in a year when this is incorrect.  The `ONE_YEAR` variable is used in the `getCurrentVotes()` function as well as the `getPastVotes()` function so it is vital that the correct time in seconds be used as it can effect users negatively.   ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25  86,400 seconds in a day x 365 = 31_536_000  ## Tools Used Manual code review   ## Recommended Mitigation Steps The correct number of seconds in a year is 31_536_000 so the `ONE_YEAR` variable should be changed to `ONE_YEAR = 31_536_000`   
# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` it imports `ERC20.sol` with some changes from the original Open Zeppelin standard.  One change is that the `transferFrom()` function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates,  followed by the external call to prevent reentrancy attacks.  Currently the `transferFrom()` function in `ERC20.sol` used by `HolyPaladinToken.sol` calls `_transfer()` first and then updates the `sender` allowance which is highly unsafe.  The openZeppelin `ER20.sol` contract which is the industry standard first updates the `sender` allowance before calling `_transfer`.  The external call should always be done last to avoid any double spending bugs or reentrancy attacks.   ## Proof of Concept https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149  Open Zeppelins Implementation https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol  ## Tools Used Manual code review   ## Recommended Mitigation Steps Be sure to follow the Checks Effects and Interactions safety pattern as the `transferFrom` function is one of the most important functions in any protocol.  Consider importing the Open Zeppelin `ERC20.sol` contract code directly as it is battle tested and safe code.   
