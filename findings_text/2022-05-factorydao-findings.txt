# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L156-L173   # Vulnerability details  ## Impact In `getRewards()` of `PermissionlessBasicPoolFactory` contract, there is a check to see that receipt is initialized receipt, but the condition used by code will be true for `receiptId` equal `0`. because `receiptId==0` is not initilized for any pool and the value of `pools[poolId].receipts[0].id` will be `0` so the condition `receipt.id == receiptId` will be passed on `getRewards()`. Any function that depends on `getRewards()` to check that if `receptId` has deposited fund, can be fooled. right now this bug has no direct money loss, but this function doesn't work as it suppose too.  ## Proof of Concept This is `getRewards()` code: ```     function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {         Pool storage pool = pools[poolId];         Receipt memory receipt = pool.receipts[receiptId];         require(pool.id == poolId, 'Uninitialized pool');         require(receipt.id == receiptId, 'Uninitialized receipt');         uint nowish = block.timestamp;         if (nowish > pool.endTime) {             nowish = pool.endTime;         }          uint secondsDiff = nowish - receipt.timeDeposited;         uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);         for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {             rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;         }         return rewardsLocal;     } ``` if the value of `receiptId` set as `0` then even so `receiptId==0` is not initialized but this line: ```         require(receipt.id == receiptId, 'Uninitialized receipt'); ``` will be passed, because, receipts start from number `1` and `pool.receipts[0]` will have zero value for his fields. This is the code in `deposit()` which is responsible for creating receipt objects. ```         pool.totalDepositsWei += amount;         pool.numReceipts++;          Receipt storage receipt = pool.receipts[pool.numReceipts];         receipt.id = pool.numReceipts;         receipt.amountDepositedWei = amount;         receipt.timeDeposited = block.timestamp;         receipt.owner = msg.sender; ``` as you can see `pool.numReceipts++` and `pool.receipts[pool.numReceipts]` increase `numReceipts` and use it as receipts index. so receipnts will start from index `1`. This bug will cause that `getRewards(poolId, 0)` return `0` instead of reverting. any function that depend on reverting of `getRewards()` for uninitialized receipts can be excploited by sending `receipntId` as `0`. this function can be inside this contract or other contracts. (`withdraw` use `getRewards` and we will see that we can create `WithdrawalOccurred` event for `receiptsId` as 0)  ## Tools Used VIM  ## Recommended Mitigation Steps If you want to start from index `1` then add this line too to ensure `receipntId` is not `0` too: ``` require(receiptId > 0, 'Uninitialized receipt'); ``` or we could check for uninitialized receipnts with `owner` field as non-zero.   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleVesting.sol#L115 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L92   # Vulnerability details  ## Impact Contracts should clarify what is the intended behavior for Merkle trees with multiple leafs with the same address.   ## Recommended Mitigation Steps  There is 2 possible behaviors:   - either - what is currently done - you only authorize one claim per address, in which case the multiple leaf are here to give users a choice - for example you could use `MerkleVesting` to give users the choice between 2 sets of vesting parameters and have something close to `MerkleResistor`.  - either you use a mapping based on the leaf to store if a leaf has been claimed or not.    This behavior should be clarified in the comments at least, and made clear to merkle tree builders.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234   # Vulnerability details  ## Impact Pool owners can prevent withdrawals of specific receipts without impacting any other functionality  ## Proof of Concept Reciepts are non-transferrable, so a malicious owner can monitor the blockchain for receipt creations, and inspect which account holds the receiptId. Next, by changing settings in a custom reward token that reverts for specific addresses, the owner can prevent that specific receipt owner from withdrawing: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); 231           } 232    233           success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei); 234           require(success, 'Token transfer failed'); ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234  While the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a straight forward fix outlined below in the mitigation section  ## Tools Used Code inspection  ## Recommended Mitigation Steps Rather than reverting the whole withdrawal if only one transfer fails, return a boolean of whether all withdrawals were successful, and allow `withdraw()` to be called multiple times, keeping track of what has been transferred and what hasn't   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272   # Vulnerability details  ## Impact Pool owners can prevent taxes from being paid without impacting any other functionality  ## Proof of Concept By adding a custom reward token that always reverts for transfers to `globalBenericiary`, the owner can prevent taxes from being paid: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  258       /// @notice Withdraw taxes from pool 259       /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary 260       /// @param poolId which pool are we talking about? 261       function withdrawTaxes(uint poolId) external { 262           Pool storage pool = pools[poolId]; 263           require(pool.id == poolId, 'Uninitialized pool'); 264    265           bool success = true; 266           for (uint i = 0; i < pool.rewardTokens.length; i++) { 267               uint tax = taxes[poolId][i]; 268               taxes[poolId][i] = 0; 269               success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax); 270           } 271           require(success, 'Token transfer failed'); 272       } ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272  While the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a simple fix outlined below in the mitigation section  ## Tools Used Code inspection  ## Recommended Mitigation Steps Force taxes to be paid during `withdraw()`   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231   # Vulnerability details  ## Impact The `withdraw()` has an unbounded loop with external calls. If the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit (`transferFrom()`) is less than the gas cost of the withdrawal (`transfer()`), then the `withdraw()` function may revert due to exceeding the block size gas limit.  ## Proof of Concept `transfer()` is an external call, and `rewards.length` has no maximum size: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  224           for (uint i = 0; i < rewards.length; i++) { 225               pool.rewardsWeiClaimed[i] += rewards[i]; 226               pool.rewardFunding[i] -= rewards[i]; 227               uint tax = (pool.taxPerCapita * rewards[i]) / 1000; 228               uint transferAmount = rewards[i] - tax; 229               taxes[poolId][i] += tax; 230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); 231           } ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231  ## Tools Used Code inspection  ## Recommended Mitigation Steps Allow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L259 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L264   # Vulnerability details  ## Details & Impact  It is possible for `coinsPerSecond` to be zero. In these cases, the `startTime` calculation   ```solidity uint startTime = block.timestamp + vestingTime - (totalCoins / coinsPerSecond); ```  will revert from division by zero, preventing initialization, and by extension, withdrawals of vested tokens.  ## Proof of Concept  We assume vesting time chosen is the maximum (`tree.maxEndTime`) so that `totalCoins = maxTotalPayments`. These examples showcase some possibilities for which the calculated `coinsPerSecond` can be zero.  ### Example 1: High upfront percentage  - `pctUpFront = 99` (99% up front) - `totalCoins = 10_000e6` (10k USDC) - `vestingTime = 1 year`  ```solidity uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100); // 10_000e6 * (100 - 99) / (365 * 86400 * 100) // = 0 ```  ### Example 2: Small reward amount / token decimals  - `pctUpFront = 0` - `totalCoins = 100_000e2` (100k EURS) - `vestingTime = 180 days`  ```solidity uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100); // 100_000e2 * 100 / (180 * 86400 * 100) // = 0 ```  ## Recommended Mitigation Steps  Scale up `coinsPerSecond` by `PRECISION`, then scale down when executing withdrawals. While it isn’t foolproof, the possibility of `coinsPerSecond` being zero is reduced significantly.  ```solidity // L264 uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) * PRECISION / (vestingTime * 100);  // L184 currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond / PRECISION; ```  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L242-L256 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L234   # Vulnerability details  ## Impact  If one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token.  The impact of one user not being able to call `withdraw()` is that the owner will now never be able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner.  Thus, one malicious user may deliberately get them selves blacklisted to prevent the owner from claiming the final rewards. Since the attacker may do this with negligible balance in their `deposit()` this attack is very cheap.  ## Proof of Concept  It is possible for `IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);` to fail for numerous reasons. Such as if a user has been blacklisted (in certain ERC20 tokens) or if a token is paused or there is an attack and the token is stuck.  This will prevent `withdraw()` from being called.  ```solidity         for (uint i = 0; i < rewards.length; i++) {             pool.rewardsWeiClaimed[i] += rewards[i];             pool.rewardFunding[i] -= rewards[i];             uint tax = (pool.taxPerCapita * rewards[i]) / 1000;             uint transferAmount = rewards[i] - tax;             taxes[poolId][i] += tax;             success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);         }          success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);         require(success, 'Token transfer failed'); ```  Since line 245 of `withdrawExcessRewards()` requires that `require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');`, if one single user is unable to withdraw then it is impossible for the owner to claim the excess rewards and they are forever stuck in the contract.  ## Recommended Mitigation Steps  Consider allowing `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L245   # Vulnerability details  ## Impact  An attacker may cause a DoS attack on `withdrawExcessRewards()` by creating a excessive number of `receipts` with minimal value. Each of these receipts will need to be withdrawn before the owner can call `withdrawExcessRewards()`.   The impact is the owner would have to pay an unbounded amount of gas to `withdraw()` all the accounts and receive their excess funds.  ## Proof of Concept  `withdrawExcessRewards()` has the requirement that `totalDepositsWei` for the pool is zero before the owner may call this function as seen on line 245.  ```solidity         require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn'); ```  `pool.totalDepositsWei` is added to each time a user calls `deposit()`. It is increased by the amount the user deposits. There are no restrictions on the amount that may be deposited as a result a user may add 1 wei (or the smallest unit on any currency) which has negligible value.  The owner can force withdraw these accounts by calling `withdraw()` so long as `block.timestamp > pool.endTime`. They would be required to do this for each account that was created.  This could be a significant amount of gas costs, especially if the gas price has increased since the attacker originally made the deposits.  ## Recommended Mitigation Steps  Consider adding a minimum deposit amount for each pool that can be configured by the pool owner.  Alternatively, allow the owner to call `withdrawExcessRewards()` given some other criteria such as  - A fix period of time (e.g. 1 month) has passed since the end of the auction; and - 90% of the deposits have been withdrawn These criteria can be customised as desired by the design team.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L261-L272   # Vulnerability details  ## Impact  It is possible for the owner of a pool to prevent any taxes being withdrawn by the `globalBeneficiary`. The impact is the taxed tokens will be permanently locked in the contract and `withdrawTaxes()` will not be callable for that `poolId`.   ## Proof of Concept  The attack works by setting one of the `rewardTokenAddresses` to a malicious contract during `addPool()`. The malicious contract is set such that it will revert on the call `pool.rewardTokens[i]).transfer(globalBeneficiary, tax)` if an only if the `to` address is `globalBeneficiary.  The result of this attack is that if one reward transfer fails then entire `withdrawTaxes()` transaction will revert and no taxes can be claimed. However, the pool will function correctly for all other users.  ```solidity     function withdrawTaxes(uint poolId) external {         Pool storage pool = pools[poolId];         require(pool.id == poolId, 'Uninitialized pool');           bool success = true;         for (uint i = 0; i < pool.rewardTokens.length; i++) {             uint tax = taxes[poolId][i];             taxes[poolId][i] = 0;             success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);         }         require(success, 'Token transfer failed');     } ```  ## Recommended Mitigation Steps  There are a few mitigations to this issue.  The first is for the `withdrawTaxes()` function to take both `poolId` and `rewardIndex` as a parameters to allowing the tax beneficiary to only withdraw from certain reward tokens in the pool. This would allow the beneficiary to withdraw from all reward tokens except malicious ones.  The second mitigation is to implement a `try-catch` condition around the withdrawal of reward tokens. In the catch statement re-instate the `taxes[poolId][i] = tax` if the transfer fails. Alternatively just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82   # Vulnerability details  ## Impact The passThruGate function of the SpeedBumpPriceGate contract is used to charge NFT purchase fees. Since the price of NFT will change due to the previous purchase, users are likely to send more ether than the actual purchase price in order to ensure that they can purchase NFT. However, the passThruGate function did not return the excess ether, which would cause asset loss to the user. Consider the following scenario:  1. An NFT is sold for 0.15 eth 2. User A believes that the value of the NFT is acceptable within 0.3 eth, considering that someone may buy the NFT before him, so user A transfers 0.3 eth to buy the NFT 3. When user A's transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, user A actually spends 0.3 eth. ## Proof of Concept https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82 ## Tools Used None ## Recommended Mitigation Steps ``` -   function passThruGate(uint index, address) override external payable { +  function passThruGate(uint index, address payer) override external payable {         uint price = getCost(index);         require(msg.value >= price, 'Please send more ETH');          // bump up the price         Gate storage gate = gates[index];         // multiply by the price increase factor         gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;         // move up the reference         gate.lastPurchaseBlock = block.number;          // pass thru the ether         if (msg.value > 0) {             // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here -           (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(""); +          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}("");             require(sent, 'ETH transfer failed');         } +      if (msg.value - price > 0){  +         (bool sent, bytes memory data) = payer.call{value: msg.value - price}(""); +          require(sent, 'ETH transfer failed');}     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282   # Vulnerability details  ## Impact Contract `PermissionlessBasicPoolFactory` calculates rewards by using hardcoded value of decimals `18` (1e18) for ERC20 tokens. This leads to wrong rewards calculations and effectively loss of funds for all pools that will be using ERC20 tokens with different decimals than `18`. Example of such a token is USDC that has 6 decimals only.  ## Proof of Concept * https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169 * https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add support for different number of decimals than `18` by dynamically checking `decimals()` for the tokens that are part of the rewards calculations. Alternatively if such a support is not needed, new require statements should be added to `addPool` that will be checking that the number of decimals for all ERC20 tokens is `18`.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L137-L149   # Vulnerability details  ## Impact Every time transferFrom or transfer function in ERC20 standard is called there is a possibility that underlying smart contract did not transfer the exact amount entered. It is required to find out contract balance increase/decrease after the transfer. This pattern also prevents from re-entrancy attack vector.  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Recommended code: ```solidity function fundPool(uint poolId) internal {     Pool storage pool = pools[poolId];     bool success = true;     uint amount;     for (uint i = 0; i < pool.rewardFunding.length; i++) {         amount = getMaximumRewards(poolId, i);         // transfer the tokens from pool-creator to this contract           uint256 balanceBefore = IERC20(pool.rewardTokens[i]).balanceOf(address(this)); // remembering asset balance before the transfer         IERC20(pool.rewardTokens[i]).safeTransferFrom(msg.sender, address(this), amount);         uint256 newAmount = IERC20(pool.rewardTokens[i]).balanceOf(address(this)) - balanceBefore; // updating actual amount to the contract balance increase         success = success && newAmount == amount; // making sure amounts match          // bookkeeping to make sure pools don't share tokens         pool.rewardFunding[i] += amount;     }     require(success, 'Token deposits failed'); } ```  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144   # Vulnerability details  ## Impact  ERC20 standard allows transferF function of some contracts to return bool or return nothing. Some tokens such as USDT return nothing. This could lead to funds stuck in the contract without possibility to retrieve them. Using safeTransferFrom of SafeERC20.sol is recommended instead.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used   ## Recommended Mitigation Steps  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230   # Vulnerability details  ## Impact `PermissionlessBasicPoolFactory.withdraw` requires each reward token transfers to succeed before withdrawing the deposit. If one of the reward token is a malicious/pausable contract that reverts on transfer, unaware users that deposited into this pool will have their funds stuck in the contract.   ## Recommended Mitigation Steps Add an `emergencyWithdraw` function that ignores failed reward token transfers.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L156-L173   # Vulnerability details  ## Impact In `getRewards()` of `PermissionlessBasicPoolFactory` contract, there is a check to see that receipt is initialized receipt, but the condition used by code will be true for `receiptId` equal `0`. because `receiptId==0` is not initilized for any pool and the value of `pools[poolId].receipts[0].id` will be `0` so the condition `receipt.id == receiptId` will be passed on `getRewards()`. Any function that depends on `getRewards()` to check that if `receptId` has deposited fund, can be fooled. right now this bug has no direct money loss, but this function doesn't work as it suppose too.  ## Proof of Concept This is `getRewards()` code: ```     function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {         Pool storage pool = pools[poolId];         Receipt memory receipt = pool.receipts[receiptId];         require(pool.id == poolId, 'Uninitialized pool');         require(receipt.id == receiptId, 'Uninitialized receipt');         uint nowish = block.timestamp;         if (nowish > pool.endTime) {             nowish = pool.endTime;         }          uint secondsDiff = nowish - receipt.timeDeposited;         uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);         for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {             rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;         }         return rewardsLocal;     } ``` if the value of `receiptId` set as `0` then even so `receiptId==0` is not initialized but this line: ```         require(receipt.id == receiptId, 'Uninitialized receipt'); ``` will be passed, because, receipts start from number `1` and `pool.receipts[0]` will have zero value for his fields. This is the code in `deposit()` which is responsible for creating receipt objects. ```         pool.totalDepositsWei += amount;         pool.numReceipts++;          Receipt storage receipt = pool.receipts[pool.numReceipts];         receipt.id = pool.numReceipts;         receipt.amountDepositedWei = amount;         receipt.timeDeposited = block.timestamp;         receipt.owner = msg.sender; ``` as you can see `pool.numReceipts++` and `pool.receipts[pool.numReceipts]` increase `numReceipts` and use it as receipts index. so receipnts will start from index `1`. This bug will cause that `getRewards(poolId, 0)` return `0` instead of reverting. any function that depend on reverting of `getRewards()` for uninitialized receipts can be excploited by sending `receipntId` as `0`. this function can be inside this contract or other contracts. (`withdraw` use `getRewards` and we will see that we can create `WithdrawalOccurred` event for `receiptsId` as 0)  ## Tools Used VIM  ## Recommended Mitigation Steps If you want to start from index `1` then add this line too to ensure `receipntId` is not `0` too: ``` require(receiptId > 0, 'Uninitialized receipt'); ``` or we could check for uninitialized receipnts with `owner` field as non-zero.   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleVesting.sol#L115 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L92   # Vulnerability details  ## Impact Contracts should clarify what is the intended behavior for Merkle trees with multiple leafs with the same address.   ## Recommended Mitigation Steps  There is 2 possible behaviors:   - either - what is currently done - you only authorize one claim per address, in which case the multiple leaf are here to give users a choice - for example you could use `MerkleVesting` to give users the choice between 2 sets of vesting parameters and have something close to `MerkleResistor`.  - either you use a mapping based on the leaf to store if a leaf has been claimed or not.    This behavior should be clarified in the comments at least, and made clear to merkle tree builders.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234   # Vulnerability details  ## Impact Pool owners can prevent withdrawals of specific receipts without impacting any other functionality  ## Proof of Concept Reciepts are non-transferrable, so a malicious owner can monitor the blockchain for receipt creations, and inspect which account holds the receiptId. Next, by changing settings in a custom reward token that reverts for specific addresses, the owner can prevent that specific receipt owner from withdrawing: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); 231           } 232    233           success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei); 234           require(success, 'Token transfer failed'); ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234  While the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a straight forward fix outlined below in the mitigation section  ## Tools Used Code inspection  ## Recommended Mitigation Steps Rather than reverting the whole withdrawal if only one transfer fails, return a boolean of whether all withdrawals were successful, and allow `withdraw()` to be called multiple times, keeping track of what has been transferred and what hasn't   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272   # Vulnerability details  ## Impact Pool owners can prevent taxes from being paid without impacting any other functionality  ## Proof of Concept By adding a custom reward token that always reverts for transfers to `globalBenericiary`, the owner can prevent taxes from being paid: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  258       /// @notice Withdraw taxes from pool 259       /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary 260       /// @param poolId which pool are we talking about? 261       function withdrawTaxes(uint poolId) external { 262           Pool storage pool = pools[poolId]; 263           require(pool.id == poolId, 'Uninitialized pool'); 264    265           bool success = true; 266           for (uint i = 0; i < pool.rewardTokens.length; i++) { 267               uint tax = taxes[poolId][i]; 268               taxes[poolId][i] = 0; 269               success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax); 270           } 271           require(success, 'Token transfer failed'); 272       } ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272  While the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a simple fix outlined below in the mitigation section  ## Tools Used Code inspection  ## Recommended Mitigation Steps Force taxes to be paid during `withdraw()`   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231   # Vulnerability details  ## Impact The `withdraw()` has an unbounded loop with external calls. If the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit (`transferFrom()`) is less than the gas cost of the withdrawal (`transfer()`), then the `withdraw()` function may revert due to exceeding the block size gas limit.  ## Proof of Concept `transfer()` is an external call, and `rewards.length` has no maximum size: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  224           for (uint i = 0; i < rewards.length; i++) { 225               pool.rewardsWeiClaimed[i] += rewards[i]; 226               pool.rewardFunding[i] -= rewards[i]; 227               uint tax = (pool.taxPerCapita * rewards[i]) / 1000; 228               uint transferAmount = rewards[i] - tax; 229               taxes[poolId][i] += tax; 230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); 231           } ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231  ## Tools Used Code inspection  ## Recommended Mitigation Steps Allow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required   
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L259 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L264   # Vulnerability details  ## Details & Impact  It is possible for `coinsPerSecond` to be zero. In these cases, the `startTime` calculation   ```solidity uint startTime = block.timestamp + vestingTime - (totalCoins / coinsPerSecond); ```  will revert from division by zero, preventing initialization, and by extension, withdrawals of vested tokens.  ## Proof of Concept  We assume vesting time chosen is the maximum (`tree.maxEndTime`) so that `totalCoins = maxTotalPayments`. These examples showcase some possibilities for which the calculated `coinsPerSecond` can be zero.  ### Example 1: High upfront percentage  - `pctUpFront = 99` (99% up front) - `totalCoins = 10_000e6` (10k USDC) - `vestingTime = 1 year`  ```solidity uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100); // 10_000e6 * (100 - 99) / (365 * 86400 * 100) // = 0 ```  ### Example 2: Small reward amount / token decimals  - `pctUpFront = 0` - `totalCoins = 100_000e2` (100k EURS) - `vestingTime = 180 days`  ```solidity uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100); // 100_000e2 * 100 / (180 * 86400 * 100) // = 0 ```  ## Recommended Mitigation Steps  Scale up `coinsPerSecond` by `PRECISION`, then scale down when executing withdrawals. While it isn’t foolproof, the possibility of `coinsPerSecond` being zero is reduced significantly.  ```solidity // L264 uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) * PRECISION / (vestingTime * 100);  // L184 currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond / PRECISION; ```  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L242-L256 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L234   # Vulnerability details  ## Impact  If one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token.  The impact of one user not being able to call `withdraw()` is that the owner will now never be able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner.  Thus, one malicious user may deliberately get them selves blacklisted to prevent the owner from claiming the final rewards. Since the attacker may do this with negligible balance in their `deposit()` this attack is very cheap.  ## Proof of Concept  It is possible for `IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);` to fail for numerous reasons. Such as if a user has been blacklisted (in certain ERC20 tokens) or if a token is paused or there is an attack and the token is stuck.  This will prevent `withdraw()` from being called.  ```solidity         for (uint i = 0; i < rewards.length; i++) {             pool.rewardsWeiClaimed[i] += rewards[i];             pool.rewardFunding[i] -= rewards[i];             uint tax = (pool.taxPerCapita * rewards[i]) / 1000;             uint transferAmount = rewards[i] - tax;             taxes[poolId][i] += tax;             success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);         }          success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);         require(success, 'Token transfer failed'); ```  Since line 245 of `withdrawExcessRewards()` requires that `require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');`, if one single user is unable to withdraw then it is impossible for the owner to claim the excess rewards and they are forever stuck in the contract.  ## Recommended Mitigation Steps  Consider allowing `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L245   # Vulnerability details  ## Impact  An attacker may cause a DoS attack on `withdrawExcessRewards()` by creating a excessive number of `receipts` with minimal value. Each of these receipts will need to be withdrawn before the owner can call `withdrawExcessRewards()`.   The impact is the owner would have to pay an unbounded amount of gas to `withdraw()` all the accounts and receive their excess funds.  ## Proof of Concept  `withdrawExcessRewards()` has the requirement that `totalDepositsWei` for the pool is zero before the owner may call this function as seen on line 245.  ```solidity         require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn'); ```  `pool.totalDepositsWei` is added to each time a user calls `deposit()`. It is increased by the amount the user deposits. There are no restrictions on the amount that may be deposited as a result a user may add 1 wei (or the smallest unit on any currency) which has negligible value.  The owner can force withdraw these accounts by calling `withdraw()` so long as `block.timestamp > pool.endTime`. They would be required to do this for each account that was created.  This could be a significant amount of gas costs, especially if the gas price has increased since the attacker originally made the deposits.  ## Recommended Mitigation Steps  Consider adding a minimum deposit amount for each pool that can be configured by the pool owner.  Alternatively, allow the owner to call `withdrawExcessRewards()` given some other criteria such as  - A fix period of time (e.g. 1 month) has passed since the end of the auction; and - 90% of the deposits have been withdrawn These criteria can be customised as desired by the design team.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L261-L272   # Vulnerability details  ## Impact  It is possible for the owner of a pool to prevent any taxes being withdrawn by the `globalBeneficiary`. The impact is the taxed tokens will be permanently locked in the contract and `withdrawTaxes()` will not be callable for that `poolId`.   ## Proof of Concept  The attack works by setting one of the `rewardTokenAddresses` to a malicious contract during `addPool()`. The malicious contract is set such that it will revert on the call `pool.rewardTokens[i]).transfer(globalBeneficiary, tax)` if an only if the `to` address is `globalBeneficiary.  The result of this attack is that if one reward transfer fails then entire `withdrawTaxes()` transaction will revert and no taxes can be claimed. However, the pool will function correctly for all other users.  ```solidity     function withdrawTaxes(uint poolId) external {         Pool storage pool = pools[poolId];         require(pool.id == poolId, 'Uninitialized pool');           bool success = true;         for (uint i = 0; i < pool.rewardTokens.length; i++) {             uint tax = taxes[poolId][i];             taxes[poolId][i] = 0;             success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);         }         require(success, 'Token transfer failed');     } ```  ## Recommended Mitigation Steps  There are a few mitigations to this issue.  The first is for the `withdrawTaxes()` function to take both `poolId` and `rewardIndex` as a parameters to allowing the tax beneficiary to only withdraw from certain reward tokens in the pool. This would allow the beneficiary to withdraw from all reward tokens except malicious ones.  The second mitigation is to implement a `try-catch` condition around the withdrawal of reward tokens. In the catch statement re-instate the `taxes[poolId][i] = tax` if the transfer fails. Alternatively just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82   # Vulnerability details  ## Impact The passThruGate function of the SpeedBumpPriceGate contract is used to charge NFT purchase fees. Since the price of NFT will change due to the previous purchase, users are likely to send more ether than the actual purchase price in order to ensure that they can purchase NFT. However, the passThruGate function did not return the excess ether, which would cause asset loss to the user. Consider the following scenario:  1. An NFT is sold for 0.15 eth 2. User A believes that the value of the NFT is acceptable within 0.3 eth, considering that someone may buy the NFT before him, so user A transfers 0.3 eth to buy the NFT 3. When user A's transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, user A actually spends 0.3 eth. ## Proof of Concept https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82 ## Tools Used None ## Recommended Mitigation Steps ``` -   function passThruGate(uint index, address) override external payable { +  function passThruGate(uint index, address payer) override external payable {         uint price = getCost(index);         require(msg.value >= price, 'Please send more ETH');          // bump up the price         Gate storage gate = gates[index];         // multiply by the price increase factor         gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;         // move up the reference         gate.lastPurchaseBlock = block.number;          // pass thru the ether         if (msg.value > 0) {             // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here -           (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(""); +          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}("");             require(sent, 'ETH transfer failed');         } +      if (msg.value - price > 0){  +         (bool sent, bytes memory data) = payer.call{value: msg.value - price}(""); +          require(sent, 'ETH transfer failed');}     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282   # Vulnerability details  ## Impact Contract `PermissionlessBasicPoolFactory` calculates rewards by using hardcoded value of decimals `18` (1e18) for ERC20 tokens. This leads to wrong rewards calculations and effectively loss of funds for all pools that will be using ERC20 tokens with different decimals than `18`. Example of such a token is USDC that has 6 decimals only.  ## Proof of Concept * https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169 * https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add support for different number of decimals than `18` by dynamically checking `decimals()` for the tokens that are part of the rewards calculations. Alternatively if such a support is not needed, new require statements should be added to `addPool` that will be checking that the number of decimals for all ERC20 tokens is `18`.  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L137-L149   # Vulnerability details  ## Impact Every time transferFrom or transfer function in ERC20 standard is called there is a possibility that underlying smart contract did not transfer the exact amount entered. It is required to find out contract balance increase/decrease after the transfer. This pattern also prevents from re-entrancy attack vector.  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Recommended code: ```solidity function fundPool(uint poolId) internal {     Pool storage pool = pools[poolId];     bool success = true;     uint amount;     for (uint i = 0; i < pool.rewardFunding.length; i++) {         amount = getMaximumRewards(poolId, i);         // transfer the tokens from pool-creator to this contract           uint256 balanceBefore = IERC20(pool.rewardTokens[i]).balanceOf(address(this)); // remembering asset balance before the transfer         IERC20(pool.rewardTokens[i]).safeTransferFrom(msg.sender, address(this), amount);         uint256 newAmount = IERC20(pool.rewardTokens[i]).balanceOf(address(this)) - balanceBefore; // updating actual amount to the contract balance increase         success = success && newAmount == amount; // making sure amounts match          // bookkeeping to make sure pools don't share tokens         pool.rewardFunding[i] += amount;     }     require(success, 'Token deposits failed'); } ```  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144   # Vulnerability details  ## Impact  ERC20 standard allows transferF function of some contracts to return bool or return nothing. Some tokens such as USDT return nothing. This could lead to funds stuck in the contract without possibility to retrieve them. Using safeTransferFrom of SafeERC20.sol is recommended instead.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used   ## Recommended Mitigation Steps  
# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230   # Vulnerability details  ## Impact `PermissionlessBasicPoolFactory.withdraw` requires each reward token transfers to succeed before withdrawing the deposit. If one of the reward token is a malicious/pausable contract that reverts on transfer, unaware users that deposited into this pool will have their funds stuck in the contract.   ## Recommended Mitigation Steps Add an `emergencyWithdraw` function that ignores failed reward token transfers.  
