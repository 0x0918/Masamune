# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L356   # Vulnerability details  Unlike maxDiscount, minDiscount is missing some sanity checks: minDiscount should be smaller than MAX_BPS minDoscount should be smaller than maxDiscount  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L430-L437   # Vulnerability details  During the [video](https://drive.google.com/file/d/1hCzQrgZEsbd0t2mtuaXm7Cp3YS-ZIlw3/view?usp=sharing) it was explained that the policy operations team was meant to be a nimble group that could change protocol values considered to be safe. Further, it was explained that since pricing comes from an oracle, and there would have to be unusual coordination between the two to affect outcomes, the group was given the ability to clear the pricing flag to get things moving again once the price was determined to be valid  ## Impact If an oracle price falls out of the valid min/max range, the `citadelPriceFlag` is set to true, but the out-of-bounds value is not stored. If the policy operations team calls `clearCitadelPriceFlag()`, the stale price from before the flag will be used. Not only is it an issue because of stale prices, but this means the policy op team now has a way to affect pricing not under the control of the oracle (i.e. no unusual coordination required to affect an outcome). Incorrect pricing leads to incorrect asset valuations, and loss of funds.  ## Proof of Concept  The flag is set but the price is not stored File: src/Funding.sol (lines [427-437](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L427-L437)) ```solidity         if (             _citadelPriceInAsset < minCitadelPriceInAsset ||             _citadelPriceInAsset > maxCitadelPriceInAsset         ) {             citadelPriceFlag = true;             emit CitadelPriceFlag(                 _citadelPriceInAsset,                 minCitadelPriceInAsset,                 maxCitadelPriceInAsset             );         } else { ```  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always set the `citadelPriceInAsset`   
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109   # Vulnerability details  ## Impact When `vest` is called by xCTDL vault, the previous amount will re-lock according to the new vesting timeline. While this is as described in L127, `claimableBalance` might revert due to underflow if `vesting[recipient].claimedAmounts` > 0 because the user will need to vest the `claimedAmounts` again which should not be an expected behavior as it is already vested.  ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ``` https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109 ```         uint256 locked = vesting[recipient].lockedAmounts;         uint256 claimed = vesting[recipient].claimedAmounts;         if (block.timestamp >= vesting[recipient].unlockEnd) {             return locked - claimed;         }         return             ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /                 (vesting[recipient].unlockEnd -                     vesting[recipient].unlockBegin)) - claimed; ```  ## Recommended Mitigation Steps Reset claimedAmounts on new vest ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts -              vesting[recipient].claimedAmounts +             _amount;         vesting[recipient].claimedAmounts = 0         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ```  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769   # Vulnerability details  ## Impact The Funding contract's `deposit()` function uses the `getAmountOut()` function to determine how many citadel tokens the user should receive for their deposit. But, if no discount is set, the function always returns 0. Now the `deposit()` function tries to deposit 0 tokens for the user through the StakedCitadel contract. But, that function requires the number of tokens to be `!= 0`. The transaction reverts.  This means, that no deposits are possible. Unless there is a discount.  ## Proof of Concept `Funding.deposit()` calls `getAmountOut()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177  Here's the [`getAmountOut()` function](https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202): ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {         uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmountWithoutDiscount * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          // unless the above if block is executed, `citadelAmount_` is 0 when this line is executed.         // 0 = 0 / x         citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  Call to `StakedCitadel.depositFor()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184  require statement that makes the whole transaction revert: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769  ## Tools Used none  ## Recommended Mitigation Steps Change the `getAmountOut()` function to:  ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {          uint256 citadelAmount_ = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmount_ * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893   # Vulnerability details  ## Impact The StakedCitadel contract's `balance()` function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.  Since most of the funds will be located in the strategy, the vault's balance will be very low. Some of the issues that arise from this:  **You can't deposit to a vault that already minted shares but has no balance of the underlying token**:  1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob tries to deposit but the transaction fails because the contract tries to divide by zero: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890 (`pool == balance()`)  **You get more shares than you should** 1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob now first transfers 1 token to the vault so that the balance is now `1` instead of `0`. 5. Bob deposits 5 tokens. He receives `5 * 10 / 1 == 50` shares: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890  Now, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.  It simply breaks the whole accounting of the vault.  ## Proof of Concept The comment says that it should be vault's + strategy's balance: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295  Here's another vault from the badger team where the function is implemented correctly: https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262  ## Tools Used none  ## Recommended Mitigation Steps Add the strategy's balance to the return value of the`balance()` function like [here](https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262).  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204   # Vulnerability details  ## Impact `Function.buy` buys the tokens for whatever price is set as `tokenOutPrice`. This might lead to accidental collisions or front-running attacks when user is trying to buy the tokens and his transaction is being included after the transaction of changing the price of the token via `setTokenOutPrice`.  Scenario: 1. User wants to `buy` tokens and can see price `tokenOutPrice` 2. User likes the price and issues a transaction to `buy` tokens 3. At the same time `CONTRACT_GOVERNANCE_ROLE` account is increasing `tokenOutPrice` through `setTokenOutPrice` 4. `setTokenOutPrice` transaction is included before user's `buy` transaction 5. User buys tokens with the price he was not aware of  Another variation of this attack can be performed using front-running.  ## Proof of Concept * https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add additional parameter `uint256 believedPrice` to `KnightingRound.buy` function and check if `believedPrice` is equal to `tokenOutPrice`.  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/CitadelMinter.sol#L217   # Vulnerability details  ## Impact User can sandwich `mintAndDistribute` function if mintable is high enough - Deposit before - Withdraw after - Take after 21 days citadels  ## Proof of Concept `mintAndDistribute` increase a price of staking share, that allows to withdraw more than deposited. user takes part of distributed citadels, so different users have smaller profit from distribution  ## Tools Used  ## Recommended Mitigation Steps Call `mintAndDistribute` through flashbots  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830   # Vulnerability details  ## Impact In the _withdraw function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the _withdraw function to fail, so that the user cannot withdraw the tokens.  ```         IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);         token.safeTransfer(vesting, _amount);         ...     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external {         require(msg.sender == vault, "StakedCitadelVester: only xCTDL vault");         require(_amount > 0, "StakedCitadelVester: cannot vest 0");          vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;          emit Vest(             recipient,             vesting[recipient].lockedAmounts,             _unlockBegin,             vesting[recipient].unlockEnd         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/interfaces/citadel/IVesting.sol#L5  ## Tools Used None ## Recommended Mitigation Steps  Use the correct function name ``` interface IVesting {     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external; } ... IVesting(vesting).vest(msg.sender, _amount, block.timestamp); token.safeTransfer(vesting, _amount); ```  
Median Oracle code non-existent, yet file exists:  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/oracles/MedianOracle.sol
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L356   # Vulnerability details  Unlike maxDiscount, minDiscount is missing some sanity checks: minDiscount should be smaller than MAX_BPS minDoscount should be smaller than maxDiscount  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L430-L437   # Vulnerability details  During the [video](https://drive.google.com/file/d/1hCzQrgZEsbd0t2mtuaXm7Cp3YS-ZIlw3/view?usp=sharing) it was explained that the policy operations team was meant to be a nimble group that could change protocol values considered to be safe. Further, it was explained that since pricing comes from an oracle, and there would have to be unusual coordination between the two to affect outcomes, the group was given the ability to clear the pricing flag to get things moving again once the price was determined to be valid  ## Impact If an oracle price falls out of the valid min/max range, the `citadelPriceFlag` is set to true, but the out-of-bounds value is not stored. If the policy operations team calls `clearCitadelPriceFlag()`, the stale price from before the flag will be used. Not only is it an issue because of stale prices, but this means the policy op team now has a way to affect pricing not under the control of the oracle (i.e. no unusual coordination required to affect an outcome). Incorrect pricing leads to incorrect asset valuations, and loss of funds.  ## Proof of Concept  The flag is set but the price is not stored File: src/Funding.sol (lines [427-437](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L427-L437)) ```solidity         if (             _citadelPriceInAsset < minCitadelPriceInAsset ||             _citadelPriceInAsset > maxCitadelPriceInAsset         ) {             citadelPriceFlag = true;             emit CitadelPriceFlag(                 _citadelPriceInAsset,                 minCitadelPriceInAsset,                 maxCitadelPriceInAsset             );         } else { ```  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always set the `citadelPriceInAsset`   
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109   # Vulnerability details  ## Impact When `vest` is called by xCTDL vault, the previous amount will re-lock according to the new vesting timeline. While this is as described in L127, `claimableBalance` might revert due to underflow if `vesting[recipient].claimedAmounts` > 0 because the user will need to vest the `claimedAmounts` again which should not be an expected behavior as it is already vested.  ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ``` https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109 ```         uint256 locked = vesting[recipient].lockedAmounts;         uint256 claimed = vesting[recipient].claimedAmounts;         if (block.timestamp >= vesting[recipient].unlockEnd) {             return locked - claimed;         }         return             ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /                 (vesting[recipient].unlockEnd -                     vesting[recipient].unlockBegin)) - claimed; ```  ## Recommended Mitigation Steps Reset claimedAmounts on new vest ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts -              vesting[recipient].claimedAmounts +             _amount;         vesting[recipient].claimedAmounts = 0         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ```  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769   # Vulnerability details  ## Impact The Funding contract's `deposit()` function uses the `getAmountOut()` function to determine how many citadel tokens the user should receive for their deposit. But, if no discount is set, the function always returns 0. Now the `deposit()` function tries to deposit 0 tokens for the user through the StakedCitadel contract. But, that function requires the number of tokens to be `!= 0`. The transaction reverts.  This means, that no deposits are possible. Unless there is a discount.  ## Proof of Concept `Funding.deposit()` calls `getAmountOut()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177  Here's the [`getAmountOut()` function](https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202): ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {         uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmountWithoutDiscount * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          // unless the above if block is executed, `citadelAmount_` is 0 when this line is executed.         // 0 = 0 / x         citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  Call to `StakedCitadel.depositFor()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184  require statement that makes the whole transaction revert: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769  ## Tools Used none  ## Recommended Mitigation Steps Change the `getAmountOut()` function to:  ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {          uint256 citadelAmount_ = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmount_ * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893   # Vulnerability details  ## Impact The StakedCitadel contract's `balance()` function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.  Since most of the funds will be located in the strategy, the vault's balance will be very low. Some of the issues that arise from this:  **You can't deposit to a vault that already minted shares but has no balance of the underlying token**:  1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob tries to deposit but the transaction fails because the contract tries to divide by zero: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890 (`pool == balance()`)  **You get more shares than you should** 1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob now first transfers 1 token to the vault so that the balance is now `1` instead of `0`. 5. Bob deposits 5 tokens. He receives `5 * 10 / 1 == 50` shares: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890  Now, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.  It simply breaks the whole accounting of the vault.  ## Proof of Concept The comment says that it should be vault's + strategy's balance: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295  Here's another vault from the badger team where the function is implemented correctly: https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262  ## Tools Used none  ## Recommended Mitigation Steps Add the strategy's balance to the return value of the`balance()` function like [here](https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262).  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204   # Vulnerability details  ## Impact `Function.buy` buys the tokens for whatever price is set as `tokenOutPrice`. This might lead to accidental collisions or front-running attacks when user is trying to buy the tokens and his transaction is being included after the transaction of changing the price of the token via `setTokenOutPrice`.  Scenario: 1. User wants to `buy` tokens and can see price `tokenOutPrice` 2. User likes the price and issues a transaction to `buy` tokens 3. At the same time `CONTRACT_GOVERNANCE_ROLE` account is increasing `tokenOutPrice` through `setTokenOutPrice` 4. `setTokenOutPrice` transaction is included before user's `buy` transaction 5. User buys tokens with the price he was not aware of  Another variation of this attack can be performed using front-running.  ## Proof of Concept * https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add additional parameter `uint256 believedPrice` to `KnightingRound.buy` function and check if `believedPrice` is equal to `tokenOutPrice`.  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/CitadelMinter.sol#L217   # Vulnerability details  ## Impact User can sandwich `mintAndDistribute` function if mintable is high enough - Deposit before - Withdraw after - Take after 21 days citadels  ## Proof of Concept `mintAndDistribute` increase a price of staking share, that allows to withdraw more than deposited. user takes part of distributed citadels, so different users have smaller profit from distribution  ## Tools Used  ## Recommended Mitigation Steps Call `mintAndDistribute` through flashbots  
# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830   # Vulnerability details  ## Impact In the _withdraw function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the _withdraw function to fail, so that the user cannot withdraw the tokens.  ```         IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);         token.safeTransfer(vesting, _amount);         ...     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external {         require(msg.sender == vault, "StakedCitadelVester: only xCTDL vault");         require(_amount > 0, "StakedCitadelVester: cannot vest 0");          vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;          emit Vest(             recipient,             vesting[recipient].lockedAmounts,             _unlockBegin,             vesting[recipient].unlockEnd         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/interfaces/citadel/IVesting.sol#L5  ## Tools Used None ## Recommended Mitigation Steps  Use the correct function name ``` interface IVesting {     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external; } ... IVesting(vesting).vest(msg.sender, _amount, block.timestamp); token.safeTransfer(vesting, _amount); ```  
Median Oracle code non-existent, yet file exists:  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/oracles/MedianOracle.sol
