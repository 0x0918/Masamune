# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on storage access.  ## Proof of Concept  ```pos.market``` variable is being read up to three times from storage: https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L371  ## Recommended Mitigation Steps  Save the needed storage variable to memory and use it.  Now: ``` Position.Info storage pos = positions[_positionId]; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos.market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos.market]; ... IOverlayV1Market(pos.market).exitOI(... ```  To be: ``` Position.Info storage pos = positions[_positionId]; address memory pos_market = pos.market; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos_market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos_market]; ... IOverlayV1Market(pos_market).exitOI(... ```  
# Handle  hyh   # Vulnerability details  ## Impact  Actual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than value of fees stored.  This can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse be failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.  ## Proof of Concept  The fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.  https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311  ## Recommended Mitigation Steps  Adjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.  Now: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt; else _userValueAdjusted = 0; ```  To be: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) {  _userValueAdjusted -= _userDebt; } else {  _userValueAdjusted = 0;  _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0; } ```   
# Handle  pauliax   # Vulnerability details  ## Impact contract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address: ```solidity  IOverlayTokenNew immutable public ovl; ``` This variable is initialized in the constructor and fetched from the mothership contract: ```solidity   mothership = IOverlayV1Mothership(_mothership);   ovl = IOverlayV1Mothership(_mothership).ovl(); ``` ovl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address: ```solidity function setOVL (address _ovl) external onlyGovernor {     ovl = _ovl; } ```  OverlayV1OVLCollateral and OverlayV1Governance will still use this old cached value.  ## Recommended Mitigation Steps Consider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).  
# Handle  pauliax   # Vulnerability details  ## Impact Overlay uses OZ contracts version 4.3.2: ```yaml   dependencies:     - OpenZeppelin/openzeppelin-contracts@4.3.2 ``` and has a contract that inherits from ERC1155Supply: ```solidity   contract OverlayV1OVLCollateral is ERC1155Supply ``` This version has a recently discovered vulnerability: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg  In your case, function unwind relies on totalSupply when calculating _userNotional, _userDebt, _userCost, and _userOi, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.  ## Recommended Mitigation Steps Consider updating to a patched version of 4.3.3.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract OverlayTokenNew inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract OverlayTokenNew is Context ``` Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol  OverlayTokenNew mixes usage of msg.sender and _msgSender().  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.  
# Handle  pauliax   # Vulnerability details  ## Impact There are TODOs left in the code. While this does not cause any direct issue, it indicates a bad smell and uncertainty. In previous reports, such submissions were assigned a score of 'low' so I think it's a fair game to submit this as an issue here also.  Reference: https://github.com/code-423n4/2021-09-swivel-findings/issues/67 https://github.com/code-423n4/2021-10-tempus-findings/issues/39  Also, there are some misleading comments, e.g.: ```solidity     /// @notice Internal update function to price, cap, and pay funding.     function update () public virtual returns ( ``` the comment says that function is internal but it is actually declared as public.  ## Recommended Mitigation Steps Consider implementing or removing TODOs and updating misleading comments.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/OverlayV1UniswapV3Market.sol#L14-L14  ```solidity=14 uint256 internal X96 = 0x1000000000000000000000000; ```  Some storage variables include `X96` will not never be changed and they should not be.  Changing them to `constant` can save gas.  
# Handle  WatchPug   # Vulnerability details  Based on the context, `marginBurnRate` should be able to be updated after deployment. However, there is no function to update it.  ### Recommendation  Change to:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L158-L166  ```solidity=158 function adjustGlobalParams(     uint16 _fee,     uint16 _feeBurnRate,     address _feeTo,     uint _marginBurnRate ) external onlyGovernor {     fee = _fee;     feeBurnRate = _feeBurnRate;     feeTo = _feeTo;     marginBurnRate = _marginBurnRate; } ```  Or change `marginBurnRate` to immutable if it's not supposed to be updated later (for gas saving).  
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`. To get the market liquidity _in ETH_ (and not the other token pair), it uses the `ethIs0` boolean.  ```solidity _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  However, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the _market_ feed where the liquidity is taken from:  ```solidity // in constructor, if token0 is eth refers to ovlFeed ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;  // in fetchPricePoint, _liquidity comes from different market feed ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo); _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  ## Impact If the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted). For example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.  ## Recommended Mitigation Steps It seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.   
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.constructor` does not verify that the `marcoWindow > microWindow` but the code implicitly uses this assumption when computing the TWAPs.  ## Recommended Mitigation Steps Validate that `macroWindow > microWindow` in the constructor.   
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market` contract assumes that one of the tokens of `_ovlFeed` is ETH but does not check it in the constructor:  ```solidity constructor(     address _mothership,     address _ovlFeed,     address _marketFeed,     address _quote,     address _eth,     uint128 _baseAmount,     uint256 _macroWindow,     uint256 _microWindow,     uint256 _priceFrameCap ) OverlayV1Market (     _mothership ) OverlayV1Comptroller (     _microWindow ) OverlayV1OI (     _microWindow ) OverlayV1PricePoint (     _priceFrameCap ) {      // immutables     eth = _eth;     // could be that token1 is not ETH either     ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;     // ... } ```  ## Impact If `token0` is _not_ ETH, then it assumes `token1` is ETH but never validates this assumption. This could lead to wrong market liquidity and prices calculations if an `_ovlFeed` is supplied that is not actually the OVL/ETH feed.  ## Recommended Mitigation Steps Check that `(token0 == OVL && token1 == WETH) || (token1 == OVL && token0 == WETH)` for `_ovlFeed`.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function unwind() of OverlayV1OVLCollateral.sol a tmp variable _userOiShares is used the store the value of _shares. However _shares is still uses multiple times in the function.  Using _userOiShares everywhere would save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L273-L336  ```JS  function unwind (  uint256 _positionId,  uint256 _shares ) external {         require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), "OVLV1:!shares");    // uses _shares         ...         uint _userOiShares = _shares; // move to start of the function         uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;    // uses _shares         uint _userDebt = _shares * pos.debt / _totalPosShares;                                                          // uses _shares         uint _userCost = _shares * pos.cost / _totalPosShares;                                                           // uses _shares         uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;                                          // uses _shares ...         _burn(msg.sender, _positionId, _shares);   // uses _shares ```  ## Tools Used  ## Recommended Mitigation Steps Move "uint _userOiShares = _shares;" to the start of function unwind() Replace all other instances of "_shares" with "_userOiShares"    
# Handle  defsec   # Vulnerability details  ## Impact  In the adjustGlobalParams function on line 1603of "https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L1630", adjustGlobalParams function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFee function that begins on line 163 of adjustGlobalParams sets the liquidity and transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to "https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L163" contract and go to line #163. - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the adjustGlobalParams function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function value() of OverlayV1OVLCollateral.sol doesn't explicitly check for liquidated positions. However because oiShares and debt are set to 0 during liquidation the resulting value will still be 0.  It seems more logical to check for liquidation in the beginning of the function and immediately return 0. This saves gas for the situation where the function value() is called from another smart contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L424-L448 ``` function value (  uint _positionId ) public view returns ( uint256 value_) {         Position.Info storage pos = positions[_positionId];         IOverlayV1Market _market = IOverlayV1Market(pos.market);         (   uint _oi,  uint _oiShares,   uint _priceFrame ) = _market.positionInfo( pos.isLong, pos.pricePoint );         value_ = pos.value(  _oi, _oiShares,  _priceFrame ); } ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following to function value(): ```JS         if (pos.oiShares == 0) return 0; // liquidated ```    
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. In `OverlayV1OVLCollateral.sol`, `mothership.fee()` can be cached as a storage variable and save ~21000 gas each time.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L305-L305  ```solidity=305 uint _feeAmount = _userNotional.mulUp(mothership.fee()); ```  ## Recommendation  - Add a storage variable in `OverlayV1OVLCollateral.sol`; - Add a function `updateFee()` - Call `updateFee()` after `OverlayV1Mothership.sol#adjustGlobalParams()`  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you try to build a position and have set the _leverage accidentally to 0  (which can be done if you call the smart contract directly). Then the function build() will call enterOI() which will revert when trying to calculate debtAdjusted_ .  However no user friendly error message is given.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Market.sol ```JS function enterOI ( bool _isLong,  uint _collateral,  uint _leverage ) external onlyCollateral returns (...) {  ...         collateralAdjusted_ = _collateral - _impact - fee_;       // will be > 0         oiAdjusted_ = collateralAdjusted_ * _leverage;            // if _leverage==0 then oiAdjusted_  == 0         debtAdjusted_ = oiAdjusted_ - collateralAdjusted_;   // will be negative and thus will revert ```     ## Tools Used  ## Recommended Mitigation Steps Add something like the following to the function build() require(_leverage != 0, "OVLV1:leverage==0")  
# Handle  gpersoon   # Vulnerability details  ## Impact The function oiCap() of OverlayV1Comptroller.sol save the value of brrrrdExpected in a tmp variable _brrrrdExpected. Lateron brrrrdExpected is still used while _brrrrdExpected could also be used. This saves a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L255-L279  ```JS  function oiCap() public virtual view returns (  uint cap_ ) {     ...         uint _brrrrdExpected = brrrrdExpected;     ...         cap_ = _surpassed ? 0 : _burnt || _expected             ? _oiCap(false, depth(), staticCap, 0, 0)             : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected);  // can also use _brrrrdExpected  ``` ## Tools Used  ## Recommended Mitigation Steps Replace ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected); ``` with ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, _brrrrdExpected); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The function roll() of OverlayV1Comptroller.sol can be simplified. This saves some gas and also makes the function easier to read.  See below at "Recommended Mitigation Steps"  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L352-L385 ```JS function roll( Roller[60] storage rollers, Roller memory _roller, uint _lastMoment, uint _cycloid ) internal returns ( uint cycloid_) {         if (_roller.time != _lastMoment) {             _cycloid += 1;             if (_cycloid < CHORD) {                 rollers[_cycloid] = _roller;             } else {                 _cycloid = 0;                 rollers[_cycloid] = _roller;             }         } else {             rollers[_cycloid] = _roller;         }         cycloid_ = _cycloid;     } ```  ## Tools Used  ## Recommended Mitigation Steps Change the function to: ```JS     function roll (Roller[60] storage rollers,Roller memory _roller,uint _lastMoment,uint _cycloid) internal returns (uint cycloid_) {         if (_roller.time != _lastMoment)               _cycloid = (_cycloid + 1) % CHORD;                                       rollers[_cycloid] = _roller;         cycloid_ = _cycloid;     } ```    
# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier to save some gas for failure transactions.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L118-L137  ```solidity=119 function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (     bool success_ ) {      _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];      require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");      unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }      success_ = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L167-L186 ```solidity=167 function transferFromBurn(     address sender,     address recipient,     uint256 amount,     uint256 burnt ) public override onlyBurner returns (     bool success ) {      _transferBurn(sender, recipient, amount, burnt);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount + burnt, "OVL:allowance<amount+burnt");      unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }      success = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L241-L260 ```solidity=241 function transferFromMint(     address sender,     address recipient,     uint256 amount,     uint256 minted ) public override onlyMinter returns (     bool ) {      _transferMint(sender, recipient, amount, minted);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount, "OVL:allowance<amount");      unchecked { _approve(sender, msg.sender, currentAllowance - amount); }      return true;  } ```  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L75-L79  ```solidity function setOVL (address _ovl) external onlyGovernor {          ovl = _ovl;      } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L87-L116  ```solidity     function initializeMarket(address market) external onlyGovernor {          require(!marketExists[market], "OVLV1:!!initialized");          marketExists[market] = true;         marketActive[market] = true;          allMarkets.push(market);      }      /// @notice Disables an existing market contract for a mirin market     function disableMarket(address market) external onlyGovernor {          require(marketActive[market], "OVLV1: !enabled");          marketActive[market] = false;      }      /// @notice Enables an existing market contract for a mirin market     function enableMarket(address market) external onlyGovernor {          require(marketExists[market], "OVLV1: !exists");          require(!marketActive[market], "OVLV1: !disabled");          marketActive[market] = true;      } ```  And all functions in `OverlayV1Governance.sol`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply. Whereas the similar functions _mint() and _burn() do update _totalSupply.  This means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.  For the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see). But other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364 ```JS function _mint( address account, uint256 amount) internal virtual {    ...       _totalSupply += amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395 ```JS function _burn(address account, uint256 amount) internal virtual {    ...         _totalSupply -= amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286  ## Tools Used  ## Recommended Mitigation Steps Update _totalSupply  in _transferMint() and _transferBurn()   
# Handle  gpersoon   # Vulnerability details  ## Impact The function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false; But it does revoke the roles.  Now enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require. So you can never grant the roles again.  Note: enableCollateral also doesn't set collateralActive[_collateral] = true  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153  ```JS  function enableCollateral (address _collateral) external onlyGovernor {         require(collateralExists[_collateral], "OVLV1:!exists");         require(!collateralActive[_collateral], "OVLV1:!disabled");         OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     }      function disableCollateral (address _collateral) external onlyGovernor {         require(collateralActive[_collateral], "OVLV1:!enabled");         OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     } ```  ## Tools Used  ## Recommended Mitigation Steps In function enableCollateral() add the following (after the require): collateralActive[_collateral] = true;  In function disableCollateral add the following (after the require): collateralActive[_collateral] = false;  
# Handle  harleythedog   # Vulnerability details  ## Impact The function isUnderwater should return true iff the position value is < 0. In the case of a short position, this is when oi * (2 - priceFrame) - debt < 0 (based on the logic given in the _value function). Rearranging this equation, a short position is underwater iff oi * 2 < oi * priceFrame + debt. However, in the function _isUnderwater in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.  Fortunately, the V1 implementation of OverlayOVLCollateral does not directly use the isUnderwater function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:  // TODO: think through edge case of underwater position ... and fee adjustments ...  which hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.  ## Proof of Concept See code for _isUnderwater here: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70  Notice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that isUnder will be false, which is obviously incorrect).  Also, see the TODO comment here that shows isUndewater is important: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304   ## Tools Used Inspection  ## Recommended Mitigation Steps Flip the left and right side of the inequality for short positions in _isUnderwater.  
# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L261 https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L317  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I suggest removing the commented-out code or adding an explanation.  
# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  "@param" should be "@return" https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/market/OverlayV1Market.sol#L83-L85  Not sure what this comment is for maybe just needs to be deleted. https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L155  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the comments if the suggestions are valid.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/OverlayV1UniswapV3Market.sol#L171  _tickToPrice function has underscore even it is public function. Underscore is used to indicate internal or private functions.   ## Tools Used Manual  ## Recommended Mitigation Steps Change function to internal or private, or remove underscore if you want to keep it as public function.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on storage access.  ## Proof of Concept  ```pos.market``` variable is being read up to three times from storage: https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L371  ## Recommended Mitigation Steps  Save the needed storage variable to memory and use it.  Now: ``` Position.Info storage pos = positions[_positionId]; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos.market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos.market]; ... IOverlayV1Market(pos.market).exitOI(... ```  To be: ``` Position.Info storage pos = positions[_positionId]; address memory pos_market = pos.market; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos_market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos_market]; ... IOverlayV1Market(pos_market).exitOI(... ```  
# Handle  hyh   # Vulnerability details  ## Impact  Actual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than value of fees stored.  This can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse be failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.  ## Proof of Concept  The fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.  https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311  ## Recommended Mitigation Steps  Adjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.  Now: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt; else _userValueAdjusted = 0; ```  To be: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) {  _userValueAdjusted -= _userDebt; } else {  _userValueAdjusted = 0;  _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0; } ```   
# Handle  pauliax   # Vulnerability details  ## Impact contract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address: ```solidity  IOverlayTokenNew immutable public ovl; ``` This variable is initialized in the constructor and fetched from the mothership contract: ```solidity   mothership = IOverlayV1Mothership(_mothership);   ovl = IOverlayV1Mothership(_mothership).ovl(); ``` ovl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address: ```solidity function setOVL (address _ovl) external onlyGovernor {     ovl = _ovl; } ```  OverlayV1OVLCollateral and OverlayV1Governance will still use this old cached value.  ## Recommended Mitigation Steps Consider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).  
# Handle  pauliax   # Vulnerability details  ## Impact Overlay uses OZ contracts version 4.3.2: ```yaml   dependencies:     - OpenZeppelin/openzeppelin-contracts@4.3.2 ``` and has a contract that inherits from ERC1155Supply: ```solidity   contract OverlayV1OVLCollateral is ERC1155Supply ``` This version has a recently discovered vulnerability: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg  In your case, function unwind relies on totalSupply when calculating _userNotional, _userDebt, _userCost, and _userOi, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.  ## Recommended Mitigation Steps Consider updating to a patched version of 4.3.3.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract OverlayTokenNew inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract OverlayTokenNew is Context ``` Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol  OverlayTokenNew mixes usage of msg.sender and _msgSender().  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.  
# Handle  pauliax   # Vulnerability details  ## Impact There are TODOs left in the code. While this does not cause any direct issue, it indicates a bad smell and uncertainty. In previous reports, such submissions were assigned a score of 'low' so I think it's a fair game to submit this as an issue here also.  Reference: https://github.com/code-423n4/2021-09-swivel-findings/issues/67 https://github.com/code-423n4/2021-10-tempus-findings/issues/39  Also, there are some misleading comments, e.g.: ```solidity     /// @notice Internal update function to price, cap, and pay funding.     function update () public virtual returns ( ``` the comment says that function is internal but it is actually declared as public.  ## Recommended Mitigation Steps Consider implementing or removing TODOs and updating misleading comments.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/OverlayV1UniswapV3Market.sol#L14-L14  ```solidity=14 uint256 internal X96 = 0x1000000000000000000000000; ```  Some storage variables include `X96` will not never be changed and they should not be.  Changing them to `constant` can save gas.  
# Handle  WatchPug   # Vulnerability details  Based on the context, `marginBurnRate` should be able to be updated after deployment. However, there is no function to update it.  ### Recommendation  Change to:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L158-L166  ```solidity=158 function adjustGlobalParams(     uint16 _fee,     uint16 _feeBurnRate,     address _feeTo,     uint _marginBurnRate ) external onlyGovernor {     fee = _fee;     feeBurnRate = _feeBurnRate;     feeTo = _feeTo;     marginBurnRate = _marginBurnRate; } ```  Or change `marginBurnRate` to immutable if it's not supposed to be updated later (for gas saving).  
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`. To get the market liquidity _in ETH_ (and not the other token pair), it uses the `ethIs0` boolean.  ```solidity _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  However, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the _market_ feed where the liquidity is taken from:  ```solidity // in constructor, if token0 is eth refers to ovlFeed ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;  // in fetchPricePoint, _liquidity comes from different market feed ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo); _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  ## Impact If the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted). For example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.  ## Recommended Mitigation Steps It seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.   
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.constructor` does not verify that the `marcoWindow > microWindow` but the code implicitly uses this assumption when computing the TWAPs.  ## Recommended Mitigation Steps Validate that `macroWindow > microWindow` in the constructor.   
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market` contract assumes that one of the tokens of `_ovlFeed` is ETH but does not check it in the constructor:  ```solidity constructor(     address _mothership,     address _ovlFeed,     address _marketFeed,     address _quote,     address _eth,     uint128 _baseAmount,     uint256 _macroWindow,     uint256 _microWindow,     uint256 _priceFrameCap ) OverlayV1Market (     _mothership ) OverlayV1Comptroller (     _microWindow ) OverlayV1OI (     _microWindow ) OverlayV1PricePoint (     _priceFrameCap ) {      // immutables     eth = _eth;     // could be that token1 is not ETH either     ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;     // ... } ```  ## Impact If `token0` is _not_ ETH, then it assumes `token1` is ETH but never validates this assumption. This could lead to wrong market liquidity and prices calculations if an `_ovlFeed` is supplied that is not actually the OVL/ETH feed.  ## Recommended Mitigation Steps Check that `(token0 == OVL && token1 == WETH) || (token1 == OVL && token0 == WETH)` for `_ovlFeed`.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function unwind() of OverlayV1OVLCollateral.sol a tmp variable _userOiShares is used the store the value of _shares. However _shares is still uses multiple times in the function.  Using _userOiShares everywhere would save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L273-L336  ```JS  function unwind (  uint256 _positionId,  uint256 _shares ) external {         require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), "OVLV1:!shares");    // uses _shares         ...         uint _userOiShares = _shares; // move to start of the function         uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;    // uses _shares         uint _userDebt = _shares * pos.debt / _totalPosShares;                                                          // uses _shares         uint _userCost = _shares * pos.cost / _totalPosShares;                                                           // uses _shares         uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;                                          // uses _shares ...         _burn(msg.sender, _positionId, _shares);   // uses _shares ```  ## Tools Used  ## Recommended Mitigation Steps Move "uint _userOiShares = _shares;" to the start of function unwind() Replace all other instances of "_shares" with "_userOiShares"    
# Handle  defsec   # Vulnerability details  ## Impact  In the adjustGlobalParams function on line 1603of "https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L1630", adjustGlobalParams function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFee function that begins on line 163 of adjustGlobalParams sets the liquidity and transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to "https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L163" contract and go to line #163. - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the adjustGlobalParams function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function value() of OverlayV1OVLCollateral.sol doesn't explicitly check for liquidated positions. However because oiShares and debt are set to 0 during liquidation the resulting value will still be 0.  It seems more logical to check for liquidation in the beginning of the function and immediately return 0. This saves gas for the situation where the function value() is called from another smart contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L424-L448 ``` function value (  uint _positionId ) public view returns ( uint256 value_) {         Position.Info storage pos = positions[_positionId];         IOverlayV1Market _market = IOverlayV1Market(pos.market);         (   uint _oi,  uint _oiShares,   uint _priceFrame ) = _market.positionInfo( pos.isLong, pos.pricePoint );         value_ = pos.value(  _oi, _oiShares,  _priceFrame ); } ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following to function value(): ```JS         if (pos.oiShares == 0) return 0; // liquidated ```    
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. In `OverlayV1OVLCollateral.sol`, `mothership.fee()` can be cached as a storage variable and save ~21000 gas each time.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L305-L305  ```solidity=305 uint _feeAmount = _userNotional.mulUp(mothership.fee()); ```  ## Recommendation  - Add a storage variable in `OverlayV1OVLCollateral.sol`; - Add a function `updateFee()` - Call `updateFee()` after `OverlayV1Mothership.sol#adjustGlobalParams()`  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you try to build a position and have set the _leverage accidentally to 0  (which can be done if you call the smart contract directly). Then the function build() will call enterOI() which will revert when trying to calculate debtAdjusted_ .  However no user friendly error message is given.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Market.sol ```JS function enterOI ( bool _isLong,  uint _collateral,  uint _leverage ) external onlyCollateral returns (...) {  ...         collateralAdjusted_ = _collateral - _impact - fee_;       // will be > 0         oiAdjusted_ = collateralAdjusted_ * _leverage;            // if _leverage==0 then oiAdjusted_  == 0         debtAdjusted_ = oiAdjusted_ - collateralAdjusted_;   // will be negative and thus will revert ```     ## Tools Used  ## Recommended Mitigation Steps Add something like the following to the function build() require(_leverage != 0, "OVLV1:leverage==0")  
# Handle  gpersoon   # Vulnerability details  ## Impact The function oiCap() of OverlayV1Comptroller.sol save the value of brrrrdExpected in a tmp variable _brrrrdExpected. Lateron brrrrdExpected is still used while _brrrrdExpected could also be used. This saves a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L255-L279  ```JS  function oiCap() public virtual view returns (  uint cap_ ) {     ...         uint _brrrrdExpected = brrrrdExpected;     ...         cap_ = _surpassed ? 0 : _burnt || _expected             ? _oiCap(false, depth(), staticCap, 0, 0)             : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected);  // can also use _brrrrdExpected  ``` ## Tools Used  ## Recommended Mitigation Steps Replace ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected); ``` with ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, _brrrrdExpected); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The function roll() of OverlayV1Comptroller.sol can be simplified. This saves some gas and also makes the function easier to read.  See below at "Recommended Mitigation Steps"  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L352-L385 ```JS function roll( Roller[60] storage rollers, Roller memory _roller, uint _lastMoment, uint _cycloid ) internal returns ( uint cycloid_) {         if (_roller.time != _lastMoment) {             _cycloid += 1;             if (_cycloid < CHORD) {                 rollers[_cycloid] = _roller;             } else {                 _cycloid = 0;                 rollers[_cycloid] = _roller;             }         } else {             rollers[_cycloid] = _roller;         }         cycloid_ = _cycloid;     } ```  ## Tools Used  ## Recommended Mitigation Steps Change the function to: ```JS     function roll (Roller[60] storage rollers,Roller memory _roller,uint _lastMoment,uint _cycloid) internal returns (uint cycloid_) {         if (_roller.time != _lastMoment)               _cycloid = (_cycloid + 1) % CHORD;                                       rollers[_cycloid] = _roller;         cycloid_ = _cycloid;     } ```    
# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier to save some gas for failure transactions.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L118-L137  ```solidity=119 function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (     bool success_ ) {      _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];      require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");      unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }      success_ = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L167-L186 ```solidity=167 function transferFromBurn(     address sender,     address recipient,     uint256 amount,     uint256 burnt ) public override onlyBurner returns (     bool success ) {      _transferBurn(sender, recipient, amount, burnt);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount + burnt, "OVL:allowance<amount+burnt");      unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }      success = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L241-L260 ```solidity=241 function transferFromMint(     address sender,     address recipient,     uint256 amount,     uint256 minted ) public override onlyMinter returns (     bool ) {      _transferMint(sender, recipient, amount, minted);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount, "OVL:allowance<amount");      unchecked { _approve(sender, msg.sender, currentAllowance - amount); }      return true;  } ```  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L75-L79  ```solidity function setOVL (address _ovl) external onlyGovernor {          ovl = _ovl;      } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L87-L116  ```solidity     function initializeMarket(address market) external onlyGovernor {          require(!marketExists[market], "OVLV1:!!initialized");          marketExists[market] = true;         marketActive[market] = true;          allMarkets.push(market);      }      /// @notice Disables an existing market contract for a mirin market     function disableMarket(address market) external onlyGovernor {          require(marketActive[market], "OVLV1: !enabled");          marketActive[market] = false;      }      /// @notice Enables an existing market contract for a mirin market     function enableMarket(address market) external onlyGovernor {          require(marketExists[market], "OVLV1: !exists");          require(!marketActive[market], "OVLV1: !disabled");          marketActive[market] = true;      } ```  And all functions in `OverlayV1Governance.sol`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply. Whereas the similar functions _mint() and _burn() do update _totalSupply.  This means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.  For the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see). But other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364 ```JS function _mint( address account, uint256 amount) internal virtual {    ...       _totalSupply += amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395 ```JS function _burn(address account, uint256 amount) internal virtual {    ...         _totalSupply -= amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286  ## Tools Used  ## Recommended Mitigation Steps Update _totalSupply  in _transferMint() and _transferBurn()   
# Handle  gpersoon   # Vulnerability details  ## Impact The function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false; But it does revoke the roles.  Now enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require. So you can never grant the roles again.  Note: enableCollateral also doesn't set collateralActive[_collateral] = true  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153  ```JS  function enableCollateral (address _collateral) external onlyGovernor {         require(collateralExists[_collateral], "OVLV1:!exists");         require(!collateralActive[_collateral], "OVLV1:!disabled");         OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     }      function disableCollateral (address _collateral) external onlyGovernor {         require(collateralActive[_collateral], "OVLV1:!enabled");         OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     } ```  ## Tools Used  ## Recommended Mitigation Steps In function enableCollateral() add the following (after the require): collateralActive[_collateral] = true;  In function disableCollateral add the following (after the require): collateralActive[_collateral] = false;  
# Handle  harleythedog   # Vulnerability details  ## Impact The function isUnderwater should return true iff the position value is < 0. In the case of a short position, this is when oi * (2 - priceFrame) - debt < 0 (based on the logic given in the _value function). Rearranging this equation, a short position is underwater iff oi * 2 < oi * priceFrame + debt. However, in the function _isUnderwater in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.  Fortunately, the V1 implementation of OverlayOVLCollateral does not directly use the isUnderwater function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:  // TODO: think through edge case of underwater position ... and fee adjustments ...  which hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.  ## Proof of Concept See code for _isUnderwater here: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70  Notice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that isUnder will be false, which is obviously incorrect).  Also, see the TODO comment here that shows isUndewater is important: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304   ## Tools Used Inspection  ## Recommended Mitigation Steps Flip the left and right side of the inequality for short positions in _isUnderwater.  
# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L261 https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L317  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I suggest removing the commented-out code or adding an explanation.  
# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  "@param" should be "@return" https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/market/OverlayV1Market.sol#L83-L85  Not sure what this comment is for maybe just needs to be deleted. https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L155  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the comments if the suggestions are valid.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/OverlayV1UniswapV3Market.sol#L171  _tickToPrice function has underscore even it is public function. Underscore is used to indicate internal or private functions.   ## Tools Used Manual  ## Recommended Mitigation Steps Change function to internal or private, or remove underscore if you want to keep it as public function.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on storage access.  ## Proof of Concept  ```pos.market``` variable is being read up to three times from storage: https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L371  ## Recommended Mitigation Steps  Save the needed storage variable to memory and use it.  Now: ``` Position.Info storage pos = positions[_positionId]; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos.market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos.market]; ... IOverlayV1Market(pos.market).exitOI(... ```  To be: ``` Position.Info storage pos = positions[_positionId]; address memory pos_market = pos.market; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos_market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos_market]; ... IOverlayV1Market(pos_market).exitOI(... ```  
# Handle  hyh   # Vulnerability details  ## Impact  Actual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than value of fees stored.  This can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse be failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.  ## Proof of Concept  The fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.  https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311  ## Recommended Mitigation Steps  Adjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.  Now: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt; else _userValueAdjusted = 0; ```  To be: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) {  _userValueAdjusted -= _userDebt; } else {  _userValueAdjusted = 0;  _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0; } ```   
# Handle  pauliax   # Vulnerability details  ## Impact contract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address: ```solidity  IOverlayTokenNew immutable public ovl; ``` This variable is initialized in the constructor and fetched from the mothership contract: ```solidity   mothership = IOverlayV1Mothership(_mothership);   ovl = IOverlayV1Mothership(_mothership).ovl(); ``` ovl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address: ```solidity function setOVL (address _ovl) external onlyGovernor {     ovl = _ovl; } ```  OverlayV1OVLCollateral and OverlayV1Governance will still use this old cached value.  ## Recommended Mitigation Steps Consider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).  
# Handle  pauliax   # Vulnerability details  ## Impact Overlay uses OZ contracts version 4.3.2: ```yaml   dependencies:     - OpenZeppelin/openzeppelin-contracts@4.3.2 ``` and has a contract that inherits from ERC1155Supply: ```solidity   contract OverlayV1OVLCollateral is ERC1155Supply ``` This version has a recently discovered vulnerability: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg  In your case, function unwind relies on totalSupply when calculating _userNotional, _userDebt, _userCost, and _userOi, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.  ## Recommended Mitigation Steps Consider updating to a patched version of 4.3.3.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract OverlayTokenNew inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract OverlayTokenNew is Context ``` Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol  OverlayTokenNew mixes usage of msg.sender and _msgSender().  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.  
# Handle  pauliax   # Vulnerability details  ## Impact There are TODOs left in the code. While this does not cause any direct issue, it indicates a bad smell and uncertainty. In previous reports, such submissions were assigned a score of 'low' so I think it's a fair game to submit this as an issue here also.  Reference: https://github.com/code-423n4/2021-09-swivel-findings/issues/67 https://github.com/code-423n4/2021-10-tempus-findings/issues/39  Also, there are some misleading comments, e.g.: ```solidity     /// @notice Internal update function to price, cap, and pay funding.     function update () public virtual returns ( ``` the comment says that function is internal but it is actually declared as public.  ## Recommended Mitigation Steps Consider implementing or removing TODOs and updating misleading comments.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/OverlayV1UniswapV3Market.sol#L14-L14  ```solidity=14 uint256 internal X96 = 0x1000000000000000000000000; ```  Some storage variables include `X96` will not never be changed and they should not be.  Changing them to `constant` can save gas.  
# Handle  WatchPug   # Vulnerability details  Based on the context, `marginBurnRate` should be able to be updated after deployment. However, there is no function to update it.  ### Recommendation  Change to:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L158-L166  ```solidity=158 function adjustGlobalParams(     uint16 _fee,     uint16 _feeBurnRate,     address _feeTo,     uint _marginBurnRate ) external onlyGovernor {     fee = _fee;     feeBurnRate = _feeBurnRate;     feeTo = _feeTo;     marginBurnRate = _marginBurnRate; } ```  Or change `marginBurnRate` to immutable if it's not supposed to be updated later (for gas saving).  
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`. To get the market liquidity _in ETH_ (and not the other token pair), it uses the `ethIs0` boolean.  ```solidity _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  However, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the _market_ feed where the liquidity is taken from:  ```solidity // in constructor, if token0 is eth refers to ovlFeed ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;  // in fetchPricePoint, _liquidity comes from different market feed ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo); _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  ## Impact If the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted). For example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.  ## Recommended Mitigation Steps It seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.   
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.constructor` does not verify that the `marcoWindow > microWindow` but the code implicitly uses this assumption when computing the TWAPs.  ## Recommended Mitigation Steps Validate that `macroWindow > microWindow` in the constructor.   
# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market` contract assumes that one of the tokens of `_ovlFeed` is ETH but does not check it in the constructor:  ```solidity constructor(     address _mothership,     address _ovlFeed,     address _marketFeed,     address _quote,     address _eth,     uint128 _baseAmount,     uint256 _macroWindow,     uint256 _microWindow,     uint256 _priceFrameCap ) OverlayV1Market (     _mothership ) OverlayV1Comptroller (     _microWindow ) OverlayV1OI (     _microWindow ) OverlayV1PricePoint (     _priceFrameCap ) {      // immutables     eth = _eth;     // could be that token1 is not ETH either     ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;     // ... } ```  ## Impact If `token0` is _not_ ETH, then it assumes `token1` is ETH but never validates this assumption. This could lead to wrong market liquidity and prices calculations if an `_ovlFeed` is supplied that is not actually the OVL/ETH feed.  ## Recommended Mitigation Steps Check that `(token0 == OVL && token1 == WETH) || (token1 == OVL && token0 == WETH)` for `_ovlFeed`.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function unwind() of OverlayV1OVLCollateral.sol a tmp variable _userOiShares is used the store the value of _shares. However _shares is still uses multiple times in the function.  Using _userOiShares everywhere would save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L273-L336  ```JS  function unwind (  uint256 _positionId,  uint256 _shares ) external {         require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), "OVLV1:!shares");    // uses _shares         ...         uint _userOiShares = _shares; // move to start of the function         uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;    // uses _shares         uint _userDebt = _shares * pos.debt / _totalPosShares;                                                          // uses _shares         uint _userCost = _shares * pos.cost / _totalPosShares;                                                           // uses _shares         uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;                                          // uses _shares ...         _burn(msg.sender, _positionId, _shares);   // uses _shares ```  ## Tools Used  ## Recommended Mitigation Steps Move "uint _userOiShares = _shares;" to the start of function unwind() Replace all other instances of "_shares" with "_userOiShares"    
# Handle  defsec   # Vulnerability details  ## Impact  In the adjustGlobalParams function on line 1603of "https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L1630", adjustGlobalParams function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFee function that begins on line 163 of adjustGlobalParams sets the liquidity and transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to "https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L163" contract and go to line #163. - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the adjustGlobalParams function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function value() of OverlayV1OVLCollateral.sol doesn't explicitly check for liquidated positions. However because oiShares and debt are set to 0 during liquidation the resulting value will still be 0.  It seems more logical to check for liquidation in the beginning of the function and immediately return 0. This saves gas for the situation where the function value() is called from another smart contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L424-L448 ``` function value (  uint _positionId ) public view returns ( uint256 value_) {         Position.Info storage pos = positions[_positionId];         IOverlayV1Market _market = IOverlayV1Market(pos.market);         (   uint _oi,  uint _oiShares,   uint _priceFrame ) = _market.positionInfo( pos.isLong, pos.pricePoint );         value_ = pos.value(  _oi, _oiShares,  _priceFrame ); } ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following to function value(): ```JS         if (pos.oiShares == 0) return 0; // liquidated ```    
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. In `OverlayV1OVLCollateral.sol`, `mothership.fee()` can be cached as a storage variable and save ~21000 gas each time.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L305-L305  ```solidity=305 uint _feeAmount = _userNotional.mulUp(mothership.fee()); ```  ## Recommendation  - Add a storage variable in `OverlayV1OVLCollateral.sol`; - Add a function `updateFee()` - Call `updateFee()` after `OverlayV1Mothership.sol#adjustGlobalParams()`  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you try to build a position and have set the _leverage accidentally to 0  (which can be done if you call the smart contract directly). Then the function build() will call enterOI() which will revert when trying to calculate debtAdjusted_ .  However no user friendly error message is given.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Market.sol ```JS function enterOI ( bool _isLong,  uint _collateral,  uint _leverage ) external onlyCollateral returns (...) {  ...         collateralAdjusted_ = _collateral - _impact - fee_;       // will be > 0         oiAdjusted_ = collateralAdjusted_ * _leverage;            // if _leverage==0 then oiAdjusted_  == 0         debtAdjusted_ = oiAdjusted_ - collateralAdjusted_;   // will be negative and thus will revert ```     ## Tools Used  ## Recommended Mitigation Steps Add something like the following to the function build() require(_leverage != 0, "OVLV1:leverage==0")  
# Handle  gpersoon   # Vulnerability details  ## Impact The function oiCap() of OverlayV1Comptroller.sol save the value of brrrrdExpected in a tmp variable _brrrrdExpected. Lateron brrrrdExpected is still used while _brrrrdExpected could also be used. This saves a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L255-L279  ```JS  function oiCap() public virtual view returns (  uint cap_ ) {     ...         uint _brrrrdExpected = brrrrdExpected;     ...         cap_ = _surpassed ? 0 : _burnt || _expected             ? _oiCap(false, depth(), staticCap, 0, 0)             : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected);  // can also use _brrrrdExpected  ``` ## Tools Used  ## Recommended Mitigation Steps Replace ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected); ``` with ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, _brrrrdExpected); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The function roll() of OverlayV1Comptroller.sol can be simplified. This saves some gas and also makes the function easier to read.  See below at "Recommended Mitigation Steps"  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L352-L385 ```JS function roll( Roller[60] storage rollers, Roller memory _roller, uint _lastMoment, uint _cycloid ) internal returns ( uint cycloid_) {         if (_roller.time != _lastMoment) {             _cycloid += 1;             if (_cycloid < CHORD) {                 rollers[_cycloid] = _roller;             } else {                 _cycloid = 0;                 rollers[_cycloid] = _roller;             }         } else {             rollers[_cycloid] = _roller;         }         cycloid_ = _cycloid;     } ```  ## Tools Used  ## Recommended Mitigation Steps Change the function to: ```JS     function roll (Roller[60] storage rollers,Roller memory _roller,uint _lastMoment,uint _cycloid) internal returns (uint cycloid_) {         if (_roller.time != _lastMoment)               _cycloid = (_cycloid + 1) % CHORD;                                       rollers[_cycloid] = _roller;         cycloid_ = _cycloid;     } ```    
# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier to save some gas for failure transactions.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L118-L137  ```solidity=119 function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (     bool success_ ) {      _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];      require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");      unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }      success_ = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L167-L186 ```solidity=167 function transferFromBurn(     address sender,     address recipient,     uint256 amount,     uint256 burnt ) public override onlyBurner returns (     bool success ) {      _transferBurn(sender, recipient, amount, burnt);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount + burnt, "OVL:allowance<amount+burnt");      unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }      success = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L241-L260 ```solidity=241 function transferFromMint(     address sender,     address recipient,     uint256 amount,     uint256 minted ) public override onlyMinter returns (     bool ) {      _transferMint(sender, recipient, amount, minted);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount, "OVL:allowance<amount");      unchecked { _approve(sender, msg.sender, currentAllowance - amount); }      return true;  } ```  
# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L75-L79  ```solidity function setOVL (address _ovl) external onlyGovernor {          ovl = _ovl;      } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L87-L116  ```solidity     function initializeMarket(address market) external onlyGovernor {          require(!marketExists[market], "OVLV1:!!initialized");          marketExists[market] = true;         marketActive[market] = true;          allMarkets.push(market);      }      /// @notice Disables an existing market contract for a mirin market     function disableMarket(address market) external onlyGovernor {          require(marketActive[market], "OVLV1: !enabled");          marketActive[market] = false;      }      /// @notice Enables an existing market contract for a mirin market     function enableMarket(address market) external onlyGovernor {          require(marketExists[market], "OVLV1: !exists");          require(!marketActive[market], "OVLV1: !disabled");          marketActive[market] = true;      } ```  And all functions in `OverlayV1Governance.sol`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply. Whereas the similar functions _mint() and _burn() do update _totalSupply.  This means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.  For the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see). But other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364 ```JS function _mint( address account, uint256 amount) internal virtual {    ...       _totalSupply += amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395 ```JS function _burn(address account, uint256 amount) internal virtual {    ...         _totalSupply -= amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286  ## Tools Used  ## Recommended Mitigation Steps Update _totalSupply  in _transferMint() and _transferBurn()   
# Handle  gpersoon   # Vulnerability details  ## Impact The function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false; But it does revoke the roles.  Now enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require. So you can never grant the roles again.  Note: enableCollateral also doesn't set collateralActive[_collateral] = true  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153  ```JS  function enableCollateral (address _collateral) external onlyGovernor {         require(collateralExists[_collateral], "OVLV1:!exists");         require(!collateralActive[_collateral], "OVLV1:!disabled");         OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     }      function disableCollateral (address _collateral) external onlyGovernor {         require(collateralActive[_collateral], "OVLV1:!enabled");         OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     } ```  ## Tools Used  ## Recommended Mitigation Steps In function enableCollateral() add the following (after the require): collateralActive[_collateral] = true;  In function disableCollateral add the following (after the require): collateralActive[_collateral] = false;  
# Handle  harleythedog   # Vulnerability details  ## Impact The function isUnderwater should return true iff the position value is < 0. In the case of a short position, this is when oi * (2 - priceFrame) - debt < 0 (based on the logic given in the _value function). Rearranging this equation, a short position is underwater iff oi * 2 < oi * priceFrame + debt. However, in the function _isUnderwater in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.  Fortunately, the V1 implementation of OverlayOVLCollateral does not directly use the isUnderwater function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:  // TODO: think through edge case of underwater position ... and fee adjustments ...  which hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.  ## Proof of Concept See code for _isUnderwater here: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70  Notice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that isUnder will be false, which is obviously incorrect).  Also, see the TODO comment here that shows isUndewater is important: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304   ## Tools Used Inspection  ## Recommended Mitigation Steps Flip the left and right side of the inequality for short positions in _isUnderwater.  
# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L261 https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L317  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I suggest removing the commented-out code or adding an explanation.  
# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  "@param" should be "@return" https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/market/OverlayV1Market.sol#L83-L85  Not sure what this comment is for maybe just needs to be deleted. https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L155  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the comments if the suggestions are valid.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/OverlayV1UniswapV3Market.sol#L171  _tickToPrice function has underscore even it is public function. Underscore is used to indicate internal or private functions.   ## Tools Used Manual  ## Recommended Mitigation Steps Change function to internal or private, or remove underscore if you want to keep it as public function.  
