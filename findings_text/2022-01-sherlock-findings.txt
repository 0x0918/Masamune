# Handle  danb   # Vulnerability details  all external function which are not onlyOwner have whenNotPaused modifier. but transfer doesn't have it (Sherlok is ERC721). https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L366  this was very important during the exploit to badger dao: https://mobile.twitter.com/flashfish0x/status/1466369783016869892  i suggest you add whenNotPaused to _beforeTokenTransfer    
# Handle  GreyArt   # Vulnerability details  ## Impact  Other relevant view functions like `lockupEnd()`, `sherRewards()` and `tokenBalanceOf()` revert for non-existent IDs, but `viewRewardForArbRestake()` doesn’t.  ## Recommended Mitigation Steps  Include the existence check in `viewRewardForArbRestake()`.  `if (!_exists(_tokenID)) revert NonExistent();`  
# Handle  hyh   # Vulnerability details  ## Impact  Sucessfull `arbRestake` performs `_redeemShares` for `arbRewardShares` amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the `addressShares` of an `nftOwner`.  As a result the `tokenBalanceOfAddress` function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from `addressShares` in `_beforeTokenTransfer`, leaving the arbitrage removed shares permanently in `addressShares` of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.  ## Proof of Concept  `arbRestake` redeems `arbRewardShares`, which are a part of total shares of an NFT:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L673   This will effectively reduce the `stakeShares`:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L491  But there is no mechanics in place to reduce `addressShares` of the owner apart from mint/burn/transfer, so `addressShares` will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.   ## Recommended Mitigation Steps  Add a flag to `_redeemShares` indicating that it was called for a partial shares decrease, say `isPartialRedeem`, and do `addressShares[nftOwner] -= _stakeShares` when `isPartialRedeem == true`.  Another option is to do bigger refactoring, making stakeShares and addressShares always change simultaneously.   
# Handle  kirk-baird   # Vulnerability details  ## Impact  This is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.  Note: this attack requires gaining control of execution `sher.transfer()` which will depend on the implementation of the SHER token. Control may be gained by the attacker if the contract implements ERC777 or otherwise makes external calls during `transfer()`.  ## Proof of Concept  See [_sendSherRewards](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L442)  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);     // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];   } ```  Here `sherRewards` are deleted after the potential external call is made in `sher.safeTransfer()`. As a result if an attacker reenters this function `sherRewards_` they will still maintain the original balance of rewards and again transfer the SHER tokens.  As `_sendSherRewardsToOwner()` is `internal` the attack can be initiated through the `external` function `ownerRestake()` [see here.](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L595)  Steps to produce the attack:  1) Deploy attack contract to handle reenterancy 2) Call `initialStake()` from the attack contract with the smallest `period` 3) Wait for `period` amount of time to pass 4) Have the attack contract call `ownerRestake()`. The attack contract will gain control of the (See note above about control flow). This will recursively call `ownerRestake()` until the balance of `Sherlock` is 0 or less than the user's reward amount. Then allow reentrancy loop to unwind and complete.  ## Tools Used  n/a  ## Recommended Mitigation Steps  Reentrancy can be mitigated by one of two solutions.  The first option is to add a reentrancy guard like `nonReentrant` the is used in `SherlockClaimManager.sol`.  The second option is to use the checks-effects-interactions pattern. This would involve doing all validation checks and state changes before making any potential external calls. For example the above function could be modified as follows.  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);   } ```  Additionally the following functions are not exploitable however should be updated to use the check-effects-interations pattern. - `Sherlock._redeemShares()` should do `_transferTokensOut()` last. - `Sherlock.initialStake()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` last - `SherClaim.add()` should do `sher.safeTransferFrom(msg.sender, address(this), _amount);` after updating `userClaims`  - `SherlockProtocolManager.depositToActiveBalance()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` after updating `activeBalances`    
# Handle  egjlmn1   # Vulnerability details  ## Impact A user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally. This attack is possible because you enable staking a small amount of tokens.  ## Proof of Concept See the following attack: 1. the first user (user A) who enters the system stake 1 token 2. another user (user B) is about to stake X tokens 3. user A frontrun and transfer X tokens to the system via `ERC20.transfer` 4. user B stakes X tokens, and the shares he receives is: `shares = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);` `shares = (X * 1) / (X + 1 + X - X) = X/(X+1) = 0` meaning all the tokens he staked got him no shares, and those tokens are now a part of the single share that user A holds 5. user A can now redeem his shares and get the 1 token he staked, the X tokens user B staked, and the X tokens he `ERC20.transfer` to the system because all the money in the system is in a single share that user A holds.  In general, since there is only a single share, for any user who is going to stake X tokens, if the system has X+1 tokens in its balance, the user won't get any shares and all the money will go to the attacker.  ## Tools Used Manual code review  ## Recommended Mitigation Steps Force users to stake at least some amount in the system (Uniswap forces users to pay at least `1e18`) That way the amount the attacker will need to ERC20.transfer to the system will be at least `X*1e18` instead of `X` which is unrealistic  
# Handle  robee   # Vulnerability details  You use safeApprove of openZeppelin although it's deprecated.  (see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38) You should change it to increase/decrease Allowance as OpenZeppilin says. This appears in the following locations in the code base:          Deprecated safeApprove in AaveV2Strategy.sol line 70: want.safeApprove(address(lp), type(uint256).max);          Deprecated safeApprove in SherlockClaimManager.sol line 421: TOKEN.safeApprove(address(UMA), _amount);          Deprecated safeApprove in SherlockClaimManager.sol line 464: TOKEN.safeApprove(address(UMA), 0);          Deprecated safeApprove in SherBuy.sol line 99: usdc.approve(address(sherlockPosition), type(uint256).max);          Deprecated safeApprove in SherBuy.sol line 169: sher.approve(address(sherClaim), sherAmount);    
# Handle  danb   # Vulnerability details  all external function which are not onlyOwner have whenNotPaused modifier. but transfer doesn't have it (Sherlok is ERC721). https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L366  this was very important during the exploit to badger dao: https://mobile.twitter.com/flashfish0x/status/1466369783016869892  i suggest you add whenNotPaused to _beforeTokenTransfer    
# Handle  GreyArt   # Vulnerability details  ## Impact  Other relevant view functions like `lockupEnd()`, `sherRewards()` and `tokenBalanceOf()` revert for non-existent IDs, but `viewRewardForArbRestake()` doesn’t.  ## Recommended Mitigation Steps  Include the existence check in `viewRewardForArbRestake()`.  `if (!_exists(_tokenID)) revert NonExistent();`  
# Handle  hyh   # Vulnerability details  ## Impact  Sucessfull `arbRestake` performs `_redeemShares` for `arbRewardShares` amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the `addressShares` of an `nftOwner`.  As a result the `tokenBalanceOfAddress` function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from `addressShares` in `_beforeTokenTransfer`, leaving the arbitrage removed shares permanently in `addressShares` of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.  ## Proof of Concept  `arbRestake` redeems `arbRewardShares`, which are a part of total shares of an NFT:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L673   This will effectively reduce the `stakeShares`:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L491  But there is no mechanics in place to reduce `addressShares` of the owner apart from mint/burn/transfer, so `addressShares` will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.   ## Recommended Mitigation Steps  Add a flag to `_redeemShares` indicating that it was called for a partial shares decrease, say `isPartialRedeem`, and do `addressShares[nftOwner] -= _stakeShares` when `isPartialRedeem == true`.  Another option is to do bigger refactoring, making stakeShares and addressShares always change simultaneously.   
# Handle  kirk-baird   # Vulnerability details  ## Impact  This is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.  Note: this attack requires gaining control of execution `sher.transfer()` which will depend on the implementation of the SHER token. Control may be gained by the attacker if the contract implements ERC777 or otherwise makes external calls during `transfer()`.  ## Proof of Concept  See [_sendSherRewards](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L442)  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);     // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];   } ```  Here `sherRewards` are deleted after the potential external call is made in `sher.safeTransfer()`. As a result if an attacker reenters this function `sherRewards_` they will still maintain the original balance of rewards and again transfer the SHER tokens.  As `_sendSherRewardsToOwner()` is `internal` the attack can be initiated through the `external` function `ownerRestake()` [see here.](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L595)  Steps to produce the attack:  1) Deploy attack contract to handle reenterancy 2) Call `initialStake()` from the attack contract with the smallest `period` 3) Wait for `period` amount of time to pass 4) Have the attack contract call `ownerRestake()`. The attack contract will gain control of the (See note above about control flow). This will recursively call `ownerRestake()` until the balance of `Sherlock` is 0 or less than the user's reward amount. Then allow reentrancy loop to unwind and complete.  ## Tools Used  n/a  ## Recommended Mitigation Steps  Reentrancy can be mitigated by one of two solutions.  The first option is to add a reentrancy guard like `nonReentrant` the is used in `SherlockClaimManager.sol`.  The second option is to use the checks-effects-interactions pattern. This would involve doing all validation checks and state changes before making any potential external calls. For example the above function could be modified as follows.  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);   } ```  Additionally the following functions are not exploitable however should be updated to use the check-effects-interations pattern. - `Sherlock._redeemShares()` should do `_transferTokensOut()` last. - `Sherlock.initialStake()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` last - `SherClaim.add()` should do `sher.safeTransferFrom(msg.sender, address(this), _amount);` after updating `userClaims`  - `SherlockProtocolManager.depositToActiveBalance()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` after updating `activeBalances`    
# Handle  egjlmn1   # Vulnerability details  ## Impact A user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally. This attack is possible because you enable staking a small amount of tokens.  ## Proof of Concept See the following attack: 1. the first user (user A) who enters the system stake 1 token 2. another user (user B) is about to stake X tokens 3. user A frontrun and transfer X tokens to the system via `ERC20.transfer` 4. user B stakes X tokens, and the shares he receives is: `shares = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);` `shares = (X * 1) / (X + 1 + X - X) = X/(X+1) = 0` meaning all the tokens he staked got him no shares, and those tokens are now a part of the single share that user A holds 5. user A can now redeem his shares and get the 1 token he staked, the X tokens user B staked, and the X tokens he `ERC20.transfer` to the system because all the money in the system is in a single share that user A holds.  In general, since there is only a single share, for any user who is going to stake X tokens, if the system has X+1 tokens in its balance, the user won't get any shares and all the money will go to the attacker.  ## Tools Used Manual code review  ## Recommended Mitigation Steps Force users to stake at least some amount in the system (Uniswap forces users to pay at least `1e18`) That way the amount the attacker will need to ERC20.transfer to the system will be at least `X*1e18` instead of `X` which is unrealistic  
# Handle  robee   # Vulnerability details  You use safeApprove of openZeppelin although it's deprecated.  (see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38) You should change it to increase/decrease Allowance as OpenZeppilin says. This appears in the following locations in the code base:          Deprecated safeApprove in AaveV2Strategy.sol line 70: want.safeApprove(address(lp), type(uint256).max);          Deprecated safeApprove in SherlockClaimManager.sol line 421: TOKEN.safeApprove(address(UMA), _amount);          Deprecated safeApprove in SherlockClaimManager.sol line 464: TOKEN.safeApprove(address(UMA), 0);          Deprecated safeApprove in SherBuy.sol line 99: usdc.approve(address(sherlockPosition), type(uint256).max);          Deprecated safeApprove in SherBuy.sol line 169: sher.approve(address(sherClaim), sherAmount);    
# Handle  danb   # Vulnerability details  all external function which are not onlyOwner have whenNotPaused modifier. but transfer doesn't have it (Sherlok is ERC721). https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L366  this was very important during the exploit to badger dao: https://mobile.twitter.com/flashfish0x/status/1466369783016869892  i suggest you add whenNotPaused to _beforeTokenTransfer    
# Handle  GreyArt   # Vulnerability details  ## Impact  Other relevant view functions like `lockupEnd()`, `sherRewards()` and `tokenBalanceOf()` revert for non-existent IDs, but `viewRewardForArbRestake()` doesn’t.  ## Recommended Mitigation Steps  Include the existence check in `viewRewardForArbRestake()`.  `if (!_exists(_tokenID)) revert NonExistent();`  
# Handle  hyh   # Vulnerability details  ## Impact  Sucessfull `arbRestake` performs `_redeemShares` for `arbRewardShares` amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the `addressShares` of an `nftOwner`.  As a result the `tokenBalanceOfAddress` function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from `addressShares` in `_beforeTokenTransfer`, leaving the arbitrage removed shares permanently in `addressShares` of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.  ## Proof of Concept  `arbRestake` redeems `arbRewardShares`, which are a part of total shares of an NFT:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L673   This will effectively reduce the `stakeShares`:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L491  But there is no mechanics in place to reduce `addressShares` of the owner apart from mint/burn/transfer, so `addressShares` will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.   ## Recommended Mitigation Steps  Add a flag to `_redeemShares` indicating that it was called for a partial shares decrease, say `isPartialRedeem`, and do `addressShares[nftOwner] -= _stakeShares` when `isPartialRedeem == true`.  Another option is to do bigger refactoring, making stakeShares and addressShares always change simultaneously.   
# Handle  kirk-baird   # Vulnerability details  ## Impact  This is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.  Note: this attack requires gaining control of execution `sher.transfer()` which will depend on the implementation of the SHER token. Control may be gained by the attacker if the contract implements ERC777 or otherwise makes external calls during `transfer()`.  ## Proof of Concept  See [_sendSherRewards](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L442)  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);     // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];   } ```  Here `sherRewards` are deleted after the potential external call is made in `sher.safeTransfer()`. As a result if an attacker reenters this function `sherRewards_` they will still maintain the original balance of rewards and again transfer the SHER tokens.  As `_sendSherRewardsToOwner()` is `internal` the attack can be initiated through the `external` function `ownerRestake()` [see here.](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L595)  Steps to produce the attack:  1) Deploy attack contract to handle reenterancy 2) Call `initialStake()` from the attack contract with the smallest `period` 3) Wait for `period` amount of time to pass 4) Have the attack contract call `ownerRestake()`. The attack contract will gain control of the (See note above about control flow). This will recursively call `ownerRestake()` until the balance of `Sherlock` is 0 or less than the user's reward amount. Then allow reentrancy loop to unwind and complete.  ## Tools Used  n/a  ## Recommended Mitigation Steps  Reentrancy can be mitigated by one of two solutions.  The first option is to add a reentrancy guard like `nonReentrant` the is used in `SherlockClaimManager.sol`.  The second option is to use the checks-effects-interactions pattern. This would involve doing all validation checks and state changes before making any potential external calls. For example the above function could be modified as follows.  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);   } ```  Additionally the following functions are not exploitable however should be updated to use the check-effects-interations pattern. - `Sherlock._redeemShares()` should do `_transferTokensOut()` last. - `Sherlock.initialStake()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` last - `SherClaim.add()` should do `sher.safeTransferFrom(msg.sender, address(this), _amount);` after updating `userClaims`  - `SherlockProtocolManager.depositToActiveBalance()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` after updating `activeBalances`    
# Handle  egjlmn1   # Vulnerability details  ## Impact A user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally. This attack is possible because you enable staking a small amount of tokens.  ## Proof of Concept See the following attack: 1. the first user (user A) who enters the system stake 1 token 2. another user (user B) is about to stake X tokens 3. user A frontrun and transfer X tokens to the system via `ERC20.transfer` 4. user B stakes X tokens, and the shares he receives is: `shares = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);` `shares = (X * 1) / (X + 1 + X - X) = X/(X+1) = 0` meaning all the tokens he staked got him no shares, and those tokens are now a part of the single share that user A holds 5. user A can now redeem his shares and get the 1 token he staked, the X tokens user B staked, and the X tokens he `ERC20.transfer` to the system because all the money in the system is in a single share that user A holds.  In general, since there is only a single share, for any user who is going to stake X tokens, if the system has X+1 tokens in its balance, the user won't get any shares and all the money will go to the attacker.  ## Tools Used Manual code review  ## Recommended Mitigation Steps Force users to stake at least some amount in the system (Uniswap forces users to pay at least `1e18`) That way the amount the attacker will need to ERC20.transfer to the system will be at least `X*1e18` instead of `X` which is unrealistic  
# Handle  robee   # Vulnerability details  You use safeApprove of openZeppelin although it's deprecated.  (see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38) You should change it to increase/decrease Allowance as OpenZeppilin says. This appears in the following locations in the code base:          Deprecated safeApprove in AaveV2Strategy.sol line 70: want.safeApprove(address(lp), type(uint256).max);          Deprecated safeApprove in SherlockClaimManager.sol line 421: TOKEN.safeApprove(address(UMA), _amount);          Deprecated safeApprove in SherlockClaimManager.sol line 464: TOKEN.safeApprove(address(UMA), 0);          Deprecated safeApprove in SherBuy.sol line 99: usdc.approve(address(sherlockPosition), type(uint256).max);          Deprecated safeApprove in SherBuy.sol line 169: sher.approve(address(sherClaim), sherAmount);    
