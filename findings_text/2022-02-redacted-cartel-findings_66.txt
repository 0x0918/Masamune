## BribeVault: `fee` is not used anywhere The variable is [set](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L65) and [allowed to be changed](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108) and even an event is there, however it is not used anywhere. The fees are [being read](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L272) directly from the admin's sent parameters and there's no check against the fee previously set. Consider removing it or aligning the `transferBribes` function to use it.  ## RewardDistributor: no sender check for ETH receive function [This](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59) is RB's receive function: ```     // Enables BribeVault to transfer native tokens     receive() external payable {} ``` If it is only used from BribeVault, consider adding a check that verifies that the sender is BribeVault - otherwise misc ether might get sent and locked in the contract.  ## RewardDistributor: ETH being sent using `transfer` In _claim, ETH is [being sent](](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)) using the `transfer` function. While this might be a design choice, it might cause problems and fail to transfer to smart contracts, [such as gnosis safe](https://help.gnosis-safe.io/en/articles/5249851-why-can-t-i-transfer-eth-from-a-contract-into-a-safe). There are mitigations (see in the article), and this is why I rated it as a low issue and not medium. However, for normal user experience, consider changing the `transfer` to `call`. If the concern is reentrancy, you obviously know that there are other mitigations (CEI pattern and reentrancy guard).  ## TokemakBribe: consider adding sanity check for `round` When [setting a new round](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108:#L110), as there is no check that `_newRound > _round`, a team member can add rounds "retroactively": ```     function setRound(uint256 _newRound) external onlyAuthorized {         _round = _newRound;     } ``` I don't really consider this a danger. The worst case would be that a team member (not the admin) listens to TXs in the mempool, and when somebody deposits a bribe, the team member would change the round to be another one which is more beneficial for the team member, and therefore the bribe would be misattributed. However, we are talking about a team member, plus the emergency withdraw function can withdraw it, plus   anyway further releasing of the bribe to claimers requires admin actions. So I do not believe that this is a real risk. This is why I label this as low and not medium. However adding a check that `_newRound > _round` seems like an easy sanity check to add.  ## TokemakBribe: wrong comment for getRound [The comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L113:#L116) for `getRound` is same as for `setRound`. ```     /**         @notice Set a new voting round         @return round uint256 The current round number      */     function getRound() external view returns (uint256) { ```  ## ETH bribes dependent on BribeVault address Regarding using BribeVault's address as the native token address, [a comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L226) mentions "For native tokens, the token address is set to this contract to prevent overwriting storage - the address can be anything but address(this) safer". I might be missing something but I don't see how BribeVault's address is safer than an immutable like 0xEE..E. Since RewardDistributor [can change](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65) BribeVault, this means that the reward identifier would also need to be changed. So again, I might be missing something but at the moment it seems to me that using the changing BribeVault address as the native token identifier just adds complexity.  ## BribeVault: transferBribes: unchecked transfer of ERC20 tokens The function [doesn't use](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296:#L297) safeTransfer for sending of tokens: ```                 IERC20(token).transfer(feeRecipient, feeAmount);                 IERC20(token).transfer(distributor, distributorAmount); ``` This might be on purpose, to not totally fail the whole loop and lose gas if one token is problematic and failed to send. If so, make sure the admin properly checks that all transfers succeeded. For easy checking I believe you can change to safeTransfer and use try/catch to emit an event if the transfer failed.
