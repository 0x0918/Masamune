### Unchecked Gas Optimisation in Minter.sol A check is already made to make sure that `issuedNonInflationSupply` does not exceed a certain value so an arithmetic overflow is not possible  Change `issuedNonInflationSupply += amount;` to `unchecked { issuedNonInflationSupply += amount;} `  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L154  ### Unchecked Gas Optimisations in AmmGauge.sol We can make another unchecked addition because `totalStaked` will always be larger than `balances[user]`  Change ``` balances[account] += staked; totalStaked += staked; ```  to ``` totalStaked += staked; unchecked { balances[account] += staked; }  ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L112-L113  In Line 134 and 135 Change ``` balances[msg.sender] -= unstaked; totalStaked -= unstaked; ``` to  ``` balances[msg.sender] -= unstaked; unchecked { totalStaked -= unstaked } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L134-L135  ### KeeperGauge.sol Change `epoch++` to `++epoch` as talked about [here](https://www.reddit.com/r/ethdev/comments/tcwspw/i_vs_i_gas_efficiency/) https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98  Change ```         keeperRecords[beneficiary].feesInPeriod[epoch] += amount;         perPeriodTotalFees[epoch] += amount; ``` to ```         perPeriodTotalFees[epoch] += amount;         unchecked { keeperRecords[beneficiary].feesInPeriod[epoch] += amount; }          ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87-L88  # BkdLocker.sol As we already make a value check we do not need to worry about arithmetic overflow Wrap `unchecked` around ```         totalStashed[msg.sender] += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L119-L123  Again we have a similar issue  Change ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         totalLocked -= totalAvailableToWithdraw; ``` to ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         unchecked { totalLocked -= totalAvailableToWithdraw; } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L149-L152  `curRewardTokenData.feeBalance` will always be larger than or equal to `curRewardTokenData.userShares[msg.sender]` of any user so we can change Line 216 to `unchecked { curRewardTokenData.feeBalance -= claimable; }`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L214-L216  ### Gas Savings in `_userCheckpoint()` in `BkdLocker.sol` Contract Variables such as `boostFactors` and `curRewardTokenData` are read multiple times throughout the contract. This requires multiple SLOAD operations which are very expensive. It is better to load the variables into memory and use those when reading while the storage variables can be used for writing.  See [here](https://dev.to/javier123454321/solidity-gas-optimization-pt1-4271) for more info i.e. ```                RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -                 curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 );  ``` can be changed to ```         RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];         RewardTokenData memory _curRewardTokenData = curRewardTokenData           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (_curRewardTokenData.feeIntegral -                 _curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 ); ```  This also applies to `boostFactors` and `prevRewardTokenData`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L335  
