Handle: IllIllI  Risk rating: Gas Optimizations  Gas report: [See markdown file here](https://github.com/code-423n4/2022-02-badger-citadel-findings/blob/main/data/IllIllI_112.md)
## Overall  We find the `2022-02-badger-citadel` codebase well-documented, well-structured, with a fair amount of tests, and pretty gas efficient.  There are 2 Non-critical issues and 1 Low severity issue found.  ### [N1] Inconsistent style of error messages  Some of the error messages are prefixed with `TokenSale:` while some are not.  Consider updating the error messages to keep the style of error messages consistent.  ### [N2] Tokens with fee on transfer are not supported  There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.  In the current implementation, `TokenSaleUpgradeable.sol#buy()` assumes that the received amount is the same as the transfer amount, and uses it to calculate `tokenOutAmount_`.  https://github.com/code-423n4/2022-02-badger-citadel/blob/main/contracts/TokenSaleUpgradeable.sol#L180-L183  Consider calling `balanceOf()` before and after the transfer to get the actual transferred amount if a token with transfer tax as `tokenIn` should be supported.  ### [L3] Allowing `setTokenOutPrice` after the token sale starts can result in unexpected results for buyers  In the current implementation, the owner can call `setTokenOutPrice()` and change the tokenOutPrice anytime, including when the token sale already started. In the case of network congestion or in chance, if the owner `setTokenOutPrice()` to a higher price, it can result in unexpected tokenOutAmount for the buyers who submitted their `buy()` txs before but only get packed into the block after the `setTokenOutPrice()` tx.  We consider this an undesirable situation for users and there is pretty much no other way to prevent it, therefore it should be prevented at the smart contract level.  Consider making `setTokenOutPrice()` only callable before the sale starts.
# Handle  PostMan56   # Vulnerability details  ## Impact This is my first time submitting so please let me know if it's bad or poorly explained   Small gas optimization in the function  'getTokenInLimitLeft' and use of uint256 vs uint8  ## Proof of Concept 'getTokenInLimitLeft'     function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {         if (totalTokenIn < tokenInLimit) {             limitLeft_ = tokenInLimit - totalTokenIn;         }     } In gas estimates(before): ``` "Creation": {        "codeDepositCost": "3427600",     "executionCost": "3828",     "totalCost": "3431428" } ```     function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {         if (totalTokenIn <= tokenInLimit) {             limitLeft_ = tokenInLimit - totalTokenIn;         }     }  In gas estimates(after): ``` "Creation": {     "codeDepositCost": "3427400",     "executionCost": "3828",     "totalCost": "3431228" } ```  ## Proof of Concept uint256 vs uint8 uint8 can be found in lines: 56, 57, 65, 146  In gas estimates(before): ``` "Creation": {     "codeDepositCost": "3427600",     "executionCost": "3828",     "totalCost": "3431428" } ``` In gas estimates(after): ``` "Creation": {     "codeDepositCost": "3394800",     "executionCost": "3787",     "totalCost": "3398587" } ``` ## Tools Used Remix gas estimates  ## Recommended Mitigation Steps < & > contains ISZERO opcode making it cost more To negate this add = after < or > to save 200 gas on contract deploy  use of uint256 is cheaper than uint8 in data types  
Handle: IllIllI  Risk rating: Gas Optimizations  Gas report: [See markdown file here](https://github.com/code-423n4/2022-02-badger-citadel-findings/blob/main/data/IllIllI_112.md)
## Overall  We find the `2022-02-badger-citadel` codebase well-documented, well-structured, with a fair amount of tests, and pretty gas efficient.  There are 2 Non-critical issues and 1 Low severity issue found.  ### [N1] Inconsistent style of error messages  Some of the error messages are prefixed with `TokenSale:` while some are not.  Consider updating the error messages to keep the style of error messages consistent.  ### [N2] Tokens with fee on transfer are not supported  There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.  In the current implementation, `TokenSaleUpgradeable.sol#buy()` assumes that the received amount is the same as the transfer amount, and uses it to calculate `tokenOutAmount_`.  https://github.com/code-423n4/2022-02-badger-citadel/blob/main/contracts/TokenSaleUpgradeable.sol#L180-L183  Consider calling `balanceOf()` before and after the transfer to get the actual transferred amount if a token with transfer tax as `tokenIn` should be supported.  ### [L3] Allowing `setTokenOutPrice` after the token sale starts can result in unexpected results for buyers  In the current implementation, the owner can call `setTokenOutPrice()` and change the tokenOutPrice anytime, including when the token sale already started. In the case of network congestion or in chance, if the owner `setTokenOutPrice()` to a higher price, it can result in unexpected tokenOutAmount for the buyers who submitted their `buy()` txs before but only get packed into the block after the `setTokenOutPrice()` tx.  We consider this an undesirable situation for users and there is pretty much no other way to prevent it, therefore it should be prevented at the smart contract level.  Consider making `setTokenOutPrice()` only callable before the sale starts.
# Handle  PostMan56   # Vulnerability details  ## Impact This is my first time submitting so please let me know if it's bad or poorly explained   Small gas optimization in the function  'getTokenInLimitLeft' and use of uint256 vs uint8  ## Proof of Concept 'getTokenInLimitLeft'     function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {         if (totalTokenIn < tokenInLimit) {             limitLeft_ = tokenInLimit - totalTokenIn;         }     } In gas estimates(before): ``` "Creation": {        "codeDepositCost": "3427600",     "executionCost": "3828",     "totalCost": "3431428" } ```     function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {         if (totalTokenIn <= tokenInLimit) {             limitLeft_ = tokenInLimit - totalTokenIn;         }     }  In gas estimates(after): ``` "Creation": {     "codeDepositCost": "3427400",     "executionCost": "3828",     "totalCost": "3431228" } ```  ## Proof of Concept uint256 vs uint8 uint8 can be found in lines: 56, 57, 65, 146  In gas estimates(before): ``` "Creation": {     "codeDepositCost": "3427600",     "executionCost": "3828",     "totalCost": "3431428" } ``` In gas estimates(after): ``` "Creation": {     "codeDepositCost": "3394800",     "executionCost": "3787",     "totalCost": "3398587" } ``` ## Tools Used Remix gas estimates  ## Recommended Mitigation Steps < & > contains ISZERO opcode making it cost more To negate this add = after < or > to save 200 gas on contract deploy  use of uint256 is cheaper than uint8 in data types  
