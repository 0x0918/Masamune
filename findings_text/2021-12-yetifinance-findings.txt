# Handle  pauliax   # Vulnerability details  ## Impact condition should be inclusive >= : ```solidity   if (available > totalClaimed.add(_amount)) ```  
# Handle  gzeon   # Vulnerability details  ## Impact The 3 variable defined in L365-367 are used only once https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/Whitelist.sol#L365-367 ```         uint256 price = getPrice(_collateral);         uint256 decimals = collateralParams[_collateral].decimals;         uint256 ratio = collateralParams[_collateral].ratio; ```  We can skip them and do everything inline: ``` return (getPrice(_collateral).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals))); ```  Similarly, L352-354 ```         return getPrice(_collateral).mul(_amount).div(10**collateralParams[_collateral].decimals); ```  
# Handle  pauliax   # Vulnerability details  ## Impact _isBeforeFeeBootstrapPeriod() is re-evaluated again and again inside the loop, although its value could be cached outside the loop and re-used to reduce gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact In function _transfer, shares.to128(); can be cached to skip the same calculation again: ```solidity   users[from].balance = fromUser.balance - shares.to128();   users[to].balance = toUser.balance + shares.to128(); ``` Same here, the result can be extracted to a constant as it never changes: ```solidity   (DECIMAL_PRECISION / 2) ```  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `troveManager` in `TroveManagerRedemptions#_updateBaseRateFromRedemption()`      https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L432-L447      ```solidity=432     function _updateBaseRateFromRedemption(uint256 _YUSDDrawn, uint256 _totalYUSDSupply)     internal     returns (uint256)     {         uint256 decayedBaseRate = troveManager.calcDecayedBaseRate();          /* Convert the drawn Collateral back to YUSD at face value rate (1 YUSD:1 USD), in order to get          * the fraction of total supply that was redeemed at face value. */         uint256 redeemedYUSDFraction = _YUSDDrawn.mul(10**18).div(_totalYUSDSupply);          uint256 newBaseRate = decayedBaseRate.add(redeemedYUSDFraction.div(BETA));         newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%          troveManager.updateBaseRate(newBaseRate);         return newBaseRate;     }     ```  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L791-L795  ```solidity=791 if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease      newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee)); } else { // otherwise increase by opposite subtraction     newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange)); } ```  `_debtChange - _variableYUSDFee` at L792 and `_variableYUSDFee - _debtChange` at L794 will never underflow.   https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L240-L241  ```solidity=240 _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); ```  `_balances[account] + amount` will not overflow if `_totalSupply.add(amount)` dose not overflow.    https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L248-L249  ```solidity=248 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance"); _totalSupply = _totalSupply.sub(amount); ```  `_totalSupply - amount` will not underflow if `_balances[account].sub(amount)` dose not underflow.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L839-L847  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {         for (uint i = 0; i < _colls.tokens.length; i++) {             address token = _colls.tokens[i];             uint amount = _colls.amounts[i];             if (whitelist.isWrapped(token)) {                 IWAsset(token).updateReward(_borrower, _newOwner, amount);             }         }     } ```  Since `amount` is only needed in `if (whitelist.isWrapped(token)) {...}`, so `uint amount = _colls.amounts[i];` should be moved to inside `if (whitelist.isWrapped(token)) {...}`.  Furthermore, considering that `amount` is only used once, it can be replaced with `_colls.amounts[i]`.  ### Recommendation  Change to:  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     for (uint i = 0; i < _colls.tokens.length; i++) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L297-L301  ```solidity=297     function _requireCallerIsTMLorSP() internal view {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             "YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool");     } ```  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L128-L131  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         _requireCallerIsTMLorSP();         _transfer(_poolAddress, _receiver, _amount);     } ```   `_requireCallerIsTMLorSP()` is unnecessary as it's being used only once. Therefore it can be inlined in `returnFromPool()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             "YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool");         _transfer(_poolAddress, _receiver, _amount);     } ```  Other examples include:  -   `TroveManagerRedemptions.sol#_getRedemptionFee()` can be inlined in `TroveManagerRedemptions.sol#redeemCollateral()`  
# Handle  kenzo   # Vulnerability details  TeamLockup mentions on "vestingLength" that it is the "number of YETI that are claimable every day after vesting starts". However, the vesting calculation treats it as if was the number of YETI that are claimable every second, not every day.  ## Impact Tokens would be released faster than planned. Or, if the tokens are planned to be released every second and not every day (I'm guessing it's less likely), then this is a wrong comment.  ## Proof of Concept The description of `vestingLength`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L15) ```     uint immutable vestingLength; // number of YETI that are claimable every day after vesting starts ```  The calculation to decide how many tokens can be released: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L41:#L43) ```         uint timePastVesting = block.timestamp.sub(vestingStart);         uint available = _min(totalVest,(totalVest.mul(timePastVesting)).div(vestingLength)); ``` The problem is that `timePastVesting` is in seconds, and `vestingLength` is in days.  ## Recommended Mitigation Steps Divide the calculation by `1 day` to align the units.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/ERC20_8.sol#L68-L70  ```solidity=68         require(_num_tokens <= balances[msg.sender], "You are trying to transfer more tokens than you have");          balances[msg.sender] = balances[msg.sender] - _num_tokens; ```  `balances[msg.sender] - _num_tokens` will never underflow.  
# Handle  kenzo   # Vulnerability details  LockupContract, LockupContractFactory amd ShortLockupContract all have comments that say: ``` Within the first year from deployment, the deployer of the YETIToken (Liquity AG's address) may transfer YETI only to valid LockupContracts, and no other addresses (this is enforced in YETIToken.sol's transfer() function). The above two restrictions ensure that until one year after system deployment, YETI tokens originating from Liquity AG cannot enter circulating supply and cannot be staked to earn system revenue. ```  This comment is outdated (verified with sponsor). There is no such lockup on YETI tokens issued to team/treasury. (There might be other type of vesting which is probably implemented using TeamLockup.)  ## Impact Confusion, wrong description of team's capability to use yeti tokens issued.  ## Proof of Concept [Code ref](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/LockupContract.sol#L13:#L18).  ## Recommended Mitigation Steps Remove outdated comments.  
# Handle  pauliax   # Vulnerability details  ## Impact ecrecover returns an empty address when the signature is invalid. As far as I checked, with the current codebase, there is no way to exploit it to gain any benefits, but it is a good practice to check against that. ```solidity   address recoveredAddress = ecrecover(digest, v, r, s);   require(recoveredAddress == owner, 'YUSD: invalid signature'); ```  ## Recommended Mitigation Steps require recoveredAddress != address(0)  You could also consider using OZ's ECDSA library for signature verifications: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function setAddresses in contract Whitelist is intended to be invoked only once (confirmed with the sponsor) but currently, it has no prevention from being called multiple times.  Maybe this should also be prevented in sYETIToken's setAddresses and ThreePieceWiseLinearPriceCurve's setAddresses.  ## Recommended Mitigation Steps Prevent repeated access of setAddresses in Whitelist and potentially in sYETIToken and ThreePieceWiseLinearPriceCurve.  
# Handle  Ruhum   # Vulnerability details  ## Impact View functions consume less gas. `WJLP.getPendingRewards()` is technically also a view function but not specified as one. Because the `IMasterChefJoeV2` interface used by the contract is wrong. It says `poolInfo()` is not a view function, which it is.  ## Proof of Concept getPendingRewards: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L190  Faulty interface function: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L29  actually poolinfo is just an array so its getter is a view function: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV2.sol#L85  ## Tools Used none  ## Recommended Mitigation Step Declare both functions as `view` to save gas  
# Handle  Ruhum   # Vulnerability details  ## Impact All the other passed variables are checked. Only `_whitelistAddress` is ignored. This allows passing a zero function which would break the functionality.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/CollSurplusPool.sol#L51-L54  ## Tools Used none  ## Recommended Mitigation Steps add `checkContract(_whitelistAddress)`  
# Handle  kenzo   # Vulnerability details  When changing collateral's ratio, it is rightly checked to be smaller than 110%. However when adding new collateral, the ratio check is not there, so it can be added with ratio that is larger than 110%.  ## Impact Accidentally adding an asset with larger ratio would result in users being able to withdraw more YUSD than supplied VC.  ## Proof of Concept When an asset is being added, there is no sanity check that the ratio is within the correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L92:#L127)  This is unlike `changeRatio`, which validates that the new ratio is in correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L204) ``` require(_ratio < 1100000000000000000, "ratio must be less than 1.10 => greater than 1.1 would mean taking out more YUSD than collateral VC"); ```  ## Recommended Mitigation Steps Add the same ratio check to `addCollateral`.  
# Handle  cmichel   # Vulnerability details  Calling `WJLP.unwrap` burns WJLP, withdraws the amount from the master chef and returns the same amount of JLP back to the `to` address. However, it does not update the internal accounting in `WJLP` with a `_userUpdate` call.  This needs to be done on the caller side according to the comment in the `WJLP.unwrap` function: > "Prior to this being called, the user whose assets we are burning should have their rewards updated"  This happens when being called from the `StabilityPool` but not when being called from the `ActivePool.sendCollateralsUnwrap`:  ```solidity function sendCollateralsUnwrap(address _to, address[] memory _tokens, uint[] memory _amounts, bool _collectRewards) external override returns (bool) {     _requireCallerIsBOorTroveMorTMLorSP();     require(_tokens.length == _amounts.length);     for (uint i = 0; i < _tokens.length; i++) {         if (whitelist.isWrapped(_tokens[i])) {             // @audit this burns the tokens for _to but does not reduce their amount. so there are no tokens in WJLP masterchef but can keep claiming             IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]);             if (_collectRewards) {                 IWAsset(_tokens[i]).claimRewardFor(_to);             }         } else {             _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails         }     }     return true; } ```  ## Impact The `unwrapFor` call withdraws the tokens from the Masterchef and pays out the user, but their user balance is never decreased by the withdrawn amount. They can still use their previous balance to claim rewards through `WJLP.claimReward` which updated their unclaimed joe reward according to the old balance. Funds from the WJLP pool can be stolen.  ## Recommended Mitigation Steps As the comment says, make sure the user is updated before each `unwrap` call. It might be easier and safer to have a second authorized `unwrapFor` function that accepts a `rewardOwner` parameter, the user that needs to be updated.   
# Handle  cmichel   # Vulnerability details  The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:  ```solidity function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {     require(YUSDToSell > 0, "Zero amount");     require(lastBuybackTime + 69 hours < block.timestamp, "Must have 69 hours pass before another buyBack");     yusdToken.approve(routerAddress, YUSDToSell);     uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);     lastBuybackTime = block.timestamp;     // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]     // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)     lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);     emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]); } ```  It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap `path` parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).  ## Impact The `lastBuyBackPrice` will be wrong when using a different path. This will lead `rebase`s using a different yeti amount and the `effectiveYetiTokenBalance` being updated wrong.  ## Recommended Mitigation Steps Verify the first and last element of the path are YETI/YUSD and use the first and last amount parameter.   
# Handle  cmichel   # Vulnerability details  The `sYETIToken.transferFrom` function does not emit a new `Approval` event when decreasing the allowance. Most ERC20 implementations, like OpenZeppelin's, emit this event when the `allowance` is decreased.  ## Impact Off-chain scripts and frontends will not correctly track the `allowance`s of users when listening to the `Approval` event. This can lead to failed transactions as a higher approval is assumed than it actually is.  ## Recommended Mitigation Steps Emit the `Approval` event also in `transferFrom` if the approval is decreased.   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..  ```solidity if (decay > 0 && decay < decayTime) {     // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     fee = lastFeePercent; } ```  ## Recommended Mitigation Steps It seems wrong to handle the `decay == 0` case (decay happened in same block) the same way as the `decay >= decayTime` case (decay happened long time ago) as is done in the `else` branch. I believe it should be like this instead:  ```solidity // decay == 0 case should be full lastFeePercent if(decay < decayTime) {     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     // reset to zero if decay >= decayTime     fee = 0; } ```  
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap:  > If dollarCap == 0, then it is not capped. Otherwise, **then the total + the total input** must be less than the cap.  The code only checks if the input is less than the cap:  ```solidity // @param _collateralVCInput is how much collateral is being input by the user into the system if (dollarCap != 0) {     require(_collateralVCInput <= dollarCap, "Collateral input exceeds cap"); } ```  ## Recommended Mitigation Steps Clarify the desired behavior and reconcile the code with the comments.   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1, f2, f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0), b3 = f_3(0)`) for each of these but uses **unsigned integers** for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.  #### Example: Check out this two-piece linear interest curve of Aave:  ![Aave](https://docs.aave.com/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M51Fy3ipxJS-0euJX3h-2670852272%2Fuploads%2Fycd9OMRnInNeetUa7Lj1%2FScreenshot%202021-11-23%20at%2018.52.26.png?alt=media&token=7a25b900-7023-4ee5-b582-367d56d31894) The intersection of the second steep straight line with the y-axis `b_2 = f_2(0)` would be negative.  Example: Imagine a curve that is flat at `10%` on the first 50% utilization but shoots up to `110%` at 100% utilization.  - `m1 = 0, b1 = 10%, cutoff1 = 50%`  - `m2 = 200%` => `b2 = m1 * cutoff1 + b1 - m2 * cutoff1 = f1(cutoff1) - m2 * cutoff1 = 10% - 200% * 50% = 10% - 100% = -90%`. (`f2(100%) = 200% * 100% - 90% = 110%` ✅) This function would revert in the `b2` computation as it underflows due to being a negative value.  ## Impact Most curves that are actually desired for a lending platform (becoming steeper at higher utilization) cannot be used.  ## Recommended Mitigation Steps Evaluate the piecewise linear function in a different way that does not require computing the y-axis intersection value. For example, for `cutoff2 >= x > cutoff1`, use `f(x) = f_1(cutoff) + f_2(x - cutoff)`. See [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol#L85).   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function does not check that `_cutoff1 <= _cutoff2` and also does not revert in this case. However, this always indicates an error in how this function should be used.  ## Recommended Mitigation Steps Add a `_cutoff1 <= _cutoff2` check.  
# Handle  heiho1   # Vulnerability details  ## Impact  CheckContract is used in ActivePool, BorrowerOperations, CollSurplusPool, DefaultPool, HintHelpers, PriceFeed, SortedTroves, StabilityPool, TroveManager, TroveManagerLiquidations, TroveManagerRedemptions but this is a view function and could easily be implemented as an internal library call.  This would result in slightly larger contract bytecode but should be far more gas efficient than an external contract call as is the current case.  ## Proof of Concept  https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678  """ Use any of the internal calling methods. We prefer internal library calls, because of the associated class features (see Class Features of Solidity by the same author). Using an external call to a public library function is very expensive, and will only be worth it to avoid including a lot of code into the bytecode for your contract. Using a local contract component is the most expensive option and should be avoided unless essential. """  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/CheckContract.sol#L6  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare CheckContract as an internal library:  https://medium.com/coinmonks/all-you-should-know-about-libraries-in-solidity-dd8bc953eae7  """ Embedded Library: If a smart contract is consuming a library which have only internal functions than EVM simply embeds library into the contract. Instead of using delegate call to call a function, it simply uses JUMP statement(normal method call). There is no need to separately deploy library in this scenario. """  
# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerRedemptions does not inherit contracts/Interfaces/ITroveManagerRedemptions.sol but should.  Note that TroveManager.sol does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L38  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as "TroveManagerRedemptions is TroveManagerBase, ITroveManagerRedemptions"  
# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerLiquidations does not inherit contracts/Interfaces/ITroveManagerLiquidations.sol but should.  Note that TroveManager.sol  does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L14  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as "TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations"  
# Handle  heiho1   # Vulnerability details  ## Impact  Got an error attempting Slither analysis due to several contracts defining "SafeMath"   - In this case there are *two* distinct safe math libraries, one dependent on solc 0.6.11 and one dependent on solc ^0.8.0. This can lead to confusion during development.  Ideally the safe math version of the application contract [0.6.11] would be standardized but in this case *re-naming* the SafeMath contracts also suffices.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol#L15  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/SafeMath.sol#L21    ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol to SafeMath080.sol [and updating the declared contract to the same name]  
# Handle  heiho1   # Vulnerability details  ## Impact Got an error attempting Slither analysis due to Pool2Unipool and Unipool declaring the same contract named LPTokenWrapper.  It is confusing and error prone to have such similarly named contracts and there is no clear benefit to re-using the name.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename LPTokenWrapper in Pool2Unipool to 'Pool2LPTokenWrapper' and correct any related imports.  
# Handle  Dravee   # Vulnerability details  ## Impact In a number of places a `keccak("string")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  ## Proof of Concept ``` YETI\YETIToken.sol:   50:     bytes32 private constant _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");   51:     bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");  YETI\BoringCrypto\Domain.sol:   10:     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256("EIP712Domain(uint256 chainId,address verifyingContract)"); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change all `constant` hashes to be `immutable`  
# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.   ## Proof of Concept Instances missing a non-zero check: ``` ActivePool.sol:   156:         bool sent = IERC20(_collateral).transfer(_to, _amount);  BorrowerOperations.sol:   742:             bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);  DefaultPool.sol:   121:         bool success = IERC20(_collateral).transfer(activePool, _amount);  StabilityPool.sol:   947:                 IERC20(assets[i]).transfer(_to, amounts[i]);  TeamAllocation.sol:   69:             require(YETI.transfer(member, amount));   77:         YETI.transfer(_to, _amount);  YetiFinanceTreasury.sol:   25:         _token.transfer(_to, _amount);  AssetWrappers\WJLP\WJLP.sol:   127:         JLP.transferFrom(_from, address(this), _amount);   166:         JLP.transfer(_to, _amount);   273:             JOE.transfer(_to, _amount);  Dependencies\LiquityBase.sol:   170:             if (!token.transfer(_to, _coll.amounts[i])) {  LPRewards\Dependencies\SafeERC20.sol:   23:         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));   27:         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));  YETI\CommunityIssuance.sol:   125:         yetiToken.transfer(_account, _YETIamount);  YETI\LockupContract.sol:   68:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\ShortLockupContract.sol:   67:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\sYETIToken.sol:   203:         yetiToken.transfer(to, amount);  YETI\TeamLockup.sol:   47:             require(YETI.transfer(multisig, _amount)); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0. It is done at some places already, like here: https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/LPRewards/Unipool.sol#L189-L192  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L890`  ``` https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L699  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L873  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L920  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L929  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/ActivePool.sol#L167  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `WJLP.sol`, state variables `JLP` and `JOE` are initialized in the constructor and never reassigned again. Thus, they can be declared `immutable` rather than `constant` in order to save gas  ## Proof of Concept  [https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41)  ## Tools Used  Editor  
# Handle  kenzo   # Vulnerability details  When ActivePool sends collateral which is a wrapped asset, it first unwraps the asset, and only after that updates the rewards. This should be done in opposite order. As a comment in WJLP's `unwrapFor` rightfully mentions - "Prior to this being called, the user whose assets we are burning should have their rewards updated".  ## Impact Lost yield for user.  ## Proof of Concept In ActivePool's `sendCollateralsUnwrap` (which is used throughout the protocol), it firsts unwraps the asset, and only afterwards calls `claimRewardFor` which will update the rewards: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol#L186:#L188) ``` IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]); if (_collectRewards) {         IWAsset(_tokens[i]).claimRewardFor(_to); } ``` `claimRewardFor` will end up calling `_userUpdate`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L246:#L263) ```     function _userUpdate(address _user, uint256 _amount, bool _isDeposit) private returns (uint pendingJoeSent) {         uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;         UserInfo storage user = userInfo[_user];         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12);     } ``` Now, as ActivePool has already called `unwrapFor` and has burnt the user's tokens, and let's assume they all were used as collateral, it means user.amount=0*, and the user's unclaimedJOEReward won't get updated to reflect the rewards from the last user update. This is why, indeed as the comment in `unwrapFor` says, user's reward should be updated prior to that.  *Note: at the moment `unwrapFor` doesn't updates the user's user.amount, but as I detailed in another issue, that's a bug, as that means the user will continue accruing rewards even after his JLP were removed from the protocol.  ## Recommended Mitigation Steps Change the order of operations in `sendCollateralsUnwrap` to first send the updated rewards and then unwrap the asset. You can also consider adding to the beginning of `unwrapFor` a call to `_userUpdate(_to, 0, true)` to make sure the rewards are updated before unwrapping. Note: as user can choose to have JOE rewards accrue to a different address than the address that uses WJLP as collateral, you'll have to make sure you update the current accounts. I'll detail this in another issue.  
# Handle  kenzo   # Vulnerability details  After updating user's rewards in `_userUpdate`, if the user has not claimed them, and `_userUpdate` is called again (eg. on another `wrap`), the user's unclaimed rewards will lose the previous unclaimed due to wrong calculation.  ## Impact Loss of yield for user.  ## Proof of Concept When updating the user's unclaimedJoeReward, the function doesn't save it's previous value. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L251:#L253) ```         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         // update for JOE rewards that are already accounted for in user.unclaimedJOEReward         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12); ``` So for example, rewards can be lost in the following scenario. We'll mark "acc1" for the value of "accJoePerShare" at step 1. 1. User Zebulun wraps 100 tokens. After  `_userUpdate` is called: unclaimedJOEReward  = 0, rewardDebt = 100*acc1. 2. Zebulun wraps 50 tokens: unclaimedJOEReward = 100*acc2 - 100*acc1, rewardDebt = 150 * acc2. 3. Zebulun wraps 1 token: unclaimedJOEReward = 150*acc3 - 150*acc2, rewardDebt = 151*acc3 So in the last step, Zebulun's rewards only take into account the change in accJoePerShare in steps 2-3, and lost the unclaimed rewards from steps 1-2.  ## Recommended Mitigation Steps Change the unclaimed rewards calculation to: ``` user.unclaimedJOEReward = user.unclaimedJOEReward.add(user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt)); ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact Gas wastage  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/YetiCustomBase.sol  2. Observe that in _subColls function the last for loop is not required if n=0 since this means that all token amount is 0   
# Handle  kenzo   # Vulnerability details  WJLP can only be unwrapped from the Active Pool or Stability Pool. A user who decided to wrap his JLP, but not use all of them in a trove, Wouldn't be able to just unwrap them.  ## Impact Impaired functionality for users. Would have to incur fees for simple unwrapping.  ## Proof of Concept The unwrap functionality is only available from `unwrapFor` function, and that function is only callable from AP or SP. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L149) ``` function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP(); ```  ## Recommended Mitigation Steps Allow anybody to call the function. As it will burn the holder's WJLP, a user could only unwrap tokens that are not in use.  
# Handle  kenzo   # Vulnerability details  WJLP doesn't update the inner accounting (for JOE rewards) when unwrapping user's tokens. The user will continue to receive rewards, on the expanse of users who haven't claimed their rewards yet.  ## Impact Loss of yield for users.  ## Proof of Concept The unwrap function just withdraws JLP from MasterChefJoe, burns the user's WJLP, and sends the JLP back to the user. It does not update the inner accounting (`userInfo`). [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L167) ```     function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP();         _MasterChefJoe.withdraw(_poolPid, _amount);         // msg.sender is either Active Pool or Stability Pool         // each one has the ability to unwrap and burn WAssets they own and         // send them to someone else         _burn(msg.sender, _amount);         JLP.transfer(_to, _amount);     } ```  ## Recommended Mitigation Steps Need to keep userInfo updated. Have to take into consideration the fact that user can choose to set the reward claiming address to be a different account than the one that holds the WJLP.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variables `yetiToken` and `unlockTime` inside the `ShortLockupContract` contract are never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variable `yetiToken` inside the `LockupContract` contract is never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  
# Handle  hyh   # Vulnerability details  # Impact  The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to `effectiveYetiTokenBalance` during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.  The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users’ claims. In other words, the contract will be in default if enough users claim after that.  ## Proof of Concept  Now the whole balance amount is used instead of the amount bought back from market.  Rebasing amount is added to `effectiveYetiTokenBalance`, so it should be limited by extra Yeti tokens, not the whole balance: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L247  ## Recommended Mitigation Steps  It looks like only extra tokens should be used for the check, i.e. `yetiToken.balance - effectiveYetiTokenBalance`.  Now: ``` function rebase() external {   ...   uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));   uint256 valueOfContract = _getValueOfContract(yetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (yetiTokenBalance < additionalYetiTokenBalance) {     additionalYetiTokenBalance = yetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {   uint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```  As the `_getValueOfContract` function isn't used elsewhere, the logic can be simplified. To be: ``` function rebase() external {   ...   uint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);   uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (additionalYetiTokenBalance > adjustedYetiTokenBalance) {     additionalYetiTokenBalance = adjustedYetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```   
# Handle  hyh   # Vulnerability details  # Impact  Core system logic can break up if enumeration structure be updated.  ## Proof of Concept  BorrowerOperations and StabilityPool check the active status of a trove by comparing TroveManager's getTroveStatus with 1: BorrowerOperations: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L902 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L907 StabilityPool: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1104  TroveManagers inherit Status enumeration from TroveManagerBase: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TroveManagerBase.sol#L72  ## Recommended Mitigation Steps  With further system development it will be harder to track fixes needed on enumeration change. Consider implementing TroveManager.isTroveActive(borrower) where trove.status is checked against Status.active and the corresponding boolean is returned.   
# Handle  hyh   # Vulnerability details  # Impact  Transactions will not be reverted on failed transfer call, setting system state as if it was successful. This will lead to wrong state accounting down the road with a wide spectrum of possible consequences.  ## Proof of Concept  _safeJoeTransfer do not check for JOE.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L268  _safeJoeTransfer is called by _sendJoeReward, which is used in reward claiming.  JOE token use transfer from OpenZeppelin ERC20: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/JoeToken.sol#L9  Which does return success code: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L113  Trader Joe also uses checked transfer when dealing with JOE tokens: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L102   Also, unwrapFor do not check for JLP.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L166   ## Recommended Mitigation Steps  Add a require() check for the success of JOE transfer in _safeJoeTransfer function and create and use a similar function with the same check for JLP token transfers  
# Handle  hyh   # Vulnerability details  Console log code to be removed: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152  
# Handle  hyh   # Vulnerability details  # Impact  WJLP set configuration variables via setAddresses initialize function that has no access controls, so whenever it is being run not atomically with contract creation it can be front run by an attacker. The fix is to redeploy the contracts.  ## Proof of Concept  WJLP.setAddresses: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L102  WJLP.constructor: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L82  ## Recommended Mitigation Steps  a. Either set access rights in the constructor and restrict initialize access b. Or run setAddresses atomically along with contract construction each time  It is also advised to check for zero addressed supplied by a caller both in constructor and setAddresses. Misconfiguration with zero address also leads to redeployment.  
# Handle  dalgarim   # Vulnerability details  ## Impact sYETIToken.sol mint function checks if msg.sender is zero address. It is extremely unlikely that someone possesses a private key of zero address. This 'require' statement semantically has no meaning  ## Proof of Concept [mint](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L175) ``` function mint(uint256 amount) public returns (bool) {         require(msg.sender != address(0), "Zero address");         User memory user = users[msg.sender];          uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;         user.balance += shares.to128();         user.lockedUntil = (block.timestamp + LOCK_TIME).to128();         users[msg.sender] = user;         totalSupply += shares;          yetiToken.sendToSYETI(msg.sender, amount);         effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);          emit Transfer(address(0), msg.sender, shares);         return true;     } ```  ## Tools Used Manual  ## Recommended Mitigation Steps The require statement can be removed  
# Handle  Jujic   # Vulnerability details  ## Impact The uint   `percentBacked ` can not  be negative.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L131 ``` uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance); require(percentBacked <= 1e18 && percentBacked >= 0, "percent backed out of bounds"); ```  ## Tools Used Remix  ## Recommended Mitigation Steps You should remove the `percentBacked >= 0` from require to save some gas.  
# Handle  hyh   # Vulnerability details  # Impact  Comment is misleading, now stating the opposite of the implemented logic.  ## Proof of Concept  Comment states that tokens added are `not less than amount repurchased`, while it should be `not more`: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L246   ## Recommended Mitigation Steps  Now: ``` // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  To be: ``` // Ensure that the amount of YETI tokens effectively added is <= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  _requireValidRouterParams and _requireRouterAVAXIndicesInOrder functions along with IYetiRouter interface are unused:  _requireValidRouterParams https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1053  _requireRouterAVAXIndicesInOrder https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1067  IYetiRouter import and the interface itself: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L12 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Interfaces/IYetiRouter.sol  ## Recommended Mitigation Steps  If it is not meant to be implemented further consider removal to enhance code readability and size  
# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. `withdrawColl` outcome will not be as expected by a caller.  ## Proof of Concept  `_adjustTrove` doesn't check for array lengths and all other array providing usages of this function do check them before usage.  BorrowerOperations.withdrawColl doesn't: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L373  ## Recommended Mitigation Steps  Add the check:  Now: ``` params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```  To be: ``` require(_collsOut.length == _amountsOut.length); params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```   
# Handle  Jujic   # Vulnerability details  ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L53-L55  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManager.sol#L35-L39   Example: ``` uint256 public constant BOOTSTRAP_PERIOD = 14 days; ``` ## Tools Used Remix ## Recommended Mitigation Steps  
# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.  Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.  Example Medium Issue : https://github.com/code-423n4/2021-08-notional-findings/issues/18  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/PriceFeed.sol#L578"  2. Only the following checks are implemented.  ```         if (!_response.success) {return true;}         // Check for an invalid roundId that is 0         if (_response.roundId == 0) {return true;}         // Check for an invalid timeStamp that is 0, or in the future         if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}         // Check for non-positive price         if (_response.answer <= 0) {return true;}   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```  
# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. The following contract is using ABI coder v2.  "https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/YETI/sYETIToken.sol#L3"   ## Tools Used  None  ## Recommended Mitigation Steps  Upgrade pragma to 0.8.0  and After the 0.8.0, ABI coder v2 is activated by default. Upgrade pragma to 0.8.0 version. It is recommended to delete redundant codes.  From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  
# Handle  Jujic   # Vulnerability details  ## Impact Removing the assignment will save gas. ``` _totalSupply = 0; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L93  ## Tools Used  ## Recommended Mitigation Steps Remove the assignment.  
# Handle  Jujic   # Vulnerability details  ## Impact ``` deploymentTime = block.timestamp; uint public constant BOOTSTRAP_PERIOD = 14 days;  deploymentTime.add(BOOTSTRAP_PERIOD) // doesn't overflow  ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L899  ## Tools Used Remix ## Recommended Mitigation Steps I recommend   not  use Safemath for this operation.  
# Handle  SolidityScan   # Vulnerability details  ## Impact Events are important and should be emitted for tracking this off-chain for all important functions.   ## Proof of Concept 1. The function "updateTeamAddress" is used to update the team's address but we can notice no event is emitted.  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/TeamAllocation.sol#L81-L83  2. The same in function "updateTeamWallet" at  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YetiFinanceTreasury.sol#L28-L30  ## Tools Used  ## Recommended Mitigation Steps Add an event to these important functions where address updation is happening. This can also be marked as indexed event for better off-chain tracking  
# Handle  jayjonah8   # Vulnerability details  ## Impact the constructor in TellorCaller.sol should ensure that the _tellorMasterAddress arg passed in is not a zero address as a safegaurd.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TellorCaller.sol#L24  ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_tellorMasterAddress) != address(0), "Zero address")  
# Handle  jayjonah8   # Vulnerability details  ## Impact In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments,  but anyone can call it passing in _tokens and _amounts args to update stability pool balances.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1143  ## Tools Used Manual code review   ## Recommended Mitigation Steps Allow only the ActivePool to call the receiveCollateral() function: require(msg.sender = address(active pool address), "Can only be called by ActivePool")  
# Handle  Jujic   # Vulnerability details  ## Impact contract WJLP does not need to import this contract in production ``` import "hardhat/console.sol"; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L8  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152-L160  ## Tools Used Remix  ## Recommended Mitigation Steps Remove this contract  to reduce the size of the contract and thus save some deployment gas.  
# Handle  Jujic   # Vulnerability details  ## Impact Some of the variable can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L90-L91  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L107-L108  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L144-L145  ``` dollarCap // can be cashed decayTime // can be cashed  ``` ## Tools Used Remix  ## Recommended Mitigation Steps   
# Handle  Jujic   # Vulnerability details  ## Impact ``` IERC20 public immutable JLP; IERC20 public  immutable JOE; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41-L44  ## Tools Used REmix ## Recommended Mitigation Steps  
# Handle  SolidityScan   # Vulnerability details  ### Description  Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.  ## Impact Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ## Proof of Concept 1.  uint constant public _100pct = 1000000000000000000;  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L19  2. uint constant public _110pct = 1100000000000000000; // 1.1e18 == 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L21  3. uint constant public MCR = 1100000000000000000; // 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L24  4. uint constant public CCR = 1500000000000000000; // 150% https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L27  ## Tools Used  ## Recommended Mitigation Steps Scientific notation in the form of 2e10 is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal MeE is equivalent to M * 10**E. Examples include 2e10, 2e10, 2e-10, 2.5e1. As suggested in official docs https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals  
# Handle  SolidityScan   # Vulnerability details  ### Description  Smart Contracts are Gas sensitive and heavily depend on how Gas is spent and managed across the code. This affects each and every function definition and logic.   Therefore having any unused functions in the code cost unnecessary Gas usage and thus negatively impacts the Contract and the organization.  ## Impact Having unused function definitions and parameters negatively affects the contract and costs unnecessary Gas. This also makes it difficult and confusing for auditors to go through the code.  ## Proof of Concept The function "_getColls" is not used anywhere in the code  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L146-L153  ## Tools Used  ## Recommended Mitigation Steps Evaluate if the function call should be used anywhere otherwise remove the function definition.  
# Handle  jayjonah8   # Vulnerability details  ## Impact There are no events emitted in the WJLP.sol file for important function calls.  The contract should make use of events for important functions like claimReward() so the protocol can track important events after deployment.  This can help spot unusual activity and assist in monitoring the protocol while its live.    ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L215  ## Tools Used Manual code review     
# Handle  jayjonah8   # Vulnerability details  ## Impact In WJLP.sol, the wrap() function pulls in _amount base tokens from _from, then stakes them to mint WAssets which it sends to _to.  It then updates _rewardOwner's reward tracking such that it now has the right to future yields from the newly minted WAssets.  But the function does not make sure that _from and _to are not the same address and failure to make this check in functions with transfer functionality has lead to severe bugs in other protocols since users rewards are updated on such transfers this can be used to manipulate the system.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L126  https://medium.com/@Knownsec_Blockchain_Lab/knownsec-blockchain-lab-i-kill-myself-monox-finance-security-incident-analysis-2dcb4d5ac8f   ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_from) != address(_to), "_from and _to cannot be the same")  
# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:           approve without approving 0 first WJLP.sol, 127, JLP.approve(address(_MasterChefJoe), _amount);          approve without approving 0 first EchidnaProxy.sol, 134, return yusdToken.approve(spender, amount);          approve without approving 0 first sYETIToken.sol, 229, yusdToken.approve(routerAddress, YUSDToSell);   
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ActivePool.sol, i, 133         change to prefix increment and unchecked: ActivePool.sol, i, 167         change to prefix increment and unchecked: ActivePool.sol, i, 184         change to prefix increment and unchecked: BorrowerOperations.sol, i, 699         change to prefix increment and unchecked: BorrowerOperations.sol, i, 737         change to prefix increment and unchecked: BorrowerOperations.sol, i, 873         change to prefix increment and unchecked: BorrowerOperations.sol, i, 890         change to prefix increment and unchecked: BorrowerOperations.sol, i, 920         change to prefix increment and unchecked: BorrowerOperations.sol, i, 929         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1061         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1068         change to prefix increment and unchecked: DefaultPool.sol, i, 97         change to prefix increment and unchecked: DefaultPool.sol, i, 133         change to prefix increment and unchecked: LiquityBase.sol, i, 63         change to prefix increment and unchecked: LiquityBase.sol, i, 97         change to prefix increment and unchecked: LiquityBase.sol, i, 106         change to prefix increment and unchecked: LiquityBase.sol, i, 115         change to prefix increment and unchecked: LiquityBase.sol, i, 149         change to prefix increment and unchecked: LiquityBase.sol, i, 158         change to prefix increment and unchecked: LiquityBase.sol, i, 168         change to prefix increment and unchecked: YetiCustomBase.sol, i, 36         change to prefix increment and unchecked: YetiCustomBase.sol, i, 44         change to prefix increment and unchecked: YetiCustomBase.sol, i, 59         change to prefix increment and unchecked: YetiCustomBase.sol, i, 104         change to prefix increment and unchecked: YetiCustomBase.sol, i, 122         change to prefix increment and unchecked: YetiCustomBase.sol, i, 144         change to prefix increment and unchecked: YetiCustomBase.sol, i, 152         change to prefix increment and unchecked: YetiCustomBase.sol, i, 165         change to prefix increment and unchecked: YetiCustomBase.sol, i, 178         change to prefix increment and unchecked: HintHelpers.sol, i, 139         just change to unchecked: MultiTroveGetter.sol, idx, 73         just change to unchecked: MultiTroveGetter.sol, idx, 79         just change to unchecked: MultiTroveGetter.sol, idx, 90         just change to unchecked: MultiTroveGetter.sol, idx, 96         change to prefix increment and unchecked: MultiTroveGetter.sol, i, 110         change to prefix increment and unchecked: StabilityPool.sol, i, 562         change to prefix increment and unchecked: StabilityPool.sol, i, 588         change to prefix increment and unchecked: StabilityPool.sol, i, 592         change to prefix increment and unchecked: StabilityPool.sol, i, 628         change to prefix increment and unchecked: StabilityPool.sol, i, 720         change to prefix increment and unchecked: StabilityPool.sol, i, 942         change to prefix increment and unchecked: StabilityPool.sol, i, 1011         change to prefix increment and unchecked: TeamAllocation.sol, i, 66         change to prefix increment and unchecked: CDPManagerTester.sol, i, 14         change to prefix increment and unchecked: EchidnaTester.sol, i, 103         change to prefix increment and unchecked: EchidnaTester.sol, i, 121         change to prefix increment and unchecked: TroveManager.sol, i, 234         change to prefix increment and unchecked: TroveManager.sol, i, 348         change to prefix increment and unchecked: TroveManager.sol, i, 374         change to prefix increment and unchecked: TroveManager.sol, i, 397         change to prefix increment and unchecked: TroveManager.sol, i, 420         change to prefix increment and unchecked: TroveManager.sol, i, 460         change to prefix increment and unchecked: TroveManager.sol, i, 476         change to prefix increment and unchecked: TroveManager.sol, i, 525         change to prefix increment and unchecked: TroveManager.sol, i, 582         change to prefix increment and unchecked: TroveManager.sol, i, 603         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 255         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 334         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 394         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 475         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 808         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 840         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 304         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 517  
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           BorrowerOperations.sol, variable name: _colls times: 2 at: _requireNoDuplicateColls         BorrowerOperations.sol, variable name: _indices times: 2 at: _requireRouterAVAXIndicesInOrder         DefaultPool.sol, variable name: _amounts times: 2 at: sendCollsToActivePool         YetiCustomBase.sol, variable name: _amounts times: 2 at: _subColls         StabilityPool.sol, variable name: amounts times: 2 at: _sendGainsToDepositor         TroveManager.sol, variable name: lastCollError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: lastYUSDDebtError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: totalStakes times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: allColls times: 2 at: _closeTrove    
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           WJLP.sol Variable activePool is read 2 times in the function: unwrapFor         WJLP.sol Variable stabilityPool is read 2 times in the function: unwrapFor         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice_v         EchidnaTester.sol Variable troveManager is read 9 times in the function: constructor         EchidnaTester.sol Variable borrowerOperations is read 8 times in the function: constructor         EchidnaTester.sol Variable activePool is read 6 times in the function: constructor         EchidnaTester.sol Variable defaultPool is read 4 times in the function: constructor         EchidnaTester.sol Variable stabilityPool is read 6 times in the function: constructor         EchidnaTester.sol Variable gasPool is read 3 times in the function: constructor         EchidnaTester.sol Variable troveManagerLiquidations is read 4 times in the function: constructor         EchidnaTester.sol Variable troveManagerRedemptions is read 5 times in the function: constructor         EchidnaTester.sol Variable yusdToken is read 5 times in the function: constructor         EchidnaTester.sol Variable whitelist is read 4 times in the function: constructor         EchidnaTester.sol Variable collSurplusPool is read 4 times in the function: constructor         EchidnaTester.sol Variable priceFeedTestnet is read 3 times in the function: constructor         EchidnaTester.sol Variable sortedTroves is read 4 times in the function: constructor         EchidnaTester.sol Variable MCR is read 2 times in the function: constructor         EchidnaTester.sol Variable CCR is read 2 times in the function: constructor         ERC20.sol Variable totalSupply is read 2 times in the function: _mint         TeamLockup.sol Variable totalClaimed is read 2 times in the function: claimYeti         YETIToken.sol Variable _totalSupply is read 2 times in the function: constructor   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: ActivePool.sol, In line 252, Require message length to shorten: 35, The message: ActivePool: Caller is not whitelist         Solidity file: BorrowerOperations.sol, In line 215, Require message length to shorten: 39, The message: BOps: colls and amounts length mismatch         Solidity file: BorrowerOperations.sol, In line 874, Require message length to shorten: 33, The message: BOps: Collateral not in whitelist         Solidity file: CollSurplusPool.sol, In line 167, Require message length to shorten: 40, The message: CollSurplusPool: Caller is not Whitelist         Solidity file: DefaultPool.sol, In line 122, Require message length to shorten: 38, The message: DefaultPool: sending collateral failed         Solidity file: DefaultPool.sol, In line 167, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: LiquitySafeMath128.sol, In line 10, Require message length to shorten: 37, The message: LiquitySafeMath128: addition overflow         Solidity file: LiquitySafeMath128.sol, In line 16, Require message length to shorten: 40, The message: LiquitySafeMath128: subtraction overflow         Solidity file: SafeMath.sol, In line 87, Require message length to shorten: 33, The message: SafeMath: multiplication overflow         Solidity file: Address.sol, In line 115, Require message length to shorten: 38, The message: Address: insufficient balance for call         Solidity file: Address.sol, In line 140, Require message length to shorten: 36, The message: Address: static call to non-contract         Solidity file: SortedTroves.sol, In line 131, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: SortedTroves.sol, In line 230, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: StabilityPool.sol, In line 1076, Require message length to shorten: 39, The message: StabilityPool: Caller is not ActivePool         Solidity file: StabilityPool.sol, In line 1095, Require message length to shorten: 40, The message: StabilityPool: User must have no deposit         Solidity file: StabilityPool.sol, In line 1099, Require message length to shorten: 38, The message: StabilityPool: Amount must be non-zero         Solidity file: StabilityPool.sol, In line 1138, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: SortedTrovesTester.sol, In line 23, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: TroveManagerLiquidations.sol, In line 180, Require message length to shorten: 34, The message: TroveManager: nothing to liquidate         Solidity file: TroveManagerRedemptions.sol, In line 520, Require message length to shorten: 34, The message: must be non zero redemption amount         Solidity file: CommunityIssuance.sol, In line 131, Require message length to shorten: 35, The message: CommunityIssuance: caller is not SP         Solidity file: YETIToken.sol, In line 198, Require message length to shorten: 36, The message: YETI: transfer from the zero address         Solidity file: YETIToken.sol, In line 222, Require message length to shorten: 39, The message: YETI: caller must be the SYETI contract         Solidity file: YUSDToken.sol, In line 294, Require message length to shorten: 37, The message: YUSD: Caller is not the StabilityPool  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           ActivePool.sol, line 6, import "./Interfaces/IStabilityPool.sol";         ActivePool.sol, line 7, import "./Interfaces/IDefaultPool.sol";         ActivePool.sol, line 13, import "./Dependencies/LiquityBase.sol";         ERC20_8.sol, line 3, import "./Interfaces/IERC20_8.sol";         IMasterChefJoeV2.sol, line 1, import "./IERC20_8.sol";         IRewarder.sol, line 3, import "./IERC20_8.sol";         LiquityBase.sol, line 8, import "../Interfaces/IWhitelist.sol";         TroveManagerBase.sol, line 12, import "../Interfaces/IWhitelist.sol";         Whitelist.sol, line 13, import "../Interfaces/IERC20.sol";         Whitelist.sol, line 14, import "./LiquityMath.sol";         YetiCustomBase.sol, line 6, import "../Interfaces/IERC20.sol";         ICollSurplusPool.sol, line 4, import "../Dependencies/YetiCustomBase.sol";         ILiquityBase.sol, line 4, import "./IPriceFeed.sol";         MockAggregator.sol, line 5, import "hardhat/console.sol";         NonPayable.sol, line 4, //import "hardhat/console.sol";         SortedTrovesTester.sol, line 4, import "../Interfaces/ISortedTroves.sol";         TroveManagerLiquidations.sol, line 6, import "hardhat/console.sol";         sYETIToken.sol, line 9, import "./BoringCrypto/BoringBatchable.sol";  
# Handle  pauliax   # Vulnerability details  ## Impact condition should be inclusive >= : ```solidity   if (available > totalClaimed.add(_amount)) ```  
# Handle  gzeon   # Vulnerability details  ## Impact The 3 variable defined in L365-367 are used only once https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/Whitelist.sol#L365-367 ```         uint256 price = getPrice(_collateral);         uint256 decimals = collateralParams[_collateral].decimals;         uint256 ratio = collateralParams[_collateral].ratio; ```  We can skip them and do everything inline: ``` return (getPrice(_collateral).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals))); ```  Similarly, L352-354 ```         return getPrice(_collateral).mul(_amount).div(10**collateralParams[_collateral].decimals); ```  
# Handle  pauliax   # Vulnerability details  ## Impact _isBeforeFeeBootstrapPeriod() is re-evaluated again and again inside the loop, although its value could be cached outside the loop and re-used to reduce gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact In function _transfer, shares.to128(); can be cached to skip the same calculation again: ```solidity   users[from].balance = fromUser.balance - shares.to128();   users[to].balance = toUser.balance + shares.to128(); ``` Same here, the result can be extracted to a constant as it never changes: ```solidity   (DECIMAL_PRECISION / 2) ```  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `troveManager` in `TroveManagerRedemptions#_updateBaseRateFromRedemption()`      https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L432-L447      ```solidity=432     function _updateBaseRateFromRedemption(uint256 _YUSDDrawn, uint256 _totalYUSDSupply)     internal     returns (uint256)     {         uint256 decayedBaseRate = troveManager.calcDecayedBaseRate();          /* Convert the drawn Collateral back to YUSD at face value rate (1 YUSD:1 USD), in order to get          * the fraction of total supply that was redeemed at face value. */         uint256 redeemedYUSDFraction = _YUSDDrawn.mul(10**18).div(_totalYUSDSupply);          uint256 newBaseRate = decayedBaseRate.add(redeemedYUSDFraction.div(BETA));         newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%          troveManager.updateBaseRate(newBaseRate);         return newBaseRate;     }     ```  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L791-L795  ```solidity=791 if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease      newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee)); } else { // otherwise increase by opposite subtraction     newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange)); } ```  `_debtChange - _variableYUSDFee` at L792 and `_variableYUSDFee - _debtChange` at L794 will never underflow.   https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L240-L241  ```solidity=240 _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); ```  `_balances[account] + amount` will not overflow if `_totalSupply.add(amount)` dose not overflow.    https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L248-L249  ```solidity=248 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance"); _totalSupply = _totalSupply.sub(amount); ```  `_totalSupply - amount` will not underflow if `_balances[account].sub(amount)` dose not underflow.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L839-L847  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {         for (uint i = 0; i < _colls.tokens.length; i++) {             address token = _colls.tokens[i];             uint amount = _colls.amounts[i];             if (whitelist.isWrapped(token)) {                 IWAsset(token).updateReward(_borrower, _newOwner, amount);             }         }     } ```  Since `amount` is only needed in `if (whitelist.isWrapped(token)) {...}`, so `uint amount = _colls.amounts[i];` should be moved to inside `if (whitelist.isWrapped(token)) {...}`.  Furthermore, considering that `amount` is only used once, it can be replaced with `_colls.amounts[i]`.  ### Recommendation  Change to:  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     for (uint i = 0; i < _colls.tokens.length; i++) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L297-L301  ```solidity=297     function _requireCallerIsTMLorSP() internal view {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             "YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool");     } ```  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L128-L131  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         _requireCallerIsTMLorSP();         _transfer(_poolAddress, _receiver, _amount);     } ```   `_requireCallerIsTMLorSP()` is unnecessary as it's being used only once. Therefore it can be inlined in `returnFromPool()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             "YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool");         _transfer(_poolAddress, _receiver, _amount);     } ```  Other examples include:  -   `TroveManagerRedemptions.sol#_getRedemptionFee()` can be inlined in `TroveManagerRedemptions.sol#redeemCollateral()`  
# Handle  kenzo   # Vulnerability details  TeamLockup mentions on "vestingLength" that it is the "number of YETI that are claimable every day after vesting starts". However, the vesting calculation treats it as if was the number of YETI that are claimable every second, not every day.  ## Impact Tokens would be released faster than planned. Or, if the tokens are planned to be released every second and not every day (I'm guessing it's less likely), then this is a wrong comment.  ## Proof of Concept The description of `vestingLength`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L15) ```     uint immutable vestingLength; // number of YETI that are claimable every day after vesting starts ```  The calculation to decide how many tokens can be released: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L41:#L43) ```         uint timePastVesting = block.timestamp.sub(vestingStart);         uint available = _min(totalVest,(totalVest.mul(timePastVesting)).div(vestingLength)); ``` The problem is that `timePastVesting` is in seconds, and `vestingLength` is in days.  ## Recommended Mitigation Steps Divide the calculation by `1 day` to align the units.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/ERC20_8.sol#L68-L70  ```solidity=68         require(_num_tokens <= balances[msg.sender], "You are trying to transfer more tokens than you have");          balances[msg.sender] = balances[msg.sender] - _num_tokens; ```  `balances[msg.sender] - _num_tokens` will never underflow.  
# Handle  kenzo   # Vulnerability details  LockupContract, LockupContractFactory amd ShortLockupContract all have comments that say: ``` Within the first year from deployment, the deployer of the YETIToken (Liquity AG's address) may transfer YETI only to valid LockupContracts, and no other addresses (this is enforced in YETIToken.sol's transfer() function). The above two restrictions ensure that until one year after system deployment, YETI tokens originating from Liquity AG cannot enter circulating supply and cannot be staked to earn system revenue. ```  This comment is outdated (verified with sponsor). There is no such lockup on YETI tokens issued to team/treasury. (There might be other type of vesting which is probably implemented using TeamLockup.)  ## Impact Confusion, wrong description of team's capability to use yeti tokens issued.  ## Proof of Concept [Code ref](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/LockupContract.sol#L13:#L18).  ## Recommended Mitigation Steps Remove outdated comments.  
# Handle  pauliax   # Vulnerability details  ## Impact ecrecover returns an empty address when the signature is invalid. As far as I checked, with the current codebase, there is no way to exploit it to gain any benefits, but it is a good practice to check against that. ```solidity   address recoveredAddress = ecrecover(digest, v, r, s);   require(recoveredAddress == owner, 'YUSD: invalid signature'); ```  ## Recommended Mitigation Steps require recoveredAddress != address(0)  You could also consider using OZ's ECDSA library for signature verifications: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function setAddresses in contract Whitelist is intended to be invoked only once (confirmed with the sponsor) but currently, it has no prevention from being called multiple times.  Maybe this should also be prevented in sYETIToken's setAddresses and ThreePieceWiseLinearPriceCurve's setAddresses.  ## Recommended Mitigation Steps Prevent repeated access of setAddresses in Whitelist and potentially in sYETIToken and ThreePieceWiseLinearPriceCurve.  
# Handle  Ruhum   # Vulnerability details  ## Impact View functions consume less gas. `WJLP.getPendingRewards()` is technically also a view function but not specified as one. Because the `IMasterChefJoeV2` interface used by the contract is wrong. It says `poolInfo()` is not a view function, which it is.  ## Proof of Concept getPendingRewards: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L190  Faulty interface function: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L29  actually poolinfo is just an array so its getter is a view function: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV2.sol#L85  ## Tools Used none  ## Recommended Mitigation Step Declare both functions as `view` to save gas  
# Handle  Ruhum   # Vulnerability details  ## Impact All the other passed variables are checked. Only `_whitelistAddress` is ignored. This allows passing a zero function which would break the functionality.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/CollSurplusPool.sol#L51-L54  ## Tools Used none  ## Recommended Mitigation Steps add `checkContract(_whitelistAddress)`  
# Handle  kenzo   # Vulnerability details  When changing collateral's ratio, it is rightly checked to be smaller than 110%. However when adding new collateral, the ratio check is not there, so it can be added with ratio that is larger than 110%.  ## Impact Accidentally adding an asset with larger ratio would result in users being able to withdraw more YUSD than supplied VC.  ## Proof of Concept When an asset is being added, there is no sanity check that the ratio is within the correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L92:#L127)  This is unlike `changeRatio`, which validates that the new ratio is in correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L204) ``` require(_ratio < 1100000000000000000, "ratio must be less than 1.10 => greater than 1.1 would mean taking out more YUSD than collateral VC"); ```  ## Recommended Mitigation Steps Add the same ratio check to `addCollateral`.  
# Handle  cmichel   # Vulnerability details  Calling `WJLP.unwrap` burns WJLP, withdraws the amount from the master chef and returns the same amount of JLP back to the `to` address. However, it does not update the internal accounting in `WJLP` with a `_userUpdate` call.  This needs to be done on the caller side according to the comment in the `WJLP.unwrap` function: > "Prior to this being called, the user whose assets we are burning should have their rewards updated"  This happens when being called from the `StabilityPool` but not when being called from the `ActivePool.sendCollateralsUnwrap`:  ```solidity function sendCollateralsUnwrap(address _to, address[] memory _tokens, uint[] memory _amounts, bool _collectRewards) external override returns (bool) {     _requireCallerIsBOorTroveMorTMLorSP();     require(_tokens.length == _amounts.length);     for (uint i = 0; i < _tokens.length; i++) {         if (whitelist.isWrapped(_tokens[i])) {             // @audit this burns the tokens for _to but does not reduce their amount. so there are no tokens in WJLP masterchef but can keep claiming             IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]);             if (_collectRewards) {                 IWAsset(_tokens[i]).claimRewardFor(_to);             }         } else {             _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails         }     }     return true; } ```  ## Impact The `unwrapFor` call withdraws the tokens from the Masterchef and pays out the user, but their user balance is never decreased by the withdrawn amount. They can still use their previous balance to claim rewards through `WJLP.claimReward` which updated their unclaimed joe reward according to the old balance. Funds from the WJLP pool can be stolen.  ## Recommended Mitigation Steps As the comment says, make sure the user is updated before each `unwrap` call. It might be easier and safer to have a second authorized `unwrapFor` function that accepts a `rewardOwner` parameter, the user that needs to be updated.   
# Handle  cmichel   # Vulnerability details  The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:  ```solidity function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {     require(YUSDToSell > 0, "Zero amount");     require(lastBuybackTime + 69 hours < block.timestamp, "Must have 69 hours pass before another buyBack");     yusdToken.approve(routerAddress, YUSDToSell);     uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);     lastBuybackTime = block.timestamp;     // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]     // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)     lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);     emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]); } ```  It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap `path` parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).  ## Impact The `lastBuyBackPrice` will be wrong when using a different path. This will lead `rebase`s using a different yeti amount and the `effectiveYetiTokenBalance` being updated wrong.  ## Recommended Mitigation Steps Verify the first and last element of the path are YETI/YUSD and use the first and last amount parameter.   
# Handle  cmichel   # Vulnerability details  The `sYETIToken.transferFrom` function does not emit a new `Approval` event when decreasing the allowance. Most ERC20 implementations, like OpenZeppelin's, emit this event when the `allowance` is decreased.  ## Impact Off-chain scripts and frontends will not correctly track the `allowance`s of users when listening to the `Approval` event. This can lead to failed transactions as a higher approval is assumed than it actually is.  ## Recommended Mitigation Steps Emit the `Approval` event also in `transferFrom` if the approval is decreased.   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..  ```solidity if (decay > 0 && decay < decayTime) {     // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     fee = lastFeePercent; } ```  ## Recommended Mitigation Steps It seems wrong to handle the `decay == 0` case (decay happened in same block) the same way as the `decay >= decayTime` case (decay happened long time ago) as is done in the `else` branch. I believe it should be like this instead:  ```solidity // decay == 0 case should be full lastFeePercent if(decay < decayTime) {     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     // reset to zero if decay >= decayTime     fee = 0; } ```  
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap:  > If dollarCap == 0, then it is not capped. Otherwise, **then the total + the total input** must be less than the cap.  The code only checks if the input is less than the cap:  ```solidity // @param _collateralVCInput is how much collateral is being input by the user into the system if (dollarCap != 0) {     require(_collateralVCInput <= dollarCap, "Collateral input exceeds cap"); } ```  ## Recommended Mitigation Steps Clarify the desired behavior and reconcile the code with the comments.   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1, f2, f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0), b3 = f_3(0)`) for each of these but uses **unsigned integers** for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.  #### Example: Check out this two-piece linear interest curve of Aave:  ![Aave](https://docs.aave.com/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M51Fy3ipxJS-0euJX3h-2670852272%2Fuploads%2Fycd9OMRnInNeetUa7Lj1%2FScreenshot%202021-11-23%20at%2018.52.26.png?alt=media&token=7a25b900-7023-4ee5-b582-367d56d31894) The intersection of the second steep straight line with the y-axis `b_2 = f_2(0)` would be negative.  Example: Imagine a curve that is flat at `10%` on the first 50% utilization but shoots up to `110%` at 100% utilization.  - `m1 = 0, b1 = 10%, cutoff1 = 50%`  - `m2 = 200%` => `b2 = m1 * cutoff1 + b1 - m2 * cutoff1 = f1(cutoff1) - m2 * cutoff1 = 10% - 200% * 50% = 10% - 100% = -90%`. (`f2(100%) = 200% * 100% - 90% = 110%` ✅) This function would revert in the `b2` computation as it underflows due to being a negative value.  ## Impact Most curves that are actually desired for a lending platform (becoming steeper at higher utilization) cannot be used.  ## Recommended Mitigation Steps Evaluate the piecewise linear function in a different way that does not require computing the y-axis intersection value. For example, for `cutoff2 >= x > cutoff1`, use `f(x) = f_1(cutoff) + f_2(x - cutoff)`. See [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol#L85).   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function does not check that `_cutoff1 <= _cutoff2` and also does not revert in this case. However, this always indicates an error in how this function should be used.  ## Recommended Mitigation Steps Add a `_cutoff1 <= _cutoff2` check.  
# Handle  heiho1   # Vulnerability details  ## Impact  CheckContract is used in ActivePool, BorrowerOperations, CollSurplusPool, DefaultPool, HintHelpers, PriceFeed, SortedTroves, StabilityPool, TroveManager, TroveManagerLiquidations, TroveManagerRedemptions but this is a view function and could easily be implemented as an internal library call.  This would result in slightly larger contract bytecode but should be far more gas efficient than an external contract call as is the current case.  ## Proof of Concept  https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678  """ Use any of the internal calling methods. We prefer internal library calls, because of the associated class features (see Class Features of Solidity by the same author). Using an external call to a public library function is very expensive, and will only be worth it to avoid including a lot of code into the bytecode for your contract. Using a local contract component is the most expensive option and should be avoided unless essential. """  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/CheckContract.sol#L6  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare CheckContract as an internal library:  https://medium.com/coinmonks/all-you-should-know-about-libraries-in-solidity-dd8bc953eae7  """ Embedded Library: If a smart contract is consuming a library which have only internal functions than EVM simply embeds library into the contract. Instead of using delegate call to call a function, it simply uses JUMP statement(normal method call). There is no need to separately deploy library in this scenario. """  
# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerRedemptions does not inherit contracts/Interfaces/ITroveManagerRedemptions.sol but should.  Note that TroveManager.sol does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L38  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as "TroveManagerRedemptions is TroveManagerBase, ITroveManagerRedemptions"  
# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerLiquidations does not inherit contracts/Interfaces/ITroveManagerLiquidations.sol but should.  Note that TroveManager.sol  does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L14  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as "TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations"  
# Handle  heiho1   # Vulnerability details  ## Impact  Got an error attempting Slither analysis due to several contracts defining "SafeMath"   - In this case there are *two* distinct safe math libraries, one dependent on solc 0.6.11 and one dependent on solc ^0.8.0. This can lead to confusion during development.  Ideally the safe math version of the application contract [0.6.11] would be standardized but in this case *re-naming* the SafeMath contracts also suffices.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol#L15  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/SafeMath.sol#L21    ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol to SafeMath080.sol [and updating the declared contract to the same name]  
# Handle  heiho1   # Vulnerability details  ## Impact Got an error attempting Slither analysis due to Pool2Unipool and Unipool declaring the same contract named LPTokenWrapper.  It is confusing and error prone to have such similarly named contracts and there is no clear benefit to re-using the name.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename LPTokenWrapper in Pool2Unipool to 'Pool2LPTokenWrapper' and correct any related imports.  
# Handle  Dravee   # Vulnerability details  ## Impact In a number of places a `keccak("string")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  ## Proof of Concept ``` YETI\YETIToken.sol:   50:     bytes32 private constant _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");   51:     bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");  YETI\BoringCrypto\Domain.sol:   10:     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256("EIP712Domain(uint256 chainId,address verifyingContract)"); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change all `constant` hashes to be `immutable`  
# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.   ## Proof of Concept Instances missing a non-zero check: ``` ActivePool.sol:   156:         bool sent = IERC20(_collateral).transfer(_to, _amount);  BorrowerOperations.sol:   742:             bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);  DefaultPool.sol:   121:         bool success = IERC20(_collateral).transfer(activePool, _amount);  StabilityPool.sol:   947:                 IERC20(assets[i]).transfer(_to, amounts[i]);  TeamAllocation.sol:   69:             require(YETI.transfer(member, amount));   77:         YETI.transfer(_to, _amount);  YetiFinanceTreasury.sol:   25:         _token.transfer(_to, _amount);  AssetWrappers\WJLP\WJLP.sol:   127:         JLP.transferFrom(_from, address(this), _amount);   166:         JLP.transfer(_to, _amount);   273:             JOE.transfer(_to, _amount);  Dependencies\LiquityBase.sol:   170:             if (!token.transfer(_to, _coll.amounts[i])) {  LPRewards\Dependencies\SafeERC20.sol:   23:         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));   27:         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));  YETI\CommunityIssuance.sol:   125:         yetiToken.transfer(_account, _YETIamount);  YETI\LockupContract.sol:   68:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\ShortLockupContract.sol:   67:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\sYETIToken.sol:   203:         yetiToken.transfer(to, amount);  YETI\TeamLockup.sol:   47:             require(YETI.transfer(multisig, _amount)); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0. It is done at some places already, like here: https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/LPRewards/Unipool.sol#L189-L192  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L890`  ``` https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L699  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L873  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L920  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L929  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/ActivePool.sol#L167  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `WJLP.sol`, state variables `JLP` and `JOE` are initialized in the constructor and never reassigned again. Thus, they can be declared `immutable` rather than `constant` in order to save gas  ## Proof of Concept  [https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41)  ## Tools Used  Editor  
# Handle  kenzo   # Vulnerability details  When ActivePool sends collateral which is a wrapped asset, it first unwraps the asset, and only after that updates the rewards. This should be done in opposite order. As a comment in WJLP's `unwrapFor` rightfully mentions - "Prior to this being called, the user whose assets we are burning should have their rewards updated".  ## Impact Lost yield for user.  ## Proof of Concept In ActivePool's `sendCollateralsUnwrap` (which is used throughout the protocol), it firsts unwraps the asset, and only afterwards calls `claimRewardFor` which will update the rewards: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol#L186:#L188) ``` IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]); if (_collectRewards) {         IWAsset(_tokens[i]).claimRewardFor(_to); } ``` `claimRewardFor` will end up calling `_userUpdate`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L246:#L263) ```     function _userUpdate(address _user, uint256 _amount, bool _isDeposit) private returns (uint pendingJoeSent) {         uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;         UserInfo storage user = userInfo[_user];         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12);     } ``` Now, as ActivePool has already called `unwrapFor` and has burnt the user's tokens, and let's assume they all were used as collateral, it means user.amount=0*, and the user's unclaimedJOEReward won't get updated to reflect the rewards from the last user update. This is why, indeed as the comment in `unwrapFor` says, user's reward should be updated prior to that.  *Note: at the moment `unwrapFor` doesn't updates the user's user.amount, but as I detailed in another issue, that's a bug, as that means the user will continue accruing rewards even after his JLP were removed from the protocol.  ## Recommended Mitigation Steps Change the order of operations in `sendCollateralsUnwrap` to first send the updated rewards and then unwrap the asset. You can also consider adding to the beginning of `unwrapFor` a call to `_userUpdate(_to, 0, true)` to make sure the rewards are updated before unwrapping. Note: as user can choose to have JOE rewards accrue to a different address than the address that uses WJLP as collateral, you'll have to make sure you update the current accounts. I'll detail this in another issue.  
# Handle  kenzo   # Vulnerability details  After updating user's rewards in `_userUpdate`, if the user has not claimed them, and `_userUpdate` is called again (eg. on another `wrap`), the user's unclaimed rewards will lose the previous unclaimed due to wrong calculation.  ## Impact Loss of yield for user.  ## Proof of Concept When updating the user's unclaimedJoeReward, the function doesn't save it's previous value. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L251:#L253) ```         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         // update for JOE rewards that are already accounted for in user.unclaimedJOEReward         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12); ``` So for example, rewards can be lost in the following scenario. We'll mark "acc1" for the value of "accJoePerShare" at step 1. 1. User Zebulun wraps 100 tokens. After  `_userUpdate` is called: unclaimedJOEReward  = 0, rewardDebt = 100*acc1. 2. Zebulun wraps 50 tokens: unclaimedJOEReward = 100*acc2 - 100*acc1, rewardDebt = 150 * acc2. 3. Zebulun wraps 1 token: unclaimedJOEReward = 150*acc3 - 150*acc2, rewardDebt = 151*acc3 So in the last step, Zebulun's rewards only take into account the change in accJoePerShare in steps 2-3, and lost the unclaimed rewards from steps 1-2.  ## Recommended Mitigation Steps Change the unclaimed rewards calculation to: ``` user.unclaimedJOEReward = user.unclaimedJOEReward.add(user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt)); ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact Gas wastage  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/YetiCustomBase.sol  2. Observe that in _subColls function the last for loop is not required if n=0 since this means that all token amount is 0   
# Handle  kenzo   # Vulnerability details  WJLP can only be unwrapped from the Active Pool or Stability Pool. A user who decided to wrap his JLP, but not use all of them in a trove, Wouldn't be able to just unwrap them.  ## Impact Impaired functionality for users. Would have to incur fees for simple unwrapping.  ## Proof of Concept The unwrap functionality is only available from `unwrapFor` function, and that function is only callable from AP or SP. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L149) ``` function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP(); ```  ## Recommended Mitigation Steps Allow anybody to call the function. As it will burn the holder's WJLP, a user could only unwrap tokens that are not in use.  
# Handle  kenzo   # Vulnerability details  WJLP doesn't update the inner accounting (for JOE rewards) when unwrapping user's tokens. The user will continue to receive rewards, on the expanse of users who haven't claimed their rewards yet.  ## Impact Loss of yield for users.  ## Proof of Concept The unwrap function just withdraws JLP from MasterChefJoe, burns the user's WJLP, and sends the JLP back to the user. It does not update the inner accounting (`userInfo`). [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L167) ```     function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP();         _MasterChefJoe.withdraw(_poolPid, _amount);         // msg.sender is either Active Pool or Stability Pool         // each one has the ability to unwrap and burn WAssets they own and         // send them to someone else         _burn(msg.sender, _amount);         JLP.transfer(_to, _amount);     } ```  ## Recommended Mitigation Steps Need to keep userInfo updated. Have to take into consideration the fact that user can choose to set the reward claiming address to be a different account than the one that holds the WJLP.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variables `yetiToken` and `unlockTime` inside the `ShortLockupContract` contract are never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variable `yetiToken` inside the `LockupContract` contract is never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  
# Handle  hyh   # Vulnerability details  # Impact  The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to `effectiveYetiTokenBalance` during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.  The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users’ claims. In other words, the contract will be in default if enough users claim after that.  ## Proof of Concept  Now the whole balance amount is used instead of the amount bought back from market.  Rebasing amount is added to `effectiveYetiTokenBalance`, so it should be limited by extra Yeti tokens, not the whole balance: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L247  ## Recommended Mitigation Steps  It looks like only extra tokens should be used for the check, i.e. `yetiToken.balance - effectiveYetiTokenBalance`.  Now: ``` function rebase() external {   ...   uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));   uint256 valueOfContract = _getValueOfContract(yetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (yetiTokenBalance < additionalYetiTokenBalance) {     additionalYetiTokenBalance = yetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {   uint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```  As the `_getValueOfContract` function isn't used elsewhere, the logic can be simplified. To be: ``` function rebase() external {   ...   uint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);   uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (additionalYetiTokenBalance > adjustedYetiTokenBalance) {     additionalYetiTokenBalance = adjustedYetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```   
# Handle  hyh   # Vulnerability details  # Impact  Core system logic can break up if enumeration structure be updated.  ## Proof of Concept  BorrowerOperations and StabilityPool check the active status of a trove by comparing TroveManager's getTroveStatus with 1: BorrowerOperations: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L902 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L907 StabilityPool: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1104  TroveManagers inherit Status enumeration from TroveManagerBase: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TroveManagerBase.sol#L72  ## Recommended Mitigation Steps  With further system development it will be harder to track fixes needed on enumeration change. Consider implementing TroveManager.isTroveActive(borrower) where trove.status is checked against Status.active and the corresponding boolean is returned.   
# Handle  hyh   # Vulnerability details  # Impact  Transactions will not be reverted on failed transfer call, setting system state as if it was successful. This will lead to wrong state accounting down the road with a wide spectrum of possible consequences.  ## Proof of Concept  _safeJoeTransfer do not check for JOE.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L268  _safeJoeTransfer is called by _sendJoeReward, which is used in reward claiming.  JOE token use transfer from OpenZeppelin ERC20: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/JoeToken.sol#L9  Which does return success code: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L113  Trader Joe also uses checked transfer when dealing with JOE tokens: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L102   Also, unwrapFor do not check for JLP.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L166   ## Recommended Mitigation Steps  Add a require() check for the success of JOE transfer in _safeJoeTransfer function and create and use a similar function with the same check for JLP token transfers  
# Handle  hyh   # Vulnerability details  Console log code to be removed: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152  
# Handle  hyh   # Vulnerability details  # Impact  WJLP set configuration variables via setAddresses initialize function that has no access controls, so whenever it is being run not atomically with contract creation it can be front run by an attacker. The fix is to redeploy the contracts.  ## Proof of Concept  WJLP.setAddresses: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L102  WJLP.constructor: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L82  ## Recommended Mitigation Steps  a. Either set access rights in the constructor and restrict initialize access b. Or run setAddresses atomically along with contract construction each time  It is also advised to check for zero addressed supplied by a caller both in constructor and setAddresses. Misconfiguration with zero address also leads to redeployment.  
# Handle  dalgarim   # Vulnerability details  ## Impact sYETIToken.sol mint function checks if msg.sender is zero address. It is extremely unlikely that someone possesses a private key of zero address. This 'require' statement semantically has no meaning  ## Proof of Concept [mint](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L175) ``` function mint(uint256 amount) public returns (bool) {         require(msg.sender != address(0), "Zero address");         User memory user = users[msg.sender];          uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;         user.balance += shares.to128();         user.lockedUntil = (block.timestamp + LOCK_TIME).to128();         users[msg.sender] = user;         totalSupply += shares;          yetiToken.sendToSYETI(msg.sender, amount);         effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);          emit Transfer(address(0), msg.sender, shares);         return true;     } ```  ## Tools Used Manual  ## Recommended Mitigation Steps The require statement can be removed  
# Handle  Jujic   # Vulnerability details  ## Impact The uint   `percentBacked ` can not  be negative.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L131 ``` uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance); require(percentBacked <= 1e18 && percentBacked >= 0, "percent backed out of bounds"); ```  ## Tools Used Remix  ## Recommended Mitigation Steps You should remove the `percentBacked >= 0` from require to save some gas.  
# Handle  hyh   # Vulnerability details  # Impact  Comment is misleading, now stating the opposite of the implemented logic.  ## Proof of Concept  Comment states that tokens added are `not less than amount repurchased`, while it should be `not more`: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L246   ## Recommended Mitigation Steps  Now: ``` // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  To be: ``` // Ensure that the amount of YETI tokens effectively added is <= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  _requireValidRouterParams and _requireRouterAVAXIndicesInOrder functions along with IYetiRouter interface are unused:  _requireValidRouterParams https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1053  _requireRouterAVAXIndicesInOrder https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1067  IYetiRouter import and the interface itself: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L12 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Interfaces/IYetiRouter.sol  ## Recommended Mitigation Steps  If it is not meant to be implemented further consider removal to enhance code readability and size  
# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. `withdrawColl` outcome will not be as expected by a caller.  ## Proof of Concept  `_adjustTrove` doesn't check for array lengths and all other array providing usages of this function do check them before usage.  BorrowerOperations.withdrawColl doesn't: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L373  ## Recommended Mitigation Steps  Add the check:  Now: ``` params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```  To be: ``` require(_collsOut.length == _amountsOut.length); params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```   
# Handle  Jujic   # Vulnerability details  ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L53-L55  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManager.sol#L35-L39   Example: ``` uint256 public constant BOOTSTRAP_PERIOD = 14 days; ``` ## Tools Used Remix ## Recommended Mitigation Steps  
# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.  Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.  Example Medium Issue : https://github.com/code-423n4/2021-08-notional-findings/issues/18  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/PriceFeed.sol#L578"  2. Only the following checks are implemented.  ```         if (!_response.success) {return true;}         // Check for an invalid roundId that is 0         if (_response.roundId == 0) {return true;}         // Check for an invalid timeStamp that is 0, or in the future         if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}         // Check for non-positive price         if (_response.answer <= 0) {return true;}   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```  
# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. The following contract is using ABI coder v2.  "https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/YETI/sYETIToken.sol#L3"   ## Tools Used  None  ## Recommended Mitigation Steps  Upgrade pragma to 0.8.0  and After the 0.8.0, ABI coder v2 is activated by default. Upgrade pragma to 0.8.0 version. It is recommended to delete redundant codes.  From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  
# Handle  Jujic   # Vulnerability details  ## Impact Removing the assignment will save gas. ``` _totalSupply = 0; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L93  ## Tools Used  ## Recommended Mitigation Steps Remove the assignment.  
# Handle  Jujic   # Vulnerability details  ## Impact ``` deploymentTime = block.timestamp; uint public constant BOOTSTRAP_PERIOD = 14 days;  deploymentTime.add(BOOTSTRAP_PERIOD) // doesn't overflow  ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L899  ## Tools Used Remix ## Recommended Mitigation Steps I recommend   not  use Safemath for this operation.  
# Handle  SolidityScan   # Vulnerability details  ## Impact Events are important and should be emitted for tracking this off-chain for all important functions.   ## Proof of Concept 1. The function "updateTeamAddress" is used to update the team's address but we can notice no event is emitted.  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/TeamAllocation.sol#L81-L83  2. The same in function "updateTeamWallet" at  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YetiFinanceTreasury.sol#L28-L30  ## Tools Used  ## Recommended Mitigation Steps Add an event to these important functions where address updation is happening. This can also be marked as indexed event for better off-chain tracking  
# Handle  jayjonah8   # Vulnerability details  ## Impact the constructor in TellorCaller.sol should ensure that the _tellorMasterAddress arg passed in is not a zero address as a safegaurd.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TellorCaller.sol#L24  ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_tellorMasterAddress) != address(0), "Zero address")  
# Handle  jayjonah8   # Vulnerability details  ## Impact In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments,  but anyone can call it passing in _tokens and _amounts args to update stability pool balances.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1143  ## Tools Used Manual code review   ## Recommended Mitigation Steps Allow only the ActivePool to call the receiveCollateral() function: require(msg.sender = address(active pool address), "Can only be called by ActivePool")  
# Handle  Jujic   # Vulnerability details  ## Impact contract WJLP does not need to import this contract in production ``` import "hardhat/console.sol"; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L8  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152-L160  ## Tools Used Remix  ## Recommended Mitigation Steps Remove this contract  to reduce the size of the contract and thus save some deployment gas.  
# Handle  Jujic   # Vulnerability details  ## Impact Some of the variable can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L90-L91  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L107-L108  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L144-L145  ``` dollarCap // can be cashed decayTime // can be cashed  ``` ## Tools Used Remix  ## Recommended Mitigation Steps   
# Handle  Jujic   # Vulnerability details  ## Impact ``` IERC20 public immutable JLP; IERC20 public  immutable JOE; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41-L44  ## Tools Used REmix ## Recommended Mitigation Steps  
# Handle  SolidityScan   # Vulnerability details  ### Description  Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.  ## Impact Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ## Proof of Concept 1.  uint constant public _100pct = 1000000000000000000;  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L19  2. uint constant public _110pct = 1100000000000000000; // 1.1e18 == 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L21  3. uint constant public MCR = 1100000000000000000; // 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L24  4. uint constant public CCR = 1500000000000000000; // 150% https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L27  ## Tools Used  ## Recommended Mitigation Steps Scientific notation in the form of 2e10 is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal MeE is equivalent to M * 10**E. Examples include 2e10, 2e10, 2e-10, 2.5e1. As suggested in official docs https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals  
# Handle  SolidityScan   # Vulnerability details  ### Description  Smart Contracts are Gas sensitive and heavily depend on how Gas is spent and managed across the code. This affects each and every function definition and logic.   Therefore having any unused functions in the code cost unnecessary Gas usage and thus negatively impacts the Contract and the organization.  ## Impact Having unused function definitions and parameters negatively affects the contract and costs unnecessary Gas. This also makes it difficult and confusing for auditors to go through the code.  ## Proof of Concept The function "_getColls" is not used anywhere in the code  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L146-L153  ## Tools Used  ## Recommended Mitigation Steps Evaluate if the function call should be used anywhere otherwise remove the function definition.  
# Handle  jayjonah8   # Vulnerability details  ## Impact There are no events emitted in the WJLP.sol file for important function calls.  The contract should make use of events for important functions like claimReward() so the protocol can track important events after deployment.  This can help spot unusual activity and assist in monitoring the protocol while its live.    ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L215  ## Tools Used Manual code review     
# Handle  jayjonah8   # Vulnerability details  ## Impact In WJLP.sol, the wrap() function pulls in _amount base tokens from _from, then stakes them to mint WAssets which it sends to _to.  It then updates _rewardOwner's reward tracking such that it now has the right to future yields from the newly minted WAssets.  But the function does not make sure that _from and _to are not the same address and failure to make this check in functions with transfer functionality has lead to severe bugs in other protocols since users rewards are updated on such transfers this can be used to manipulate the system.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L126  https://medium.com/@Knownsec_Blockchain_Lab/knownsec-blockchain-lab-i-kill-myself-monox-finance-security-incident-analysis-2dcb4d5ac8f   ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_from) != address(_to), "_from and _to cannot be the same")  
# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:           approve without approving 0 first WJLP.sol, 127, JLP.approve(address(_MasterChefJoe), _amount);          approve without approving 0 first EchidnaProxy.sol, 134, return yusdToken.approve(spender, amount);          approve without approving 0 first sYETIToken.sol, 229, yusdToken.approve(routerAddress, YUSDToSell);   
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ActivePool.sol, i, 133         change to prefix increment and unchecked: ActivePool.sol, i, 167         change to prefix increment and unchecked: ActivePool.sol, i, 184         change to prefix increment and unchecked: BorrowerOperations.sol, i, 699         change to prefix increment and unchecked: BorrowerOperations.sol, i, 737         change to prefix increment and unchecked: BorrowerOperations.sol, i, 873         change to prefix increment and unchecked: BorrowerOperations.sol, i, 890         change to prefix increment and unchecked: BorrowerOperations.sol, i, 920         change to prefix increment and unchecked: BorrowerOperations.sol, i, 929         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1061         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1068         change to prefix increment and unchecked: DefaultPool.sol, i, 97         change to prefix increment and unchecked: DefaultPool.sol, i, 133         change to prefix increment and unchecked: LiquityBase.sol, i, 63         change to prefix increment and unchecked: LiquityBase.sol, i, 97         change to prefix increment and unchecked: LiquityBase.sol, i, 106         change to prefix increment and unchecked: LiquityBase.sol, i, 115         change to prefix increment and unchecked: LiquityBase.sol, i, 149         change to prefix increment and unchecked: LiquityBase.sol, i, 158         change to prefix increment and unchecked: LiquityBase.sol, i, 168         change to prefix increment and unchecked: YetiCustomBase.sol, i, 36         change to prefix increment and unchecked: YetiCustomBase.sol, i, 44         change to prefix increment and unchecked: YetiCustomBase.sol, i, 59         change to prefix increment and unchecked: YetiCustomBase.sol, i, 104         change to prefix increment and unchecked: YetiCustomBase.sol, i, 122         change to prefix increment and unchecked: YetiCustomBase.sol, i, 144         change to prefix increment and unchecked: YetiCustomBase.sol, i, 152         change to prefix increment and unchecked: YetiCustomBase.sol, i, 165         change to prefix increment and unchecked: YetiCustomBase.sol, i, 178         change to prefix increment and unchecked: HintHelpers.sol, i, 139         just change to unchecked: MultiTroveGetter.sol, idx, 73         just change to unchecked: MultiTroveGetter.sol, idx, 79         just change to unchecked: MultiTroveGetter.sol, idx, 90         just change to unchecked: MultiTroveGetter.sol, idx, 96         change to prefix increment and unchecked: MultiTroveGetter.sol, i, 110         change to prefix increment and unchecked: StabilityPool.sol, i, 562         change to prefix increment and unchecked: StabilityPool.sol, i, 588         change to prefix increment and unchecked: StabilityPool.sol, i, 592         change to prefix increment and unchecked: StabilityPool.sol, i, 628         change to prefix increment and unchecked: StabilityPool.sol, i, 720         change to prefix increment and unchecked: StabilityPool.sol, i, 942         change to prefix increment and unchecked: StabilityPool.sol, i, 1011         change to prefix increment and unchecked: TeamAllocation.sol, i, 66         change to prefix increment and unchecked: CDPManagerTester.sol, i, 14         change to prefix increment and unchecked: EchidnaTester.sol, i, 103         change to prefix increment and unchecked: EchidnaTester.sol, i, 121         change to prefix increment and unchecked: TroveManager.sol, i, 234         change to prefix increment and unchecked: TroveManager.sol, i, 348         change to prefix increment and unchecked: TroveManager.sol, i, 374         change to prefix increment and unchecked: TroveManager.sol, i, 397         change to prefix increment and unchecked: TroveManager.sol, i, 420         change to prefix increment and unchecked: TroveManager.sol, i, 460         change to prefix increment and unchecked: TroveManager.sol, i, 476         change to prefix increment and unchecked: TroveManager.sol, i, 525         change to prefix increment and unchecked: TroveManager.sol, i, 582         change to prefix increment and unchecked: TroveManager.sol, i, 603         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 255         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 334         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 394         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 475         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 808         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 840         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 304         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 517  
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           BorrowerOperations.sol, variable name: _colls times: 2 at: _requireNoDuplicateColls         BorrowerOperations.sol, variable name: _indices times: 2 at: _requireRouterAVAXIndicesInOrder         DefaultPool.sol, variable name: _amounts times: 2 at: sendCollsToActivePool         YetiCustomBase.sol, variable name: _amounts times: 2 at: _subColls         StabilityPool.sol, variable name: amounts times: 2 at: _sendGainsToDepositor         TroveManager.sol, variable name: lastCollError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: lastYUSDDebtError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: totalStakes times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: allColls times: 2 at: _closeTrove    
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           WJLP.sol Variable activePool is read 2 times in the function: unwrapFor         WJLP.sol Variable stabilityPool is read 2 times in the function: unwrapFor         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice_v         EchidnaTester.sol Variable troveManager is read 9 times in the function: constructor         EchidnaTester.sol Variable borrowerOperations is read 8 times in the function: constructor         EchidnaTester.sol Variable activePool is read 6 times in the function: constructor         EchidnaTester.sol Variable defaultPool is read 4 times in the function: constructor         EchidnaTester.sol Variable stabilityPool is read 6 times in the function: constructor         EchidnaTester.sol Variable gasPool is read 3 times in the function: constructor         EchidnaTester.sol Variable troveManagerLiquidations is read 4 times in the function: constructor         EchidnaTester.sol Variable troveManagerRedemptions is read 5 times in the function: constructor         EchidnaTester.sol Variable yusdToken is read 5 times in the function: constructor         EchidnaTester.sol Variable whitelist is read 4 times in the function: constructor         EchidnaTester.sol Variable collSurplusPool is read 4 times in the function: constructor         EchidnaTester.sol Variable priceFeedTestnet is read 3 times in the function: constructor         EchidnaTester.sol Variable sortedTroves is read 4 times in the function: constructor         EchidnaTester.sol Variable MCR is read 2 times in the function: constructor         EchidnaTester.sol Variable CCR is read 2 times in the function: constructor         ERC20.sol Variable totalSupply is read 2 times in the function: _mint         TeamLockup.sol Variable totalClaimed is read 2 times in the function: claimYeti         YETIToken.sol Variable _totalSupply is read 2 times in the function: constructor   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: ActivePool.sol, In line 252, Require message length to shorten: 35, The message: ActivePool: Caller is not whitelist         Solidity file: BorrowerOperations.sol, In line 215, Require message length to shorten: 39, The message: BOps: colls and amounts length mismatch         Solidity file: BorrowerOperations.sol, In line 874, Require message length to shorten: 33, The message: BOps: Collateral not in whitelist         Solidity file: CollSurplusPool.sol, In line 167, Require message length to shorten: 40, The message: CollSurplusPool: Caller is not Whitelist         Solidity file: DefaultPool.sol, In line 122, Require message length to shorten: 38, The message: DefaultPool: sending collateral failed         Solidity file: DefaultPool.sol, In line 167, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: LiquitySafeMath128.sol, In line 10, Require message length to shorten: 37, The message: LiquitySafeMath128: addition overflow         Solidity file: LiquitySafeMath128.sol, In line 16, Require message length to shorten: 40, The message: LiquitySafeMath128: subtraction overflow         Solidity file: SafeMath.sol, In line 87, Require message length to shorten: 33, The message: SafeMath: multiplication overflow         Solidity file: Address.sol, In line 115, Require message length to shorten: 38, The message: Address: insufficient balance for call         Solidity file: Address.sol, In line 140, Require message length to shorten: 36, The message: Address: static call to non-contract         Solidity file: SortedTroves.sol, In line 131, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: SortedTroves.sol, In line 230, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: StabilityPool.sol, In line 1076, Require message length to shorten: 39, The message: StabilityPool: Caller is not ActivePool         Solidity file: StabilityPool.sol, In line 1095, Require message length to shorten: 40, The message: StabilityPool: User must have no deposit         Solidity file: StabilityPool.sol, In line 1099, Require message length to shorten: 38, The message: StabilityPool: Amount must be non-zero         Solidity file: StabilityPool.sol, In line 1138, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: SortedTrovesTester.sol, In line 23, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: TroveManagerLiquidations.sol, In line 180, Require message length to shorten: 34, The message: TroveManager: nothing to liquidate         Solidity file: TroveManagerRedemptions.sol, In line 520, Require message length to shorten: 34, The message: must be non zero redemption amount         Solidity file: CommunityIssuance.sol, In line 131, Require message length to shorten: 35, The message: CommunityIssuance: caller is not SP         Solidity file: YETIToken.sol, In line 198, Require message length to shorten: 36, The message: YETI: transfer from the zero address         Solidity file: YETIToken.sol, In line 222, Require message length to shorten: 39, The message: YETI: caller must be the SYETI contract         Solidity file: YUSDToken.sol, In line 294, Require message length to shorten: 37, The message: YUSD: Caller is not the StabilityPool  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           ActivePool.sol, line 6, import "./Interfaces/IStabilityPool.sol";         ActivePool.sol, line 7, import "./Interfaces/IDefaultPool.sol";         ActivePool.sol, line 13, import "./Dependencies/LiquityBase.sol";         ERC20_8.sol, line 3, import "./Interfaces/IERC20_8.sol";         IMasterChefJoeV2.sol, line 1, import "./IERC20_8.sol";         IRewarder.sol, line 3, import "./IERC20_8.sol";         LiquityBase.sol, line 8, import "../Interfaces/IWhitelist.sol";         TroveManagerBase.sol, line 12, import "../Interfaces/IWhitelist.sol";         Whitelist.sol, line 13, import "../Interfaces/IERC20.sol";         Whitelist.sol, line 14, import "./LiquityMath.sol";         YetiCustomBase.sol, line 6, import "../Interfaces/IERC20.sol";         ICollSurplusPool.sol, line 4, import "../Dependencies/YetiCustomBase.sol";         ILiquityBase.sol, line 4, import "./IPriceFeed.sol";         MockAggregator.sol, line 5, import "hardhat/console.sol";         NonPayable.sol, line 4, //import "hardhat/console.sol";         SortedTrovesTester.sol, line 4, import "../Interfaces/ISortedTroves.sol";         TroveManagerLiquidations.sol, line 6, import "hardhat/console.sol";         sYETIToken.sol, line 9, import "./BoringCrypto/BoringBatchable.sol";  
# Handle  pauliax   # Vulnerability details  ## Impact condition should be inclusive >= : ```solidity   if (available > totalClaimed.add(_amount)) ```  
# Handle  gzeon   # Vulnerability details  ## Impact The 3 variable defined in L365-367 are used only once https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/Whitelist.sol#L365-367 ```         uint256 price = getPrice(_collateral);         uint256 decimals = collateralParams[_collateral].decimals;         uint256 ratio = collateralParams[_collateral].ratio; ```  We can skip them and do everything inline: ``` return (getPrice(_collateral).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals))); ```  Similarly, L352-354 ```         return getPrice(_collateral).mul(_amount).div(10**collateralParams[_collateral].decimals); ```  
# Handle  pauliax   # Vulnerability details  ## Impact _isBeforeFeeBootstrapPeriod() is re-evaluated again and again inside the loop, although its value could be cached outside the loop and re-used to reduce gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact In function _transfer, shares.to128(); can be cached to skip the same calculation again: ```solidity   users[from].balance = fromUser.balance - shares.to128();   users[to].balance = toUser.balance + shares.to128(); ``` Same here, the result can be extracted to a constant as it never changes: ```solidity   (DECIMAL_PRECISION / 2) ```  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `troveManager` in `TroveManagerRedemptions#_updateBaseRateFromRedemption()`      https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L432-L447      ```solidity=432     function _updateBaseRateFromRedemption(uint256 _YUSDDrawn, uint256 _totalYUSDSupply)     internal     returns (uint256)     {         uint256 decayedBaseRate = troveManager.calcDecayedBaseRate();          /* Convert the drawn Collateral back to YUSD at face value rate (1 YUSD:1 USD), in order to get          * the fraction of total supply that was redeemed at face value. */         uint256 redeemedYUSDFraction = _YUSDDrawn.mul(10**18).div(_totalYUSDSupply);          uint256 newBaseRate = decayedBaseRate.add(redeemedYUSDFraction.div(BETA));         newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%          troveManager.updateBaseRate(newBaseRate);         return newBaseRate;     }     ```  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L791-L795  ```solidity=791 if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease      newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee)); } else { // otherwise increase by opposite subtraction     newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange)); } ```  `_debtChange - _variableYUSDFee` at L792 and `_variableYUSDFee - _debtChange` at L794 will never underflow.   https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L240-L241  ```solidity=240 _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); ```  `_balances[account] + amount` will not overflow if `_totalSupply.add(amount)` dose not overflow.    https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L248-L249  ```solidity=248 _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance"); _totalSupply = _totalSupply.sub(amount); ```  `_totalSupply - amount` will not underflow if `_balances[account].sub(amount)` dose not underflow.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L839-L847  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {         for (uint i = 0; i < _colls.tokens.length; i++) {             address token = _colls.tokens[i];             uint amount = _colls.amounts[i];             if (whitelist.isWrapped(token)) {                 IWAsset(token).updateReward(_borrower, _newOwner, amount);             }         }     } ```  Since `amount` is only needed in `if (whitelist.isWrapped(token)) {...}`, so `uint amount = _colls.amounts[i];` should be moved to inside `if (whitelist.isWrapped(token)) {...}`.  Furthermore, considering that `amount` is only used once, it can be replaced with `_colls.amounts[i]`.  ### Recommendation  Change to:  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     for (uint i = 0; i < _colls.tokens.length; i++) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L297-L301  ```solidity=297     function _requireCallerIsTMLorSP() internal view {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             "YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool");     } ```  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L128-L131  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         _requireCallerIsTMLorSP();         _transfer(_poolAddress, _receiver, _amount);     } ```   `_requireCallerIsTMLorSP()` is unnecessary as it's being used only once. Therefore it can be inlined in `returnFromPool()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=128     function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {         require(             msg.sender == stabilityPoolAddress || msg.sender == troveManagerLiquidationsAddress,             "YUSD: Caller is neither TroveManagerLiquidator nor StabilityPool");         _transfer(_poolAddress, _receiver, _amount);     } ```  Other examples include:  -   `TroveManagerRedemptions.sol#_getRedemptionFee()` can be inlined in `TroveManagerRedemptions.sol#redeemCollateral()`  
# Handle  kenzo   # Vulnerability details  TeamLockup mentions on "vestingLength" that it is the "number of YETI that are claimable every day after vesting starts". However, the vesting calculation treats it as if was the number of YETI that are claimable every second, not every day.  ## Impact Tokens would be released faster than planned. Or, if the tokens are planned to be released every second and not every day (I'm guessing it's less likely), then this is a wrong comment.  ## Proof of Concept The description of `vestingLength`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L15) ```     uint immutable vestingLength; // number of YETI that are claimable every day after vesting starts ```  The calculation to decide how many tokens can be released: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L41:#L43) ```         uint timePastVesting = block.timestamp.sub(vestingStart);         uint available = _min(totalVest,(totalVest.mul(timePastVesting)).div(vestingLength)); ``` The problem is that `timePastVesting` is in seconds, and `vestingLength` is in days.  ## Recommended Mitigation Steps Divide the calculation by `1 day` to align the units.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/ERC20_8.sol#L68-L70  ```solidity=68         require(_num_tokens <= balances[msg.sender], "You are trying to transfer more tokens than you have");          balances[msg.sender] = balances[msg.sender] - _num_tokens; ```  `balances[msg.sender] - _num_tokens` will never underflow.  
# Handle  kenzo   # Vulnerability details  LockupContract, LockupContractFactory amd ShortLockupContract all have comments that say: ``` Within the first year from deployment, the deployer of the YETIToken (Liquity AG's address) may transfer YETI only to valid LockupContracts, and no other addresses (this is enforced in YETIToken.sol's transfer() function). The above two restrictions ensure that until one year after system deployment, YETI tokens originating from Liquity AG cannot enter circulating supply and cannot be staked to earn system revenue. ```  This comment is outdated (verified with sponsor). There is no such lockup on YETI tokens issued to team/treasury. (There might be other type of vesting which is probably implemented using TeamLockup.)  ## Impact Confusion, wrong description of team's capability to use yeti tokens issued.  ## Proof of Concept [Code ref](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/LockupContract.sol#L13:#L18).  ## Recommended Mitigation Steps Remove outdated comments.  
# Handle  pauliax   # Vulnerability details  ## Impact ecrecover returns an empty address when the signature is invalid. As far as I checked, with the current codebase, there is no way to exploit it to gain any benefits, but it is a good practice to check against that. ```solidity   address recoveredAddress = ecrecover(digest, v, r, s);   require(recoveredAddress == owner, 'YUSD: invalid signature'); ```  ## Recommended Mitigation Steps require recoveredAddress != address(0)  You could also consider using OZ's ECDSA library for signature verifications: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function setAddresses in contract Whitelist is intended to be invoked only once (confirmed with the sponsor) but currently, it has no prevention from being called multiple times.  Maybe this should also be prevented in sYETIToken's setAddresses and ThreePieceWiseLinearPriceCurve's setAddresses.  ## Recommended Mitigation Steps Prevent repeated access of setAddresses in Whitelist and potentially in sYETIToken and ThreePieceWiseLinearPriceCurve.  
# Handle  Ruhum   # Vulnerability details  ## Impact View functions consume less gas. `WJLP.getPendingRewards()` is technically also a view function but not specified as one. Because the `IMasterChefJoeV2` interface used by the contract is wrong. It says `poolInfo()` is not a view function, which it is.  ## Proof of Concept getPendingRewards: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L190  Faulty interface function: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L29  actually poolinfo is just an array so its getter is a view function: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV2.sol#L85  ## Tools Used none  ## Recommended Mitigation Step Declare both functions as `view` to save gas  
# Handle  Ruhum   # Vulnerability details  ## Impact All the other passed variables are checked. Only `_whitelistAddress` is ignored. This allows passing a zero function which would break the functionality.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/CollSurplusPool.sol#L51-L54  ## Tools Used none  ## Recommended Mitigation Steps add `checkContract(_whitelistAddress)`  
# Handle  kenzo   # Vulnerability details  When changing collateral's ratio, it is rightly checked to be smaller than 110%. However when adding new collateral, the ratio check is not there, so it can be added with ratio that is larger than 110%.  ## Impact Accidentally adding an asset with larger ratio would result in users being able to withdraw more YUSD than supplied VC.  ## Proof of Concept When an asset is being added, there is no sanity check that the ratio is within the correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L92:#L127)  This is unlike `changeRatio`, which validates that the new ratio is in correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L204) ``` require(_ratio < 1100000000000000000, "ratio must be less than 1.10 => greater than 1.1 would mean taking out more YUSD than collateral VC"); ```  ## Recommended Mitigation Steps Add the same ratio check to `addCollateral`.  
# Handle  cmichel   # Vulnerability details  Calling `WJLP.unwrap` burns WJLP, withdraws the amount from the master chef and returns the same amount of JLP back to the `to` address. However, it does not update the internal accounting in `WJLP` with a `_userUpdate` call.  This needs to be done on the caller side according to the comment in the `WJLP.unwrap` function: > "Prior to this being called, the user whose assets we are burning should have their rewards updated"  This happens when being called from the `StabilityPool` but not when being called from the `ActivePool.sendCollateralsUnwrap`:  ```solidity function sendCollateralsUnwrap(address _to, address[] memory _tokens, uint[] memory _amounts, bool _collectRewards) external override returns (bool) {     _requireCallerIsBOorTroveMorTMLorSP();     require(_tokens.length == _amounts.length);     for (uint i = 0; i < _tokens.length; i++) {         if (whitelist.isWrapped(_tokens[i])) {             // @audit this burns the tokens for _to but does not reduce their amount. so there are no tokens in WJLP masterchef but can keep claiming             IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]);             if (_collectRewards) {                 IWAsset(_tokens[i]).claimRewardFor(_to);             }         } else {             _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails         }     }     return true; } ```  ## Impact The `unwrapFor` call withdraws the tokens from the Masterchef and pays out the user, but their user balance is never decreased by the withdrawn amount. They can still use their previous balance to claim rewards through `WJLP.claimReward` which updated their unclaimed joe reward according to the old balance. Funds from the WJLP pool can be stolen.  ## Recommended Mitigation Steps As the comment says, make sure the user is updated before each `unwrap` call. It might be easier and safer to have a second authorized `unwrapFor` function that accepts a `rewardOwner` parameter, the user that needs to be updated.   
# Handle  cmichel   # Vulnerability details  The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:  ```solidity function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {     require(YUSDToSell > 0, "Zero amount");     require(lastBuybackTime + 69 hours < block.timestamp, "Must have 69 hours pass before another buyBack");     yusdToken.approve(routerAddress, YUSDToSell);     uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);     lastBuybackTime = block.timestamp;     // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]     // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)     lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);     emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]); } ```  It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap `path` parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).  ## Impact The `lastBuyBackPrice` will be wrong when using a different path. This will lead `rebase`s using a different yeti amount and the `effectiveYetiTokenBalance` being updated wrong.  ## Recommended Mitigation Steps Verify the first and last element of the path are YETI/YUSD and use the first and last amount parameter.   
# Handle  cmichel   # Vulnerability details  The `sYETIToken.transferFrom` function does not emit a new `Approval` event when decreasing the allowance. Most ERC20 implementations, like OpenZeppelin's, emit this event when the `allowance` is decreased.  ## Impact Off-chain scripts and frontends will not correctly track the `allowance`s of users when listening to the `Approval` event. This can lead to failed transactions as a higher approval is assumed than it actually is.  ## Recommended Mitigation Steps Emit the `Approval` event also in `transferFrom` if the approval is decreased.   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..  ```solidity if (decay > 0 && decay < decayTime) {     // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     fee = lastFeePercent; } ```  ## Recommended Mitigation Steps It seems wrong to handle the `decay == 0` case (decay happened in same block) the same way as the `decay >= decayTime` case (decay happened long time ago) as is done in the `else` branch. I believe it should be like this instead:  ```solidity // decay == 0 case should be full lastFeePercent if(decay < decayTime) {     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     // reset to zero if decay >= decayTime     fee = 0; } ```  
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap:  > If dollarCap == 0, then it is not capped. Otherwise, **then the total + the total input** must be less than the cap.  The code only checks if the input is less than the cap:  ```solidity // @param _collateralVCInput is how much collateral is being input by the user into the system if (dollarCap != 0) {     require(_collateralVCInput <= dollarCap, "Collateral input exceeds cap"); } ```  ## Recommended Mitigation Steps Clarify the desired behavior and reconcile the code with the comments.   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1, f2, f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0), b3 = f_3(0)`) for each of these but uses **unsigned integers** for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.  #### Example: Check out this two-piece linear interest curve of Aave:  ![Aave](https://docs.aave.com/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M51Fy3ipxJS-0euJX3h-2670852272%2Fuploads%2Fycd9OMRnInNeetUa7Lj1%2FScreenshot%202021-11-23%20at%2018.52.26.png?alt=media&token=7a25b900-7023-4ee5-b582-367d56d31894) The intersection of the second steep straight line with the y-axis `b_2 = f_2(0)` would be negative.  Example: Imagine a curve that is flat at `10%` on the first 50% utilization but shoots up to `110%` at 100% utilization.  - `m1 = 0, b1 = 10%, cutoff1 = 50%`  - `m2 = 200%` => `b2 = m1 * cutoff1 + b1 - m2 * cutoff1 = f1(cutoff1) - m2 * cutoff1 = 10% - 200% * 50% = 10% - 100% = -90%`. (`f2(100%) = 200% * 100% - 90% = 110%` ✅) This function would revert in the `b2` computation as it underflows due to being a negative value.  ## Impact Most curves that are actually desired for a lending platform (becoming steeper at higher utilization) cannot be used.  ## Recommended Mitigation Steps Evaluate the piecewise linear function in a different way that does not require computing the y-axis intersection value. For example, for `cutoff2 >= x > cutoff1`, use `f(x) = f_1(cutoff) + f_2(x - cutoff)`. See [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol#L85).   
# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function does not check that `_cutoff1 <= _cutoff2` and also does not revert in this case. However, this always indicates an error in how this function should be used.  ## Recommended Mitigation Steps Add a `_cutoff1 <= _cutoff2` check.  
# Handle  heiho1   # Vulnerability details  ## Impact  CheckContract is used in ActivePool, BorrowerOperations, CollSurplusPool, DefaultPool, HintHelpers, PriceFeed, SortedTroves, StabilityPool, TroveManager, TroveManagerLiquidations, TroveManagerRedemptions but this is a view function and could easily be implemented as an internal library call.  This would result in slightly larger contract bytecode but should be far more gas efficient than an external contract call as is the current case.  ## Proof of Concept  https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678  """ Use any of the internal calling methods. We prefer internal library calls, because of the associated class features (see Class Features of Solidity by the same author). Using an external call to a public library function is very expensive, and will only be worth it to avoid including a lot of code into the bytecode for your contract. Using a local contract component is the most expensive option and should be avoided unless essential. """  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/CheckContract.sol#L6  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare CheckContract as an internal library:  https://medium.com/coinmonks/all-you-should-know-about-libraries-in-solidity-dd8bc953eae7  """ Embedded Library: If a smart contract is consuming a library which have only internal functions than EVM simply embeds library into the contract. Instead of using delegate call to call a function, it simply uses JUMP statement(normal method call). There is no need to separately deploy library in this scenario. """  
# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerRedemptions does not inherit contracts/Interfaces/ITroveManagerRedemptions.sol but should.  Note that TroveManager.sol does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L38  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as "TroveManagerRedemptions is TroveManagerBase, ITroveManagerRedemptions"  
# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerLiquidations does not inherit contracts/Interfaces/ITroveManagerLiquidations.sol but should.  Note that TroveManager.sol  does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L14  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as "TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations"  
# Handle  heiho1   # Vulnerability details  ## Impact  Got an error attempting Slither analysis due to several contracts defining "SafeMath"   - In this case there are *two* distinct safe math libraries, one dependent on solc 0.6.11 and one dependent on solc ^0.8.0. This can lead to confusion during development.  Ideally the safe math version of the application contract [0.6.11] would be standardized but in this case *re-naming* the SafeMath contracts also suffices.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol#L15  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/SafeMath.sol#L21    ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol to SafeMath080.sol [and updating the declared contract to the same name]  
# Handle  heiho1   # Vulnerability details  ## Impact Got an error attempting Slither analysis due to Pool2Unipool and Unipool declaring the same contract named LPTokenWrapper.  It is confusing and error prone to have such similarly named contracts and there is no clear benefit to re-using the name.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename LPTokenWrapper in Pool2Unipool to 'Pool2LPTokenWrapper' and correct any related imports.  
# Handle  Dravee   # Vulnerability details  ## Impact In a number of places a `keccak("string")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  ## Proof of Concept ``` YETI\YETIToken.sol:   50:     bytes32 private constant _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");   51:     bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");  YETI\BoringCrypto\Domain.sol:   10:     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256("EIP712Domain(uint256 chainId,address verifyingContract)"); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change all `constant` hashes to be `immutable`  
# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.   ## Proof of Concept Instances missing a non-zero check: ``` ActivePool.sol:   156:         bool sent = IERC20(_collateral).transfer(_to, _amount);  BorrowerOperations.sol:   742:             bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);  DefaultPool.sol:   121:         bool success = IERC20(_collateral).transfer(activePool, _amount);  StabilityPool.sol:   947:                 IERC20(assets[i]).transfer(_to, amounts[i]);  TeamAllocation.sol:   69:             require(YETI.transfer(member, amount));   77:         YETI.transfer(_to, _amount);  YetiFinanceTreasury.sol:   25:         _token.transfer(_to, _amount);  AssetWrappers\WJLP\WJLP.sol:   127:         JLP.transferFrom(_from, address(this), _amount);   166:         JLP.transfer(_to, _amount);   273:             JOE.transfer(_to, _amount);  Dependencies\LiquityBase.sol:   170:             if (!token.transfer(_to, _coll.amounts[i])) {  LPRewards\Dependencies\SafeERC20.sol:   23:         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));   27:         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));  YETI\CommunityIssuance.sol:   125:         yetiToken.transfer(_account, _YETIamount);  YETI\LockupContract.sol:   68:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\ShortLockupContract.sol:   67:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\sYETIToken.sol:   203:         yetiToken.transfer(to, amount);  YETI\TeamLockup.sol:   47:             require(YETI.transfer(multisig, _amount)); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0. It is done at some places already, like here: https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/LPRewards/Unipool.sol#L189-L192  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {     uint length = arr.length;     for (uint i = 0; i < arr.length; i++) {         sum += arr[i];     } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L890`  ``` https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L699  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L873  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L920  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/BorrowerOperations.sol#L929  https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/ActivePool.sol#L167  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `WJLP.sol`, state variables `JLP` and `JOE` are initialized in the constructor and never reassigned again. Thus, they can be declared `immutable` rather than `constant` in order to save gas  ## Proof of Concept  [https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41)  ## Tools Used  Editor  
# Handle  kenzo   # Vulnerability details  When ActivePool sends collateral which is a wrapped asset, it first unwraps the asset, and only after that updates the rewards. This should be done in opposite order. As a comment in WJLP's `unwrapFor` rightfully mentions - "Prior to this being called, the user whose assets we are burning should have their rewards updated".  ## Impact Lost yield for user.  ## Proof of Concept In ActivePool's `sendCollateralsUnwrap` (which is used throughout the protocol), it firsts unwraps the asset, and only afterwards calls `claimRewardFor` which will update the rewards: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol#L186:#L188) ``` IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]); if (_collectRewards) {         IWAsset(_tokens[i]).claimRewardFor(_to); } ``` `claimRewardFor` will end up calling `_userUpdate`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L246:#L263) ```     function _userUpdate(address _user, uint256 _amount, bool _isDeposit) private returns (uint pendingJoeSent) {         uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;         UserInfo storage user = userInfo[_user];         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12);     } ``` Now, as ActivePool has already called `unwrapFor` and has burnt the user's tokens, and let's assume they all were used as collateral, it means user.amount=0*, and the user's unclaimedJOEReward won't get updated to reflect the rewards from the last user update. This is why, indeed as the comment in `unwrapFor` says, user's reward should be updated prior to that.  *Note: at the moment `unwrapFor` doesn't updates the user's user.amount, but as I detailed in another issue, that's a bug, as that means the user will continue accruing rewards even after his JLP were removed from the protocol.  ## Recommended Mitigation Steps Change the order of operations in `sendCollateralsUnwrap` to first send the updated rewards and then unwrap the asset. You can also consider adding to the beginning of `unwrapFor` a call to `_userUpdate(_to, 0, true)` to make sure the rewards are updated before unwrapping. Note: as user can choose to have JOE rewards accrue to a different address than the address that uses WJLP as collateral, you'll have to make sure you update the current accounts. I'll detail this in another issue.  
# Handle  kenzo   # Vulnerability details  After updating user's rewards in `_userUpdate`, if the user has not claimed them, and `_userUpdate` is called again (eg. on another `wrap`), the user's unclaimed rewards will lose the previous unclaimed due to wrong calculation.  ## Impact Loss of yield for user.  ## Proof of Concept When updating the user's unclaimedJoeReward, the function doesn't save it's previous value. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L251:#L253) ```         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         // update for JOE rewards that are already accounted for in user.unclaimedJOEReward         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12); ``` So for example, rewards can be lost in the following scenario. We'll mark "acc1" for the value of "accJoePerShare" at step 1. 1. User Zebulun wraps 100 tokens. After  `_userUpdate` is called: unclaimedJOEReward  = 0, rewardDebt = 100*acc1. 2. Zebulun wraps 50 tokens: unclaimedJOEReward = 100*acc2 - 100*acc1, rewardDebt = 150 * acc2. 3. Zebulun wraps 1 token: unclaimedJOEReward = 150*acc3 - 150*acc2, rewardDebt = 151*acc3 So in the last step, Zebulun's rewards only take into account the change in accJoePerShare in steps 2-3, and lost the unclaimed rewards from steps 1-2.  ## Recommended Mitigation Steps Change the unclaimed rewards calculation to: ``` user.unclaimedJOEReward = user.unclaimedJOEReward.add(user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt)); ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact Gas wastage  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/YetiCustomBase.sol  2. Observe that in _subColls function the last for loop is not required if n=0 since this means that all token amount is 0   
# Handle  kenzo   # Vulnerability details  WJLP can only be unwrapped from the Active Pool or Stability Pool. A user who decided to wrap his JLP, but not use all of them in a trove, Wouldn't be able to just unwrap them.  ## Impact Impaired functionality for users. Would have to incur fees for simple unwrapping.  ## Proof of Concept The unwrap functionality is only available from `unwrapFor` function, and that function is only callable from AP or SP. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L149) ``` function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP(); ```  ## Recommended Mitigation Steps Allow anybody to call the function. As it will burn the holder's WJLP, a user could only unwrap tokens that are not in use.  
# Handle  kenzo   # Vulnerability details  WJLP doesn't update the inner accounting (for JOE rewards) when unwrapping user's tokens. The user will continue to receive rewards, on the expanse of users who haven't claimed their rewards yet.  ## Impact Loss of yield for users.  ## Proof of Concept The unwrap function just withdraws JLP from MasterChefJoe, burns the user's WJLP, and sends the JLP back to the user. It does not update the inner accounting (`userInfo`). [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L167) ```     function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP();         _MasterChefJoe.withdraw(_poolPid, _amount);         // msg.sender is either Active Pool or Stability Pool         // each one has the ability to unwrap and burn WAssets they own and         // send them to someone else         _burn(msg.sender, _amount);         JLP.transfer(_to, _amount);     } ```  ## Recommended Mitigation Steps Need to keep userInfo updated. Have to take into consideration the fact that user can choose to set the reward claiming address to be a different account than the one that holds the WJLP.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variables `yetiToken` and `unlockTime` inside the `ShortLockupContract` contract are never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variable `yetiToken` inside the `LockupContract` contract is never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  
# Handle  hyh   # Vulnerability details  # Impact  The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to `effectiveYetiTokenBalance` during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.  The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users’ claims. In other words, the contract will be in default if enough users claim after that.  ## Proof of Concept  Now the whole balance amount is used instead of the amount bought back from market.  Rebasing amount is added to `effectiveYetiTokenBalance`, so it should be limited by extra Yeti tokens, not the whole balance: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L247  ## Recommended Mitigation Steps  It looks like only extra tokens should be used for the check, i.e. `yetiToken.balance - effectiveYetiTokenBalance`.  Now: ``` function rebase() external {   ...   uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));   uint256 valueOfContract = _getValueOfContract(yetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (yetiTokenBalance < additionalYetiTokenBalance) {     additionalYetiTokenBalance = yetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {   uint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```  As the `_getValueOfContract` function isn't used elsewhere, the logic can be simplified. To be: ``` function rebase() external {   ...   uint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);   uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (additionalYetiTokenBalance > adjustedYetiTokenBalance) {     additionalYetiTokenBalance = adjustedYetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```   
# Handle  hyh   # Vulnerability details  # Impact  Core system logic can break up if enumeration structure be updated.  ## Proof of Concept  BorrowerOperations and StabilityPool check the active status of a trove by comparing TroveManager's getTroveStatus with 1: BorrowerOperations: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L902 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L907 StabilityPool: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1104  TroveManagers inherit Status enumeration from TroveManagerBase: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TroveManagerBase.sol#L72  ## Recommended Mitigation Steps  With further system development it will be harder to track fixes needed on enumeration change. Consider implementing TroveManager.isTroveActive(borrower) where trove.status is checked against Status.active and the corresponding boolean is returned.   
# Handle  hyh   # Vulnerability details  # Impact  Transactions will not be reverted on failed transfer call, setting system state as if it was successful. This will lead to wrong state accounting down the road with a wide spectrum of possible consequences.  ## Proof of Concept  _safeJoeTransfer do not check for JOE.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L268  _safeJoeTransfer is called by _sendJoeReward, which is used in reward claiming.  JOE token use transfer from OpenZeppelin ERC20: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/JoeToken.sol#L9  Which does return success code: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L113  Trader Joe also uses checked transfer when dealing with JOE tokens: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L102   Also, unwrapFor do not check for JLP.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L166   ## Recommended Mitigation Steps  Add a require() check for the success of JOE transfer in _safeJoeTransfer function and create and use a similar function with the same check for JLP token transfers  
# Handle  hyh   # Vulnerability details  Console log code to be removed: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152  
# Handle  hyh   # Vulnerability details  # Impact  WJLP set configuration variables via setAddresses initialize function that has no access controls, so whenever it is being run not atomically with contract creation it can be front run by an attacker. The fix is to redeploy the contracts.  ## Proof of Concept  WJLP.setAddresses: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L102  WJLP.constructor: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L82  ## Recommended Mitigation Steps  a. Either set access rights in the constructor and restrict initialize access b. Or run setAddresses atomically along with contract construction each time  It is also advised to check for zero addressed supplied by a caller both in constructor and setAddresses. Misconfiguration with zero address also leads to redeployment.  
# Handle  dalgarim   # Vulnerability details  ## Impact sYETIToken.sol mint function checks if msg.sender is zero address. It is extremely unlikely that someone possesses a private key of zero address. This 'require' statement semantically has no meaning  ## Proof of Concept [mint](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L175) ``` function mint(uint256 amount) public returns (bool) {         require(msg.sender != address(0), "Zero address");         User memory user = users[msg.sender];          uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;         user.balance += shares.to128();         user.lockedUntil = (block.timestamp + LOCK_TIME).to128();         users[msg.sender] = user;         totalSupply += shares;          yetiToken.sendToSYETI(msg.sender, amount);         effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);          emit Transfer(address(0), msg.sender, shares);         return true;     } ```  ## Tools Used Manual  ## Recommended Mitigation Steps The require statement can be removed  
# Handle  Jujic   # Vulnerability details  ## Impact The uint   `percentBacked ` can not  be negative.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L131 ``` uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance); require(percentBacked <= 1e18 && percentBacked >= 0, "percent backed out of bounds"); ```  ## Tools Used Remix  ## Recommended Mitigation Steps You should remove the `percentBacked >= 0` from require to save some gas.  
# Handle  hyh   # Vulnerability details  # Impact  Comment is misleading, now stating the opposite of the implemented logic.  ## Proof of Concept  Comment states that tokens added are `not less than amount repurchased`, while it should be `not more`: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L246   ## Recommended Mitigation Steps  Now: ``` // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  To be: ``` // Ensure that the amount of YETI tokens effectively added is <= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  _requireValidRouterParams and _requireRouterAVAXIndicesInOrder functions along with IYetiRouter interface are unused:  _requireValidRouterParams https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1053  _requireRouterAVAXIndicesInOrder https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1067  IYetiRouter import and the interface itself: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L12 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Interfaces/IYetiRouter.sol  ## Recommended Mitigation Steps  If it is not meant to be implemented further consider removal to enhance code readability and size  
# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. `withdrawColl` outcome will not be as expected by a caller.  ## Proof of Concept  `_adjustTrove` doesn't check for array lengths and all other array providing usages of this function do check them before usage.  BorrowerOperations.withdrawColl doesn't: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L373  ## Recommended Mitigation Steps  Add the check:  Now: ``` params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```  To be: ``` require(_collsOut.length == _amountsOut.length); params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```   
# Handle  Jujic   # Vulnerability details  ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L53-L55  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManager.sol#L35-L39   Example: ``` uint256 public constant BOOTSTRAP_PERIOD = 14 days; ``` ## Tools Used Remix ## Recommended Mitigation Steps  
# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.  Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.  Example Medium Issue : https://github.com/code-423n4/2021-08-notional-findings/issues/18  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/PriceFeed.sol#L578"  2. Only the following checks are implemented.  ```         if (!_response.success) {return true;}         // Check for an invalid roundId that is 0         if (_response.roundId == 0) {return true;}         // Check for an invalid timeStamp that is 0, or in the future         if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}         // Check for non-positive price         if (_response.answer <= 0) {return true;}   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "..."); require(timeStamp != 0, "..."); ```  
# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. The following contract is using ABI coder v2.  "https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/YETI/sYETIToken.sol#L3"   ## Tools Used  None  ## Recommended Mitigation Steps  Upgrade pragma to 0.8.0  and After the 0.8.0, ABI coder v2 is activated by default. Upgrade pragma to 0.8.0 version. It is recommended to delete redundant codes.  From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  
# Handle  Jujic   # Vulnerability details  ## Impact Removing the assignment will save gas. ``` _totalSupply = 0; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L93  ## Tools Used  ## Recommended Mitigation Steps Remove the assignment.  
# Handle  Jujic   # Vulnerability details  ## Impact ``` deploymentTime = block.timestamp; uint public constant BOOTSTRAP_PERIOD = 14 days;  deploymentTime.add(BOOTSTRAP_PERIOD) // doesn't overflow  ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L899  ## Tools Used Remix ## Recommended Mitigation Steps I recommend   not  use Safemath for this operation.  
# Handle  SolidityScan   # Vulnerability details  ## Impact Events are important and should be emitted for tracking this off-chain for all important functions.   ## Proof of Concept 1. The function "updateTeamAddress" is used to update the team's address but we can notice no event is emitted.  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/TeamAllocation.sol#L81-L83  2. The same in function "updateTeamWallet" at  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YetiFinanceTreasury.sol#L28-L30  ## Tools Used  ## Recommended Mitigation Steps Add an event to these important functions where address updation is happening. This can also be marked as indexed event for better off-chain tracking  
# Handle  jayjonah8   # Vulnerability details  ## Impact the constructor in TellorCaller.sol should ensure that the _tellorMasterAddress arg passed in is not a zero address as a safegaurd.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TellorCaller.sol#L24  ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_tellorMasterAddress) != address(0), "Zero address")  
# Handle  jayjonah8   # Vulnerability details  ## Impact In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments,  but anyone can call it passing in _tokens and _amounts args to update stability pool balances.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1143  ## Tools Used Manual code review   ## Recommended Mitigation Steps Allow only the ActivePool to call the receiveCollateral() function: require(msg.sender = address(active pool address), "Can only be called by ActivePool")  
# Handle  Jujic   # Vulnerability details  ## Impact contract WJLP does not need to import this contract in production ``` import "hardhat/console.sol"; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L8  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152-L160  ## Tools Used Remix  ## Recommended Mitigation Steps Remove this contract  to reduce the size of the contract and thus save some deployment gas.  
# Handle  Jujic   # Vulnerability details  ## Impact Some of the variable can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L90-L91  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L107-L108  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L144-L145  ``` dollarCap // can be cashed decayTime // can be cashed  ``` ## Tools Used Remix  ## Recommended Mitigation Steps   
# Handle  Jujic   # Vulnerability details  ## Impact ``` IERC20 public immutable JLP; IERC20 public  immutable JOE; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41-L44  ## Tools Used REmix ## Recommended Mitigation Steps  
# Handle  SolidityScan   # Vulnerability details  ### Description  Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.  ## Impact Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ## Proof of Concept 1.  uint constant public _100pct = 1000000000000000000;  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L19  2. uint constant public _110pct = 1100000000000000000; // 1.1e18 == 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L21  3. uint constant public MCR = 1100000000000000000; // 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L24  4. uint constant public CCR = 1500000000000000000; // 150% https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L27  ## Tools Used  ## Recommended Mitigation Steps Scientific notation in the form of 2e10 is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal MeE is equivalent to M * 10**E. Examples include 2e10, 2e10, 2e-10, 2.5e1. As suggested in official docs https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals  
# Handle  SolidityScan   # Vulnerability details  ### Description  Smart Contracts are Gas sensitive and heavily depend on how Gas is spent and managed across the code. This affects each and every function definition and logic.   Therefore having any unused functions in the code cost unnecessary Gas usage and thus negatively impacts the Contract and the organization.  ## Impact Having unused function definitions and parameters negatively affects the contract and costs unnecessary Gas. This also makes it difficult and confusing for auditors to go through the code.  ## Proof of Concept The function "_getColls" is not used anywhere in the code  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L146-L153  ## Tools Used  ## Recommended Mitigation Steps Evaluate if the function call should be used anywhere otherwise remove the function definition.  
# Handle  jayjonah8   # Vulnerability details  ## Impact There are no events emitted in the WJLP.sol file for important function calls.  The contract should make use of events for important functions like claimReward() so the protocol can track important events after deployment.  This can help spot unusual activity and assist in monitoring the protocol while its live.    ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L215  ## Tools Used Manual code review     
# Handle  jayjonah8   # Vulnerability details  ## Impact In WJLP.sol, the wrap() function pulls in _amount base tokens from _from, then stakes them to mint WAssets which it sends to _to.  It then updates _rewardOwner's reward tracking such that it now has the right to future yields from the newly minted WAssets.  But the function does not make sure that _from and _to are not the same address and failure to make this check in functions with transfer functionality has lead to severe bugs in other protocols since users rewards are updated on such transfers this can be used to manipulate the system.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L126  https://medium.com/@Knownsec_Blockchain_Lab/knownsec-blockchain-lab-i-kill-myself-monox-finance-security-incident-analysis-2dcb4d5ac8f   ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_from) != address(_to), "_from and _to cannot be the same")  
# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:           approve without approving 0 first WJLP.sol, 127, JLP.approve(address(_MasterChefJoe), _amount);          approve without approving 0 first EchidnaProxy.sol, 134, return yusdToken.approve(spender, amount);          approve without approving 0 first sYETIToken.sol, 229, yusdToken.approve(routerAddress, YUSDToSell);   
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ActivePool.sol, i, 133         change to prefix increment and unchecked: ActivePool.sol, i, 167         change to prefix increment and unchecked: ActivePool.sol, i, 184         change to prefix increment and unchecked: BorrowerOperations.sol, i, 699         change to prefix increment and unchecked: BorrowerOperations.sol, i, 737         change to prefix increment and unchecked: BorrowerOperations.sol, i, 873         change to prefix increment and unchecked: BorrowerOperations.sol, i, 890         change to prefix increment and unchecked: BorrowerOperations.sol, i, 920         change to prefix increment and unchecked: BorrowerOperations.sol, i, 929         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1061         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1068         change to prefix increment and unchecked: DefaultPool.sol, i, 97         change to prefix increment and unchecked: DefaultPool.sol, i, 133         change to prefix increment and unchecked: LiquityBase.sol, i, 63         change to prefix increment and unchecked: LiquityBase.sol, i, 97         change to prefix increment and unchecked: LiquityBase.sol, i, 106         change to prefix increment and unchecked: LiquityBase.sol, i, 115         change to prefix increment and unchecked: LiquityBase.sol, i, 149         change to prefix increment and unchecked: LiquityBase.sol, i, 158         change to prefix increment and unchecked: LiquityBase.sol, i, 168         change to prefix increment and unchecked: YetiCustomBase.sol, i, 36         change to prefix increment and unchecked: YetiCustomBase.sol, i, 44         change to prefix increment and unchecked: YetiCustomBase.sol, i, 59         change to prefix increment and unchecked: YetiCustomBase.sol, i, 104         change to prefix increment and unchecked: YetiCustomBase.sol, i, 122         change to prefix increment and unchecked: YetiCustomBase.sol, i, 144         change to prefix increment and unchecked: YetiCustomBase.sol, i, 152         change to prefix increment and unchecked: YetiCustomBase.sol, i, 165         change to prefix increment and unchecked: YetiCustomBase.sol, i, 178         change to prefix increment and unchecked: HintHelpers.sol, i, 139         just change to unchecked: MultiTroveGetter.sol, idx, 73         just change to unchecked: MultiTroveGetter.sol, idx, 79         just change to unchecked: MultiTroveGetter.sol, idx, 90         just change to unchecked: MultiTroveGetter.sol, idx, 96         change to prefix increment and unchecked: MultiTroveGetter.sol, i, 110         change to prefix increment and unchecked: StabilityPool.sol, i, 562         change to prefix increment and unchecked: StabilityPool.sol, i, 588         change to prefix increment and unchecked: StabilityPool.sol, i, 592         change to prefix increment and unchecked: StabilityPool.sol, i, 628         change to prefix increment and unchecked: StabilityPool.sol, i, 720         change to prefix increment and unchecked: StabilityPool.sol, i, 942         change to prefix increment and unchecked: StabilityPool.sol, i, 1011         change to prefix increment and unchecked: TeamAllocation.sol, i, 66         change to prefix increment and unchecked: CDPManagerTester.sol, i, 14         change to prefix increment and unchecked: EchidnaTester.sol, i, 103         change to prefix increment and unchecked: EchidnaTester.sol, i, 121         change to prefix increment and unchecked: TroveManager.sol, i, 234         change to prefix increment and unchecked: TroveManager.sol, i, 348         change to prefix increment and unchecked: TroveManager.sol, i, 374         change to prefix increment and unchecked: TroveManager.sol, i, 397         change to prefix increment and unchecked: TroveManager.sol, i, 420         change to prefix increment and unchecked: TroveManager.sol, i, 460         change to prefix increment and unchecked: TroveManager.sol, i, 476         change to prefix increment and unchecked: TroveManager.sol, i, 525         change to prefix increment and unchecked: TroveManager.sol, i, 582         change to prefix increment and unchecked: TroveManager.sol, i, 603         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 255         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 334         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 394         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 475         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 808         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 840         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 304         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 517  
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           BorrowerOperations.sol, variable name: _colls times: 2 at: _requireNoDuplicateColls         BorrowerOperations.sol, variable name: _indices times: 2 at: _requireRouterAVAXIndicesInOrder         DefaultPool.sol, variable name: _amounts times: 2 at: sendCollsToActivePool         YetiCustomBase.sol, variable name: _amounts times: 2 at: _subColls         StabilityPool.sol, variable name: amounts times: 2 at: _sendGainsToDepositor         TroveManager.sol, variable name: lastCollError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: lastYUSDDebtError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: totalStakes times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: allColls times: 2 at: _closeTrove    
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           WJLP.sol Variable activePool is read 2 times in the function: unwrapFor         WJLP.sol Variable stabilityPool is read 2 times in the function: unwrapFor         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice_v         EchidnaTester.sol Variable troveManager is read 9 times in the function: constructor         EchidnaTester.sol Variable borrowerOperations is read 8 times in the function: constructor         EchidnaTester.sol Variable activePool is read 6 times in the function: constructor         EchidnaTester.sol Variable defaultPool is read 4 times in the function: constructor         EchidnaTester.sol Variable stabilityPool is read 6 times in the function: constructor         EchidnaTester.sol Variable gasPool is read 3 times in the function: constructor         EchidnaTester.sol Variable troveManagerLiquidations is read 4 times in the function: constructor         EchidnaTester.sol Variable troveManagerRedemptions is read 5 times in the function: constructor         EchidnaTester.sol Variable yusdToken is read 5 times in the function: constructor         EchidnaTester.sol Variable whitelist is read 4 times in the function: constructor         EchidnaTester.sol Variable collSurplusPool is read 4 times in the function: constructor         EchidnaTester.sol Variable priceFeedTestnet is read 3 times in the function: constructor         EchidnaTester.sol Variable sortedTroves is read 4 times in the function: constructor         EchidnaTester.sol Variable MCR is read 2 times in the function: constructor         EchidnaTester.sol Variable CCR is read 2 times in the function: constructor         ERC20.sol Variable totalSupply is read 2 times in the function: _mint         TeamLockup.sol Variable totalClaimed is read 2 times in the function: claimYeti         YETIToken.sol Variable _totalSupply is read 2 times in the function: constructor   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: ActivePool.sol, In line 252, Require message length to shorten: 35, The message: ActivePool: Caller is not whitelist         Solidity file: BorrowerOperations.sol, In line 215, Require message length to shorten: 39, The message: BOps: colls and amounts length mismatch         Solidity file: BorrowerOperations.sol, In line 874, Require message length to shorten: 33, The message: BOps: Collateral not in whitelist         Solidity file: CollSurplusPool.sol, In line 167, Require message length to shorten: 40, The message: CollSurplusPool: Caller is not Whitelist         Solidity file: DefaultPool.sol, In line 122, Require message length to shorten: 38, The message: DefaultPool: sending collateral failed         Solidity file: DefaultPool.sol, In line 167, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: LiquitySafeMath128.sol, In line 10, Require message length to shorten: 37, The message: LiquitySafeMath128: addition overflow         Solidity file: LiquitySafeMath128.sol, In line 16, Require message length to shorten: 40, The message: LiquitySafeMath128: subtraction overflow         Solidity file: SafeMath.sol, In line 87, Require message length to shorten: 33, The message: SafeMath: multiplication overflow         Solidity file: Address.sol, In line 115, Require message length to shorten: 38, The message: Address: insufficient balance for call         Solidity file: Address.sol, In line 140, Require message length to shorten: 36, The message: Address: static call to non-contract         Solidity file: SortedTroves.sol, In line 131, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: SortedTroves.sol, In line 230, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: StabilityPool.sol, In line 1076, Require message length to shorten: 39, The message: StabilityPool: Caller is not ActivePool         Solidity file: StabilityPool.sol, In line 1095, Require message length to shorten: 40, The message: StabilityPool: User must have no deposit         Solidity file: StabilityPool.sol, In line 1099, Require message length to shorten: 38, The message: StabilityPool: Amount must be non-zero         Solidity file: StabilityPool.sol, In line 1138, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: SortedTrovesTester.sol, In line 23, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: TroveManagerLiquidations.sol, In line 180, Require message length to shorten: 34, The message: TroveManager: nothing to liquidate         Solidity file: TroveManagerRedemptions.sol, In line 520, Require message length to shorten: 34, The message: must be non zero redemption amount         Solidity file: CommunityIssuance.sol, In line 131, Require message length to shorten: 35, The message: CommunityIssuance: caller is not SP         Solidity file: YETIToken.sol, In line 198, Require message length to shorten: 36, The message: YETI: transfer from the zero address         Solidity file: YETIToken.sol, In line 222, Require message length to shorten: 39, The message: YETI: caller must be the SYETI contract         Solidity file: YUSDToken.sol, In line 294, Require message length to shorten: 37, The message: YUSD: Caller is not the StabilityPool  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           ActivePool.sol, line 6, import "./Interfaces/IStabilityPool.sol";         ActivePool.sol, line 7, import "./Interfaces/IDefaultPool.sol";         ActivePool.sol, line 13, import "./Dependencies/LiquityBase.sol";         ERC20_8.sol, line 3, import "./Interfaces/IERC20_8.sol";         IMasterChefJoeV2.sol, line 1, import "./IERC20_8.sol";         IRewarder.sol, line 3, import "./IERC20_8.sol";         LiquityBase.sol, line 8, import "../Interfaces/IWhitelist.sol";         TroveManagerBase.sol, line 12, import "../Interfaces/IWhitelist.sol";         Whitelist.sol, line 13, import "../Interfaces/IERC20.sol";         Whitelist.sol, line 14, import "./LiquityMath.sol";         YetiCustomBase.sol, line 6, import "../Interfaces/IERC20.sol";         ICollSurplusPool.sol, line 4, import "../Dependencies/YetiCustomBase.sol";         ILiquityBase.sol, line 4, import "./IPriceFeed.sol";         MockAggregator.sol, line 5, import "hardhat/console.sol";         NonPayable.sol, line 4, //import "hardhat/console.sol";         SortedTrovesTester.sol, line 4, import "../Interfaces/ISortedTroves.sol";         TroveManagerLiquidations.sol, line 6, import "hardhat/console.sol";         sYETIToken.sol, line 9, import "./BoringCrypto/BoringBatchable.sol";  
