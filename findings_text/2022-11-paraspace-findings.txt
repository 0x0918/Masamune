# Lines of code  https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95 https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L129-L155 https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L167-L193   # Vulnerability details  ## Impact  All CryptoPunk deposits can be stolen  ## Proof of Concept  CryptoPunks were created before the ERC721 standard. A consequence of this is that they do not possess the `transferFrom` method. To approximate this a user can `offerPunkForSaleToAddress` for a price of 0 to effectively approve the contract to `transferFrom`.    [WPunkGateway.sol#L77-L95](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95)      function supplyPunk(         DataTypes.ERC721SupplyParams[] calldata punkIndexes,         address onBehalfOf,         uint16 referralCode     ) external nonReentrant {         for (uint256 i = 0; i < punkIndexes.length; i++) {             Punk.buyPunk(punkIndexes[i].tokenId);             Punk.transferPunk(proxy, punkIndexes[i].tokenId);             // gatewayProxy is the sender of this function, not the original gateway             WPunk.mint(punkIndexes[i].tokenId);         }         Pool.supplyERC721(             address(WPunk),             punkIndexes,             onBehalfOf,             referralCode         );     }  The current implementation of `WPunkGateway#supplyPunk` allows anyone to execute and determine where the nTokens are minted to. To complete the flow supply flow a user would need to `offerPunkForSaleToAddress` for a price of 0 to `WPunkGateway`. After they have done this, anyone can call the function to deposit the punk and mint the nTokens to themselves, effectively stealing it.  Example: `User A` owns `tokenID` of 1. They want to deposit it so they call `offerPunkForSaleToAddress` with an amount of 0, effectively approving the `WPunkGateway` to transfer their CryptoPunk. `User B` monitors the transactions and immediately calls `supplyPunk` with themselves as `onBehalfOf`. This completes the transfer of the CryptoPunk and deposits it into the pool but mints the `nTokens` to `User B`, allowing them to effectively steal the CryptoPunk   The same fundamental issue exists with `acceptBidWithCredit` and `batchAcceptBidWithCredit`  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Query the punkIndexToAddress to find the owner and only allow owner to deposit:          for (uint256 i = 0; i < punkIndexes.length; i++) {     +       address owner = Punk.punkIndexToAddress(punkIndexes[i].tokenId);     +       require(owner == msg.sender);              Punk.buyPunk(punkIndexes[i].tokenId);             Punk.transferPunk(proxy, punkIndexes[i].tokenId);             // gatewayProxy is the sender of this function, not the original gateway             WPunk.mint(punkIndexes[i].tokenId);         }
# Lines of code  https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/NFTFloorOracle.sol#L335   # Vulnerability details  ## Impact During `_removeFeeder` operation in `NFTFloorOracle` contract, the feeder is removed from `feeders` array, and linking in `feederPositionMap` for the specific feeder is removed. Deletion logic is implemented in "Swap + Pop" way, so indexes changes, but existing **code doesn't update indexes in** `feederPositionMap` **after feeder removal**, which causes the issue of Denial of Service for further removals. As a result: - Impossible to remove some `feeders` from the contract due to Out of Bounds array access. Removal fails because of transaction revert. - Data in `feederPositionMap` is corrupted after some `feeders` removal. Data linking from `feederPositionMap.index` to `feeders` array is broken.   ## Proof of Concept ```     address internal feederA = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;     address internal feederB = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;     address internal feederC = 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;      function corruptFeedersMapping() external {         console.log("Starting from empty feeders array. Array size: %s", feeders.length);         address[] memory initialFeeders = new address[](3);         initialFeeders[0] = feederA;         initialFeeders[1] = feederB;         initialFeeders[2] = feederC;         this.addFeeders(initialFeeders);         console.log("Feeders array: [%s, %s, %s]", initialFeeders[0], initialFeeders[1], initialFeeders[2]);         console.log("Remove feeder B");         this.removeFeeder(feederB);         console.log("feederPositionMap[A] = %s, feederPositionMap[C] = %s", feederPositionMap[feederA].index, feederPositionMap[feederC].index);         console.log("Mapping for Feeder C store index 2, which was not updated after removal of B. Feeders array length is : %s", feeders.length);         console.log("Try remove Feeder C. Transaction will be reverted because of access out of bounds of array. Data is corrupted");         this.removeFeeder(feederC);     } ``` Snippet execution result: ![Alt text](https://i.gyazo.com/90ac873cd71194527d4d3b9bfe6e317e.png "Optional title")  ## Tools Used Visual inspection; Solidity snippet for PoC  ## Recommended Mitigation Steps Update index in `feederPositionMap` after feeders swap and pop. ``` feeders[feederIndex] = feeders[feeders.length - 1]; feederPositionMap[feeders[feederIndex]].index = feederIndex; //Index update added as a recommendation feeders.pop(); ```
