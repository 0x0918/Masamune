# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117   # Vulnerability details  ## Impact  When deactivateOracle() is called for an oracle in OracleRegistry it is still available for option spreads minting.  This way a user can continue to mint new options within spreads that rely on an oracle that was deactivated. As economic output of spreads is close to vanilla options, so all users who already posses an option linked to a deactivated oracle can surpass this deactivation, being able to mint new options linked to it as a part of option spreads.  ## Proof of Concept  Oracle active state is checked with isOracleActive() during option creation in validateOptionParameters() and during option minting in _mintOptionsPosition().  It isn't checked during spreads creation:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117  In other words besides vanilla option minting and creation all spectrum of operations is available for the deactivated oracle assets, including spreads minting, which economically is reasonably close to vanilla minting.  ## Recommended Mitigation Steps  If oracle deactivation is meant to transfer all related assets to the close only state then consider requiring oracle to be active on spreads minting as well in the same way it's done for vanilla option minting:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L188-L197   
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516   # Vulnerability details  ## Impact  A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.  The Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.  ## Proof of Concept  When the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal _qTokenPermit:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L91-L92  _qTokenPermit calls the IQToken(_qToken) address provided without performing any additional checks:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516  This way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.  ## Recommended Mitigation Steps  Given that QToken can be called directly please examine the need for QTokenPermit ActionType.  If current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided.  
## Title 1 Missing input validation on array lengths  ### Impact The functions below fail to perform input validation on arrays to verify the lengths match. A mismatch could lead to an exception or undefined behavior.  ## #Proof of Concept https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L138-L160  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L163-L184  ### Tools Used Manual review on VScode  ### Recommended Mitigation Steps Add input validation to check that the length of both arrays match.  ---------------------------------------------------------------------------------------------------------------------  -------------------------------------------------------------------------------------------------------------------- ## Title 2 Use of ecrecover is susceptible to signature malleability  ### Impact The ecrecover function is used in metaSetApprovalForAll() to recover the address from the signature. The built-in EVM precompile ecrecover is susceptible to signature malleability which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   ## #Proof of Concept https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L218-L219  ### Tools Used Manual review on VScode  ### Recommended Mitigation Steps Consider using the openzeppelin ECDSA library for signature verifications.
## Issue 1 (Low) - Exclusive time checks should be inclusive  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L325-L328  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L563-L566   ### Impact At least one of the following checks is slightly inaccurate due to exclusive timestamp checks.  ``` require(             block.timestamp > qToken.expiryTime(),             "Controller: Can not exercise options before their expiry"         ); ```  ``` require(             IQToken(_qToken).expiryTime() > block.timestamp,             "Controller: Cannot mint expired options"         ); ```  The second statement ceases minting the moment the expiryTime is hit which makes sense. The first statement doesn't allow the options to be exercised until after the expiry time, causing a gap in functionality.   ### Recommended Steps The first statement should be:  ``` require(             block.timestamp >= qToken.expiryTime(),             "Controller: Can not exercise options before their expiry"         ); ```  ## Issue 2 (Low) - Missing Address(0) Checks in Constructor Address Params  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L325-L328  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L563-L566  ### Impact These two contracts do not check for address(0) in their constructors and will require redeployment if necessary.  ### Recommended Steps Add require statements != address(0) in both constructors.  ## Issue 3 (Low) - Front-Runnable Initializers  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L134-L159  ### Impact Lack of access control on initialize(), can be front-run.  ### Recommended Steps Add access control for OnlyOwner.  ## Issue 4 (Low) - Function input doesn't match purpose  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/QuantCalculator.sol#L61-L163  ### Impact The address parameter in the following function is named `_msgSender` but it can arbitrarily be any account since it has external visibility.  ``` function calculateClaimableCollateral(         uint256 _collateralTokenId,         uint256 _amount,         address _msgSender     )         external         view         override         returns (             uint256 returnableCollateral,             address collateralAsset,             uint256 amountToClaim         )     { ```  ### Recommended Steps Rename to "user" or similar.   
# QA Report  ## Non-Critical Findings  ### Contract implementations should inherit their interface  #### Description  It's best practice for a contract to inherit from it's interface. This improves the contract's clarity and makes sure the contract implementation complies with the defined interface.  #### Findings  [QuantConfig.sol](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L13):  ```solidity contract QuantConfig is     AccessControlUpgradeable,     OwnableUpgradeable,     IQuantConfig, // @audit-info add interface IQuantConfig     ITimelockedConfig {   ... } ```  #### Recommended mitigation steps  Inherit from the missing interface or contract.  ---  ### Public functions that could be declared external  #### Description  Following functions should be declared `external`, as functions that are never called by the contract internally should be declared external (to save gas) as well as for code clarity reasons.  #### Findings  [ChainlinkFixedTimeOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L56)   [ProviderOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L68)   [ChainlinkOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L136)   [PriceRegistry.hasSettlementPrice()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L116)    #### Recommended mitigation steps  Use the `external` attribute for functions never called from the contract.  ---  ### Spelling mistakes  #### Description  Spelling mistakes found.  #### Findings  **[timelock/ConfigTimelockController.sol](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol)**  [L623](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L623): `_isProtocoValueSetter` -> `_isProtocolValueSetter`  #### Recommended mitigation steps  Fix spelling mistakes.  ---  ### Redundant storage access - use variable `assetOracle`  #### Description  _I know there are no rewards for gas optimizations, nevertheless I want to address this finding to prevent any future issues and confusions._  The current implementation of [ProviderOracleManager.getAssetOracle()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L78) has a `require` statement which repeatedly accesses `assetOracles[_asset]` from storage:  ```solidity function getAssetOracle(address _asset)     public     view     override     returns (address) {     address assetOracle = assetOracles[_asset];     require(         assetOracles[_asset] != address(0), // @audit repeated storage variable access         "ProviderOracleManager: Oracle doesn't exist for that asset"     );     return assetOracle; } ```  #### Findings  [ProviderOracleManager.getAssetOracle()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L78)  #### Recommended mitigation steps  Change code to:  ```solidity function getAssetOracle(address _asset)     public     view     override     returns (address) {     address assetOracle = assetOracles[_asset];     require(         assetOracle != address(0), // @audit use `assetOracle` instead         "ProviderOracleManager: Oracle doesn't exist for that asset"     );     return assetOracle; } ```  ## Low Risk  ### Missing documentation of function parameters  #### Description  Function parameters should be fully documented to provide clear instructions what parameters are used for.  #### Findings  [QTokenStringUtils.\_qTokenName()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/QTokenStringUtils.sol#L41): missing `@param` for `_strikeAsset`   [OptionsUtils.getTargetQTokenAddress()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/OptionsUtils.sol#L32): missing `@param` for `_quantConfig`   [OptionsUtils.getTargetCollateralTokenId()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L67): missing `@param` for `_quantConfig`    #### Recommended mitigation steps  Add `@param` documentation for all parameters.  ---  ### `ChainlinkOracleManager.isValidOption()` always returns `true` for any asset  #### Description  The current implementation of `ChainlinkOracleManager.isValidOption()` always returns true, not matter which `_asset` is passed:  ```solidity function isValidOption(     address,     uint256,     uint256 )     public     view     virtual     override(ProviderOracleManager, IProviderOracleManager)     returns (bool) {     return true; // @audit-info always returns `true` } ```  There are no risks caused by to this implementation as there are checks in place to make sure there's a valid oracle price for the underlying qToken asset (e.g in [PriceRegistry.getSettlementPriceWithDecimals()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L72)).  Nevertheless this function should check if the passed `_asset` is valid.  #### Findings  [ChainlinkOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L133)  #### Recommended mitigation steps  Change implementation to:  ```solidity function isValidOption(     address _asset,     uint256,     uint256 )     public     view     virtual     override(ProviderOracleManager, IProviderOracleManager)     returns (bool) {     getAssetOracle(_asset); // @audit-info add this function call which has a `require` statement to assert `_asset` is supported by oracle      return true; } ```  and fix failing unit test in [ChainlinkOracleManager.test.ts#L385](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/test/ChainlinkOracleManager.test.ts#L385)  ---  ### Shadowed variables  #### Description  Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  The variable `_timestamps` does not pose any immediate risk to the contract as it's not used in the contract, incorrect usage of the variable is possible and can cause serious issues if the developer does not pay close attention.  The variable `minDelay` could cause issues as it's used in the contract. As the shadowed `minDelay` variable in the inherited contract `TimelockController.sol` can be changed (with `updateDelay()`), the variable with the same name in contract `ConfigTimelockController` does not change and is out of sync.  #### Findings  [timelock/ConfigTimelockController.sol.\_timestamps](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)   [timelock/ConfigTimelockController.sol.minDelay](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L18)  #### Recommended mitigation steps  **[timelock/ConfigTimelockController.sol.\_timestamps](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)**:  Remove variable declaration `_timestamps`:  ```solidity mapping(bytes32 => uint256) private _timestamps; ```  **[timelock/ConfigTimelockController.sol.minDelay](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L18)**:  Remove variable declaration `minDelay`:  ```solidity uint256 public minDelay; ```  Replace all occurrences of `minDelay` with `getMinDelay()`. 
# Low 1 Deprecated `_setupRole` function used  ## Impact  The _setupRole function is deprecated according to the Open Zeppelin comment `NOTE: This function is deprecated in favor of {_grantRole}`  Use the recommended _grantRole function instead.  ## Proof of concept  Where _setupRole is used in rolla https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L160-L161 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L79-L90  Open Zeppelin comment https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L195  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Avoid using deprecated functions. Replace _setupRole with _grantRole  # Low 2 _timestamps variable shadowing  ## Impact  ConfigTimelockController.sol inherits TimelockController.sol but declares a new _timestamps mapping equivalent to the mapping in TimelockController.sol. This shadowing of the mapping will cause problems in calls to parent functions that use the _timestamps mapping, because the _timestamps mapping in ConfigTimelockController.sol is not used.  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Proof of concept  _timestamps is declared in TimelockController.sol https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L29  An identical _timestamps mapping is declared in ConfigTimelockController.sol, which inherits TimelockController.sol and does not need to declare an identical mapping with the same name https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Tools Used  Slither https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing  ## Recommended Mitigation Steps  Remove the line of code declaring the _timestamps mapping in ConfigTimelockController.sol so that the _timestamps mapping from TimelockController.sol is used throughout.  # Low 3 Roles not added to quantRoles  ## Impact  The quantRoles mapping is intended to store all roles used by QuantConfig.sol. Other contracts import the IQuantConfig.sol interface and call config.quantRoles. Most of the contracts calling config.quantRoles do so for a role that is never added to the quantRoles mapping in QuantConfig.sol. Because solidity variables has a default value, querying an entity of a `string => bytes32` mapping that does not exist with return an empty bytes32 value of bytes32(0). This interferes with the intended logic of the contracts and in some cases will result in if statements that always return one condition because the quantRoles mapping is never updated outside of the _setProtocolRole function.  ## Proof of concept  Observe that the quantRoles mapping has a new role added in the _setProtocolRole function of QuantConfig.sol, and this is the only function in QuantConfig.sol that modifies this mapping https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L177  Because the _setProtocolRole is an internal function, another contract would need to inherit QuantConfig.sol in order to modify the quantRoles mapping. But no other contract in the Rolla project does this. There are several roles, such as FALLBACK_PRICE_ROLE, which are queried in the quantRoles mapping but will never return a value other than bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L81  Another example is the COLLATERAL_MINTER_ROLE role, which is queried twice but never set and will always return bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L108 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L145  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The simplest approach is a manual one that may result in error. The owner of QuantConfig.sol can call setProtocolRole to set these roles after QuantConfig is deployed. This may even be the intended approach with this code, but there is no test or other code that demonstrates setting the FALLBACK_PRICE_ROLE in the quantRoles mapping.  A more robust solution is to call _setProtocolRole with all the hardcoded roles in the initialize function of QuantConfig.sol, like what is done for oracleManagerRole in this line https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L164  # Low 4 Missing reentrancy guard on ERC1155 _mint  ## Impact  The ERC1155 _mint function is vulnerable to reentrancy. A nonreentrant modifier or lock modifier should be applied to functions that have reentrancy weaknesses for protection from this attack vector. Even though no direct reentrancy attack may exist on these Rolla functions today, that could change in the future and proper defensive measures are crucial.  ## Proof of concept  The ERC1155 _mint function is used in mintCollateralToken https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L116  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the nonReentrant modifier from the Open Zeppelin library https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol
### L-01: Missing Zero check QuantCalculator.constructor(contracts/QuantCalculator.sol#55) lacks a zero-check on : optionsFactory = _optionsFactory (contracts/QuantCalculator.sol#57)  ### L-02:  Ether lock Payable function with no method of withdrawal available, eventually ends up locking ether  ``` executeMetaTransaction() (contracts/utils/EIP712MetaTransaction.sol#55-93) ```
# C4-001 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  PrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.  ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L200  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L394  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L472 ```  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.  # C4-002 : Front-runnable Initializers  ## Impact - LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L148  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L134 ```  2. initialize functions does not have access control. They are vulnerable to front-running.   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.  # C4-003 : Use of ecrecover is susceptible to signature malleability  ## Impact - LOW  The ecrecover function is used in permit() to recover the address from the signature. The built-in EVM precompile ecrecover is susceptible to signature malleability which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).  ## Proof of Concept  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using OpenZeppelin’s ECDSA library (which prevents this malleability) instead of the built-in function.  # C4-004 : transferOwnership should be two step process  ## Impact  "QuantConfig.sol" inherit OpenZeppelin's OwnableUpgradeable contract which enables the onlyOwner role to transfer ownership to another address. It's possible that the onlyOwner role mistakenly transfers ownership to the wrong address, resulting in a loss of the onlyOwner role. The current ownership transfer process involves the current owner calling Unlock.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier. Lack of two-step procedure for critical operations leaves them error-prone if the address is incorrect, the new address will take on the functionality of the new role immediately  for Ex : -Alice deploys a new version of the whitehack group address. When she invokes the whitehack group address setter to replace the address, she accidentally enters the wrong address. The new address now has access to the role immediately and is too late to revert   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L15" 2. The contracts have many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. 
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415   # Vulnerability details  ## Impact In the `_call()` function in `TimelockController.sol`, a call is executed with the following code:  ``` function _call(         bytes32 id,         uint256 index,         address target,         uint256 value,         bytes memory data     ) private {         // solhint-disable-next-line avoid-low-level-calls         (bool success, ) = target.call{value: value}(data);         require(success, "TimelockController: underlying transaction reverted");          emit CallExecuted(id, index, target, value, data);     } ```  Per the Solidity docs:  "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed."   Therefore, transfers may fail silently.  ## Proof of Concept Please find the documentation here: https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used Manual review.  ## Recommended Mitigation Steps Check for the account's existence prior to transferring.  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L22-L34   # Vulnerability details  Use of Upgradeable Proxy Contract Structure allows the logic of the contract to be arbitrarily changed.  This allows the proxy admin to perform malicious actions e.g., taking funds from users' wallets up to the allowance limit.  This action can be performed by the malicious/compromised proxy admin without any restriction.   Considering that the purpose of this particular contract is for accounting of the Collateral and LongShortTokens, we believe the users' allowances should not be hold by this upgradeable contract.  ### PoC  Given:  - collateral: `USDC`  #### Rug Users' Allowances  1. Alice `approve()` and `_mintOptionsPosition()` with `1e8 USDC`; 2. Bob  `approve()` and `_mintOptionsPosition()` with `5e8 USDC`; 3. A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets;  #### Rug Contract's Holdings (funds that belongs to users)  A malicious/compromised proxy admin can just call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.  ### Severity  A smart contract being structured as an upgradeable contract alone is not usually considered as a high severity risk. But given the severe impact (all the funds in the contract and funds in users' wallets can be stolen), we mark it as a `High` severity issue.  ### Recommendation  Consider using the non-upgradeable `CollateralToken` contract to hold user's allowances instead.  See also the Recommendation of [WP-H7].  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19   # Vulnerability details  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L550-L558  ```solidity     /// @notice Allows a sender/signer to make external calls to any other contract.     /// @dev A separate OperateProxy contract is used to make the external calls so     /// that the Controller, which holds funds and has special privileges in the Quant     /// Protocol, is never the `msg.sender` in any of those external calls.     /// @param _callee The address of the contract to be called.     /// @param _data The calldata to be sent to the contract.     function _call(address _callee, bytes memory _data) internal {         IOperateProxy(operateProxy).callFunction(_callee, _data);     } ```  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19  ```solidity     function callFunction(address callee, bytes memory data) external override {         require(             callee != address(0),             "OperateProxy: cannot make function calls to the zero address"         );          (bool success, bytes memory returnData) = address(callee).call(data);         require(success, "OperateProxy: low-level call failed");         emit FunctionCallExecuted(tx.origin, returnData);     } ```  As the `OperateProxy.sol#callFunction()` function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.  For example, if a certain business logic requires a successful `token.transferFrom()` call to be made with the `OperateProxy`, if the `token` is not a existing contract, the call will return `success: true` instead of `success: false` and break the caller's assumption and potentially malfunction features or even cause fund loss to users.  The qBridge exploit (January 2022) was caused by a similar issue.  As a reference, OpenZeppelin's `Address.functionCall()` will check and `require(isContract(target), "Address: call to non-contract");`  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L135  ```solidity     function functionCallWithValue(         address target,         bytes memory data,         uint256 value,         string memory errorMessage     ) internal returns (bytes memory) {         require(address(this).balance >= value, "Address: insufficient balance for call");         require(isContract(target), "Address: call to non-contract");          (bool success, bytes memory returndata) = target.call{value: value}(data);         return verifyCallResult(success, returndata, errorMessage);     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L36-L42  ```solidity     function isContract(address account) internal view returns (bool) {         // This method relies on extcodesize/address.code.length, which returns 0         // for contracts in construction, since the code is only stored at the end         // of the constructor execution.          return account.code.length > 0;     } ```  ### Recommendation  Consider adding a check and throw when the `callee` is not a contract.  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86   # Vulnerability details  Any transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).  In the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.  As a result, the same tx can be replayed by anyone, using the same signature.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86  ```solidity     function executeMetaTransaction(         MetaAction memory metaAction,         bytes32 r,         bytes32 s,         uint8 v     ) external payable returns (bytes memory) {         require(             _verify(metaAction.from, metaAction, r, s, v),             "signer and signature don't match"         );          uint256 currentNonce = _nonces[metaAction.from];          // intentionally allow this to overflow to save gas,         // and it's impossible for someone to do 2 ^ 256 - 1 meta txs         unchecked {             _nonces[metaAction.from] = currentNonce + 1;         }          // Append the metaAction.from at the end so that it can be extracted later         // from the calling context (see _msgSender() below)         (bool success, bytes memory returnData) = address(this).call(             abi.encodePacked(                 abi.encodeWithSelector(                     IController(address(this)).operate.selector,                     metaAction.actions                 ),                 metaAction.from             )         );          require(success, "unsuccessful function call");         emit MetaTransactionExecuted(             metaAction.from,             payable(msg.sender),             currentNonce         );         return returnData;     } ```  See also the implementation of OpenZeppelin's `MinimalForwarder`:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66  ### PoC  Given:  - The collateral is USDC; - Alice got `10,000 USDC` in the wallet.  1. Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`; 2. Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob; 3. The MetaTransaction submited by Alice in step 1 get executed but failed; 4. A few days later, Bob sent `1,000 USDC` to Alice; 5. The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.  Alice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.  ### Recommendation  Failed txs should still increase the nonce.  While implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent "insufficient gas griefing attack" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114   # Vulnerability details  1. `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```  Otherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53  ```solidity     /**      * @dev Modifier to protect an initializer function from being invoked twice.      */     modifier initializer() {         // If the contract is initializing we ignore whether _initialized is set in order to support multiple         // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the         // contract may have been reentered.         require(_initializing ? _isConstructor() : !_initialized, "Initializable: contract is already initialized");          bool isTopLevelCall = !_initializing;         if (isTopLevelCall) {             _initializing = true;             _initialized = true;         }          _;          if (isTopLevelCall) {             _initializing = false;         }     } ```  See also: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1   2. `initializer` can only be called once, it can not be "called once after every upgrade".  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```   3. A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.  See the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28  ```solidity abstract contract EIP712Upgradeable is Initializable {     // ... } ```  ### Recommendation  Change to:  ```solidity abstract contract EIP712MetaTransaction is EIP712Upgradeable {     // ... } ```  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function __EIP712MetaTransaction_init(string memory _name, string memory _version)         internal         onlyInitializing     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```    
## [L] `ConfigTimelockController` One address should not be able to be a `proposer` and a `executor` at the same time  The purpose of the design which have two separate roles of `proposers` and `executors` is to prevent the centralization risk which one can propose a change and get it executed right away by themselves.  However, the current implementation allows the same address to be in `proposers` and `executors` at the same time, this makes such a design becomes a unenforced law.  In operation practise, the admin can and, we believe they have a natural tendency to add both roles to the same address as this is easier in operation.  ### Recommendation  Consider adding a check to make sure `proposers` and `executors` do not include any same address  ## [L] Tokens with fee on transfer are not supported  There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.  In the current implementation, `Controller.sol#_mintOptionsPosition()`, `Controller.sol#_mintSpread()` and `Controller.sol#_claimCollateral()` assumes that the received amount is the same as the transfer amount, and uses it for collateralToken minting and redeeming.  ### Recommendation  Making sure no FOT tokens will be whitelisted in the protocol.
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L176-L180   # Vulnerability details  ## Impact  A switch to an assetsRegistry that doesn't contain a particular underlying by mistake or as a part of griefing attack will freeze all the payoff funds accounted for already issued QTokens with this underlying. I.e. all buyers and sellers of the associated QTokens will have the payoff funds frozen until assetsRegistry be updated as Controller's _claimCollateral, _neutralizePosition and _exercise will be failing in this case.  For example, suppose LINK is added as an underlying to assetsRegistry, some time passed and options were minted, then the registry is updated and LINK is no longer listed there. All the users with not yet fulfilled claims on the issued LINK options will have their funds frozen until assetsRegistry be updated again to include LINK back.  In other words, at the moment there is no way to separate new options issuance and existing options settlement, which makes a removal of an underlying a tricky task, given that maturity of the options isn't restricted.  ## Proof of Concept  In QuantConfig the priceRegistry setting is immutable, while oracleRegistry and assetsRegistry can be reset by an owner:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L47-L64  oracleRegistry reset affect new option creation and minting only.  On the other hand, apart from QToken creation, assetsRegistry is used in the most of payoff calculations.  This way assetsRegistry reset to a contract that doesn't have a record of a particular underlying will freeze all the payoff calculation functionality as OptionsUtils.getPayoutDecimals, which will become unavailable, is called by QuantCalculator's getCollateralRequirement, getExercisePayout, calculateClaimableCollateral and getNeutralizationPayout.   Here is getPayoutDecimals called by getNeutralizationPayout:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L176-L180  Also, by calculateClaimableCollateral, getCollateralRequirement, getExercisePayout:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L133-L137  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L210-L214  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L261-L265  This way, a switch to an assetsRegistry that doesn't constant the underlying will make most of the QuantCalculator's payoff calculations fail, freezing all the payoff funds accounted for all the QTokens with this underlying.   ## Recommended Mitigation Steps  As getPayoutDecimals is the basic function to request the decimals, which a single constant value, consider moving it to the QToken storage instead of requesting from an outside contracts each time.  Apart from removing this attack surface, this will also provide some gas optimisation, which is viable as mentioned operations are common enough, justifying a minor increase in storage space.   
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130   # Vulnerability details  The `README.md` states: > Bob can then trade the QToken with Alice for a premium. The method for doing that is beyond the scope of the protocol but can be done via any smart contract trading platform e.g. 0x.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/README.md?plain=1#L70  It is therefore important that tokens be easily identifiable so that trading on DEXes is not error-prone.  ## Impact Currently the `QToken` `name` includes the full year but the `QToken` symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a QToken with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. Normal centralized exchanges prevent this by listing options themselves and ensuring that there are never two options with the same identifier at the same time. The Rolla protocol does not have any such protections. Users must be told to not only check that the symbol name is what they expect, but to also separately check the token name or the specific expiry, or they might buy the wrong option on a DEX, or have fat-fingered during minting on a non-Rolla web interface. It's important to minimize the possibility of mistakes, and not including the full year in the symbol makes things error-prone, and will lead to other options providers winning out.  The 0x [REST interface](https://docs.0x.org/0x-api-swap/api-references/get-swap-v1-quote) for swaps has the ability to do a swap by token name rather than by token address. I was unable to figure out whether there was an allow-list of token names, or if it is easy to add a new token. If there is no, or an easily bypassed, access-control for adding new tokens, I would say this finding should be upgraded to high-severity, though I doubt this is the case.  ## Proof of Concept ```solidity         /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 "ROLLA",                 "-",                 underlying,                 "-",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 "-",                 displayStrikePrice,                 "-",                 typeSymbol             )         ); ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130  ```solidity     /// @return 2 characters that correspond to a number     function _uintToChars(uint256 _number)         internal         pure         virtual         returns (string memory)     {         if (_number > 99) {             _number %= 100;         }          string memory str = Strings.toString(_number);          if (_number < 10) {             return string(abi.encodePacked("0", str));         }          return str;     } ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L181-L199  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include the full year in the token's symbol   
## Low-impact Issues  ### The current code will not be able to support compound options (options on options) The code that adds new assets checks whether the asset already exists or not by checking the token's symbol. Since  `QToken`s' symbols do not contain the full year, once a token with a specific year is added, a similar token 100 years into the future (or into the past) cannot be added 1. File: contracts/libraries/OptionsUtils.sol (lines [152-165](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/OptionsUtils.sol#L152-L165)) ```solidity     function isInAssetsRegistry(address _asset, address _quantConfig)         internal         view         returns (bool)     {         string memory symbol;         (, symbol, ) = IAssetsRegistry(             IQuantConfig(_quantConfig).protocolAddresses(                 ProtocolValue.encode("assetsRegistry")             )         ).assetProperties(_asset);          return bytes(symbol).length != 0;     } ```  ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: contracts/QuantCalculator.sol (line [57](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L57)) ```solidity         optionsFactory = _optionsFactory; ```   ### Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  1. File: contracts/Controller.sol (lines [30-33](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L30-L33)) ```solidity contract Controller is     IController,     EIP712MetaTransaction,     ReentrancyGuardUpgradeable ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L13)) ```solidity contract EIP712MetaTransaction is EIP712Upgradeable { ``` 3. File: contracts/QuantConfig.sol (lines [13-16](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantConfig.sol#L13-L16)) ```solidity contract QuantConfig is     AccessControlUpgradeable,     OwnableUpgradeable,     ITimelockedConfig ```  ## Non-critical Issues  ### Use a switch statement for long if-else-if chains involving a single variable https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L59-L123   ### _encodeSetProtocolRole() should take in a `ProtocolValue` like the other functions It's inconsistent for roles to be passed in as strings when they can easily be `ProtocolValue`s  1. File: contracts/timelock/ConfigTimelockController.sol ((lines [434-447](https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L434-L447)) ```solidity     function executeSetProtocolRole(         string calldata protocolRole,         address roleAdmin,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) {         execute(             quantConfig,             0,             _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),             bytes32(0),             bytes32(eta)         );     } ```  ### `public` functions not called by the contract should be declared `external` instead Inconsistencies make code hard to maintain Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  1. File: contracts/Controller.sol (lines [134-139](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L134-L139)) ```solidity     function initialize(         string memory _name,         string memory _version,         address _optionsFactory,         address _quantCalculator     ) public override initializer { ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (lines [106-108](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L106-L108)) ```solidity     function initializeEIP712(string memory _name, string memory _version)         public         initializer ``` 3. File: contracts/timelock/ConfigTimelockController.sol (lines [250-255](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L250-L255)) ```solidity     function scheduleBatchSetProtocolAddress(         bytes32[] calldata protocolValues,         address[] calldata newAddresses,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 4. File: contracts/timelock/ConfigTimelockController.sol (lines [281-286](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L281-L286)) ```solidity     function scheduleBatchSetProtocolUints(         bytes32[] calldata protocolValues,         uint256[] calldata newUints,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 5. File: contracts/timelock/ConfigTimelockController.sol (lines [312-317](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L312-L317)) ```solidity     function scheduleBatchSetProtocolBooleans(         bytes32[] calldata protocolValues,         bool[] calldata newBooleans,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 6. File: contracts/timelock/ConfigTimelockController.sol (lines [343-348](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L343-L348)) ```solidity     function scheduleBatchSetProtocolRoles(         string[] calldata protocolRoles,         address[] calldata roleAdmins,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 7. File: contracts/timelock/ConfigTimelockController.sol (lines [374-379](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L374-L379)) ```solidity     function executeSetProtocolAddress(         bytes32 protocolAddress,         address newAddress,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 8. File: contracts/timelock/ConfigTimelockController.sol (lines [394-399](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L394-L399)) ```solidity     function executeSetProtocolUint256(         bytes32 protocolUint256,         uint256 newUint256,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 9. File: contracts/timelock/ConfigTimelockController.sol (lines [414-419](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L414-L419)) ```solidity     function executeSetProtocolBoolean(         bytes32 protocolBoolean,         bool newBoolean,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 10. File: contracts/timelock/ConfigTimelockController.sol (lines [434-439](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L434-L439)) ```solidity     function executeSetProtocolRole(         string calldata protocolRole,         address roleAdmin,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 11. File: contracts/timelock/ConfigTimelockController.sol (lines [454-459](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L454-L459)) ```solidity     function executeBatchSetProtocolAddress(         bytes32[] calldata protocolValues,         address[] calldata newAddresses,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 12. File: contracts/timelock/ConfigTimelockController.sol (lines [490-495](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L490-L495)) ```solidity     function executeBatchSetProtocolUint256(         bytes32[] calldata protocolValues,         uint256[] calldata newUints,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 13. File: contracts/timelock/ConfigTimelockController.sol (lines [526-531](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L526-L531)) ```solidity     function executeBatchSetProtocolBoolean(         bytes32[] calldata protocolValues,         bool[] calldata newBooleans,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 14. File: contracts/timelock/ConfigTimelockController.sol (lines [562-567](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L562-L567)) ```solidity     function executeBatchSetProtocolRoles(         string[] calldata protocolRoles,         address[] calldata roleAdmins,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 15. File: contracts/QuantConfig.sol (lines [148-151](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantConfig.sol#L148-L151)) ```solidity     function initialize(address payable _timelockController)         public         override         initializer ``` 16. File: contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol (lines [53-61](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L53-L61)) ```solidity     function isValidOption(         address,         uint256 _expiryTime,         uint256     )         public         view         override(ChainlinkOracleManager, IProviderOracleManager)         returns (bool) ``` 17. File: contracts/pricing/PriceRegistry.sol (lines [112-116](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L112-L116)) ```solidity     function hasSettlementPrice(         address _oracle,         address _asset,         uint256 _expiryTimestamp     ) public view override returns (bool) { ```  ### Adding a `return` statement when the function defines a named return variable, is redundant  1. File: contracts/utils/EIP712MetaTransaction.sol (line [133](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L133)) ```solidity         return sender; ```    ### Using `calldata` instead of `memory` for read-only arguments in `external` does not follow const-correctness This is an example of [const-correctness](https://stackoverflow.com/questions/8277801/what-is-the-definition-of-const-correctness) 1. File: contracts/Controller.sol (line [49](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L49)) ```solidity     function operate(ActionArgs[] memory _actions) ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (line [56](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L56)) ```solidity         MetaAction memory metaAction, ``` 3. File: contracts/utils/OperateProxy.sol (line [10](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/OperateProxy.sol#L10)) ```solidity     function callFunction(address callee, bytes memory data) external override { ``` 4. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [7](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L7)) ```solidity         bytes memory, ``` 5. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L13)) ```solidity     function initializeEIP712(string memory, string memory) external; ``` 6. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L13)) ```solidity     function initializeEIP712(string memory, string memory) external; ``` 7. File: contracts/interfaces/IController.sol (line [90](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L90)) ```solidity     function operate(ActionArgs[] memory _actions) external returns (bool); ``` 8. File: contracts/interfaces/IController.sol (line [94](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L94)) ```solidity         string memory, ``` 9. File: contracts/interfaces/IController.sol (line [95](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L95)) ```solidity         string memory, ``` 10. File: contracts/interfaces/IProviderOracleManager.sol (line [25](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IProviderOracleManager.sol#L25)) ```solidity         bytes memory _calldata ``` 11. File: contracts/interfaces/IOperateProxy.sol (line [14](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IOperateProxy.sol#L14)) ```solidity     function callFunction(address callee, bytes memory data) external; ``` 12. File: contracts/pricing/oracle/ChainlinkOracleManager.sol (line [60](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L60)) ```solidity         bytes memory ``` 13. File: contracts/pricing/oracle/ProviderOracleManager.sol (line [47](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L47)) ```solidity         bytes memory _calldata ```  ### Not using the named return variables when a function returns is confusing  1. File: contracts/timelock/TimelockController.sol (line [279](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L279)) ```solidity         return getTimestamp(id) > 0; ``` 2. File: contracts/timelock/TimelockController.sol (line [291](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L291)) ```solidity         return getTimestamp(id) > _DONE_TIMESTAMP; ``` 3. File: contracts/timelock/TimelockController.sol (line [305](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L305)) ```solidity         return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp; ``` 4. File: contracts/timelock/TimelockController.sol (line [317](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L317)) ```solidity         return getTimestamp(id) == _DONE_TIMESTAMP; ``` 5. File: contracts/timelock/TimelockController.sol (line [330](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L330)) ```solidity         return _timestamps[id]; ``` 6. File: contracts/timelock/TimelockController.sol (line [339](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L339)) ```solidity         return _minDelay; ``` 7. File: contracts/timelock/TimelockController.sol (line [353](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L353)) ```solidity         return keccak256(abi.encode(target, value, data, predecessor, salt)); ``` 8. File: contracts/timelock/TimelockController.sol (line [367](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L367)) ```solidity         return keccak256(abi.encode(targets, values, datas, predecessor, salt)); ``` 9. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ``` 10. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ``` 11. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ```  ### Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Copy-paste code shouldn't be done and should always be refactored for clean code 1. File: contracts/timelock/TimelockController.sol (lines [246-249](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L246-L249)) ```solidity         require(             targets.length == values.length,             "TimelockController: length mismatch"         ); ``` 2. File: contracts/timelock/TimelockController.sol (lines [250-253](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L250-L253)) ```solidity         require(             targets.length == datas.length,             "TimelockController: length mismatch"         ); ``` 3. File: contracts/timelock/TimelockController.sol (lines [424-427](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L424-L427)) ```solidity         require(             isOperationReady(id),             "TimelockController: operation is not ready"         ); ``` 4. File: contracts/timelock/ConfigTimelockController.sol (lines [122-125](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L122-L125)) ```solidity         require(             eta >= delay + block.timestamp,             "ConfigTimelockController: Estimated execution block must satisfy delay"         ); ``` 5. File: contracts/timelock/ConfigTimelockController.sol (lines [462-465](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L462-L465)) ```solidity         require(             length == newAddresses.length,             "ConfigTimelockController: length mismatch"         ); ``` 6. File: contracts/timelock/ConfigTimelockController.sol (lines [498-501](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L498-L501)) ```solidity         require(             length == newUints.length,             "ConfigTimelockController: length mismatch"         ); ``` 7. File: contracts/timelock/ConfigTimelockController.sol (lines [534-537](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L534-L537)) ```solidity         require(             length == newBooleans.length,             "ConfigTimelockController: length mismatch"         ); ``` 8. File: contracts/timelock/ConfigTimelockController.sol (lines [570-573](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L570-L573)) ```solidity         require(             length == roleAdmins.length,             "ConfigTimelockController: length mismatch"         ); ``` 9. File: contracts/options/CollateralToken.sol (lines [143-149](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/options/CollateralToken.sol#L143-L149)) ```solidity         require(             quantConfig.hasRole(                 quantConfig.quantRoles("COLLATERAL_MINTER_ROLE"),                 msg.sender             ),             "CollateralToken: Only a collateral minter can mint CollateralTokens"         ); ``` 10. File: contracts/options/CollateralToken.sol (lines [168-174](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/options/CollateralToken.sol#L168-L174)) ```solidity         require(             quantConfig.hasRole(                 quantConfig.quantRoles("COLLATERAL_BURNER_ROLE"),                 msg.sender             ),             "CollateralToken: Only a collateral burner can burn CollateralTokens"         ); ``` 11. File: contracts/pricing/PriceRegistry.sol (lines [98-101](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L98-L101)) ```solidity         require(             settlementPrice.price != 0,             "PriceRegistry: No settlement price has been set"         ); ``` 12. File: contracts/pricing/OracleRegistry.sol (lines [62-68](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L62-L68)) ```solidity         require(             config.hasRole(                 config.quantRoles("ORACLE_MANAGER_ROLE"),                 msg.sender             ),             "OracleRegistry: Only an oracle admin can add an oracle"         ); ```  ### Remove unused variables  1. File: contracts/timelock/ConfigTimelockController.sol (line [15](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)) ```solidity     mapping(bytes32 => uint256) private _timestamps; ``` 
https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/OptionsFactory.sol#L101 Consider using openzeppelin clones in order to save gas, because contract deployment on ethereum is very expensive.
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28   # Vulnerability details  ## Impact  This report presents 2 different incorrect behaviour that can affect the correctness of math calculations 1. Unattended Implicit rounding in QuantMath.sol `div` and `mul` 2. Inappropriate method of casting integer to unsigned integer in SignedConverter.sol `intToUint`  Bug 1 affects the correctness when calculating collateral required for `_mintSpread`. Bug 2 expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.   ## Proof of Concept  In this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.  Before getting started, we should go over an important concept while dealing with fixed point number -- rounding. Math has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of "money" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.  In QuantMath, Rolla explicitly wrote the `toScaledUint` function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it `_decimals` here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never "lose tokens" due to rounding.  ``` library QuantMath {     ...     struct FixedPointInt {         int256 value;     }      int256 private constant _SCALING_FACTOR = 1e27;     uint256 private constant _BASE_DECIMALS = 27;      ...      function toScaledUint(         FixedPointInt memory _a,         uint256 _decimals,         bool _roundDown     ) internal pure returns (uint256) {         uint256 scaledUint;          if (_decimals == _BASE_DECIMALS) {             scaledUint = _a.value.intToUint();         } else if (_decimals > _BASE_DECIMALS) {             uint256 exp = _decimals - _BASE_DECIMALS;             scaledUint = (_a.value).intToUint() * 10**exp;         } else {             uint256 exp = _BASE_DECIMALS - _decimals;             uint256 tailing;             if (!_roundDown) {                 uint256 remainer = (_a.value).intToUint() % 10**exp;                 if (remainer > 0) tailing = 1;             }             scaledUint = (_a.value).intToUint() / 10**exp + tailing;         }          return scaledUint;     }     ... } ```  In practice, the above function also works quite well (sadly, not perfect, notice the `intToUint` function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where `div` and `mul` comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the `_decimal` used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in `toScaledUint` showned above.  ```     function mul(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);     }       function div(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);     } ```  Now let's see how this implicit rounding can causes troubles. We start with the `_mintSpread` procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.  * `Controller._mintSpread`   * `QuantCalculator.getCollateralRequirement`     * `FundsCalculator.getCollateralRequirement`       * `FundsCalculator.getOptionCollateralRequirement`         * `FundsCalculator.getCallCollateralRequirement`           * scales `_qTokenToMintStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * scales `_qTokenForCollateralStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * `collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)`         * scale `_optionsAmount` from `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `collateralAmount = _optionsAmount.mul(collateralPerOption)`       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral     * scale and round up `collateralAmountFP` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`  If we extract all the math related stuff, it would be something like below  ``` def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9         if Y2 % 10^9 > 0:       #round up since we are minting spread (Controller is receiver)                 Z+=1         return Z ```  Both implicit round downs can be abused, but we shall focus on the `mul` one here. Assume we follow the following actions  1. create option `A` with strike price `10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <-> 1 WETH` 2. create option `B` with strike price `10 BUSD (10^9 under 8 decimals) <-> 1 WETH` 3. mint `10^-18` (1 under 18 decimals) option `A`         3-1. `pay 1 eth` 4. mint `10^-18` (1 under 18 decimals) spread `B` with `A` as collateral         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0`         4-6. `Z = Y2 // 10^9 = 0`         4-7. `Y2 % 10^9 = 0` so `Z` remains unchanged  We minted a call credit spread without paying any fee.  Now let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.  For neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since `Controller` is the payer here. The neutralize procedure returns the `qToken` used as collateral and pays the collateral fee back. The math part can be summarized as below.  ``` def neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9  #explicit scaling         return Z ```  There are two challenges that need to be bypassed, the first one is to avoid implicit round down in `mul`, and the second is to ensure the revenue is not rounded away during explicit scaling. To achieve this, we first mint `10^-9 + 2 * 10^-18` spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option. Then we neutralize all those spreads at once, the calculation is shown below  1. neutralize `10^-9 + 2 * 10^-18` (10^9 + 2 under 18 decimals) spread `B`         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000`         4-6. `Z = Y2 // 10^9 = 10^9 // 10^9 = 1`  And with this, we managed to generate 10^-18 weth of revenue.  This approach is pretty impractical due to the requirement of minting 10^-18 for `10^9 + 2` times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.  It's time to start looking at the second bug.  Recall we mentioned the second bug is in `intToUint`, so here's the implementation of it. It is not hard to see that this is actually an `abs` function named as `intToUint`.  ```     function intToUint(int256 a) internal pure returns (uint256) {         if (a < 0) {             return uint256(-a);         } else {             return uint256(a);         }     } ```  Where is this function used? And yes, you guessed it, in `QuantCalculator.calculateClaimableCollateral`. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.  1. mint a `qTokenLong` option 2. mint a `qTokenShort` spread with `qTokenLong` as collateral 3. wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort  ``` ----------- qTokenLong strike price  ----------- expiryPrice  ----------- qTokenShort strike price ```  Here is the outline of the long waited claimCollateral for spread.  * `Controller._claimCollateral`   * `QuantCalculator.calculateClaimableCollateral`     * `FundsCalculator.getSettlementPriceWithDecimals`     * `FundsCalculator.getPayout` for qTokenLong       * qTokenLong strike price is above expiry price, worth 0     * `FundsCalculator.getCollateralRequirement`       * This part we saw earlier, omit details     * `FundsCalculator.getPayout` for qTokenShort       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral       * `FundsCalculator.getPayoutAmount` for qTokenShort         * scale `_strikePrice` from           `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`         * scale `_expiryPrice.price` from           `_expiryPrice.decimals (8)` to `_BASE_DECIMALS (27)`         * scale `_amount` from           `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `FundsCalculator.getPayoutForCall` for qTokenShort           * `payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)`     * `returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)`     * scale and round down `abs(returnableCollateral)` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`   Again, we summarize the math part into a function  ``` def claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):          def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):                 X1 = _qTokenToMintStrikePrice * 10^19                 X2 = _qTokenForCollateralStrikePrice * 10^19                 X3 = _optionsAmount * 10^9                  Y1 = (X2 - X1) * 10^27 // X2                 Y2 = Y1 * X3 // 10^27                 return Y2          def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):                 X1 = _strikePrice * 10^19                 X2 = _expiryPrice * 10^19                 X3 = _amount * 10^9                  Y1 = (X2-X1) * X3 // 10^27                 Y2 = Y1 * 10^27 // X2                 return Y2           assert _qTokenShortStrikePrice > _expiryPrice > _qTokenLongStrikePrice          A1 = payoutFromLong = 0         A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)         A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)          B1 = A1 + A2 - A3          Z = abs(B1) // 10^9         return Z ```  Given the context, it should be pretty easy to imagine what I am aiming here, to make `B1 < 0`. We already know `A1 = 0`, so the gaol basically boils down to making `A2 < A3`. Let's further simplify this requirement and see if the equation is solvable.  ``` X = _qTokenLongStrikePrice (8 decimals) Y = _expiryPrice (8 decimals) Z = _qTokenShortStrikePrice (8 decimals) A = _amount (scaled to 27 decimals)  assert X>Y>Z>0 assert X,Y,Z are integers assert (((X - Z) * 10^27 // X) * A // 10^27) < (((Y - Z) * A // 10^27) * 10^27 // Y) ```  Notice apart from the use of `X` and `Y`, the two sides of the equation only differs by when `A` is mixed into the equation, meaning that if we temporarily ignore the limitation and set `X = Y`, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.  Utilizing this, we turn to solve the equation of  ``` (X-Z) / X - (Y-Z) / Y < 10^-27 => Z / Y - Z / X < 10^-27 => (Z = 1 yields best solution) => 1 / Y - 1 / X < 10^-27 => X - Y < X * Y * 10^-27 => 0 < X * Y - 10^27 * X + 10^27 * Y  => require X > Y, so model Y as X - B, where B > 0 and B is an integer => 0 < X^2 - B * X - 10^27 * B ```  It is not easy to see that the larger `X` is, the larger the range of allowed `B`. This is pretty important since `B` stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.  Apart form range of `B`, value of `X` is the long strike price and upper bound of range `B`, so we would also care about it, a simple estimation shows that `X` must be above `10^13.5 (8 decimals)` for there to be a solution, which amounts to about `316228 BUSD <-> 1 WETH`. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of `10^14 - 1` as X and calculate the revenue generated following this exploit path.  ``` 0 < (10^14 - 1)^2 - B * (10^14 - 1) - 10^27 * B => (10^14 - 1)^2 / (10^14 - 1 + 10^27) > B => B <= 9 ```  Now we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take `_qTokenLongStrikePrice = 10^14 - 1 (8 decimals)`, `_qTokenShortStrikePrice = 1 (8 decimals)`, `_expiryPrice = 10^14 - 2 (8 decimals)` and `_amount = 10^28 (18 decimals)` and plug it back into the function. 1. in `callCreditSpreadCollateralRequirement`         1-1. `X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19`         1-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 - 1) * 10^19 = 10^33 - 10^19`         1-3. `X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37`         1-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^33 - 2 * 10^19) * 10^27 // (10^33 - 10^19) = 999999999999989999999999999`         1-5. `Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10` 2. in `callCreditSpreadQTokenShortPayout`         2-1. `X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19`         2-2. `X2 = _expiryPrice * 10^19 = (10^14 - 2) * 10^19 = 10^33 - 2 * 10^19`         2-3. `X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37`         2-4. `Y1 = (X2 - X1) * X3 // 10^27 = (10^33 - 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29`         2-5. `Y2 = Y1 * 10^27 / X2 = (99999999999997 * 10^28) * 10^27 / (10^33 - 2 * 10^19) = 9999999999999899999999999997999999999 3. combine terms         3-1. `B1 = A1 + A2 - A3 = 0 + 9999999999999899999999999990000000000 - 9999999999999899999999999997999999999 = -2000000001         3-2. `Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2  And with this, we managed to squeeze 2 wei from a presumably worthless collateral.  This attack still suffers from several problems 1. cost of WETH in BUSD is way higher than current market 2. need to predict target price accurately to profit 3. requires large amount of WETH to profit  While it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.  This concludes our demonstration of two attacks against the potential flaws in number handling.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  For `div` and `mul`, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.  For `intToUint`, I still can't understand what the original motive is to design it as `abs` in disguise. Since nowhere in this project would we benefit from the current `abs` behaviour, in my opinion, it would be best to adopt a similar strategy to the `uintToInt` function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.  
## Summary  We found 1 low-critical finding and 1 non-critical finding: * Low-Critical Findings - Uninitialized qTokenDetails.longStrikePrice for non-spread options in CollateralToken.sol/getCollateralTokenInfo * Non-Critical Findings - Usage of ecrecover for metaTransactions without checking r/s in CollateralToken.sol/metaSetApprovalForAll  In summary of recommended security practices, it's better to initialize memory even if it's 0 and use public and verified libraries rather than craft by hand. The first finding is uninitialized memory, due to solidity doesn't guarantee uninitialized memory is almost always 0. It's better to initialize for improving security practices. The second finding is ecrecover. It's better to use a public and verified library like ECDSA. Because EIP-2 still allows signature malleability for ecrecover(), use ECDSA to remove this possibility and make the signature unique.   ## Low-Critical Findings - Uninitialized qTokenDetails.longStrikePrice for non-spread options in CollateralToken.sol/getCollateralTokenInfo  ## Impact  Uninitialize memory is almost always 0 due to solidity’s no memory recycle policy. However, this is not guaranteed in solidity documents and it would be better to initialize `qTokenDetails.longStrikePrice`. Although it won't cause any problems right now, it could be a potential threat in the future.  ## Proof of Concept  `qTokensDetails.longStrikePrice` isn't initialized when `info.qTokenAsCollateral == address(0)`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L237  ```     function getCollateralTokenInfo(uint256 id)         external         view         override         returns (QTokensDetails memory qTokensDetails)     {         CollateralTokenInfo memory info = idToInfo[id];          require(             info.qTokenAddress != address(0),             "CollateralToken: Invalid id"         );          IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)             .getQTokenInfo();          qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;         qTokensDetails.strikeAsset = shortDetails.strikeAsset;         qTokensDetails.oracle = shortDetails.oracle;         qTokensDetails.shortStrikePrice = shortDetails.strikePrice;         qTokensDetails.expiryTime = shortDetails.expiryTime;         qTokensDetails.isCall = shortDetails.isCall;          if (info.qTokenAsCollateral != address(0)) {             // the given id is for a CollateralToken representing a spread             qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)                 .strikePrice();         }     } ```  ## Recommended Mitigation Steps  Initialize qTokensDetails.longStrikePrice  ## Non-Critical Findings - Usage of ecrecover for metaTransactions without checking r/s in CollateralToken.sol/metaSetApprovalForAll  ## Impact  Using ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However since address and nonce are included in message, it should be impossible to reuse or steal signatures.  ## Proof of Concept  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L218  ``` address signer = ecrecover(hash, v, r, s); ```  ## Recommended Mitigation Steps  Use ECDSA.recover instead 
# Lines of code  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206   # Vulnerability details  ## Impact  `_slice()` in `options/QTokenStringUtils.sol` cut a string into `string[start:end]` However, while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.   ## Proof of Concept  ERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.  The bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.  The exploit can be outlined through the following steps:  * Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`  * Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.sol` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90  ```     function _qTokenName(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenName) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );            ...            tokenName = string(             abi.encodePacked(                 "ROLLA",                 " ",                 underlying,                 " ",                 _uintToChars(day),                 "-",                 monthFull,                 "-",                 Strings.toString(year),                 " ",                 displayStrikePrice,                 " ",                 typeFull             )         );     } ```  ```      function _qTokenSymbol(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenSymbol) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );          // convert the expiry to a readable string         (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(             _expiryTime         );          // get option type string         (string memory typeSymbol, ) = _getOptionType(_isCall);          // get option month string         (string memory monthSymbol, ) = _getMonth(month);          /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 "ROLLA",                 "-",                 underlying,                 "-",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 "-",                 displayStrikePrice,                 "-",                 typeSymbol             )         );     } ```  * `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute. In this case, the quotient is `10000` and the remainder is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 ``` function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)         internal         view         virtual         returns (string memory)     {         uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();         uint256 strikePriceScale = 10**strikePriceDigits;         uint256 remainder = _strikePrice % strikePriceScale;         uint256 quotient = _strikePrice / strikePriceScale;         string memory quotientStr = Strings.toString(quotient);          if (remainder == 0) {             return quotientStr;         }          uint256 trailingZeroes;         while (remainder % 10 == 0) {             remainder /= 10;             trailingZeroes++;         }          // pad the number with "1 + starting zeroes"         remainder += 10**(strikePriceDigits - trailingZeroes);          string memory tmp = Strings.toString(remainder);         tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);          return string(abi.encodePacked(quotientStr, ".", tmp));     } ```  * However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + 1];             unchecked {                 ++i;             }         }          return string(slice);     } ```  * The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Fix the bug in the `_slice()`  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + i];             unchecked {                 ++i;             }         }          return string(slice);     } ```   
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28 https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27   # Vulnerability details  The QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28   I discussed with one of the devs about the use of this specific mapping :  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27  After discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.  It is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:  require(minimum delay ≤MAXIMUM_DELAY, “ too high”)  
@return in NatSpec comment missing for :  Controller.sol:  [https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L176]  [https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L242]  EIP712MetaTx.sol:  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L148   ConfigTimeLockController.sol:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L648  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L665  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L682  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L699  ChainLinkFixedTimeOracleManager.sol:  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L77    
# Missing Zero Chcks  ## impact Zero-address checks for input validation of address-type variables is a best-practice. While this is implemented in some places, there are missing ones.  ## POC  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/ QuantCalculator.sol#L55-L57  strikeAssetDecimals and optionsFactory variables do not perform zero checks which could result in lose of funds or malfunctions.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add zero-address checks   # Arbitrary send  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414  ## impact Unprotected call to a function sending Ether to an arbitrary address.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Ensure that an arbitrary user cannot withdraw unauthorized funds.
# addAssetOracle lack oracle validation Recommended to add a check to make sure the oracle return 8 decimals https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25  # Extra lines https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L26  # Lack event on critical parameters change - Timelock delay change https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L34  # isSettled must already be true isSettled must already be true https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/QuantCalculator.sol#L249  # Should revert if newDelay < minDelay Should revert if newDelay < minDelay instead of silently set to minDelay https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L39  # Variables can be mark immutable https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/options/QToken.sol#L21 ```     /// @inheritdoc IQToken     IQuantConfig public override quantConfig;      /// @inheritdoc IQToken     address public override underlyingAsset;      /// @inheritdoc IQToken     address public override strikeAsset;      /// @inheritdoc IQToken     address public override oracle;      /// @inheritdoc IQToken     uint256 public override strikePrice;      /// @inheritdoc IQToken     uint256 public override expiryTime;      /// @inheritdoc IQToken     bool public override isCall; ```
# Confusing error message at ``deactivateOracle`` function in ``OracleRegistry.sol``   ## Target codebase https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L67  ``` require(     config.hasRole(         config.quantRoles("ORACLE_MANAGER_ROLE"),         msg.sender     ),     "OracleRegistry: Only an oracle admin can add an oracle" ); ```  Statement "Only an oracle admin can add an oracle" seems not to be right.   ## Potential fix It should say "Only an oracle admin can deactivate an oracle" or others.  ---  # Confusing error message at ``activateOracle`` function in ``OracleRegistry.sol``   ## Target codebase https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L81-L87  ``` require(     config.hasRole(         config.quantRoles("ORACLE_MANAGER_ROLE"),         msg.sender     ),     "OracleRegistry: Only an oracle admin can add an oracle" ); ```  Statement "Only an oracle admin can add an oracle" seems not to be right.   ## Potential fix It should say "Only an oracle admin can activate an oracle" or others.  ---    
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L128 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L30 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L107 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L250   # Vulnerability details  ## Impact The `ChainlinkOracleManager` contract expects every oracle to provide the price data with 8 decimals. But, that's not always the case. Depending on the asset, the decimals could also be 16. In that case, the protocol would continue the computation with the wrong price which brings up a whole lot of problems.  List of assets and their decimals: https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet  ## Proof of Concept The received price is standardized to a `FixedPointInt` using the decimals value: https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L128  The contract uses a constant value `8` for that.  ## Tools Used none  ## Recommended Mitigation Steps Use `aggregator.decimals()` to get the correct number of decimals for the current asset. Use that for the computation  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84   # Vulnerability details  ## Impact The Chainlink functions `latestAnswer()` and `getAnswer()` are deprecated. Instead, use the [`latestRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) and [`getRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#getrounddata) functions.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84  Go to https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code and search for `latestAnswer()` or `getAnswer()`. You'll find the deprecation notice.  ## Tools Used none  ## Recommended Mitigation Steps Switch to `latestRoundData()` as described [here](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata)  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117   # Vulnerability details  ## Impact ```     function mintCollateralToken(         address recipient,         uint256 collateralTokenId,         uint256 amount     ) external override {         require(             quantConfig.hasRole(                 quantConfig.quantRoles("COLLATERAL_MINTER_ROLE"),                 msg.sender             ),             "CollateralToken: Only a collateral minter can mint CollateralTokens"         );          emit CollateralTokenMinted(recipient, collateralTokenId, amount);          _mint(recipient, collateralTokenId, amount, "");     } ```  Using the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.  If the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.  We believe this is unnecessary and poses a serious centralization risk.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L138-L160 ## Tools Used None  ## Recommended Mitigation Steps Consider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.  
1. `collateralTokenId` is used as `deadline` and it could be confused, it's better to rename it or add a specific comment about that. - [Actions.sol#L110](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L110) - [Actions.sol#L135](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L135)  2. It's possible to call he method [addAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L60) multiple times with the same `_underlying`, if you call `addAsset` with empty `symbol` it will bypass the [validAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L37) modifier, and it will be possible to call again the `addAsset` with different values. It will produce a mismatch with the reality and `getAssetsLength` This could cause a loss of funds if it is not verified before that this `symbol` is other than empty. It is mandatory to add a require to verify that the `symbol` is not empty. It's also recommended to add a require in [_assetSymbol](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L24) to ensure non-existence tokens are returned.  3. It's possible to call he method [createCollateralToken](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L61) multiple times with the same `_qTokenAddress`, if you call `createCollateralToken` with empty `_qTokenAddress` it will bypass the [require(idToInfo[id].qTokenAddress == address(0))](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L81), and it will be possible to call again the `createCollateralToken` with different values. It will produce a mismatch with the reality and `collateralTokenIds` It is mandatory to add a require to verify that the `_qTokenAddress` is not empty.  4. It's possible to approve with [metaSetApprovalForAll](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218-L219) an empty address for any operator, `ecrecover` is not checked to return `address(0)`, so using `owner=address(0)` it is possible to approve or reject empty owners for any operator. It's recommended to use ECDSA from open-zeppelin.  5. When calling [_getMonth](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L255) with a value greater than 12 "December" is returned, it's best to make sure the value is as expected.  6. Use `uint8` for `decimals` in [QTokenStringUtils.sol#L142](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L142)  7. Use a buggy solidity version with immutables. The contract use immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).  8. The [minDelay](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/TimelockController.sol#L112) must always be greater than 0, otherwise it could be proposed and executed in the same block, this could cause reputation problems for the project. Since that would make a TimeLock into a EOA owned.  9. There following methods and constructors doesn't check the inputs arguments - [QuantCalculator.sol#L56-L57](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantCalculator.sol#L56-L57) - [OracleRegistry.sol#L27](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/OracleRegistry.sol#L27) - [PriceRegistry.sol#L25-L26](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/PriceRegistry.sol#L25-L26) - [ProviderOracleManager.sol#L21](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L21) - [ChainlinkFixedTimeOracleManager.sol#L21-L22](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L21-L22)  10. It's possible to call he method [addAssetOracle](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25) multiple times with the same `_asset`, if you call `addAssetOracle` with empty `_oracle` it will bypass the [assetOracles[_asset] == address(0)](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L34), and it will be possible to call again the `addAssetOracle` with different values. It will produce a mismatch with the reality and `assets` It is mandatory to add a require to verify that the `_oracle` is not empty. 
# Lines of code  ChainlinkOracleManager   # Vulnerability details   use openzeppilin's safeCast in:           ChainlinkOracleManager._binarySearchStep : unsafe cast uint64(_firstRoundProxy)         ChainlinkOracleManager._setExpiryPriceInRegistryByRound : unsafe cast uint64(_roundIdAfterExpiry)         ChainlinkOracleManager._binarySearchStep : unsafe cast uint64(_lastRoundProxy)  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117   # Vulnerability details  ## Impact  When deactivateOracle() is called for an oracle in OracleRegistry it is still available for option spreads minting.  This way a user can continue to mint new options within spreads that rely on an oracle that was deactivated. As economic output of spreads is close to vanilla options, so all users who already posses an option linked to a deactivated oracle can surpass this deactivation, being able to mint new options linked to it as a part of option spreads.  ## Proof of Concept  Oracle active state is checked with isOracleActive() during option creation in validateOptionParameters() and during option minting in _mintOptionsPosition().  It isn't checked during spreads creation:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117  In other words besides vanilla option minting and creation all spectrum of operations is available for the deactivated oracle assets, including spreads minting, which economically is reasonably close to vanilla minting.  ## Recommended Mitigation Steps  If oracle deactivation is meant to transfer all related assets to the close only state then consider requiring oracle to be active on spreads minting as well in the same way it's done for vanilla option minting:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L188-L197   
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516   # Vulnerability details  ## Impact  A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.  The Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.  ## Proof of Concept  When the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal _qTokenPermit:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L91-L92  _qTokenPermit calls the IQToken(_qToken) address provided without performing any additional checks:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516  This way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.  ## Recommended Mitigation Steps  Given that QToken can be called directly please examine the need for QTokenPermit ActionType.  If current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided.  
## Title 1 Missing input validation on array lengths  ### Impact The functions below fail to perform input validation on arrays to verify the lengths match. A mismatch could lead to an exception or undefined behavior.  ## #Proof of Concept https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L138-L160  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L163-L184  ### Tools Used Manual review on VScode  ### Recommended Mitigation Steps Add input validation to check that the length of both arrays match.  ---------------------------------------------------------------------------------------------------------------------  -------------------------------------------------------------------------------------------------------------------- ## Title 2 Use of ecrecover is susceptible to signature malleability  ### Impact The ecrecover function is used in metaSetApprovalForAll() to recover the address from the signature. The built-in EVM precompile ecrecover is susceptible to signature malleability which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   ## #Proof of Concept https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L218-L219  ### Tools Used Manual review on VScode  ### Recommended Mitigation Steps Consider using the openzeppelin ECDSA library for signature verifications.
## Issue 1 (Low) - Exclusive time checks should be inclusive  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L325-L328  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L563-L566   ### Impact At least one of the following checks is slightly inaccurate due to exclusive timestamp checks.  ``` require(             block.timestamp > qToken.expiryTime(),             "Controller: Can not exercise options before their expiry"         ); ```  ``` require(             IQToken(_qToken).expiryTime() > block.timestamp,             "Controller: Cannot mint expired options"         ); ```  The second statement ceases minting the moment the expiryTime is hit which makes sense. The first statement doesn't allow the options to be exercised until after the expiry time, causing a gap in functionality.   ### Recommended Steps The first statement should be:  ``` require(             block.timestamp >= qToken.expiryTime(),             "Controller: Can not exercise options before their expiry"         ); ```  ## Issue 2 (Low) - Missing Address(0) Checks in Constructor Address Params  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L325-L328  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L563-L566  ### Impact These two contracts do not check for address(0) in their constructors and will require redeployment if necessary.  ### Recommended Steps Add require statements != address(0) in both constructors.  ## Issue 3 (Low) - Front-Runnable Initializers  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L134-L159  ### Impact Lack of access control on initialize(), can be front-run.  ### Recommended Steps Add access control for OnlyOwner.  ## Issue 4 (Low) - Function input doesn't match purpose  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/QuantCalculator.sol#L61-L163  ### Impact The address parameter in the following function is named `_msgSender` but it can arbitrarily be any account since it has external visibility.  ``` function calculateClaimableCollateral(         uint256 _collateralTokenId,         uint256 _amount,         address _msgSender     )         external         view         override         returns (             uint256 returnableCollateral,             address collateralAsset,             uint256 amountToClaim         )     { ```  ### Recommended Steps Rename to "user" or similar.   
# QA Report  ## Non-Critical Findings  ### Contract implementations should inherit their interface  #### Description  It's best practice for a contract to inherit from it's interface. This improves the contract's clarity and makes sure the contract implementation complies with the defined interface.  #### Findings  [QuantConfig.sol](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L13):  ```solidity contract QuantConfig is     AccessControlUpgradeable,     OwnableUpgradeable,     IQuantConfig, // @audit-info add interface IQuantConfig     ITimelockedConfig {   ... } ```  #### Recommended mitigation steps  Inherit from the missing interface or contract.  ---  ### Public functions that could be declared external  #### Description  Following functions should be declared `external`, as functions that are never called by the contract internally should be declared external (to save gas) as well as for code clarity reasons.  #### Findings  [ChainlinkFixedTimeOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L56)   [ProviderOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L68)   [ChainlinkOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L136)   [PriceRegistry.hasSettlementPrice()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L116)    #### Recommended mitigation steps  Use the `external` attribute for functions never called from the contract.  ---  ### Spelling mistakes  #### Description  Spelling mistakes found.  #### Findings  **[timelock/ConfigTimelockController.sol](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol)**  [L623](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L623): `_isProtocoValueSetter` -> `_isProtocolValueSetter`  #### Recommended mitigation steps  Fix spelling mistakes.  ---  ### Redundant storage access - use variable `assetOracle`  #### Description  _I know there are no rewards for gas optimizations, nevertheless I want to address this finding to prevent any future issues and confusions._  The current implementation of [ProviderOracleManager.getAssetOracle()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L78) has a `require` statement which repeatedly accesses `assetOracles[_asset]` from storage:  ```solidity function getAssetOracle(address _asset)     public     view     override     returns (address) {     address assetOracle = assetOracles[_asset];     require(         assetOracles[_asset] != address(0), // @audit repeated storage variable access         "ProviderOracleManager: Oracle doesn't exist for that asset"     );     return assetOracle; } ```  #### Findings  [ProviderOracleManager.getAssetOracle()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L78)  #### Recommended mitigation steps  Change code to:  ```solidity function getAssetOracle(address _asset)     public     view     override     returns (address) {     address assetOracle = assetOracles[_asset];     require(         assetOracle != address(0), // @audit use `assetOracle` instead         "ProviderOracleManager: Oracle doesn't exist for that asset"     );     return assetOracle; } ```  ## Low Risk  ### Missing documentation of function parameters  #### Description  Function parameters should be fully documented to provide clear instructions what parameters are used for.  #### Findings  [QTokenStringUtils.\_qTokenName()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/QTokenStringUtils.sol#L41): missing `@param` for `_strikeAsset`   [OptionsUtils.getTargetQTokenAddress()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/OptionsUtils.sol#L32): missing `@param` for `_quantConfig`   [OptionsUtils.getTargetCollateralTokenId()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L67): missing `@param` for `_quantConfig`    #### Recommended mitigation steps  Add `@param` documentation for all parameters.  ---  ### `ChainlinkOracleManager.isValidOption()` always returns `true` for any asset  #### Description  The current implementation of `ChainlinkOracleManager.isValidOption()` always returns true, not matter which `_asset` is passed:  ```solidity function isValidOption(     address,     uint256,     uint256 )     public     view     virtual     override(ProviderOracleManager, IProviderOracleManager)     returns (bool) {     return true; // @audit-info always returns `true` } ```  There are no risks caused by to this implementation as there are checks in place to make sure there's a valid oracle price for the underlying qToken asset (e.g in [PriceRegistry.getSettlementPriceWithDecimals()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L72)).  Nevertheless this function should check if the passed `_asset` is valid.  #### Findings  [ChainlinkOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L133)  #### Recommended mitigation steps  Change implementation to:  ```solidity function isValidOption(     address _asset,     uint256,     uint256 )     public     view     virtual     override(ProviderOracleManager, IProviderOracleManager)     returns (bool) {     getAssetOracle(_asset); // @audit-info add this function call which has a `require` statement to assert `_asset` is supported by oracle      return true; } ```  and fix failing unit test in [ChainlinkOracleManager.test.ts#L385](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/test/ChainlinkOracleManager.test.ts#L385)  ---  ### Shadowed variables  #### Description  Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  The variable `_timestamps` does not pose any immediate risk to the contract as it's not used in the contract, incorrect usage of the variable is possible and can cause serious issues if the developer does not pay close attention.  The variable `minDelay` could cause issues as it's used in the contract. As the shadowed `minDelay` variable in the inherited contract `TimelockController.sol` can be changed (with `updateDelay()`), the variable with the same name in contract `ConfigTimelockController` does not change and is out of sync.  #### Findings  [timelock/ConfigTimelockController.sol.\_timestamps](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)   [timelock/ConfigTimelockController.sol.minDelay](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L18)  #### Recommended mitigation steps  **[timelock/ConfigTimelockController.sol.\_timestamps](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)**:  Remove variable declaration `_timestamps`:  ```solidity mapping(bytes32 => uint256) private _timestamps; ```  **[timelock/ConfigTimelockController.sol.minDelay](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L18)**:  Remove variable declaration `minDelay`:  ```solidity uint256 public minDelay; ```  Replace all occurrences of `minDelay` with `getMinDelay()`. 
# Low 1 Deprecated `_setupRole` function used  ## Impact  The _setupRole function is deprecated according to the Open Zeppelin comment `NOTE: This function is deprecated in favor of {_grantRole}`  Use the recommended _grantRole function instead.  ## Proof of concept  Where _setupRole is used in rolla https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L160-L161 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L79-L90  Open Zeppelin comment https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L195  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Avoid using deprecated functions. Replace _setupRole with _grantRole  # Low 2 _timestamps variable shadowing  ## Impact  ConfigTimelockController.sol inherits TimelockController.sol but declares a new _timestamps mapping equivalent to the mapping in TimelockController.sol. This shadowing of the mapping will cause problems in calls to parent functions that use the _timestamps mapping, because the _timestamps mapping in ConfigTimelockController.sol is not used.  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Proof of concept  _timestamps is declared in TimelockController.sol https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L29  An identical _timestamps mapping is declared in ConfigTimelockController.sol, which inherits TimelockController.sol and does not need to declare an identical mapping with the same name https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Tools Used  Slither https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing  ## Recommended Mitigation Steps  Remove the line of code declaring the _timestamps mapping in ConfigTimelockController.sol so that the _timestamps mapping from TimelockController.sol is used throughout.  # Low 3 Roles not added to quantRoles  ## Impact  The quantRoles mapping is intended to store all roles used by QuantConfig.sol. Other contracts import the IQuantConfig.sol interface and call config.quantRoles. Most of the contracts calling config.quantRoles do so for a role that is never added to the quantRoles mapping in QuantConfig.sol. Because solidity variables has a default value, querying an entity of a `string => bytes32` mapping that does not exist with return an empty bytes32 value of bytes32(0). This interferes with the intended logic of the contracts and in some cases will result in if statements that always return one condition because the quantRoles mapping is never updated outside of the _setProtocolRole function.  ## Proof of concept  Observe that the quantRoles mapping has a new role added in the _setProtocolRole function of QuantConfig.sol, and this is the only function in QuantConfig.sol that modifies this mapping https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L177  Because the _setProtocolRole is an internal function, another contract would need to inherit QuantConfig.sol in order to modify the quantRoles mapping. But no other contract in the Rolla project does this. There are several roles, such as FALLBACK_PRICE_ROLE, which are queried in the quantRoles mapping but will never return a value other than bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L81  Another example is the COLLATERAL_MINTER_ROLE role, which is queried twice but never set and will always return bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L108 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L145  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The simplest approach is a manual one that may result in error. The owner of QuantConfig.sol can call setProtocolRole to set these roles after QuantConfig is deployed. This may even be the intended approach with this code, but there is no test or other code that demonstrates setting the FALLBACK_PRICE_ROLE in the quantRoles mapping.  A more robust solution is to call _setProtocolRole with all the hardcoded roles in the initialize function of QuantConfig.sol, like what is done for oracleManagerRole in this line https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L164  # Low 4 Missing reentrancy guard on ERC1155 _mint  ## Impact  The ERC1155 _mint function is vulnerable to reentrancy. A nonreentrant modifier or lock modifier should be applied to functions that have reentrancy weaknesses for protection from this attack vector. Even though no direct reentrancy attack may exist on these Rolla functions today, that could change in the future and proper defensive measures are crucial.  ## Proof of concept  The ERC1155 _mint function is used in mintCollateralToken https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L116  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the nonReentrant modifier from the Open Zeppelin library https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol
### L-01: Missing Zero check QuantCalculator.constructor(contracts/QuantCalculator.sol#55) lacks a zero-check on : optionsFactory = _optionsFactory (contracts/QuantCalculator.sol#57)  ### L-02:  Ether lock Payable function with no method of withdrawal available, eventually ends up locking ether  ``` executeMetaTransaction() (contracts/utils/EIP712MetaTransaction.sol#55-93) ```
# C4-001 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  PrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.  ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L200  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L394  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L472 ```  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.  # C4-002 : Front-runnable Initializers  ## Impact - LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L148  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L134 ```  2. initialize functions does not have access control. They are vulnerable to front-running.   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.  # C4-003 : Use of ecrecover is susceptible to signature malleability  ## Impact - LOW  The ecrecover function is used in permit() to recover the address from the signature. The built-in EVM precompile ecrecover is susceptible to signature malleability which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).  ## Proof of Concept  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using OpenZeppelin’s ECDSA library (which prevents this malleability) instead of the built-in function.  # C4-004 : transferOwnership should be two step process  ## Impact  "QuantConfig.sol" inherit OpenZeppelin's OwnableUpgradeable contract which enables the onlyOwner role to transfer ownership to another address. It's possible that the onlyOwner role mistakenly transfers ownership to the wrong address, resulting in a loss of the onlyOwner role. The current ownership transfer process involves the current owner calling Unlock.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier. Lack of two-step procedure for critical operations leaves them error-prone if the address is incorrect, the new address will take on the functionality of the new role immediately  for Ex : -Alice deploys a new version of the whitehack group address. When she invokes the whitehack group address setter to replace the address, she accidentally enters the wrong address. The new address now has access to the role immediately and is too late to revert   ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L15" 2. The contracts have many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. 
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415   # Vulnerability details  ## Impact In the `_call()` function in `TimelockController.sol`, a call is executed with the following code:  ``` function _call(         bytes32 id,         uint256 index,         address target,         uint256 value,         bytes memory data     ) private {         // solhint-disable-next-line avoid-low-level-calls         (bool success, ) = target.call{value: value}(data);         require(success, "TimelockController: underlying transaction reverted");          emit CallExecuted(id, index, target, value, data);     } ```  Per the Solidity docs:  "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed."   Therefore, transfers may fail silently.  ## Proof of Concept Please find the documentation here: https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used Manual review.  ## Recommended Mitigation Steps Check for the account's existence prior to transferring.  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L22-L34   # Vulnerability details  Use of Upgradeable Proxy Contract Structure allows the logic of the contract to be arbitrarily changed.  This allows the proxy admin to perform malicious actions e.g., taking funds from users' wallets up to the allowance limit.  This action can be performed by the malicious/compromised proxy admin without any restriction.   Considering that the purpose of this particular contract is for accounting of the Collateral and LongShortTokens, we believe the users' allowances should not be hold by this upgradeable contract.  ### PoC  Given:  - collateral: `USDC`  #### Rug Users' Allowances  1. Alice `approve()` and `_mintOptionsPosition()` with `1e8 USDC`; 2. Bob  `approve()` and `_mintOptionsPosition()` with `5e8 USDC`; 3. A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets;  #### Rug Contract's Holdings (funds that belongs to users)  A malicious/compromised proxy admin can just call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.  ### Severity  A smart contract being structured as an upgradeable contract alone is not usually considered as a high severity risk. But given the severe impact (all the funds in the contract and funds in users' wallets can be stolen), we mark it as a `High` severity issue.  ### Recommendation  Consider using the non-upgradeable `CollateralToken` contract to hold user's allowances instead.  See also the Recommendation of [WP-H7].  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19   # Vulnerability details  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L550-L558  ```solidity     /// @notice Allows a sender/signer to make external calls to any other contract.     /// @dev A separate OperateProxy contract is used to make the external calls so     /// that the Controller, which holds funds and has special privileges in the Quant     /// Protocol, is never the `msg.sender` in any of those external calls.     /// @param _callee The address of the contract to be called.     /// @param _data The calldata to be sent to the contract.     function _call(address _callee, bytes memory _data) internal {         IOperateProxy(operateProxy).callFunction(_callee, _data);     } ```  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19  ```solidity     function callFunction(address callee, bytes memory data) external override {         require(             callee != address(0),             "OperateProxy: cannot make function calls to the zero address"         );          (bool success, bytes memory returnData) = address(callee).call(data);         require(success, "OperateProxy: low-level call failed");         emit FunctionCallExecuted(tx.origin, returnData);     } ```  As the `OperateProxy.sol#callFunction()` function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.  For example, if a certain business logic requires a successful `token.transferFrom()` call to be made with the `OperateProxy`, if the `token` is not a existing contract, the call will return `success: true` instead of `success: false` and break the caller's assumption and potentially malfunction features or even cause fund loss to users.  The qBridge exploit (January 2022) was caused by a similar issue.  As a reference, OpenZeppelin's `Address.functionCall()` will check and `require(isContract(target), "Address: call to non-contract");`  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L135  ```solidity     function functionCallWithValue(         address target,         bytes memory data,         uint256 value,         string memory errorMessage     ) internal returns (bytes memory) {         require(address(this).balance >= value, "Address: insufficient balance for call");         require(isContract(target), "Address: call to non-contract");          (bool success, bytes memory returndata) = target.call{value: value}(data);         return verifyCallResult(success, returndata, errorMessage);     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L36-L42  ```solidity     function isContract(address account) internal view returns (bool) {         // This method relies on extcodesize/address.code.length, which returns 0         // for contracts in construction, since the code is only stored at the end         // of the constructor execution.          return account.code.length > 0;     } ```  ### Recommendation  Consider adding a check and throw when the `callee` is not a contract.  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86   # Vulnerability details  Any transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).  In the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.  As a result, the same tx can be replayed by anyone, using the same signature.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86  ```solidity     function executeMetaTransaction(         MetaAction memory metaAction,         bytes32 r,         bytes32 s,         uint8 v     ) external payable returns (bytes memory) {         require(             _verify(metaAction.from, metaAction, r, s, v),             "signer and signature don't match"         );          uint256 currentNonce = _nonces[metaAction.from];          // intentionally allow this to overflow to save gas,         // and it's impossible for someone to do 2 ^ 256 - 1 meta txs         unchecked {             _nonces[metaAction.from] = currentNonce + 1;         }          // Append the metaAction.from at the end so that it can be extracted later         // from the calling context (see _msgSender() below)         (bool success, bytes memory returnData) = address(this).call(             abi.encodePacked(                 abi.encodeWithSelector(                     IController(address(this)).operate.selector,                     metaAction.actions                 ),                 metaAction.from             )         );          require(success, "unsuccessful function call");         emit MetaTransactionExecuted(             metaAction.from,             payable(msg.sender),             currentNonce         );         return returnData;     } ```  See also the implementation of OpenZeppelin's `MinimalForwarder`:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66  ### PoC  Given:  - The collateral is USDC; - Alice got `10,000 USDC` in the wallet.  1. Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`; 2. Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob; 3. The MetaTransaction submited by Alice in step 1 get executed but failed; 4. A few days later, Bob sent `1,000 USDC` to Alice; 5. The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.  Alice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.  ### Recommendation  Failed txs should still increase the nonce.  While implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent "insufficient gas griefing attack" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114   # Vulnerability details  1. `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```  Otherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53  ```solidity     /**      * @dev Modifier to protect an initializer function from being invoked twice.      */     modifier initializer() {         // If the contract is initializing we ignore whether _initialized is set in order to support multiple         // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the         // contract may have been reentered.         require(_initializing ? _isConstructor() : !_initialized, "Initializable: contract is already initialized");          bool isTopLevelCall = !_initializing;         if (isTopLevelCall) {             _initializing = true;             _initialized = true;         }          _;          if (isTopLevelCall) {             _initializing = false;         }     } ```  See also: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1   2. `initializer` can only be called once, it can not be "called once after every upgrade".  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```   3. A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.  See the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28  ```solidity abstract contract EIP712Upgradeable is Initializable {     // ... } ```  ### Recommendation  Change to:  ```solidity abstract contract EIP712MetaTransaction is EIP712Upgradeable {     // ... } ```  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function __EIP712MetaTransaction_init(string memory _name, string memory _version)         internal         onlyInitializing     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```    
## [L] `ConfigTimelockController` One address should not be able to be a `proposer` and a `executor` at the same time  The purpose of the design which have two separate roles of `proposers` and `executors` is to prevent the centralization risk which one can propose a change and get it executed right away by themselves.  However, the current implementation allows the same address to be in `proposers` and `executors` at the same time, this makes such a design becomes a unenforced law.  In operation practise, the admin can and, we believe they have a natural tendency to add both roles to the same address as this is easier in operation.  ### Recommendation  Consider adding a check to make sure `proposers` and `executors` do not include any same address  ## [L] Tokens with fee on transfer are not supported  There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.  In the current implementation, `Controller.sol#_mintOptionsPosition()`, `Controller.sol#_mintSpread()` and `Controller.sol#_claimCollateral()` assumes that the received amount is the same as the transfer amount, and uses it for collateralToken minting and redeeming.  ### Recommendation  Making sure no FOT tokens will be whitelisted in the protocol.
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L176-L180   # Vulnerability details  ## Impact  A switch to an assetsRegistry that doesn't contain a particular underlying by mistake or as a part of griefing attack will freeze all the payoff funds accounted for already issued QTokens with this underlying. I.e. all buyers and sellers of the associated QTokens will have the payoff funds frozen until assetsRegistry be updated as Controller's _claimCollateral, _neutralizePosition and _exercise will be failing in this case.  For example, suppose LINK is added as an underlying to assetsRegistry, some time passed and options were minted, then the registry is updated and LINK is no longer listed there. All the users with not yet fulfilled claims on the issued LINK options will have their funds frozen until assetsRegistry be updated again to include LINK back.  In other words, at the moment there is no way to separate new options issuance and existing options settlement, which makes a removal of an underlying a tricky task, given that maturity of the options isn't restricted.  ## Proof of Concept  In QuantConfig the priceRegistry setting is immutable, while oracleRegistry and assetsRegistry can be reset by an owner:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L47-L64  oracleRegistry reset affect new option creation and minting only.  On the other hand, apart from QToken creation, assetsRegistry is used in the most of payoff calculations.  This way assetsRegistry reset to a contract that doesn't have a record of a particular underlying will freeze all the payoff calculation functionality as OptionsUtils.getPayoutDecimals, which will become unavailable, is called by QuantCalculator's getCollateralRequirement, getExercisePayout, calculateClaimableCollateral and getNeutralizationPayout.   Here is getPayoutDecimals called by getNeutralizationPayout:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L176-L180  Also, by calculateClaimableCollateral, getCollateralRequirement, getExercisePayout:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L133-L137  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L210-L214  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L261-L265  This way, a switch to an assetsRegistry that doesn't constant the underlying will make most of the QuantCalculator's payoff calculations fail, freezing all the payoff funds accounted for all the QTokens with this underlying.   ## Recommended Mitigation Steps  As getPayoutDecimals is the basic function to request the decimals, which a single constant value, consider moving it to the QToken storage instead of requesting from an outside contracts each time.  Apart from removing this attack surface, this will also provide some gas optimisation, which is viable as mentioned operations are common enough, justifying a minor increase in storage space.   
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130   # Vulnerability details  The `README.md` states: > Bob can then trade the QToken with Alice for a premium. The method for doing that is beyond the scope of the protocol but can be done via any smart contract trading platform e.g. 0x.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/README.md?plain=1#L70  It is therefore important that tokens be easily identifiable so that trading on DEXes is not error-prone.  ## Impact Currently the `QToken` `name` includes the full year but the `QToken` symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a QToken with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. Normal centralized exchanges prevent this by listing options themselves and ensuring that there are never two options with the same identifier at the same time. The Rolla protocol does not have any such protections. Users must be told to not only check that the symbol name is what they expect, but to also separately check the token name or the specific expiry, or they might buy the wrong option on a DEX, or have fat-fingered during minting on a non-Rolla web interface. It's important to minimize the possibility of mistakes, and not including the full year in the symbol makes things error-prone, and will lead to other options providers winning out.  The 0x [REST interface](https://docs.0x.org/0x-api-swap/api-references/get-swap-v1-quote) for swaps has the ability to do a swap by token name rather than by token address. I was unable to figure out whether there was an allow-list of token names, or if it is easy to add a new token. If there is no, or an easily bypassed, access-control for adding new tokens, I would say this finding should be upgraded to high-severity, though I doubt this is the case.  ## Proof of Concept ```solidity         /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 "ROLLA",                 "-",                 underlying,                 "-",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 "-",                 displayStrikePrice,                 "-",                 typeSymbol             )         ); ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130  ```solidity     /// @return 2 characters that correspond to a number     function _uintToChars(uint256 _number)         internal         pure         virtual         returns (string memory)     {         if (_number > 99) {             _number %= 100;         }          string memory str = Strings.toString(_number);          if (_number < 10) {             return string(abi.encodePacked("0", str));         }          return str;     } ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L181-L199  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include the full year in the token's symbol   
## Low-impact Issues  ### The current code will not be able to support compound options (options on options) The code that adds new assets checks whether the asset already exists or not by checking the token's symbol. Since  `QToken`s' symbols do not contain the full year, once a token with a specific year is added, a similar token 100 years into the future (or into the past) cannot be added 1. File: contracts/libraries/OptionsUtils.sol (lines [152-165](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/OptionsUtils.sol#L152-L165)) ```solidity     function isInAssetsRegistry(address _asset, address _quantConfig)         internal         view         returns (bool)     {         string memory symbol;         (, symbol, ) = IAssetsRegistry(             IQuantConfig(_quantConfig).protocolAddresses(                 ProtocolValue.encode("assetsRegistry")             )         ).assetProperties(_asset);          return bytes(symbol).length != 0;     } ```  ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: contracts/QuantCalculator.sol (line [57](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L57)) ```solidity         optionsFactory = _optionsFactory; ```   ### Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  1. File: contracts/Controller.sol (lines [30-33](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L30-L33)) ```solidity contract Controller is     IController,     EIP712MetaTransaction,     ReentrancyGuardUpgradeable ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L13)) ```solidity contract EIP712MetaTransaction is EIP712Upgradeable { ``` 3. File: contracts/QuantConfig.sol (lines [13-16](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantConfig.sol#L13-L16)) ```solidity contract QuantConfig is     AccessControlUpgradeable,     OwnableUpgradeable,     ITimelockedConfig ```  ## Non-critical Issues  ### Use a switch statement for long if-else-if chains involving a single variable https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L59-L123   ### _encodeSetProtocolRole() should take in a `ProtocolValue` like the other functions It's inconsistent for roles to be passed in as strings when they can easily be `ProtocolValue`s  1. File: contracts/timelock/ConfigTimelockController.sol ((lines [434-447](https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L434-L447)) ```solidity     function executeSetProtocolRole(         string calldata protocolRole,         address roleAdmin,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) {         execute(             quantConfig,             0,             _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),             bytes32(0),             bytes32(eta)         );     } ```  ### `public` functions not called by the contract should be declared `external` instead Inconsistencies make code hard to maintain Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  1. File: contracts/Controller.sol (lines [134-139](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L134-L139)) ```solidity     function initialize(         string memory _name,         string memory _version,         address _optionsFactory,         address _quantCalculator     ) public override initializer { ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (lines [106-108](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L106-L108)) ```solidity     function initializeEIP712(string memory _name, string memory _version)         public         initializer ``` 3. File: contracts/timelock/ConfigTimelockController.sol (lines [250-255](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L250-L255)) ```solidity     function scheduleBatchSetProtocolAddress(         bytes32[] calldata protocolValues,         address[] calldata newAddresses,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 4. File: contracts/timelock/ConfigTimelockController.sol (lines [281-286](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L281-L286)) ```solidity     function scheduleBatchSetProtocolUints(         bytes32[] calldata protocolValues,         uint256[] calldata newUints,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 5. File: contracts/timelock/ConfigTimelockController.sol (lines [312-317](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L312-L317)) ```solidity     function scheduleBatchSetProtocolBooleans(         bytes32[] calldata protocolValues,         bool[] calldata newBooleans,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 6. File: contracts/timelock/ConfigTimelockController.sol (lines [343-348](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L343-L348)) ```solidity     function scheduleBatchSetProtocolRoles(         string[] calldata protocolRoles,         address[] calldata roleAdmins,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 7. File: contracts/timelock/ConfigTimelockController.sol (lines [374-379](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L374-L379)) ```solidity     function executeSetProtocolAddress(         bytes32 protocolAddress,         address newAddress,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 8. File: contracts/timelock/ConfigTimelockController.sol (lines [394-399](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L394-L399)) ```solidity     function executeSetProtocolUint256(         bytes32 protocolUint256,         uint256 newUint256,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 9. File: contracts/timelock/ConfigTimelockController.sol (lines [414-419](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L414-L419)) ```solidity     function executeSetProtocolBoolean(         bytes32 protocolBoolean,         bool newBoolean,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 10. File: contracts/timelock/ConfigTimelockController.sol (lines [434-439](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L434-L439)) ```solidity     function executeSetProtocolRole(         string calldata protocolRole,         address roleAdmin,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 11. File: contracts/timelock/ConfigTimelockController.sol (lines [454-459](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L454-L459)) ```solidity     function executeBatchSetProtocolAddress(         bytes32[] calldata protocolValues,         address[] calldata newAddresses,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 12. File: contracts/timelock/ConfigTimelockController.sol (lines [490-495](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L490-L495)) ```solidity     function executeBatchSetProtocolUint256(         bytes32[] calldata protocolValues,         uint256[] calldata newUints,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 13. File: contracts/timelock/ConfigTimelockController.sol (lines [526-531](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L526-L531)) ```solidity     function executeBatchSetProtocolBoolean(         bytes32[] calldata protocolValues,         bool[] calldata newBooleans,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 14. File: contracts/timelock/ConfigTimelockController.sol (lines [562-567](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L562-L567)) ```solidity     function executeBatchSetProtocolRoles(         string[] calldata protocolRoles,         address[] calldata roleAdmins,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 15. File: contracts/QuantConfig.sol (lines [148-151](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantConfig.sol#L148-L151)) ```solidity     function initialize(address payable _timelockController)         public         override         initializer ``` 16. File: contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol (lines [53-61](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L53-L61)) ```solidity     function isValidOption(         address,         uint256 _expiryTime,         uint256     )         public         view         override(ChainlinkOracleManager, IProviderOracleManager)         returns (bool) ``` 17. File: contracts/pricing/PriceRegistry.sol (lines [112-116](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L112-L116)) ```solidity     function hasSettlementPrice(         address _oracle,         address _asset,         uint256 _expiryTimestamp     ) public view override returns (bool) { ```  ### Adding a `return` statement when the function defines a named return variable, is redundant  1. File: contracts/utils/EIP712MetaTransaction.sol (line [133](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L133)) ```solidity         return sender; ```    ### Using `calldata` instead of `memory` for read-only arguments in `external` does not follow const-correctness This is an example of [const-correctness](https://stackoverflow.com/questions/8277801/what-is-the-definition-of-const-correctness) 1. File: contracts/Controller.sol (line [49](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L49)) ```solidity     function operate(ActionArgs[] memory _actions) ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (line [56](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L56)) ```solidity         MetaAction memory metaAction, ``` 3. File: contracts/utils/OperateProxy.sol (line [10](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/OperateProxy.sol#L10)) ```solidity     function callFunction(address callee, bytes memory data) external override { ``` 4. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [7](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L7)) ```solidity         bytes memory, ``` 5. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L13)) ```solidity     function initializeEIP712(string memory, string memory) external; ``` 6. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L13)) ```solidity     function initializeEIP712(string memory, string memory) external; ``` 7. File: contracts/interfaces/IController.sol (line [90](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L90)) ```solidity     function operate(ActionArgs[] memory _actions) external returns (bool); ``` 8. File: contracts/interfaces/IController.sol (line [94](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L94)) ```solidity         string memory, ``` 9. File: contracts/interfaces/IController.sol (line [95](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L95)) ```solidity         string memory, ``` 10. File: contracts/interfaces/IProviderOracleManager.sol (line [25](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IProviderOracleManager.sol#L25)) ```solidity         bytes memory _calldata ``` 11. File: contracts/interfaces/IOperateProxy.sol (line [14](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IOperateProxy.sol#L14)) ```solidity     function callFunction(address callee, bytes memory data) external; ``` 12. File: contracts/pricing/oracle/ChainlinkOracleManager.sol (line [60](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L60)) ```solidity         bytes memory ``` 13. File: contracts/pricing/oracle/ProviderOracleManager.sol (line [47](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L47)) ```solidity         bytes memory _calldata ```  ### Not using the named return variables when a function returns is confusing  1. File: contracts/timelock/TimelockController.sol (line [279](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L279)) ```solidity         return getTimestamp(id) > 0; ``` 2. File: contracts/timelock/TimelockController.sol (line [291](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L291)) ```solidity         return getTimestamp(id) > _DONE_TIMESTAMP; ``` 3. File: contracts/timelock/TimelockController.sol (line [305](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L305)) ```solidity         return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp; ``` 4. File: contracts/timelock/TimelockController.sol (line [317](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L317)) ```solidity         return getTimestamp(id) == _DONE_TIMESTAMP; ``` 5. File: contracts/timelock/TimelockController.sol (line [330](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L330)) ```solidity         return _timestamps[id]; ``` 6. File: contracts/timelock/TimelockController.sol (line [339](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L339)) ```solidity         return _minDelay; ``` 7. File: contracts/timelock/TimelockController.sol (line [353](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L353)) ```solidity         return keccak256(abi.encode(target, value, data, predecessor, salt)); ``` 8. File: contracts/timelock/TimelockController.sol (line [367](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L367)) ```solidity         return keccak256(abi.encode(targets, values, datas, predecessor, salt)); ``` 9. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ``` 10. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ``` 11. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ```  ### Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Copy-paste code shouldn't be done and should always be refactored for clean code 1. File: contracts/timelock/TimelockController.sol (lines [246-249](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L246-L249)) ```solidity         require(             targets.length == values.length,             "TimelockController: length mismatch"         ); ``` 2. File: contracts/timelock/TimelockController.sol (lines [250-253](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L250-L253)) ```solidity         require(             targets.length == datas.length,             "TimelockController: length mismatch"         ); ``` 3. File: contracts/timelock/TimelockController.sol (lines [424-427](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L424-L427)) ```solidity         require(             isOperationReady(id),             "TimelockController: operation is not ready"         ); ``` 4. File: contracts/timelock/ConfigTimelockController.sol (lines [122-125](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L122-L125)) ```solidity         require(             eta >= delay + block.timestamp,             "ConfigTimelockController: Estimated execution block must satisfy delay"         ); ``` 5. File: contracts/timelock/ConfigTimelockController.sol (lines [462-465](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L462-L465)) ```solidity         require(             length == newAddresses.length,             "ConfigTimelockController: length mismatch"         ); ``` 6. File: contracts/timelock/ConfigTimelockController.sol (lines [498-501](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L498-L501)) ```solidity         require(             length == newUints.length,             "ConfigTimelockController: length mismatch"         ); ``` 7. File: contracts/timelock/ConfigTimelockController.sol (lines [534-537](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L534-L537)) ```solidity         require(             length == newBooleans.length,             "ConfigTimelockController: length mismatch"         ); ``` 8. File: contracts/timelock/ConfigTimelockController.sol (lines [570-573](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L570-L573)) ```solidity         require(             length == roleAdmins.length,             "ConfigTimelockController: length mismatch"         ); ``` 9. File: contracts/options/CollateralToken.sol (lines [143-149](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/options/CollateralToken.sol#L143-L149)) ```solidity         require(             quantConfig.hasRole(                 quantConfig.quantRoles("COLLATERAL_MINTER_ROLE"),                 msg.sender             ),             "CollateralToken: Only a collateral minter can mint CollateralTokens"         ); ``` 10. File: contracts/options/CollateralToken.sol (lines [168-174](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/options/CollateralToken.sol#L168-L174)) ```solidity         require(             quantConfig.hasRole(                 quantConfig.quantRoles("COLLATERAL_BURNER_ROLE"),                 msg.sender             ),             "CollateralToken: Only a collateral burner can burn CollateralTokens"         ); ``` 11. File: contracts/pricing/PriceRegistry.sol (lines [98-101](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L98-L101)) ```solidity         require(             settlementPrice.price != 0,             "PriceRegistry: No settlement price has been set"         ); ``` 12. File: contracts/pricing/OracleRegistry.sol (lines [62-68](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L62-L68)) ```solidity         require(             config.hasRole(                 config.quantRoles("ORACLE_MANAGER_ROLE"),                 msg.sender             ),             "OracleRegistry: Only an oracle admin can add an oracle"         ); ```  ### Remove unused variables  1. File: contracts/timelock/ConfigTimelockController.sol (line [15](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)) ```solidity     mapping(bytes32 => uint256) private _timestamps; ``` 
https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/OptionsFactory.sol#L101 Consider using openzeppelin clones in order to save gas, because contract deployment on ethereum is very expensive.
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28   # Vulnerability details  ## Impact  This report presents 2 different incorrect behaviour that can affect the correctness of math calculations 1. Unattended Implicit rounding in QuantMath.sol `div` and `mul` 2. Inappropriate method of casting integer to unsigned integer in SignedConverter.sol `intToUint`  Bug 1 affects the correctness when calculating collateral required for `_mintSpread`. Bug 2 expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.   ## Proof of Concept  In this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.  Before getting started, we should go over an important concept while dealing with fixed point number -- rounding. Math has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of "money" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.  In QuantMath, Rolla explicitly wrote the `toScaledUint` function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it `_decimals` here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never "lose tokens" due to rounding.  ``` library QuantMath {     ...     struct FixedPointInt {         int256 value;     }      int256 private constant _SCALING_FACTOR = 1e27;     uint256 private constant _BASE_DECIMALS = 27;      ...      function toScaledUint(         FixedPointInt memory _a,         uint256 _decimals,         bool _roundDown     ) internal pure returns (uint256) {         uint256 scaledUint;          if (_decimals == _BASE_DECIMALS) {             scaledUint = _a.value.intToUint();         } else if (_decimals > _BASE_DECIMALS) {             uint256 exp = _decimals - _BASE_DECIMALS;             scaledUint = (_a.value).intToUint() * 10**exp;         } else {             uint256 exp = _BASE_DECIMALS - _decimals;             uint256 tailing;             if (!_roundDown) {                 uint256 remainer = (_a.value).intToUint() % 10**exp;                 if (remainer > 0) tailing = 1;             }             scaledUint = (_a.value).intToUint() / 10**exp + tailing;         }          return scaledUint;     }     ... } ```  In practice, the above function also works quite well (sadly, not perfect, notice the `intToUint` function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where `div` and `mul` comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the `_decimal` used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in `toScaledUint` showned above.  ```     function mul(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);     }       function div(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);     } ```  Now let's see how this implicit rounding can causes troubles. We start with the `_mintSpread` procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.  * `Controller._mintSpread`   * `QuantCalculator.getCollateralRequirement`     * `FundsCalculator.getCollateralRequirement`       * `FundsCalculator.getOptionCollateralRequirement`         * `FundsCalculator.getCallCollateralRequirement`           * scales `_qTokenToMintStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * scales `_qTokenForCollateralStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * `collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)`         * scale `_optionsAmount` from `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `collateralAmount = _optionsAmount.mul(collateralPerOption)`       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral     * scale and round up `collateralAmountFP` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`  If we extract all the math related stuff, it would be something like below  ``` def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9         if Y2 % 10^9 > 0:       #round up since we are minting spread (Controller is receiver)                 Z+=1         return Z ```  Both implicit round downs can be abused, but we shall focus on the `mul` one here. Assume we follow the following actions  1. create option `A` with strike price `10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <-> 1 WETH` 2. create option `B` with strike price `10 BUSD (10^9 under 8 decimals) <-> 1 WETH` 3. mint `10^-18` (1 under 18 decimals) option `A`         3-1. `pay 1 eth` 4. mint `10^-18` (1 under 18 decimals) spread `B` with `A` as collateral         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0`         4-6. `Z = Y2 // 10^9 = 0`         4-7. `Y2 % 10^9 = 0` so `Z` remains unchanged  We minted a call credit spread without paying any fee.  Now let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.  For neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since `Controller` is the payer here. The neutralize procedure returns the `qToken` used as collateral and pays the collateral fee back. The math part can be summarized as below.  ``` def neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9  #explicit scaling         return Z ```  There are two challenges that need to be bypassed, the first one is to avoid implicit round down in `mul`, and the second is to ensure the revenue is not rounded away during explicit scaling. To achieve this, we first mint `10^-9 + 2 * 10^-18` spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option. Then we neutralize all those spreads at once, the calculation is shown below  1. neutralize `10^-9 + 2 * 10^-18` (10^9 + 2 under 18 decimals) spread `B`         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000`         4-6. `Z = Y2 // 10^9 = 10^9 // 10^9 = 1`  And with this, we managed to generate 10^-18 weth of revenue.  This approach is pretty impractical due to the requirement of minting 10^-18 for `10^9 + 2` times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.  It's time to start looking at the second bug.  Recall we mentioned the second bug is in `intToUint`, so here's the implementation of it. It is not hard to see that this is actually an `abs` function named as `intToUint`.  ```     function intToUint(int256 a) internal pure returns (uint256) {         if (a < 0) {             return uint256(-a);         } else {             return uint256(a);         }     } ```  Where is this function used? And yes, you guessed it, in `QuantCalculator.calculateClaimableCollateral`. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.  1. mint a `qTokenLong` option 2. mint a `qTokenShort` spread with `qTokenLong` as collateral 3. wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort  ``` ----------- qTokenLong strike price  ----------- expiryPrice  ----------- qTokenShort strike price ```  Here is the outline of the long waited claimCollateral for spread.  * `Controller._claimCollateral`   * `QuantCalculator.calculateClaimableCollateral`     * `FundsCalculator.getSettlementPriceWithDecimals`     * `FundsCalculator.getPayout` for qTokenLong       * qTokenLong strike price is above expiry price, worth 0     * `FundsCalculator.getCollateralRequirement`       * This part we saw earlier, omit details     * `FundsCalculator.getPayout` for qTokenShort       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral       * `FundsCalculator.getPayoutAmount` for qTokenShort         * scale `_strikePrice` from           `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`         * scale `_expiryPrice.price` from           `_expiryPrice.decimals (8)` to `_BASE_DECIMALS (27)`         * scale `_amount` from           `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `FundsCalculator.getPayoutForCall` for qTokenShort           * `payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)`     * `returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)`     * scale and round down `abs(returnableCollateral)` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`   Again, we summarize the math part into a function  ``` def claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):          def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):                 X1 = _qTokenToMintStrikePrice * 10^19                 X2 = _qTokenForCollateralStrikePrice * 10^19                 X3 = _optionsAmount * 10^9                  Y1 = (X2 - X1) * 10^27 // X2                 Y2 = Y1 * X3 // 10^27                 return Y2          def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):                 X1 = _strikePrice * 10^19                 X2 = _expiryPrice * 10^19                 X3 = _amount * 10^9                  Y1 = (X2-X1) * X3 // 10^27                 Y2 = Y1 * 10^27 // X2                 return Y2           assert _qTokenShortStrikePrice > _expiryPrice > _qTokenLongStrikePrice          A1 = payoutFromLong = 0         A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)         A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)          B1 = A1 + A2 - A3          Z = abs(B1) // 10^9         return Z ```  Given the context, it should be pretty easy to imagine what I am aiming here, to make `B1 < 0`. We already know `A1 = 0`, so the gaol basically boils down to making `A2 < A3`. Let's further simplify this requirement and see if the equation is solvable.  ``` X = _qTokenLongStrikePrice (8 decimals) Y = _expiryPrice (8 decimals) Z = _qTokenShortStrikePrice (8 decimals) A = _amount (scaled to 27 decimals)  assert X>Y>Z>0 assert X,Y,Z are integers assert (((X - Z) * 10^27 // X) * A // 10^27) < (((Y - Z) * A // 10^27) * 10^27 // Y) ```  Notice apart from the use of `X` and `Y`, the two sides of the equation only differs by when `A` is mixed into the equation, meaning that if we temporarily ignore the limitation and set `X = Y`, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.  Utilizing this, we turn to solve the equation of  ``` (X-Z) / X - (Y-Z) / Y < 10^-27 => Z / Y - Z / X < 10^-27 => (Z = 1 yields best solution) => 1 / Y - 1 / X < 10^-27 => X - Y < X * Y * 10^-27 => 0 < X * Y - 10^27 * X + 10^27 * Y  => require X > Y, so model Y as X - B, where B > 0 and B is an integer => 0 < X^2 - B * X - 10^27 * B ```  It is not easy to see that the larger `X` is, the larger the range of allowed `B`. This is pretty important since `B` stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.  Apart form range of `B`, value of `X` is the long strike price and upper bound of range `B`, so we would also care about it, a simple estimation shows that `X` must be above `10^13.5 (8 decimals)` for there to be a solution, which amounts to about `316228 BUSD <-> 1 WETH`. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of `10^14 - 1` as X and calculate the revenue generated following this exploit path.  ``` 0 < (10^14 - 1)^2 - B * (10^14 - 1) - 10^27 * B => (10^14 - 1)^2 / (10^14 - 1 + 10^27) > B => B <= 9 ```  Now we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take `_qTokenLongStrikePrice = 10^14 - 1 (8 decimals)`, `_qTokenShortStrikePrice = 1 (8 decimals)`, `_expiryPrice = 10^14 - 2 (8 decimals)` and `_amount = 10^28 (18 decimals)` and plug it back into the function. 1. in `callCreditSpreadCollateralRequirement`         1-1. `X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19`         1-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 - 1) * 10^19 = 10^33 - 10^19`         1-3. `X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37`         1-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^33 - 2 * 10^19) * 10^27 // (10^33 - 10^19) = 999999999999989999999999999`         1-5. `Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10` 2. in `callCreditSpreadQTokenShortPayout`         2-1. `X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19`         2-2. `X2 = _expiryPrice * 10^19 = (10^14 - 2) * 10^19 = 10^33 - 2 * 10^19`         2-3. `X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37`         2-4. `Y1 = (X2 - X1) * X3 // 10^27 = (10^33 - 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29`         2-5. `Y2 = Y1 * 10^27 / X2 = (99999999999997 * 10^28) * 10^27 / (10^33 - 2 * 10^19) = 9999999999999899999999999997999999999 3. combine terms         3-1. `B1 = A1 + A2 - A3 = 0 + 9999999999999899999999999990000000000 - 9999999999999899999999999997999999999 = -2000000001         3-2. `Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2  And with this, we managed to squeeze 2 wei from a presumably worthless collateral.  This attack still suffers from several problems 1. cost of WETH in BUSD is way higher than current market 2. need to predict target price accurately to profit 3. requires large amount of WETH to profit  While it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.  This concludes our demonstration of two attacks against the potential flaws in number handling.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  For `div` and `mul`, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.  For `intToUint`, I still can't understand what the original motive is to design it as `abs` in disguise. Since nowhere in this project would we benefit from the current `abs` behaviour, in my opinion, it would be best to adopt a similar strategy to the `uintToInt` function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.  
## Summary  We found 1 low-critical finding and 1 non-critical finding: * Low-Critical Findings - Uninitialized qTokenDetails.longStrikePrice for non-spread options in CollateralToken.sol/getCollateralTokenInfo * Non-Critical Findings - Usage of ecrecover for metaTransactions without checking r/s in CollateralToken.sol/metaSetApprovalForAll  In summary of recommended security practices, it's better to initialize memory even if it's 0 and use public and verified libraries rather than craft by hand. The first finding is uninitialized memory, due to solidity doesn't guarantee uninitialized memory is almost always 0. It's better to initialize for improving security practices. The second finding is ecrecover. It's better to use a public and verified library like ECDSA. Because EIP-2 still allows signature malleability for ecrecover(), use ECDSA to remove this possibility and make the signature unique.   ## Low-Critical Findings - Uninitialized qTokenDetails.longStrikePrice for non-spread options in CollateralToken.sol/getCollateralTokenInfo  ## Impact  Uninitialize memory is almost always 0 due to solidity’s no memory recycle policy. However, this is not guaranteed in solidity documents and it would be better to initialize `qTokenDetails.longStrikePrice`. Although it won't cause any problems right now, it could be a potential threat in the future.  ## Proof of Concept  `qTokensDetails.longStrikePrice` isn't initialized when `info.qTokenAsCollateral == address(0)`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L237  ```     function getCollateralTokenInfo(uint256 id)         external         view         override         returns (QTokensDetails memory qTokensDetails)     {         CollateralTokenInfo memory info = idToInfo[id];          require(             info.qTokenAddress != address(0),             "CollateralToken: Invalid id"         );          IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)             .getQTokenInfo();          qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;         qTokensDetails.strikeAsset = shortDetails.strikeAsset;         qTokensDetails.oracle = shortDetails.oracle;         qTokensDetails.shortStrikePrice = shortDetails.strikePrice;         qTokensDetails.expiryTime = shortDetails.expiryTime;         qTokensDetails.isCall = shortDetails.isCall;          if (info.qTokenAsCollateral != address(0)) {             // the given id is for a CollateralToken representing a spread             qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)                 .strikePrice();         }     } ```  ## Recommended Mitigation Steps  Initialize qTokensDetails.longStrikePrice  ## Non-Critical Findings - Usage of ecrecover for metaTransactions without checking r/s in CollateralToken.sol/metaSetApprovalForAll  ## Impact  Using ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However since address and nonce are included in message, it should be impossible to reuse or steal signatures.  ## Proof of Concept  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L218  ``` address signer = ecrecover(hash, v, r, s); ```  ## Recommended Mitigation Steps  Use ECDSA.recover instead 
# Lines of code  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206   # Vulnerability details  ## Impact  `_slice()` in `options/QTokenStringUtils.sol` cut a string into `string[start:end]` However, while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.   ## Proof of Concept  ERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.  The bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.  The exploit can be outlined through the following steps:  * Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`  * Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.sol` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90  ```     function _qTokenName(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenName) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );            ...            tokenName = string(             abi.encodePacked(                 "ROLLA",                 " ",                 underlying,                 " ",                 _uintToChars(day),                 "-",                 monthFull,                 "-",                 Strings.toString(year),                 " ",                 displayStrikePrice,                 " ",                 typeFull             )         );     } ```  ```      function _qTokenSymbol(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenSymbol) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );          // convert the expiry to a readable string         (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(             _expiryTime         );          // get option type string         (string memory typeSymbol, ) = _getOptionType(_isCall);          // get option month string         (string memory monthSymbol, ) = _getMonth(month);          /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 "ROLLA",                 "-",                 underlying,                 "-",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 "-",                 displayStrikePrice,                 "-",                 typeSymbol             )         );     } ```  * `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute. In this case, the quotient is `10000` and the remainder is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 ``` function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)         internal         view         virtual         returns (string memory)     {         uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();         uint256 strikePriceScale = 10**strikePriceDigits;         uint256 remainder = _strikePrice % strikePriceScale;         uint256 quotient = _strikePrice / strikePriceScale;         string memory quotientStr = Strings.toString(quotient);          if (remainder == 0) {             return quotientStr;         }          uint256 trailingZeroes;         while (remainder % 10 == 0) {             remainder /= 10;             trailingZeroes++;         }          // pad the number with "1 + starting zeroes"         remainder += 10**(strikePriceDigits - trailingZeroes);          string memory tmp = Strings.toString(remainder);         tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);          return string(abi.encodePacked(quotientStr, ".", tmp));     } ```  * However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + 1];             unchecked {                 ++i;             }         }          return string(slice);     } ```  * The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Fix the bug in the `_slice()`  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + i];             unchecked {                 ++i;             }         }          return string(slice);     } ```   
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28 https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27   # Vulnerability details  The QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28   I discussed with one of the devs about the use of this specific mapping :  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27  After discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.  It is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:  require(minimum delay ≤MAXIMUM_DELAY, “ too high”)  
@return in NatSpec comment missing for :  Controller.sol:  [https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L176]  [https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L242]  EIP712MetaTx.sol:  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L148   ConfigTimeLockController.sol:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L648  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L665  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L682  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L699  ChainLinkFixedTimeOracleManager.sol:  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L77    
# Missing Zero Chcks  ## impact Zero-address checks for input validation of address-type variables is a best-practice. While this is implemented in some places, there are missing ones.  ## POC  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/ QuantCalculator.sol#L55-L57  strikeAssetDecimals and optionsFactory variables do not perform zero checks which could result in lose of funds or malfunctions.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add zero-address checks   # Arbitrary send  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414  ## impact Unprotected call to a function sending Ether to an arbitrary address.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Ensure that an arbitrary user cannot withdraw unauthorized funds.
# addAssetOracle lack oracle validation Recommended to add a check to make sure the oracle return 8 decimals https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25  # Extra lines https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L26  # Lack event on critical parameters change - Timelock delay change https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L34  # isSettled must already be true isSettled must already be true https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/QuantCalculator.sol#L249  # Should revert if newDelay < minDelay Should revert if newDelay < minDelay instead of silently set to minDelay https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L39  # Variables can be mark immutable https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/options/QToken.sol#L21 ```     /// @inheritdoc IQToken     IQuantConfig public override quantConfig;      /// @inheritdoc IQToken     address public override underlyingAsset;      /// @inheritdoc IQToken     address public override strikeAsset;      /// @inheritdoc IQToken     address public override oracle;      /// @inheritdoc IQToken     uint256 public override strikePrice;      /// @inheritdoc IQToken     uint256 public override expiryTime;      /// @inheritdoc IQToken     bool public override isCall; ```
# Confusing error message at ``deactivateOracle`` function in ``OracleRegistry.sol``   ## Target codebase https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L67  ``` require(     config.hasRole(         config.quantRoles("ORACLE_MANAGER_ROLE"),         msg.sender     ),     "OracleRegistry: Only an oracle admin can add an oracle" ); ```  Statement "Only an oracle admin can add an oracle" seems not to be right.   ## Potential fix It should say "Only an oracle admin can deactivate an oracle" or others.  ---  # Confusing error message at ``activateOracle`` function in ``OracleRegistry.sol``   ## Target codebase https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L81-L87  ``` require(     config.hasRole(         config.quantRoles("ORACLE_MANAGER_ROLE"),         msg.sender     ),     "OracleRegistry: Only an oracle admin can add an oracle" ); ```  Statement "Only an oracle admin can add an oracle" seems not to be right.   ## Potential fix It should say "Only an oracle admin can activate an oracle" or others.  ---    
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L128 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L30 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L107 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L250   # Vulnerability details  ## Impact The `ChainlinkOracleManager` contract expects every oracle to provide the price data with 8 decimals. But, that's not always the case. Depending on the asset, the decimals could also be 16. In that case, the protocol would continue the computation with the wrong price which brings up a whole lot of problems.  List of assets and their decimals: https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet  ## Proof of Concept The received price is standardized to a `FixedPointInt` using the decimals value: https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L128  The contract uses a constant value `8` for that.  ## Tools Used none  ## Recommended Mitigation Steps Use `aggregator.decimals()` to get the correct number of decimals for the current asset. Use that for the computation  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84   # Vulnerability details  ## Impact The Chainlink functions `latestAnswer()` and `getAnswer()` are deprecated. Instead, use the [`latestRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) and [`getRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#getrounddata) functions.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84  Go to https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code and search for `latestAnswer()` or `getAnswer()`. You'll find the deprecation notice.  ## Tools Used none  ## Recommended Mitigation Steps Switch to `latestRoundData()` as described [here](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata)  
# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117   # Vulnerability details  ## Impact ```     function mintCollateralToken(         address recipient,         uint256 collateralTokenId,         uint256 amount     ) external override {         require(             quantConfig.hasRole(                 quantConfig.quantRoles("COLLATERAL_MINTER_ROLE"),                 msg.sender             ),             "CollateralToken: Only a collateral minter can mint CollateralTokens"         );          emit CollateralTokenMinted(recipient, collateralTokenId, amount);          _mint(recipient, collateralTokenId, amount, "");     } ```  Using the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.  If the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.  We believe this is unnecessary and poses a serious centralization risk.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L138-L160 ## Tools Used None  ## Recommended Mitigation Steps Consider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.  
1. `collateralTokenId` is used as `deadline` and it could be confused, it's better to rename it or add a specific comment about that. - [Actions.sol#L110](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L110) - [Actions.sol#L135](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L135)  2. It's possible to call he method [addAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L60) multiple times with the same `_underlying`, if you call `addAsset` with empty `symbol` it will bypass the [validAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L37) modifier, and it will be possible to call again the `addAsset` with different values. It will produce a mismatch with the reality and `getAssetsLength` This could cause a loss of funds if it is not verified before that this `symbol` is other than empty. It is mandatory to add a require to verify that the `symbol` is not empty. It's also recommended to add a require in [_assetSymbol](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L24) to ensure non-existence tokens are returned.  3. It's possible to call he method [createCollateralToken](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L61) multiple times with the same `_qTokenAddress`, if you call `createCollateralToken` with empty `_qTokenAddress` it will bypass the [require(idToInfo[id].qTokenAddress == address(0))](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L81), and it will be possible to call again the `createCollateralToken` with different values. It will produce a mismatch with the reality and `collateralTokenIds` It is mandatory to add a require to verify that the `_qTokenAddress` is not empty.  4. It's possible to approve with [metaSetApprovalForAll](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218-L219) an empty address for any operator, `ecrecover` is not checked to return `address(0)`, so using `owner=address(0)` it is possible to approve or reject empty owners for any operator. It's recommended to use ECDSA from open-zeppelin.  5. When calling [_getMonth](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L255) with a value greater than 12 "December" is returned, it's best to make sure the value is as expected.  6. Use `uint8` for `decimals` in [QTokenStringUtils.sol#L142](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L142)  7. Use a buggy solidity version with immutables. The contract use immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).  8. The [minDelay](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/TimelockController.sol#L112) must always be greater than 0, otherwise it could be proposed and executed in the same block, this could cause reputation problems for the project. Since that would make a TimeLock into a EOA owned.  9. There following methods and constructors doesn't check the inputs arguments - [QuantCalculator.sol#L56-L57](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantCalculator.sol#L56-L57) - [OracleRegistry.sol#L27](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/OracleRegistry.sol#L27) - [PriceRegistry.sol#L25-L26](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/PriceRegistry.sol#L25-L26) - [ProviderOracleManager.sol#L21](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L21) - [ChainlinkFixedTimeOracleManager.sol#L21-L22](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L21-L22)  10. It's possible to call he method [addAssetOracle](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25) multiple times with the same `_asset`, if you call `addAssetOracle` with empty `_oracle` it will bypass the [assetOracles[_asset] == address(0)](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L34), and it will be possible to call again the `addAssetOracle` with different values. It will produce a mismatch with the reality and `assets` It is mandatory to add a require to verify that the `_oracle` is not empty. 
# Lines of code  ChainlinkOracleManager   # Vulnerability details   use openzeppilin's safeCast in:           ChainlinkOracleManager._binarySearchStep : unsafe cast uint64(_firstRoundProxy)         ChainlinkOracleManager._setExpiryPriceInRegistryByRound : unsafe cast uint64(_roundIdAfterExpiry)         ChainlinkOracleManager._binarySearchStep : unsafe cast uint64(_lastRoundProxy)  
