1. Possible locking of pool fee funds Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
2. Pools mechanics don't incentivize end goal Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
3. Flashloan/Whale slippage manipulation Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
4. Single depositor in pool can steal funds from other pools Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
5. allPrices gas grieving causes complete loss of on-chain oracle Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
6. Pool drain via Oracle Update Sandwich Attack Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
7. Incorrect tolerance for price reported by Chainlink Oracle Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
8. Frozen protocol fee when too many pools are deployed Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
9. Planned functionality incentivizes low pool liquidity Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
10. Deposit fees even below 100% CR & withdrawal fees above 100% Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
11. _getG is not continuous Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
12. maxPriceTolerance does not work correctly Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
13. Price updates can be sandwiched Severity: High Difficulty: n/a Type: n/a Target: n/a Description: 
14. Chainlink oracle may return stale data Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
15. Fee-free deposit() and withdraw() can be gamed Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
16. Mechanics increase bank run risk Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
17. Oracle price lag enables 1% arbitrage opportunities Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
18. Slippage calculations are not path independent for large trades Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
19. Reentrancy in SingularityPool.collectFees() Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
20. It can be profitable to split up orders Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
21. _getG exponentiation can overflow for large CR values Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: 
22. Todo comment indicates necessary change Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
23. Denial of service edge case if onlyUseChainlink is false Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
24. No pool existence check Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
25. Missing zero address check Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
26. g function discontinuity at 0.3 Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
27. Missing two-step transfer ownership pattern Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
28. Division before multiplication Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
29. Deposit cap is inaccurate Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: 
30. Use unchecked in SingularityPool.sol Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
31. Replace modifiers with internal functions Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
32. Payable functions can save gas Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
33. Use short require strings Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
34. Use Solidity errors in 0.8.4+ Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
35. Using simple comparison Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
36. Using Yul iszero() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
37. Replace bool with uint256 Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
38. Declare immutable variables internal when possible Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
39. Redundant function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
40. Remove nonReentrant modifiers Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
41. Remove feeA > feeB test in getDepositFee() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
42. Collateral ratio calculations have redundant SLOADs Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
43. Replace ProtocolFees state var with Slippage Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
44. Tight variable packing Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
45. Use unchecked when there is no risk of overflow or underflow Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
46. Do not load calldata length in memory for loops Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
47. Unnecessary named return variable assignment Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
48. Combine accounting updates in swapIn and swapOut Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
49. Routers can give infinite token approval to pools Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
50. Immutable state variable which is defined as a public variable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
51. Difference from Uniswap's safeTransferFrom() logic Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
52. Centralization risk with admin role Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
53. baseFee value not limited Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
54. No way to remove pools Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
55. Fee-on-transfer tokens not supported Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
56. Documentation inconsistencies Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
57. Decimals value borrowed from underlying ERC20 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
58. Typo Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
59. nonReentrant modifier is specific to each pool Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
60. Pool may not be able to reach depositCap Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
61. Incorrect balance accounting for fee-on-transfer and rebasing tokens Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function — function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally "low-level functions" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs 
62. Reduce footgun risk of deposit() and withdraw() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function — function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally "low-level functions" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs 
63. Code does not match docs Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function — function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally "low-level functions" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs 
64. Just-in-time LP provision can be profitable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function — function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally "low-level functions" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs 
65. Potentially misleading description of "no impermanent loss" Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function — function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally "low-level functions" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs 
66. Miscellaneous Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function — function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally "low-level functions" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs 
